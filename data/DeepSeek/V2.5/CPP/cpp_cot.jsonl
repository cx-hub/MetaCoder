{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance_counter = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            continue; // Ignore spaces\n        }\n        current_group += ch;\n        if (ch == '(') {\n            balance_counter++;\n        } else if (ch == ')') {\n            balance_counter--;\n        }\n        if (balance_counter == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number){\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_zero(vector<int> operations){\n       int balance = 0;\n       for (int operation : operations) {\n           balance += operation;\n           if (balance < 0) {\n               return true;\n           }\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/4", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   float mean_absolute_deviation(vector<float> numbers) {\n       // Calculate the mean of the dataset\n       float sum = 0;\n       for (float number : numbers) {\n           sum += number;\n       }\n       float mean = sum / numbers.size();\n\n       // Calculate the sum of absolute differences\n       float sum_of_abs_diff = 0;\n       for (float number : numbers) {\n           sum_of_abs_diff += abs(number - mean);\n       }\n\n       // Calculate and return the Mean Absolute Deviation\n       float MAD = sum_of_abs_diff / numbers.size();\n       return MAD;\n   }\n   "}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<sstream>\n   using namespace std;\n\n   vector<int> parse_nested_parens(string paren_string) {\n       vector<int> result;\n       stringstream ss(paren_string);\n       string group;\n       \n       while (ss >> group) {\n           int max_depth = 0;\n           int current_depth = 0;\n           \n           for (char c : group) {\n               if (c == '(') {\n                   current_depth++;\n                   if (current_depth > max_depth) {\n                       max_depth = current_depth;\n                   }\n               } else if (c == ')') {\n                   current_depth--;\n               }\n           }\n           \n           result.push_back(max_depth);\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/7", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_substring(vector<string> strings, string substring) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(substring) != string::npos) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/8", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> sum_product(vector<int> numbers){\n       int sum = 0;\n       int product = 1;\n       \n       for(int number : numbers){\n           sum += number;\n           product *= number;\n       }\n       \n       return {sum, product};\n   }\n   "}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> rollingMax;\n    int currentMax = numbers[0];\n    \n    for (int i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] > currentMax) {\n            currentMax = numbers[i];\n        }\n        rollingMax.push_back(currentMax);\n    }\n    \n    return rollingMax;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    int n = str.length();\n    if (n == 0) return \"\";\n\n    // Find the longest palindromic suffix\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the end of the string\n            string prefix = str.substr(0, i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, append the reverse of the entire string\n    string reversed_str(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == '0' && b[i] == '0') {\n            result += '0';\n        } else if (a[i] == '0' && b[i] == '1') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '0') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '1') {\n            result += '0';\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string longest(vector<string> strings){\n       if (strings.empty()) {\n           return \"\"; // Return empty string to represent None\n       }\n       string longest_string = strings[0];\n       for (const string& str : strings) {\n           if (str.length() > longest_string.length()) {\n               longest_string = str;\n           }\n       }\n       return longest_string;\n   }\n   "}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n){\n    // Initialize a string stream\n    stringstream ss;\n    \n    // Loop from 0 to n\n    for(int i = 0; i <= n; ++i) {\n        // Append the number followed by a space\n        ss << i << \" \";\n    }\n    \n    // Convert the string stream to a string\n    string result = ss.str();\n    \n    // Remove the trailing space\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<set>\n   using namespace std;\n\n   int count_distinct_characters(string str){ \n       // Convert the string to lowercase\n       transform(str.begin(), str.end(), str.begin(), ::tolower);\n       \n       // Use a set to store unique characters\n       set<char> unique_chars;\n       \n       // Iterate through the string and add each character to the set\n       for(char c : str) {\n           unique_chars.insert(c);\n       }\n       \n       // The size of the set is the number of distinct characters\n       return unique_chars.size();\n   }\n   "}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string){ \n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int how_many_times(string str, string substring) {\n       int count = 0;\n       int length_str = str.length();\n       int length_sub = substring.length();\n       \n       for (int i = 0; i <= length_str - length_sub; i++) {\n           if (str.substr(i, length_sub) == substring) {\n               count++;\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to associate numerals with their integer values\n    map<string, int> numeralToValue = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    // Split the input string into individual numerals\n    vector<string> numeralList;\n    stringstream ss(numbers);\n    string numeral;\n    while (ss >> numeral) {\n        numeralList.push_back(numeral);\n    }\n    \n    // Sort the numerals based on their integer values\n    sort(numeralList.begin(), numeralList.end(), [&](const string &a, const string &b) {\n        return numeralToValue[a] < numeralToValue[b];\n    });\n    \n    // Join the sorted numerals back into a single string\n    string sortedNumbers;\n    for (const string &num : numeralList) {\n        if (!sortedNumbers.empty()) {\n            sortedNumbers += \" \";\n        }\n        sortedNumbers += num;\n    }\n    \n    return sortedNumbers;\n}\n"}
{"task_id": "CPP/20", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> find_closest_elements(vector<float> numbers) {\n       vector<float> closest_pair;\n       float min_diff = INFINITY;\n\n       for (int i = 0; i < numbers.size(); i++) {\n           for (int j = i + 1; j < numbers.size(); j++) {\n               float diff = abs(numbers[i] - numbers[j]);\n               if (diff < min_diff) {\n                   min_diff = diff;\n                   closest_pair = {numbers[i], numbers[j]};\n               }\n           }\n       }\n\n       if (closest_pair[0] > closest_pair[1]) {\n           swap(closest_pair[0], closest_pair[1]);\n       }\n\n       return closest_pair;\n   }\n   "}
{"task_id": "CPP/21", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<float> rescale_to_unit(vector<float> numbers){\n       float min_value = *min_element(numbers.begin(), numbers.end());\n       float max_value = *max_element(numbers.begin(), numbers.end());\n       float range = max_value - min_value;\n       vector<float> new_numbers;\n       for (float number : numbers) {\n           float new_value = (number - min_value) / range;\n           new_numbers.push_back(new_value);\n       }\n       return new_numbers;\n   }\n   "}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case: no divisors for numbers less than or equal to 1\n    int max_divisor = 1;\n    for (int i = n / 2; i > 1; --i) {\n        if (n % i == 0) {\n            max_divisor = i;\n            break;\n        }\n    }\n    return max_divisor;\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    // Step 1: Count occurrences of each element\n    unordered_map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    // Step 2: Construct the result vector with elements that occur only once\n    vector<int> result;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    // Step 3: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str){\n    string result = \"\";\n    for (char ch : str) {\n        if (islower(ch)) {\n            result += toupper(ch);\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_prefix(vector<string> strings, string prefix) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(prefix) == 0) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/30", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> get_positive(vector<float> l){\n       vector<float> result;\n       for(float number : l){\n           if(number > 0){\n               result.push_back(number);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Special cases\n    if (n <= 1) return false;\n    if (n == 2) return true; // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Other even numbers are not prime\n\n    // Check divisibility from 3 to sqrt(n)\n    long long limit = static_cast<long long>(sqrt(n));\n    for (long long i = 3; i <= limit; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// Function to evaluate polynomial using Horner's method\ndouble poly(vector<double> xs, double x) {\n    double result = 0;\n    for (int i = xs.size() - 1; i >= 0; i--) {\n        result = result * x + xs[i];\n    }\n    return result;\n}\n\n// Function to compute the derivative of the polynomial\ndouble poly_derivative(vector<double> xs, double x) {\n    double result = 0;\n    for (int i = xs.size() - 1; i > 0; i--) {\n        result = result * x + i * xs[i];\n    }\n    return result;\n}\n\n// Function to find a zero of the polynomial using Newton-Raphson method\ndouble find_zero(vector<double> xs) {\n    double x0 = 0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double fpx = poly_derivative(xs, x0);\n\n        if (fabs(fx) < tolerance) {\n            return x0; // Converged to a zero\n        }\n\n        x0 = x0 - fx / fpx; // Newton-Raphson update\n    }\n\n    return x0; // Return the last computed value if not converged\n}\n\n// Example usage\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l){\n    // Step 1: Collect elements at indices divisible by 3\n    vector<int> third_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    \n    // Step 2: Sort the collected elements\n    sort(third_elements.begin(), third_elements.end());\n    \n    // Step 3: Replace the elements at indices divisible by 3 with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = third_elements[index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Step 1: Initialize an empty set\n    set<int> uniqueSet;\n    \n    // Step 2: Iterate through the input vector and insert each element into the set\n    for(int num : l){\n        uniqueSet.insert(num);\n    }\n    \n    // Step 3: Convert the set to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 4: Sort the vector (although the set is already sorted, this step is redundant but kept for clarity)\n    sort(uniqueVector.begin(), uniqueVector.end());\n    \n    // Step 5: Return the sorted vector\n    return uniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Initialize max_val with the first element of the vector\n    float max_val = l[0];\n    \n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < l.size(); ++i) {\n        // Compare the current element with max_val\n        if (l[i] > max_val) {\n            // Update max_val if the current element is greater\n            max_val = l[i];\n        }\n    }\n    \n    // Return the maximum element found\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int fizz_buzz(int n) {\n       int count = 0;\n       for (int i = 0; i < n; ++i) {\n           if (i % 11 == 0 || i % 13 == 0) {\n               string numStr = to_string(i);\n               for (char c : numStr) {\n                   if (c == '7') {\n                       count++;\n                   }\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> l_prime;\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the new vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime.push_back(even_values[even_index++]);\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    string output;\n    int l = s.length();\n    int num = (l + 2) / 3;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2;\n    if (n == 2) return 3;\n    \n    int count = 2;\n    int a = 2, b = 3;\n    \n    while (true) {\n        int c = a + b;\n        if (is_prime(c)) {\n            count += 1;\n            if (count == n) {\n                return c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> incr_list(vector<int> l){\n       vector<int> result;\n       for (int i = 0; i < l.size(); i++) {\n           result.push_back(l[i] + 1);\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int number : l) {\n        if (seen.find(-number) != seen.end()) {\n            return true;\n        }\n        seen.insert(number);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Special case for zero\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // Calculate the area using the formula\n    float area = 0.5 * a * h;\n    // Return the calculated area\n    return area;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four Fib4 numbers\n    vector<int> fib4_values = {0, 0, 2, 0};\n\n    // Compute Fib4 numbers iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_fib4 = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        // Update the array by shifting values\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = next_fib4;\n    }\n\n    // The n-th Fib4 number is the last element in the array\n    return fib4_values[3];\n}\n\n// Example usage\n"}
{"task_id": "CPP/47", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   float median(vector<float> l){\n       // Sort the vector\n       sort(l.begin(), l.end());\n       \n       // Get the length of the vector\n       int n = l.size();\n       \n       // Check if the length is odd or even\n       if (n % 2 != 0) {\n           // If odd, return the middle element\n           return l[n/2];\n       } else {\n           // If even, return the average of the two middle elements\n           return (l[(n/2)-1] + l[n/2]) / 2.0;\n       }\n   }\n   "}
{"task_id": "CPP/48", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool is_palindrome(string text){\n       int left = 0;\n       int right = text.length() - 1;\n       while (left < right) {\n           if (text[left] != text[right]) {\n               return false;\n           }\n           left++;\n           right--;\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\n\nint modp(int n, int p) {\n    if (n == 0) {\n        return 1;\n    }\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_shift(string s){\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        // Calculate the new character position by shifting backward by 5\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string remove_vowels(string text){\n       string vowels = \"aeiouAEIOU\";\n       string result = \"\";\n       for (char c : text) {\n           if (vowels.find(c) == string::npos) {\n               result += c;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/52", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_threshold(vector<int> l, int t) {\n       for (int num : l) {\n           if (num >= t) {\n               return false;\n           }\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // If lengths are different, they can't have the same characters\n    if (s0.length() != s1.length()) {\n        return false;\n    }\n\n    // Frequency arrays for both strings\n    int freq0[256] = {0};\n    int freq1[256] = {0};\n\n    // Fill the frequency arrays\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    for (char c : s1) {\n        freq1[c]++;\n    }\n\n    // Compare the frequency arrays\n    for (int i = 0; i < 256; i++) {\n        if (freq0[i] != freq1[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the base case for n <= 0\n    if (n == 1) return 1; // Handle the base case for n == 1\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int next = a + b;\n        a = b;\n        b = next;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool correct_bracketing(string brackets){\n       int counter = 0;\n       for (char bracket : brackets) {\n           if (bracket == '<') {\n               counter++;\n           } else if (bracket == '>') {\n               counter--;\n           }\n           if (counter < 0) {\n               return false;\n           }\n       }\n       return counter == 0;\n   }\n   "}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() < 2) return true; // A single element or empty vector is trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n        // If neither increasing nor decreasing, we can return false early\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Create a set to store unique elements from the first vector\n    unordered_set<int> unique_elements(l1.begin(), l1.end());\n    \n    // Step 2: Create an empty vector to store the result\n    vector<int> result;\n    \n    // Step 3: Iterate through the second vector and check for common elements\n    for (int num : l2) {\n        if (unique_elements.find(num) != unique_elements.end()) {\n            result.push_back(num);\n            // Remove the element from the set to ensure uniqueness in the result\n            unique_elements.erase(num);\n        }\n    }\n    \n    // Step 4: Sort the result vector\n    sort(result.begin(), result.end());\n    \n    // Step 5: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<cmath>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int divisor = 2;\n\n    // Divide out all factors of 2\n    while (n % divisor == 0) {\n        largest_factor = divisor;\n        n /= divisor;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    divisor = 3;\n    while (n > 1 && divisor <= std::sqrt(n)) {\n        while (n % divisor == 0) {\n            largest_factor = divisor;\n            n /= divisor;\n        }\n        divisor += 2; // Move to the next odd number\n    }\n\n    // If n is still greater than 1, then it is a prime factor\n    if (n > 1) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n < 0) {\n        // Handle negative input as needed\n        return -1; // or throw an exception\n    }\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n// Example usage\n"}
{"task_id": "CPP/64", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int vowels_count(string s) {\n       int count = 0;\n       transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n       for (int i = 0; i < s.length(); i++) {\n           if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n               count++;\n           } else if (s[i] == 'y' && i == s.length() - 1) { // Check if 'y' is at the end\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Perform the circular shift\n    string shifted_part = str_x.substr(len - shift);\n    string remaining_part = str_x.substr(0, len - shift);\n    \n    // Concatenate the shifted part with the remaining part\n    string result = shifted_part + remaining_part;\n    \n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digitSum(string s) {\n       int sum = 0;\n       for (char c : s) {\n           if (c >= 'A' && c <= 'Z') {\n               sum += c;\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Extract the number of apples\n    ss >> apples;\n    ss >> temp; // Skip the word \"apples\"\n    ss >> temp; // Skip the word \"and\"\n    \n    // Extract the number of oranges\n    ss >> oranges;\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    // Return the result\n    return mangoes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/68", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<limits.h> // For INT_MAX\n   using namespace std;\n\n   vector<int> pluck(vector<int> arr){\n       int smallest_even_value = INT_MAX;\n       int smallest_index = -1;\n\n       for (int i = 0; i < arr.size(); i++) {\n           if (arr[i] % 2 == 0 && arr[i] < smallest_even_value) {\n               smallest_even_value = arr[i];\n               smallest_index = i;\n           }\n       }\n\n       if (smallest_even_value == INT_MAX) {\n           return {};\n       } else {\n           return {smallest_even_value, smallest_index};\n       }\n   }\n   "}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Create an unordered_map to store the frequency of each integer\n    unordered_map<int, int> frequencyMap;\n    \n    // Step 2: Populate the unordered_map by iterating through the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    // Step 3: Iterate through the unordered_map to find the greatest integer\n    // that meets the criteria\n    int result = -1;\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    // Initialize pointers\n    int min_ptr = 0;\n    int max_ptr = lst.size() - 1;\n    \n    // Initialize result list\n    vector<int> result;\n    \n    // Alternate between min and max pointers\n    while (min_ptr <= max_ptr) {\n        if (min_ptr <= max_ptr) {\n            result.push_back(lst[min_ptr]);\n            min_ptr++;\n        }\n        if (min_ptr <= max_ptr) {\n            result.push_back(lst[max_ptr]);\n            max_ptr--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Compare the sum with the maximum possible weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int smallest_change(vector<int> arr) {\n       int left = 0;\n       int right = arr.size() - 1;\n       int change_count = 0;\n       \n       while (left < right) {\n           if (arr[left] != arr[right]) {\n               change_count++;\n           }\n           left++;\n           right--;\n       }\n       \n       return change_count;\n   }\n   "}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total number of characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total number of characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generatePrimes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the given number is the multiplication of 3 prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generatePrimes();\n    int n = primes.size();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/76", "generation": "   #include<stdio.h>\n   #include<math.h>\n   using namespace std;\n\n   bool is_simple_power(int x, int n) {\n       if (n == 1) {\n           return x == 1;\n       }\n       if (x == 1) {\n           return true;\n       }\n       int power = 1;\n       int int_val = 0;\n       while (power <= x) {\n           if (power == x) {\n               return true;\n           }\n           int_val++;\n           power = pow(n, int_val);\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        // Handle negative numbers\n        int abs_a = -a;\n        int root = cbrt(abs_a);\n        return (root * root * root == abs_a);\n    } else {\n        // Handle non-negative numbers\n        int root = cbrt(a);\n        return (root * root * root == a);\n    }\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Initialize the counter\n    int count = 0;\n    \n    // Loop through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            // Increment the counter\n            count++;\n        }\n    }\n    \n    // Return the counter\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\"; // Special case for 0\n\n    string binary = \"\";\n    while (decimal > 0) {\n        binary += to_string(decimal % 2); // Append the remainder\n        decimal /= 2; // Update decimal to be the quotient\n    }\n\n    reverse(binary.begin(), binary.end()); // Reverse the string to get correct binary\n    return \"db\" + binary + \"db\"; // Prepend and append \"db\"\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check the next 3 characters\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no duplicates were found, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<cmath>\n   using namespace std;\n\n   bool prime_length(string str) {\n       int length = str.length();\n       if (length <= 1) {\n           return false;\n       }\n       for (int i = 2; i <= sqrt(length); ++i) {\n           if (length % i == 0) {\n               return false;\n           }\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\n#include<cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers\n    \n    int numbers_starting_with_1 = pow(10, n - 1);\n    int numbers_ending_with_1 = 9 * pow(10, n - 2);\n    int numbers_starting_and_ending_with_1 = pow(10, n - 2);\n    \n    int total_count = numbers_starting_with_1 + numbers_ending_with_1 - numbers_starting_and_ending_with_1;\n    \n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of the digits of N\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to sum\n        N /= 10;        // Remove the last digit from N\n    }\n\n    // Step 2: Convert the sum to a binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        binarySum = \"0\";  // Special case for sum = 0\n    } else {\n        while (sum > 0) {\n            binarySum = (sum % 2 == 0 ? \"0\" : \"1\") + binarySum;  // Append the binary digit\n            sum /= 2;  // Shift right in binary (divide by 2)\n        }\n    }\n\n    // Step 3: Return the binary string\n    return binarySum;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string tempWord = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {\n            sort(tempWord.begin(), tempWord.end());\n            result += tempWord + \" \";\n            tempWord = \"\";\n        } else {\n            tempWord += c;\n        }\n    }\n\n    // Sort and append the last word\n    sort(tempWord.begin(), tempWord.end());\n    result += tempWord;\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If the element matches x, store the coordinates\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    // Sort the result vector\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        // First sort by row in ascending order\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        }\n        // If rows are the same, sort by column in descending order\n        return a[1] > b[1];\n    });\n    \n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<int> sort_array(vector<int> array) {\n       if (array.empty()) {\n           return array;\n       }\n\n       int sum = array[0] + array[array.size() - 1];\n       vector<int> sorted_array = array;\n\n       if (sum % 2 != 0) {\n           // Sort in ascending order\n           sort(sorted_array.begin(), sorted_array.end());\n       } else {\n           // Sort in descending order\n           sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n       }\n\n       return sorted_array;\n   }\n   "}
{"task_id": "CPP/89", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   string encrypt(string s) {\n       string result = \"\";\n       for (char c : s) {\n           if (c >= 'a' && c <= 'z') {\n               char new_char = ((c - 'a' + 4) % 26) + 'a';\n               result += new_char;\n           } else {\n               result += c;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    int smallest = lst[0];\n    int second_smallest = lst[1];\n\n    if (smallest > second_smallest) {\n        swap(smallest, second_smallest);\n    }\n\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] < smallest) {\n            second_smallest = smallest;\n            smallest = lst[i];\n        } else if (lst[i] < second_smallest && lst[i] != smallest) {\n            second_smallest = lst[i];\n        }\n    }\n\n    if (smallest == second_smallest) {\n        return -1; // Return -1 to indicate None\n    }\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint is_bored(string S){\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n    vector<char> delimiters = {'.', '?', '!'};\n    \n    while (getline(ss, sentence, delimiters[0])) {\n        for (char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                sentence.replace(pos, 1, \"\");\n                pos += 1;\n            }\n        }\n        if (!sentence.empty() && sentence.substr(0, 1) == \"I\") {\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n\n    // Check if any number is equal to the sum of the other two\n    if (int_a == int_b + int_c || int_b == int_a + int_c || int_c == int_a + int_b) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string encode(string message) {\n       string vowels = \"aeiouAEIOU\";\n       string result = \"\";\n\n       for (char &ch : message) {\n           if (vowels.find(ch) != string::npos) {\n               if (ch == 'u' || ch == 'U') {\n                   ch = (ch == 'u') ? 'a' : 'A';\n               } else if (ch == 'o' || ch == 'O') {\n                   ch = (ch == 'o') ? 'q' : 'Q';\n               } else {\n                   ch = ch + 2;\n               }\n           }\n           if (islower(ch)) {\n               ch = toupper(ch);\n           } else {\n               ch = tolower(ch);\n           }\n           result += ch;\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int number : lst) {\n        if (isPrime(number) && number > largestPrime) {\n            largestPrime = number;\n        }\n    }\n    if (largestPrime == -1) {\n        return 0;\n    }\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   bool check_dict_case(map<string, string> dict) {\n       if (dict.empty()) {\n           return false;\n       }\n\n       bool is_lower = true;\n       bool is_upper = true;\n\n       for (const auto& pair : dict) {\n           const string& key = pair.first;\n\n           if (!islower(key[0]) && !isupper(key[0])) {\n               return false;\n           }\n\n           for (char c : key) {\n               if (!islower(c)) {\n                   is_lower = false;\n               }\n               if (!isupper(c)) {\n                   is_upper = false;\n               }\n           }\n\n           if (!is_lower && !is_upper) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    if (n <= 2) return {};\n\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Calculate the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int count_upper(string s) {\n       int count = 0;\n       for (int i = 0; i < s.length(); i += 2) {\n           char ch = s[i];\n           if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a float\n    float num = stof(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1.0) == 0.5) {\n        // Round away from zero\n        if (num >= 0) {\n            return static_cast<int>(num + 0.5);\n        } else {\n            return static_cast<int>(num - 0.5);\n        }\n    } else {\n        // Use standard rounding\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current_stones);\n        current_stones += 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string currentWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!currentWord.empty()) {\n                words.push_back(currentWord);\n                currentWord = \"\";\n            }\n        } else {\n            currentWord += c;\n        }\n    }\n    \n    // Add the last word if it exists\n    if (!currentWord.empty()) {\n        words.push_back(currentWord);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // Iterate from y down to x to find the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n    \n    // If no even number is found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   using namespace std;\n\n   string convert_to_binary(int number) {\n       if (number == 0) return \"0\";\n       string binary = \"\";\n       while (number > 0) {\n           binary = to_string(number % 2) + binary;\n           number /= 2;\n       }\n       return binary;\n   }\n\n   string rounded_avg(int n, int m) {\n       if (n > m) return \"-1\";\n       \n       int sum = 0;\n       int count = m - n + 1;\n       \n       for (int i = n; i <= m; ++i) {\n           sum += i;\n       }\n       \n       double average = static_cast<double>(sum) / count;\n       int rounded_average = floor(average);\n       \n       return convert_to_binary(rounded_average);\n   }\n   "}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x){\n    vector<int> result;\n    for (int num : x) {\n        string numStr = to_string(num);\n        bool hasEvenDigit = false;\n        for (char ch : numStr) {\n            if (ch == '0' || ch == '2' || ch == '4' || ch == '6' || ch == '8') {\n                hasEvenDigit = true;\n                break;\n            }\n        }\n        if (!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to convert digits to their corresponding names\n    map<int, string> digitToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the input vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Replace each integer with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(digitToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> f(int n){\n       vector<int> result(n);\n       for (int i = 1; i <= n; ++i) {\n           if (i % 2 == 0) {\n               // Calculate factorial of i\n               int factorial = 1;\n               for (int j = 1; j <= i; ++j) {\n                   factorial *= j;\n               }\n               result[i-1] = factorial;\n           } else {\n               // Calculate sum of numbers from 1 to i\n               int sum = 0;\n               for (int j = 1; j <= i; ++j) {\n                   sum += j;\n               }\n               result[i-1] = sum;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        string s = to_string(i);\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        \n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                ++even_count;\n            } else {\n                ++odd_count;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        int sum_of_digits = 0;\n        int abs_number = abs(number);\n        while (abs_number > 0) {\n            int digit = abs_number % 10;\n            if (number < 0) {\n                digit = -digit;\n            }\n            sum_of_digits += digit;\n            abs_number /= 10;\n        }\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        // Perform a right shift operation\n        rotate(arr.rbegin(), arr.rbegin() + 1, arr.rend());\n        if (arr == sorted_arr) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n    \n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd_lst1++;\n        }\n    }\n    \n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even_lst2++;\n        }\n    }\n    \n    // Determine if we can make lst1 all even\n    if (count_odd_lst1 <= count_even_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCounts;\n    \n    // Count occurrences of each letter\n    for (char c : test) {\n        if (c != ' ') {\n            letterCounts[c]++;\n        }\n    }\n    \n    // Determine the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCounts) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Create a map with letters having the maximum count\n    map<char, int> result;\n    for (const auto& pair : letterCounts) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   vector<string> reverse_delete(string s, string c) {\n       // Create a set from characters in c\n       unordered_set<char> charSet(c.begin(), c.end());\n       \n       // Initialize an empty result string\n       string result = \"\";\n       \n       // Iterate through string s\n       for (char ch : s) {\n           // If character is not in the set, append to result string\n           if (charSet.find(ch) == charSet.end()) {\n               result += ch;\n           }\n       }\n       \n       // Check if result string is a palindrome\n       string reversedResult = result;\n       reverse(reversedResult.begin(), reversedResult.end());\n       \n       // Return the result vector\n       return {result, result == reversedResult ? \"True\" : \"False\"};\n   }\n   "}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& str : lst) {\n        int count = 0;\n        for (char ch : str) {\n            if (ch == '1' || ch == '3' || ch == '5' || ch == '7' || ch == '9') {\n                count++;\n            }\n        }\n        string formatted_string = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(formatted_string);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Initialize to a very large value\n    long long currentMin = 0;\n\n    for (long long num : nums) {\n        currentMin = min(num, currentMin + num);\n        minSum = min(minSum, currentMin);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath> // for std::ceil\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    \n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (const auto& cell : row) {\n            if (cell == 1) {\n                water_units++;\n            }\n        }\n        // Calculate the number of times the bucket needs to be lowered\n        total_lowers += std::ceil((double)water_units / capacity);\n    }\n    \n    return total_lowers;\n}\n\n// Example usage\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint countOnes(int num) {\n    return bitset<32>(num).count();\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array using a custom comparator\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b; // If number of ones is the same, sort by decimal value\n        }\n        return onesA < onesB; // Otherwise, sort by number of ones\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    // Split the string into words\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    // Check each word for the number of consonants\n    for (const string& word : words) {\n        int consonantCount = 0;\n        for (char c : word) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string result = \"\";\n    string vowels = \"aeiouAEIOU\";\n    \n    // Traverse the word from right to left\n    for (int i = word.size() - 2; i > 0; --i) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the previous and next characters are consonants\n            if (vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int count_open_1 = 0, count_close_1 = 0;\n    int count_open_2 = 0, count_close_2 = 0;\n    \n    for (char c : lst[0]) {\n        if (c == '(') count_open_1++;\n        else count_close_1++;\n    }\n    \n    for (char c : lst[1]) {\n        if (c == '(') count_open_2++;\n        else count_close_2++;\n    }\n    \n    int total_open = count_open_1 + count_open_2;\n    int total_close = count_close_1 + count_close_2;\n    \n    if (total_open != total_close) {\n        return \"No\";\n    }\n    \n    auto can_balance = [](const string& str1, const string& str2) -> bool {\n        int balance = 0;\n        for (char c : str1) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        \n        for (char c : str2) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        \n        return balance == 0;\n    };\n    \n    if (can_balance(lst[0], lst[1]) || can_balance(lst[1], lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements\n    vector<int> max_k(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the k elements in ascending order\n    sort(max_k.begin(), max_k.end());\n    \n    // Step 4: Return the sorted k elements\n    return max_k;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0) {  // Check if the index is even\n            if (lst[i] % 2 != 0) {  // Check if the element is odd\n                sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int add_elements(vector<int> arr, int k) {\n       int sum = 0;\n       for (int i = 0; i < k; ++i) {\n           if (arr[i] >= 0 && arr[i] < 100) {\n               sum += arr[i];\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If n is even\n            n = n / 2;\n        } else { // If n is odd\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add 1 to the list (since the sequence always ends at 1)\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iomanip>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n    \n    // Check if the date string matches the format \"mm-dd-yyyy\"\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    // Extract month, day, and year from the date string\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n    \n    // Validate the format and extraction\n    if (dash1 != '-' || dash2 != '-' || ss.fail()) return false;\n    \n    // Validate the month (1-12)\n    if (month < 1 || month > 12) return false;\n    \n    // Validate the day based on the month\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            if (day < 1 || day > 31) return false;\n            break;\n        case 4: case 6: case 9: case 11:\n            if (day < 1 || day > 30) return false;\n            break;\n        case 2:\n            if (isLeapYear(year)) {\n                if (day < 1 || day > 29) return false;\n            } else {\n                if (day < 1 || day > 28) return false;\n            }\n            break;\n        default:\n            return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt){\n    vector<string> words;\n    \n    // Check for whitespace and split\n    istringstream stream(txt);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    \n    // If no words found, check for commas\n    if (words.empty()) {\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            words.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        words.push_back(txt);\n    }\n    \n    // If no commas found, count odd order lowercase letters\n    if (words.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 != 0) {\n                count++;\n            }\n        }\n        words.push_back(to_string(count));\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/126", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<unordered_map>\n   using namespace std;\n\n   bool is_sorted(vector<int> lst){\n       if (lst.size() <= 1) {\n           return true;\n       }\n       \n       unordered_map<int, int> countMap;\n       \n       for (int num : lst) {\n           countMap[num]++;\n           if (countMap[num] > 2) {\n               return false;\n           }\n       }\n       \n       for (size_t i = 0; i < lst.size() - 1; ++i) {\n           if (lst[i] > lst[i + 1]) {\n               return false;\n           }\n       }\n       \n       return true;\n   }\n   "}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart <= intersectionEnd) {\n        int intersectionLength = intersectionEnd - intersectionStart + 1;\n        if (isPrime(intersectionLength)) {\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int prod_signs(vector<int> arr){\n       if (arr.empty()) {\n           return -32768;\n       }\n\n       int sum_of_magnitudes = 0;\n       int product_of_signs = 1;\n\n       for (int number : arr) {\n           sum_of_magnitudes += abs(number);\n           if (number == 0) {\n               product_of_signs = 0;\n               break;\n           } else if (number < 0) {\n               product_of_signs *= -1;\n           }\n       }\n\n       return sum_of_magnitudes * product_of_signs;\n   }\n   "}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> bestPath;\n    bool firstPath = true;\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // BFS queue\n    queue<pair<pair<int, int>, vector<int>>> q;\n\n    // Start BFS from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            q.push({{i, j}, {grid[i][j]}});\n        }\n    }\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n\n        int x = current.first.first;\n        int y = current.first.second;\n        vector<int> path = current.second;\n\n        // If path length is k, compare and update bestPath\n        if (path.size() == k) {\n            if (firstPath || path < bestPath) {\n                bestPath = path;\n                firstPath = false;\n            }\n            continue;\n        }\n\n        // Explore neighbors\n        for (auto dir : directions) {\n            int nx = x + dir.first;\n            int ny = y + dir.second;\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                q.push({{nx, ny}, newPath});\n            }\n        }\n    }\n\n    return bestPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result;\n    if (n < 1) return result; // Handle edge case where n is less than 1\n\n    // Initialize the first element of the sequence\n    result.push_back(3);\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // For even i, compute directly\n            result.push_back(1 + i / 2);\n        } else {\n            // For odd i, compute using previous values\n            int value = result[i - 2] + result[i - 3] + (1 + (i + 1) / 2);\n            result.push_back(value);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert the integer to a string\n    string numStr = to_string(n);\n    \n    // Initialize product to 1 and found_odd to false\n    int product = 1;\n    bool found_odd = false;\n    \n    // Iterate over each character in the string\n    for (char ch : numStr) {\n        // Convert character to integer\n        int digit = ch - '0';\n        \n        // Check if the digit is odd\n        if (digit % 2 != 0) {\n            // Multiply it to the product\n            product *= digit;\n            // Set found_odd to true\n            found_odd = true;\n        }\n    }\n    \n    // If no odd digits were found, set product to 0\n    if (!found_odd) {\n        product = 0;\n    }\n    \n    // Return the product\n    return product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    int depth = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            s.push(ch);\n            depth++;\n        } else if (ch == ']') {\n            if (s.empty()) {\n                return false; // Invalid subsequence\n            }\n            s.pop();\n            depth--;\n        }\n        if (depth > 1) {\n            return true; // Nested brackets found\n        }\n    }\n\n    return false; // No nesting found\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiling_num = ceil(num);  // Compute the ceiling of the number\n        sum += ceiling_num * ceiling_num;  // Square the ceiling value and add to sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool check_if_last_char_is_a_letter(string txt) {\n       if (txt.empty()) {\n           return false;\n       }\n       char last_char = txt.back();\n       if (!isalpha(last_char)) {\n           return false;\n       }\n       if (txt.length() == 1) {\n           return true;\n       }\n       char second_last_char = txt[txt.length() - 2];\n       if (second_last_char == ' ') {\n           return true;\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/135", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int can_arrange(vector<int> arr){\n       int largest_index = -1;\n       for (int i = 1; i < arr.size(); ++i) {\n           if (arr[i] < arr[i - 1]) {\n               largest_index = i;\n           }\n       }\n       return largest_index;\n   }\n   "}
{"task_id": "CPP/136", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> largest_smallest_integers(vector<int> lst) {\n       int largest_negative = 0;\n       int smallest_positive = 0;\n\n       for (int num : lst) {\n           if (num < 0) {\n               if (largest_negative == 0 || num > largest_negative) {\n                   largest_negative = num;\n               }\n           } else if (num > 0) {\n               if (smallest_positive == 0 || num < smallest_positive) {\n                   smallest_positive = num;\n               }\n           }\n       }\n\n       return {largest_negative, smallest_positive};\n   }\n   "}
{"task_id": "CPP/137", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   #include<boost/any.hpp>\n   #include<boost/lexical_cast.hpp>\n   #include<boost/algorithm/string.hpp>\n\n   using namespace std;\n   using namespace boost;\n\n   boost::any compare_one(boost::any a, boost::any b) {\n       // Helper function to convert any to double\n       auto to_double = [](boost::any val) -> double {\n           if (val.type() == typeid(int)) {\n               return static_cast<double>(any_cast<int>(val));\n           } else if (val.type() == typeid(float)) {\n               return static_cast<double>(any_cast<float>(val));\n           } else if (val.type() == typeid(string)) {\n               string str = any_cast<string>(val);\n               replace(str.begin(), str.end(), ',', '.');\n               return lexical_cast<double>(str);\n           }\n           throw runtime_error(\"Unsupported type\");\n       };\n\n       double a_double = to_double(a);\n       double b_double = to_double(b);\n\n       if (a_double > b_double) {\n           return a;\n       } else if (a_double < b_double) {\n           return b;\n       } else {\n           return string(\"None\");\n       }\n   }\n   "}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and at least 8\n    if (n % 2 == 0 && n >= 8) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count > 2) {\n                continue; // Skip adding more than 2 consecutive spaces\n            }\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count == 2) {\n                result += \"__\";\n            } else if (space_count > 2) {\n                result += '-';\n            }\n            result += ch;\n            space_count = 0;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count == 2) {\n        result += \"__\";\n    } else if (space_count > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    int dot_index = -1;\n\n    // Count digits and find the dot\n    for (int i = 0; i < file_name.size(); i++) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n\n    // Check conditions\n    if (digit_count > 3 || dot_count != 1 || dot_index == 0 || dot_index == file_name.size() - 1) {\n        return \"No\";\n    }\n\n    string before_dot = file_name.substr(0, dot_index);\n    string after_dot = file_name.substr(dot_index + 1);\n\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            lst[i] = pow(lst[i], 2);\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = pow(lst[i], 3);\n        }\n    }\n    \n    int sum = 0;\n    for (int num : lst) {\n        sum += num;\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    // Split the sentence into words\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Collect words with prime lengths\n    vector<string> primeLengthWords;\n    for (const string& w : words) {\n        if (isPrime(w.length())) {\n            primeLengthWords.push_back(w);\n        }\n    }\n\n    // Join the collected words into a single string with spaces\n    string result;\n    for (size_t i = 0; i < primeLengthWords.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += primeLengthWords[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iostream>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Function to split the string by '/' and convert to integers\n    auto splitFraction = [](const string& fraction) -> pair<int, int> {\n        size_t pos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, pos));\n        int denominator = stoi(fraction.substr(pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Extract numerators and denominators\n    auto [numerator1, denominator1] = splitFraction(x);\n    auto [numerator2, denominator2] = splitFraction(n);\n\n    // Compute the product of the fractions\n    int productNumerator = numerator1 * numerator2;\n    int productDenominator = denominator1 * denominator2;\n\n    // Check if the product is a whole number\n    return productNumerator % productDenominator == 0;\n}\n\n// Example usage\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs (number, sum of digits)\n    vector<pair<int, int>> numsWithSums;\n    for (int num : nums) {\n        numsWithSums.push_back({num, sumOfDigits(num)});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    stable_sort(numsWithSums.begin(), numsWithSums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    // Extract the sorted numbers from the sorted vector of pairs\n    vector<int> sortedNums;\n    for (const auto& pair : numsWithSums) {\n        sortedNums.push_back(pair.first);\n    }\n\n    return sortedNums;\n}\n"}
{"task_id": "CPP/146", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   int specialFilter(vector<int> nums) {\n       int count = 0;\n       for (int num : nums) {\n           if (num > 10) {\n               string numStr = to_string(num);\n               int firstDigit = numStr[0] - '0';\n               int lastDigit = numStr[numStr.size() - 1] - '0';\n               if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                   count++;\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/147", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int get_max_triples(int n) {\n       vector<int> a(n);\n       for (int i = 1; i <= n; ++i) {\n           a[i-1] = i * i - i + 1;\n       }\n       \n       int count = 0;\n       for (int i = 0; i < n-2; ++i) {\n           for (int j = i+1; j < n-1; ++j) {\n               for (int k = j+1; k < n; ++k) {\n                   if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                       ++count;\n                   }\n               }\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/148", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> bf(string planet1, string planet2) {\n       vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n       vector<string> result;\n\n       // Check if both planets are valid\n       if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n           find(planets.begin(), planets.end(), planet2) == planets.end()) {\n           return result; // Return empty vector if either planet is invalid\n       }\n\n       // Find indices of planet1 and planet2\n       int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n       int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n       // Ensure index1 is less than index2\n       if (index1 > index2) {\n           swap(index1, index2);\n       }\n\n       // Extract the sublist\n       for (int i = index1; i <= index2; ++i) {\n           result.push_back(planets[i]);\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nint x_or_y(int n, int x, int y) {\n    // Handle the case where n is less than 2\n    if (n < 2) {\n        return y;\n    }\n    \n    // Check for divisors from 2 to the square root of n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return y; // n is not a prime number\n        }\n    }\n    \n    // If no divisors were found, n is a prime number\n    return x;\n}\n\n// Example usage\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num) {  // Check if the number is a positive integer\n            int intNum = static_cast<int>(num);\n            if (intNum % 2 != 0) {  // Check if the number is odd\n                sum += static_cast<long long>(intNum) * intNum;  // Add the square of the number to sum\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result(game.size());\n    for (int i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string Strongest_Extension(string class_name, vector<string> extensions) {\n       string strongest_extension = \"\";\n       int max_strength = INT_MIN;\n       \n       for (const string& extension : extensions) {\n           int CAP = 0;\n           int SM = 0;\n           \n           for (char c : extension) {\n               if (isupper(c)) {\n                   CAP++;\n               } else if (islower(c)) {\n                   SM++;\n               }\n           }\n           \n           int strength = CAP - SM;\n           \n           if (strength > max_strength) {\n               max_strength = strength;\n               strongest_extension = extension;\n           }\n       }\n       \n       return class_name + \".\" + strongest_extension;\n   }\n   "}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate b with itself to form bb\n    string bb = b + b;\n    \n    // Check if a is a substring of bb\n    if (bb.find(a) != string::npos) {\n        return true;\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   #include<vector>\n   using namespace std;\n\n   vector<int> even_odd_count(int num) {\n       if (num < 0) {\n           num = abs(num);\n       }\n       string num_str = to_string(num);\n       int even_count = 0;\n       int odd_count = 0;\n       for (char ch : num_str) {\n           int digit = ch - '0';  // Convert character to integer\n           if (digit % 2 == 0) {\n               even_count++;\n           } else {\n               odd_count++;\n           }\n       }\n       return {even_count, odd_count};\n   }\n   "}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring int_to_mini_roman(int number){\n    vector<pair<string, int>> roman_numerals = {\n        {\"M\", 1000}, {\"CM\", 900}, {\"D\", 500}, {\"CD\", 400},\n        {\"C\", 100}, {\"XC\", 90}, {\"L\", 50}, {\"XL\", 40},\n        {\"X\", 10}, {\"IX\", 9}, {\"V\", 5}, {\"IV\", 4}, {\"I\", 1}\n    };\n    string result = \"\";\n    for (const auto& [symbol, value] : roman_numerals) {\n        while (number >= value) {\n            result += symbol;\n            number -= value;\n        }\n    }\n    transform(result.begin(), result.end(), result.begin(), ::tolower);\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<algorithm>\n\n   bool right_angle_triangle(float a, float b, float c) {\n       // Sort the sides to ensure c is the longest side\n       if (a > b) std::swap(a, b);\n       if (b > c) std::swap(b, c);\n       if (a > b) std::swap(a, b);\n\n       // Check the Pythagorean theorem\n       return (a * a + b * b == c * c);\n   }\n   "}
{"task_id": "CPP/158", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   string find_max(vector<string> words) {\n       int max_unique_count = 0;\n       string result_word = \"\";\n       \n       for (const string& word : words) {\n           unordered_set<char> unique_chars(word.begin(), word.end());\n           int unique_count = unique_chars.size();\n           \n           if (unique_count > max_unique_count) {\n               max_unique_count = unique_count;\n               result_word = word;\n           } else if (unique_count == max_unique_count) {\n               if (result_word.empty() || word < result_word) {\n                   result_word = word;\n               }\n           }\n       }\n       \n       return result_word;\n   }\n   "}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_needed = number + need;\n    int total_eaten, carrots_left;\n\n    if (remaining >= need) {\n        total_eaten = total_needed;\n        carrots_left = remaining - need;\n    } else {\n        total_eaten = number + remaining;\n        carrots_left = 0;\n    }\n\n    return {total_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand){\n    // Initialize the result with the first operand\n    int result = operand[0];\n    \n    // Iterate through the operators and operands\n    for (int i = 0; i < operato.size(); ++i) {\n        // Get the next operand\n        int next_operand = operand[i + 1];\n        \n        // Apply the operator to the current result and the next operand\n        if (operato[i] == \"+\") {\n            result += next_operand;\n        } else if (operato[i] == \"-\") {\n            result -= next_operand;\n        } else if (operato[i] == \"*\") {\n            result *= next_operand;\n        } else if (operato[i] == \"//\") {\n            result /= next_operand;\n        } else if (operato[i] == \"**\") {\n            result = pow(result, next_operand);\n        }\n    }\n    \n    // Return the final result\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    for (char &c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    \n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check if the input string is empty\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    // Initialize the MD5 context\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update the MD5 context with the input string\n    MD5_Update(&md5Context, text.c_str(), text.size());\n\n    // Finalize the MD5 context to get the hash\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5_Final(result, &md5Context);\n\n    // Convert the hash to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << hex << setw(2) << setfill('0') << (int)result[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> generate_integers(int a, int b) {\n       // Ensure a is less than or equal to b\n       if (a > b) {\n           swap(a, b);\n       }\n\n       vector<int> result;\n       for (int i = a; i <= b; ++i) {\n           if (i >= 0 && i <= 8 && i % 2 == 0) {\n               result.push_back(i);\n           }\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Check for edge cases\n    if (numbers.size() < 2 || threshold <= 0) {\n        return false;\n    }\n\n    // Iterate through each pair of numbers\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            // Calculate the absolute difference\n            float diff = abs(numbers[i] - numbers[j]);\n            // Check if the difference is less than the threshold\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n\n    // If no pairs are found that meet the condition, return false\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    stack<char> s;\n    string current_group;\n\n    for (char c : paren_string) {\n        if (c == ' ') {\n            continue; // Ignore spaces\n        }\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            if (!s.empty() && s.top() == '(') {\n                s.pop();\n                current_group += c;\n                if (s.empty()) {\n                    result.push_back(current_group);\n                    current_group.clear();\n                }\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Calculate the integer part of the number\n    float integerPart = floor(number);\n    \n    // Calculate the decimal part by subtracting the integer part from the original number\n    float decimalPart = number - integerPart;\n    \n    // Return the decimal part\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_zero(vector<int> operations){\n       int balance = 0;\n       for (int operation : operations) {\n           balance += operation;\n           if (balance < 0) {\n               return true;\n           }\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/4", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   float mean_absolute_deviation(vector<float> numbers) {\n       // Calculate the mean of the dataset\n       float sum = 0;\n       for (float number : numbers) {\n           sum += number;\n       }\n       float mean = sum / numbers.size();\n\n       // Calculate the sum of absolute differences\n       float sum_of_abs_diff = 0;\n       for (float number : numbers) {\n           sum_of_abs_diff += abs(number - mean);\n       }\n\n       // Calculate and return the Mean Absolute Deviation\n       float MAD = sum_of_abs_diff / numbers.size();\n       return MAD;\n   }\n   "}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<sstream>\n   using namespace std;\n\n   vector<int> parse_nested_parens(string paren_string) {\n       vector<int> depths;\n       stringstream ss(paren_string);\n       string group;\n       \n       while (ss >> group) {\n           int max_depth = 0;\n           int current_depth = 0;\n           \n           for (char ch : group) {\n               if (ch == '(') {\n                   current_depth++;\n                   if (current_depth > max_depth) {\n                       max_depth = current_depth;\n                   }\n               } else if (ch == ')') {\n                   current_depth--;\n               }\n           }\n           \n           depths.push_back(max_depth);\n       }\n       \n       return depths;\n   }\n   "}
{"task_id": "CPP/7", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_substring(vector<string> strings, string substring) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(substring) != string::npos) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/8", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> sum_product(vector<int> numbers){\n       int sum = 0;\n       int product = 1;\n\n       for(int number : numbers){\n           sum += number;\n           product *= number;\n       }\n\n       // Handle the case where the vector is empty\n       if(numbers.empty()){\n           sum = 0;\n           product = 1;\n       }\n\n       return {sum, product};\n   }\n   "}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> rollingMax;\n    int currentMax = numbers[0];\n    \n    for (int i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] > currentMax) {\n            currentMax = numbers[i];\n        }\n        rollingMax.push_back(currentMax);\n    }\n    \n    return rollingMax;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    int n = str.length();\n    if (n == 0) return \"\";\n\n    for (int i = 0; i < n; i++) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            string reversed_prefix = string(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, reverse the entire string and append\n    string reversed_str = string(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == '0' && b[i] == '0') {\n            result += '0';\n        } else if (a[i] == '0' && b[i] == '1') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '0') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '1') {\n            result += '0';\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string longest(vector<string> strings){\n       if (strings.empty()) {\n           return \"\";\n       }\n       string longest_string = strings[0];\n       for (const string& str : strings) {\n           if (str.length() > longest_string.length()) {\n               longest_string = str;\n           }\n       }\n       return longest_string;\n   }\n   "}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n){\n    // Initialize a string stream\n    stringstream ss;\n    \n    // Loop from 0 to n\n    for(int i = 0; i <= n; ++i) {\n        // Append the number followed by a space\n        ss << i << \" \";\n    }\n    \n    // Convert the string stream to a string\n    string result = ss.str();\n    \n    // Remove the trailing space\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str){ \n    // Convert the string to lowercase\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Initialize a set to store unique characters\n    set<char> unique_chars;\n    \n    // Iterate through the string and insert each character into the set\n    for(char c : str) {\n        unique_chars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string current_note = \"\";\n\n    for (char c : music_string) {\n        if (c == ' ') {\n            if (current_note == \"o\") {\n                beats.push_back(4);\n            } else if (current_note == \"o|\") {\n                beats.push_back(2);\n            } else if (current_note == \".|\") {\n                beats.push_back(1);\n            }\n            current_note = \"\";\n        } else {\n            current_note += c;\n        }\n    }\n\n    // Check the last note if it exists\n    if (!current_note.empty()) {\n        if (current_note == \"o\") {\n            beats.push_back(4);\n        } else if (current_note == \"o|\") {\n            beats.push_back(2);\n        } else if (current_note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int how_many_times(string str, string substring) {\n       int count = 0;\n       int substring_length = substring.length();\n       for (int i = 0; i <= str.length() - substring_length; i++) {\n           if (str.substr(i, substring_length) == substring) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to associate number words with their numerical values\n    map<string, int> numMap = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    // Split the input string into a vector of number words\n    vector<string> numWords;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        numWords.push_back(word);\n    }\n    \n    // Sort the vector of number words using a custom comparator\n    sort(numWords.begin(), numWords.end(), [&](const string &a, const string &b) {\n        return numMap[a] < numMap[b];\n    });\n    \n    // Join the sorted vector back into a single string\n    string sortedNumbers;\n    for (const string &numWord : numWords) {\n        if (!sortedNumbers.empty()) {\n            sortedNumbers += \" \";\n        }\n        sortedNumbers += numWord;\n    }\n    \n    return sortedNumbers;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    float min_diff = INFINITY; // Initialize with a large value\n    vector<float> closest_pair;\n\n    // Loop through each element in the vector\n    for (int i = 0; i < numbers.size(); i++) {\n        // Loop through the remaining elements\n        for (int j = i + 1; j < numbers.size(); j++) {\n            // Calculate the absolute difference\n            float diff = abs(numbers[i] - numbers[j]);\n            // Update the minimum difference and the closest pair if necessary\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    // Ensure the closest pair is in ascending order\n    if (closest_pair[0] > closest_pair[1]) {\n        swap(closest_pair[0], closest_pair[1]);\n    }\n\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Initialize an empty vector for the result\n    vector<float> result;\n    \n    // Find the minimum and maximum values in the input vector\n    float min_value = numbers[0];\n    float max_value = numbers[0];\n    for (float num : numbers) {\n        if (num < min_value) {\n            min_value = num;\n        }\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n    \n    // Calculate the range\n    float range = max_value - min_value;\n    \n    // Iterate through each number in the input vector\n    for (float num : numbers) {\n        // Compute the new value using the formula\n        float new_value = (num - min_value) / range;\n        // Append the new value to the result vector\n        result.push_back(new_value);\n    }\n    \n    // Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case: no divisors other than 1 for n <= 1\n    int max_divisor = 1;\n    for (int i = n / 2; i > 1; --i) {\n        if (n % i == 0) {\n            max_divisor = i;\n            break;\n        }\n    }\n    return max_divisor;\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    // Step 1: Count occurrences of each element\n    unordered_map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    // Step 2: Construct the result vector with elements that occur only once\n    vector<int> result;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    // Step 3: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str){\n    string result = \"\";\n    for (char ch : str) {\n        if (islower(ch)) {\n            result += toupper(ch);\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_prefix(vector<string> strings, string prefix) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(prefix) == 0) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/30", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> get_positive(vector<float> l){\n       vector<float> result;\n       for(float number : l){\n           if(number > 0){\n               result.push_back(number);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// Function to evaluate the polynomial at point x\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\n// Function to evaluate the derivative of the polynomial at point x\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\n// Function to find a zero of the polynomial using Newton-Raphson method\ndouble find_zero(vector<double> xs) {\n    double x = 0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    double delta;\n\n    do {\n        double fx = poly(xs, x);\n        double fpx = poly_derivative(xs, x);\n        delta = fx / fpx;\n        x -= delta;\n    } while (fabs(delta) > tolerance);\n\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l){\n    int n = l.size();\n    vector<int> l_prime(n);\n    vector<int> divByThreeValues;\n\n    // Collect values at indices divisible by three\n    for (int i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            divByThreeValues.push_back(l[i]);\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Sort the collected values\n    sort(divByThreeValues.begin(), divByThreeValues.end());\n\n    // Place sorted values back into l_prime\n    int index = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            l_prime[i] = divByThreeValues[index++];\n        }\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Step 1: Initialize an empty set\n    set<int> uniqueSet;\n    \n    // Step 2: Insert each element from the input vector into the set\n    for(int num : l){\n        uniqueSet.insert(num);\n    }\n    \n    // Step 3: Convert the set to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 4: Sort the vector (optional, as sets are typically sorted)\n    // sort(uniqueVector.begin(), uniqueVector.end());\n    \n    // Step 5: Return the sorted vector\n    return uniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Initialize max_val with the first element of the vector\n    float max_val = l[0];\n    \n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < l.size(); i++) {\n        // Update max_val if the current element is greater\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    \n    // Return the maximum value found\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> l_prime;\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the new vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime.push_back(even_values[even_index++]);\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2;\n    if (n == 2) return 3;\n    \n    int count = 2;\n    int a = 2, b = 3;\n    \n    while (true) {\n        int c = a + b;\n        if (is_prime(c)) {\n            count += 1;\n            if (count == n) {\n                return c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // The total number of collisions is n * n\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> incr_list(vector<int> l){\n       vector<int> result;\n       for (int i = 0; i < l.size(); i++) {\n           result.push_back(l[i] + 1);\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Special case for zero\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x = x / base;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // Calculate the area using the formula\n    float area = 0.5 * a * h;\n    // Return the calculated area\n    return area;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    vector<int> fib4_values = {0, 0, 2, 0};\n\n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = next_value;\n    }\n\n    return fib4_values[3];\n}\n\n"}
{"task_id": "CPP/47", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   float median(vector<float> l){\n       // Sort the vector\n       sort(l.begin(), l.end());\n       \n       // Get the length of the vector\n       int n = l.size();\n       \n       // Check if the length is odd or even\n       if (n % 2 != 0) {\n           // If odd, return the middle element\n           return l[n / 2];\n       } else {\n           // If even, return the average of the two middle elements\n           return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n       }\n   }\n   "}
{"task_id": "CPP/48", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool is_palindrome(string text){\n       int left = 0;\n       int right = text.length() - 1;\n       \n       while (left < right) {\n           if (text[left] != text[right]) {\n               return false;\n           }\n           left++;\n           right--;\n       }\n       \n       return true;\n   }\n   "}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\n\nint modp(int n, int p) {\n    if (n == 0) {\n        return 1;\n    }\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_shift(string s){\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        // Calculate the new character by shifting backward by 5 positions\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<unordered_set>\n   using namespace std;\n\n   string remove_vowels(string text){\n       unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n       string result = \"\";\n       for (char ch : text) {\n           if (vowels.find(ch) == vowels.end()) {\n               result += ch;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/52", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_threshold(vector<int> l, int t) {\n       for (int num : l) {\n           if (num >= t) {\n               return false;\n           }\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    \n    // Compare the sorted strings\n    return s0 == s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0;\n    int b = 1;\n    int result = 0;\n\n    for (int i = 2; i <= n; ++i) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            counter++;\n        } else if (bracket == '>') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false;\n        }\n    }\n    return counter == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (int i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   vector<int> common(vector<int> l1, vector<int> l2) {\n       unordered_set<int> set1(l1.begin(), l1.end());\n       vector<int> result;\n\n       for (int num : l2) {\n           if (set1.find(num) != set1.end()) {\n               result.push_back(num);\n               set1.erase(num); // Ensure uniqueness\n           }\n       }\n\n       sort(result.begin(), result.end());\n       return result;\n   }\n   "}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    \n    // Check for the smallest prime factor (2)\n    if (n % 2 == 0) {\n        largest_factor = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int factor = 3; factor * factor <= n; factor += 2) {\n        while (n % factor == 0) {\n            largest_factor = factor;\n            n /= factor;\n        }\n    }\n    \n    // If n is still greater than 2, then n itself is a prime factor\n    if (n > 2) {\n        largest_factor = n;\n    }\n    \n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            counter++;\n        } else if (ch == ')') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false;\n        }\n    }\n    return counter == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> fibfib_values = {0, 0, 1};\n\n    for (int i = 3; i <= n; ++i) {\n        int next_fibfib = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3];\n        fibfib_values.push_back(next_fibfib);\n    }\n\n    return fibfib_values[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int vowels_count(string s) {\n       int count = 0;\n       transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n       for (int i = 0; i < s.length(); i++) {\n           if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n               count++;\n           } else if (s[i] == 'y' && i == s.length() - 1) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Perform the circular shift\n    string last_part = str_x.substr(len - shift);\n    string first_part = str_x.substr(0, len - shift);\n    \n    // Concatenate the last part to the front of the first part\n    string result = last_part + first_part;\n    \n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digitSum(string s) {\n       int sum = 0;\n       for (char c : s) {\n           if (c >= 'A' && c <= 'Z') {\n               sum += c;\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0, mangoes = 0;\n    stringstream ss(s);\n    string temp;\n    \n    // Extract number of apples\n    ss >> apples >> temp; // Read the number and \"apples\"\n    \n    // Extract number of oranges\n    ss >> temp >> oranges >> temp; // Read \"and\" and the number and \"oranges\"\n    \n    // Calculate the number of mangoes\n    mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/68", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<limits.h>\n   using namespace std;\n\n   vector<int> pluck(vector<int> arr){\n       int smallest_even_value = INT_MAX;\n       int smallest_index = -1;\n\n       for (int i = 0; i < arr.size(); ++i) {\n           if (arr[i] % 2 == 0 && arr[i] < smallest_even_value) {\n               smallest_even_value = arr[i];\n               smallest_index = i;\n           }\n       }\n\n       if (smallest_index == -1) {\n           return {};\n       } else {\n           return {smallest_even_value, smallest_index};\n       }\n   }\n   "}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Create an unordered_map to store the frequency of each integer\n    unordered_map<int, int> frequencyMap;\n    \n    // Step 2: Populate the unordered_map by iterating through the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    // Step 3: Iterate through the unordered_map to find the greatest integer\n    // that meets the criteria\n    int result = -1;\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    if (lst.empty()) {\n        return lst;\n    }\n    \n    sort(lst.begin(), lst.end());\n    vector<int> result;\n    int i = 0;\n    int j = lst.size() - 1;\n    \n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool will_it_fly(vector<int> q, int w) {\n       // Check if the vector is a palindrome\n       bool is_palindrome = true;\n       int n = q.size();\n       for (int i = 0; i < n / 2; ++i) {\n           if (q[i] != q[n - 1 - i]) {\n               is_palindrome = false;\n               break;\n           }\n       }\n       \n       // Calculate the sum of the elements in the vector\n       int sum = 0;\n       for (int element : q) {\n           sum += element;\n       }\n       \n       // Check if the sum is less than or equal to the maximum possible weight\n       if (is_palindrome && sum <= w) {\n           return true;\n       } else {\n           return false;\n       }\n   }\n   "}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int mismatches = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            mismatches++;\n        }\n        left++;\n        right--;\n    }\n\n    return mismatches;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total number of characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total number of characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate all prime numbers less than 100\nvector<int> generatePrimes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = generatePrimes();\n    int n = primes.size();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/76", "generation": "   #include<stdio.h>\n   #include<math.h>\n   using namespace std;\n\n   bool is_simple_power(int x, int n) {\n       if (n == 1) {\n           return x == 1;\n       }\n       int power = 1;\n       while (power < x) {\n           power *= n;\n           if (power == x) {\n               return true;\n           }\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        // Handle negative numbers\n        int abs_a = -a;\n        int cube_root = cbrt(abs_a);\n        return (cube_root * cube_root * cube_root == abs_a);\n    } else {\n        // Handle non-negative numbers\n        int cube_root = cbrt(a);\n        return (cube_root * cube_root * cube_root == a);\n    }\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Initialize the counter\n    int count = 0;\n    \n    // Loop through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            // Increment the counter\n            count++;\n        }\n    }\n    \n    // Return the counter\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    \n    string binary_string = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary_string = to_string(remainder) + binary_string;\n        decimal = decimal / 2;\n    }\n    \n    return \"db\" + binary_string + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s){\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string, checking every set of 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    // If all sets of 3 consecutive characters are distinct, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int length = str.length();\n    if (length < 2) {\n        return false;\n    }\n    if (length == 2 || length == 3) {\n        return true;\n    }\n    for (int i = 2; i <= sqrt(length); ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\n#include<cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers\n\n    int count_starting_with_1 = pow(10, n - 1);\n    int count_ending_with_1 = 9 * pow(10, n - 2);\n    int overlapping_count = pow(10, n - 2);\n\n    int total_count = count_starting_with_1 + count_ending_with_1 - overlapping_count;\n\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n            sum /= 2;\n        }\n    }\n\n    // Step 3: Return the binary representation\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0) { // Check if index is odd\n            if (lst[i] % 2 == 0) { // Check if number is even\n                sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string anti_shuffle(string s) {\n       vector<string> words;\n       string result = \"\";\n       string currentWord = \"\";\n\n       for (char c : s) {\n           if (c == ' ') {\n               if (!currentWord.empty()) {\n                   sort(currentWord.begin(), currentWord.end());\n                   words.push_back(currentWord);\n                   currentWord = \"\";\n               }\n               result += c;\n           } else {\n               currentWord += c;\n           }\n       }\n\n       if (!currentWord.empty()) {\n           sort(currentWord.begin(), currentWord.end());\n           words.push_back(currentWord);\n       }\n\n       for (int i = 0; i < words.size(); ++i) {\n           result += words[i];\n           if (i != words.size() - 1) {\n               result += ' ';\n           }\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/87", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n       vector<vector<int>> result;\n       \n       // Find all occurrences of x and store their coordinates\n       for (int i = 0; i < lst.size(); ++i) {\n           for (int j = 0; j < lst[i].size(); ++j) {\n               if (lst[i][j] == x) {\n                   result.push_back({i, j});\n               }\n           }\n       }\n       \n       // Sort the result vector by row index in ascending order\n       sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n           return a[0] < b[0];\n       });\n       \n       // For each row index, sort the coordinates by column index in descending order\n       int currentRow = -1;\n       for (int i = 0; i < result.size(); ++i) {\n           if (result[i][0] != currentRow) {\n               currentRow = result[i][0];\n               int start = i;\n               while (i + 1 < result.size() && result[i + 1][0] == currentRow) {\n                   ++i;\n               }\n               sort(result.begin() + start, result.begin() + i + 1, [](const vector<int>& a, const vector<int>& b) {\n                   return a[1] > b[1];\n               });\n           }\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/88", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<int> sort_array(vector<int> array) {\n       if (array.empty()) {\n           return {};\n       }\n\n       int sum = array[0] + array[array.size() - 1];\n       vector<int> sorted_array = array;\n\n       if (sum % 2 != 0) {\n           // Sort in ascending order\n           sort(sorted_array.begin(), sorted_array.end());\n       } else {\n           // Sort in descending order\n           sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n       }\n\n       return sorted_array;\n   }\n   "}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char new_char = (c - 'a' + 4) % 26 + 'a';\n            result += new_char;\n        } else if (c >= 'A' && c <= 'Z') {\n            char new_char = (c - 'A' + 4) % 26 + 'A';\n            result += new_char;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    int smallest = lst[0];\n    int second_smallest = lst[1];\n\n    if (smallest > second_smallest) {\n        swap(smallest, second_smallest);\n    }\n\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] < smallest) {\n            second_smallest = smallest;\n            smallest = lst[i];\n        } else if (lst[i] < second_smallest && lst[i] != smallest) {\n            second_smallest = lst[i];\n        }\n    }\n\n    if (second_smallest == smallest) {\n        return -1; // Return -1 to indicate None\n    }\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint is_bored(string S){\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n    vector<char> delimiters = {'.', '?', '!'};\n    \n    while (getline(ss, sentence, delimiters[0])) {\n        for (char delimiter : delimiters) {\n            size_t pos = sentence.find(delimiter);\n            if (pos != string::npos) {\n                sentence = sentence.substr(0, pos);\n                break;\n            }\n        }\n        // Trim leading and trailing spaces\n        size_t start = sentence.find_first_not_of(\" \\t\\n\\r\\f\\v\");\n        size_t end = sentence.find_last_not_of(\" \\t\\n\\r\\f\\v\");\n        if (start != string::npos && end != string::npos) {\n            sentence = sentence.substr(start, end - start + 1);\n        }\n        \n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence[0] == 'I') {\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "   #include<stdio.h>\n   #include<math.h>\n   using namespace std;\n\n   bool any_int(float a, float b, float c) {\n       // Check if all three numbers are integers\n       if (floor(a) != a || floor(b) != b || floor(c) != c) {\n           return false;\n       }\n\n       // Calculate the sums\n       float sum_ab = a + b;\n       float sum_ac = a + c;\n       float sum_bc = b + c;\n\n       // Check if any number is equal to the sum of the other two\n       if (a == sum_bc || b == sum_ac || c == sum_ab) {\n           return true;\n       } else {\n           return false;\n       }\n   }\n   "}
{"task_id": "CPP/93", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string encode(string message) {\n       string vowels = \"aeiouAEIOU\";\n       string result = \"\";\n\n       for (char &ch : message) {\n           if (vowels.find(ch) != string::npos) {\n               char nextChar = ch + 2;\n               if ((islower(ch) && nextChar > 'z') || (isupper(ch) && nextChar > 'Z')) {\n                   nextChar -= 26;\n               }\n               result += nextChar;\n           } else {\n               result += islower(ch) ? toupper(ch) : tolower(ch);\n           }\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    \n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    \n    // If no prime number is found, return 0\n    if (largestPrime == -1) return 0;\n    \n    // Return the sum of the digits of the largest prime number\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   bool check_dict_case(map<string, string> dict) {\n       if (dict.empty()) {\n           return false;\n       }\n\n       bool is_lower = true;\n       bool is_upper = true;\n\n       for (const auto& pair : dict) {\n           const string& key = pair.first;\n\n           if (!islower(key[0]) && !isupper(key[0])) {\n               return false;\n           }\n\n           for (char c : key) {\n               if (!islower(c)) {\n                   is_lower = false;\n               }\n               if (!isupper(c)) {\n                   is_upper = false;\n               }\n           }\n\n           if (!is_lower && !is_upper) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    if (n < 2) return {};\n\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Calculate the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0) { // Check if index is even\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a float\n    float num = stof(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1.0) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    }\n    // Otherwise, use the round function to get the closest integer\n    else {\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> make_a_pile(int n) {\n       vector<int> stones;\n       int current_stones = n;\n       for (int i = 0; i < n; ++i) {\n           stones.push_back(current_stones);\n           current_stones += 2;\n       }\n       return stones;\n   }\n   "}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    string currentWord = \"\";\n    \n    for(char c : s) {\n        if(c == ' ' || c == ',') {\n            if(!currentWord.empty()) {\n                words.push_back(currentWord);\n                currentWord = \"\";\n            }\n        } else {\n            currentWord += c;\n        }\n    }\n    \n    // Add the last word if it exists\n    if(!currentWord.empty()) {\n        words.push_back(currentWord);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    \n    int start;\n    if (x % 2 == 0) {\n        start = x;\n    } else {\n        start = x + 1;\n    }\n    \n    int largest_even = -1;\n    for (int i = start; i <= y; i += 2) {\n        if (i % 2 == 0) {\n            largest_even = i;\n        }\n    }\n    \n    return largest_even;\n}\n"}
{"task_id": "CPP/103", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   using namespace std;\n\n   string convert_to_binary(int number) {\n       if (number == 0) return \"0\";\n       string binary = \"\";\n       while (number > 0) {\n           binary = to_string(number % 2) + binary;\n           number /= 2;\n       }\n       return binary;\n   }\n\n   string rounded_avg(int n, int m) {\n       if (n > m) return \"-1\";\n       \n       int sum = 0;\n       int count = m - n + 1;\n       \n       for (int i = n; i <= m; ++i) {\n           sum += i;\n       }\n       \n       double average = static_cast<double>(sum) / count;\n       int rounded_average = floor(average);\n       \n       return convert_to_binary(rounded_average);\n   }\n   "}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x){\n    vector<int> result;\n    \n    // Helper function to check if a number contains any even digit\n    auto hasEvenDigit = [](int num) {\n        string numStr = to_string(num);\n        for (char ch : numStr) {\n            if (ch == '0' || ch == '2' || ch == '4' || ch == '6' || ch == '8') {\n                return true;\n            }\n        }\n        return false;\n    };\n    \n    // Iterate through each number in the input vector\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the result vector\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to convert digits to their corresponding names\n    map<int, string> digitToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the input vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Replace each integer with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(digitToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> f(int n) {\n       vector<int> result(n);\n       for (int i = 1; i <= n; ++i) {\n           if (i % 2 == 0) {\n               // Calculate factorial of i\n               int factorial = 1;\n               for (int j = 1; j <= i; ++j) {\n                   factorial *= j;\n               }\n               result[i - 1] = factorial;\n           } else {\n               // Calculate sum of numbers from 1 to i\n               int sum = 0;\n               for (int j = 1; j <= i; ++j) {\n                   sum += j;\n               }\n               result[i - 1] = sum;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        string num_str = to_string(i);\n        string rev_str = num_str;\n        reverse(rev_str.begin(), rev_str.end());\n        \n        if (num_str == rev_str) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        int sum_of_digits = 0;\n        int abs_number = abs(number);\n        while (abs_number > 0) {\n            int digit = abs_number % 10;\n            if (number < 0) {\n                digit = -digit;\n            }\n            sum_of_digits += digit;\n            abs_number /= 10;\n        }\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    // Find the index of the smallest element\n    int min_index = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n\n    // Check if the sequence from min_index to end and then from start to min_index is sorted\n    for (int i = 0; i < n - 1; ++i) {\n        int current = (min_index + i) % n;\n        int next = (min_index + i + 1) % n;\n        if (arr[current] > arr[next]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even_lst2++;\n        }\n    }\n    \n    if (count_odd_lst1 <= count_even_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   map<char, int> histogram(string test) {\n       map<char, int> letterCounts;\n       \n       // Count occurrences of each letter\n       for (char c : test) {\n           if (c == ' ') continue; // Skip spaces\n           if (letterCounts.find(c) == letterCounts.end()) {\n               letterCounts[c] = 1;\n           } else {\n               letterCounts[c]++;\n           }\n       }\n       \n       // Find the maximum count\n       int maxCount = 0;\n       for (const auto& entry : letterCounts) {\n           if (entry.second > maxCount) {\n               maxCount = entry.second;\n           }\n       }\n       \n       // Create the result map with letters having the maximum count\n       map<char, int> result;\n       for (const auto& entry : letterCounts) {\n           if (entry.second == maxCount) {\n               result[entry.first] = entry.second;\n           }\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set from characters in string c\n    unordered_set<char> charsToRemove(c.begin(), c.end());\n    \n    // Initialize the result string\n    string result;\n    \n    // Iterate through each character in string s\n    for (char ch : s) {\n        // If the character is not in the set, append it to result\n        if (charsToRemove.find(ch) == charsToRemove.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    \n    // Determine if the result string is a palindrome\n    bool isPalindrome = (result == reversedResult);\n    \n    // Return the result vector\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& str : lst) {\n        int count = 0;\n        for (char ch : str) {\n            if (ch == '1' || ch == '3' || ch == '5' || ch == '7' || ch == '9') {\n                count++;\n            }\n        }\n        string formatted_string = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(formatted_string);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Edge case: empty vector\n\n    long long min_sum = nums[0]; // Initialize with the first element\n    long long current_sum = nums[0]; // Initialize with the first element\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<cmath> // for ceil function\n   using namespace std;\n\n   int max_fill(vector<vector<int>> grid, int capacity) {\n       int total_lowering_count = 0;\n       for (const auto& row : grid) {\n           int water_units = 0;\n           for (int cell : row) {\n               if (cell == 1) {\n                   water_units++;\n               }\n           }\n           int lowering_count = ceil((double)water_units / capacity);\n           total_lowering_count += lowering_count;\n       }\n       return total_lowering_count;\n   }\n   "}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Function to sort the array based on the number of ones in binary representation\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    auto comparator = [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b; // If number of ones is the same, sort by decimal value\n        }\n        return onesA < onesB; // Otherwise, sort by number of ones\n    };\n\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), comparator);\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    // Split the string into words\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    // Check each word for the number of consonants\n    for (const string& word : words) {\n        int consonantCount = 0;\n        for (char c : word) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string result = \"\";\n    string vowels = \"aeiouAEIOU\";\n    \n    // Traverse the word from right to left\n    for (int i = word.size() - 1; i > 0; --i) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the previous and next characters are consonants\n            if (i > 0 && i < word.size() - 1 && vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int count_open_1 = 0, count_close_1 = 0;\n    int count_open_2 = 0, count_close_2 = 0;\n    \n    // Count '(' and ')' in the first string\n    for (char c : lst[0]) {\n        if (c == '(') count_open_1++;\n        if (c == ')') count_close_1++;\n    }\n    \n    // Count '(' and ')' in the second string\n    for (char c : lst[1]) {\n        if (c == '(') count_open_2++;\n        if (c == ')') count_close_2++;\n    }\n    \n    int total_open = count_open_1 + count_open_2;\n    int total_close = count_close_1 + count_close_2;\n    \n    if (total_open == total_close) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements\n    vector<int> max_k(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the k elements in ascending order\n    sort(max_k.begin(), max_k.end());\n    \n    // Step 4: Return the sorted k elements\n    return max_k;\n}\n"}
{"task_id": "CPP/121", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int solution(vector<int> lst) {\n       int sum = 0;\n       for (int i = 0; i < lst.size(); ++i) {\n           if (i % 2 == 0) {  // Check if the position is even\n               if (lst[i] % 2 != 0) {  // Check if the element is odd\n                   sum += lst[i];\n               }\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/122", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int add_elements(vector<int> arr, int k) {\n       int sum = 0;\n       for (int i = 0; i < k; ++i) {\n           if (arr[i] >= 0 && arr[i] <= 99) {\n               sum += arr[i];\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If n is even\n            n = n / 2;\n        } else { // If n is odd\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final 1 to the sequence\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<sstream>\n   #include<vector>\n   using namespace std;\n\n   bool isLeapYear(int year) {\n       return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n   }\n\n   bool valid_date(string date) {\n       // Check if the date string is in the correct format\n       if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n           return false;\n       }\n\n       // Split the date string into month, day, and year\n       stringstream ss(date);\n       string token;\n       vector<string> tokens;\n       while (getline(ss, token, '-')) {\n           tokens.push_back(token);\n       }\n\n       if (tokens.size() != 3) {\n           return false;\n       }\n\n       int month = stoi(tokens[0]);\n       int day = stoi(tokens[1]);\n       int year = stoi(tokens[2]);\n\n       // Validate month\n       if (month < 1 || month > 12) {\n           return false;\n       }\n\n       // Validate day based on month\n       if (month == 2) {\n           if (isLeapYear(year)) {\n               if (day < 1 || day > 29) {\n                   return false;\n               }\n           } else {\n               if (day < 1 || day > 28) {\n                   return false;\n               }\n           }\n       } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n           if (day < 1 || day > 30) {\n               return false;\n           }\n       } else {\n           if (day < 1 || day > 31) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespaces\n    if (txt.find(' ') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        result.push_back(txt.substr(start, end - start));\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start, end - start));\n        return result;\n    }\n    \n    // Count lowercase letters with odd order\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    \n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<unordered_map>\n   using namespace std;\n\n   bool is_sorted(vector<int> lst){\n       if (lst.size() <= 1) {\n           return true;\n       }\n       \n       unordered_map<int, int> countMap;\n       \n       for (int num : lst) {\n           countMap[num]++;\n           if (countMap[num] > 2) {\n               return false;\n           }\n       }\n       \n       for (size_t i = 0; i < lst.size() - 1; ++i) {\n           if (lst[i] > lst[i + 1]) {\n               return false;\n           }\n       }\n       \n       return true;\n   }\n   "}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int maxStart = max(start1, start2);\n    int minEnd = min(end1, end2);\n    \n    if (maxStart <= minEnd) {\n        int length = minEnd - maxStart + 1;\n        if (isPrime(length)) {\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int prod_signs(vector<int> arr){\n       if (arr.empty()) {\n           return -32768;\n       }\n       int sum_of_magnitudes = 0;\n       int product_of_signs = 1;\n       for (int number : arr) {\n           sum_of_magnitudes += abs(number);\n           if (number > 0) {\n               product_of_signs *= 1;\n           } else if (number < 0) {\n               product_of_signs *= -1;\n           } else {\n               product_of_signs = 0;\n               break;\n           }\n       }\n       return sum_of_magnitudes * product_of_signs;\n   }\n   "}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> bestPath;\n    bool firstPath = true;\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // BFS function to explore paths\n    auto bfs = [&](int startX, int startY) {\n        queue<pair<vector<int>, pair<int, int>>> q;\n        q.push({{grid[startX][startY]}, {startX, startY}});\n\n        while (!q.empty()) {\n            auto current = q.front();\n            q.pop();\n\n            vector<int> currentPath = current.first;\n            int x = current.second.first;\n            int y = current.second.second;\n\n            if (currentPath.size() == k) {\n                if (firstPath || currentPath < bestPath) {\n                    bestPath = currentPath;\n                    firstPath = false;\n                }\n                continue;\n            }\n\n            for (auto dir : directions) {\n                int newX = x + dir.first;\n                int newY = y + dir.second;\n\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                    vector<int> newPath = currentPath;\n                    newPath.push_back(grid[newX][newY]);\n                    q.push({newPath, {newX, newY}});\n                }\n            }\n        }\n    };\n\n    // Start BFS from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            bfs(i, j);\n        }\n    }\n\n    return bestPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result;\n    if (n < 1) return result; // Handle edge case where n is less than 1\n\n    // Initialize the first element\n    result.push_back(3);\n\n    for (int i = 2; i <= n + 1; ++i) {\n        if (i % 2 == 0) {\n            // Even index\n            result.push_back(1 + i / 2);\n        } else {\n            // Odd index\n            int value = result[i - 2] + result[i - 3] + result[i];\n            result.push_back(value);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digits(int n) {\n       string numStr = to_string(n);\n       int product = 1;\n       bool oddFound = false;\n\n       for (char ch : numStr) {\n           int digit = ch - '0';\n           if (digit % 2 != 0) {\n               product *= digit;\n               oddFound = true;\n           }\n       }\n\n       if (!oddFound) {\n           return 0;\n       }\n\n       return product;\n   }\n   "}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool has_nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            s.push(ch);\n        } else if (ch == ']') {\n            if (!s.empty()) {\n                s.pop();\n                if (!s.empty()) {\n                    has_nested = true;\n                }\n            } else {\n                return false; // Unmatched closing bracket\n            }\n        }\n    }\n\n    // If stack is not empty, there are unmatched opening brackets\n    if (!s.empty()) {\n        return false;\n    }\n\n    return has_nested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiling_num = ceil(num);  // Compute the ceiling of the number\n        sum += ceiling_num * ceiling_num;  // Square the ceiling value and add to sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    // Get the last character of the string\n    char lastChar = txt.back();\n    \n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) {\n        return false;\n    }\n    \n    // Check if the last character is followed by a space or is the only character in the string\n    if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n        return true;\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr){\n    int largest_index = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            largest_index = i;\n        }\n    }\n    return largest_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/lexical_cast.hpp>\n#include<cctype>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert string to float handling both . and ,\n    auto convert_to_float = [](const string& str) -> float {\n        string temp = str;\n        replace(temp.begin(), temp.end(), ',', '.');\n        return boost::lexical_cast<float>(temp);\n    };\n\n    // Convert a and b to float for comparison\n    float val_a, val_b;\n    if (a.type() == typeid(int)) {\n        val_a = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val_a = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        val_a = convert_to_float(boost::any_cast<string>(a));\n    } else {\n        throw invalid_argument(\"Unsupported type for a\");\n    }\n\n    if (b.type() == typeid(int)) {\n        val_b = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val_b = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        val_b = convert_to_float(boost::any_cast<string>(b));\n    } else {\n        throw invalid_argument(\"Unsupported type for b\");\n    }\n\n    // Compare the converted values\n    if (val_a > val_b) {\n        return a;\n    } else if (val_b > val_a) {\n        return b;\n    } else {\n        return \"None\";\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // If n is less than 8, it cannot be the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n    // If n is odd, it cannot be the sum of 4 even numbers\n    if (n % 2 != 0) {\n        return false;\n    }\n    // Check if n can be divided by 2 four times\n    if (n % 8 == 0) {\n        return true;\n    }\n    // Otherwise, it cannot be the sum of 4 even numbers\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text){\n    string result = \"\";\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count > 2) {\n                result += '-';\n                space_count = 0; // Reset counter after adding hyphen\n            }\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += ch;\n            space_count = 0; // Reset counter after adding character\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    int dot_index = -1;\n\n    // Count digits and find the dot\n    for (int i = 0; i < file_name.size(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n\n    // Check digit count and dot count\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the file name into two parts\n    string before_dot = file_name.substr(0, dot_index);\n    string after_dot = file_name.substr(dot_index + 1);\n\n    // Check if before_dot is not empty and starts with a Latin alphabet letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if after_dot is one of the allowed extensions\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int sum_squares(vector<int> lst) {\n       int sum = 0;\n       for (int i = 0; i < lst.size(); ++i) {\n           if (i % 3 == 0) {\n               lst[i] = lst[i] * lst[i]; // Square the element\n           } else if (i % 4 == 0 && i % 3 != 0) {\n               lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n           }\n           sum += lst[i]; // Add the modified element to sum\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    // Split the sentence into words\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Collect words with prime lengths\n    vector<string> primeLengthWords;\n    for (const string& w : words) {\n        if (isPrime(w.length())) {\n            primeLengthWords.push_back(w);\n        }\n    }\n\n    // Join the collected words into a single string\n    string result;\n    for (size_t i = 0; i < primeLengthWords.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += primeLengthWords[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Helper function to split the string by '/'\n    auto split = [](const string& s, char delimiter) -> pair<int, int> {\n        stringstream ss(s);\n        string item;\n        getline(ss, item, delimiter);\n        int numerator = stoi(item);\n        getline(ss, item, delimiter);\n        int denominator = stoi(item);\n        return {numerator, denominator};\n    };\n\n    // Parse the input fractions\n    auto [numerator_x, denominator_x] = split(x, '/');\n    auto [numerator_n, denominator_n] = split(n, '/');\n\n    // Compute the product of the fractions\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return product_numerator % product_denominator == 0;\n}\n\n// Example usage\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\n// Custom comparator for sorting based on sum of digits\nbool compareBySumOfDigits(int a, int b, const vector<int>& original) {\n    int sumA = sumOfDigits(a);\n    int sumB = sumOfDigits(b);\n    if (sumA == sumB) {\n        // If sums are equal, maintain original order\n        return find(original.begin(), original.end(), a) < find(original.begin(), original.end(), b);\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a copy of the original vector to maintain order for equal sums\n    vector<int> original = nums;\n    \n    // Sort the vector using the custom comparator\n    sort(nums.begin(), nums.end(), [&original](int a, int b) {\n        return compareBySumOfDigits(a, b, original);\n    });\n    \n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   int specialFilter(vector<int> nums){\n       int count = 0;\n       for (int num : nums) {\n           if (num > 10) {\n               string numStr = to_string(abs(num)); // Use abs to handle negative numbers\n               char first_digit = numStr[0];\n               char last_digit = numStr[numStr.size() - 1];\n               if ((first_digit == '1' || first_digit == '3' || first_digit == '5' || first_digit == '7' || first_digit == '9') &&\n                   (last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9')) {\n                   count++;\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/147", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int get_max_triples(int n) {\n       vector<int> a(n);\n       for (int i = 1; i <= n; ++i) {\n           a[i-1] = i * i - i + 1;\n       }\n       \n       int count = 0;\n       for (int i = 0; i < n-2; ++i) {\n           for (int j = i+1; j < n-1; ++j) {\n               for (int k = j+1; k < n; ++k) {\n                   if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                       count += 1;\n                   }\n               }\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planet1 and planet2 are valid planet names\n    bool isValidPlanet1 = find(planets.begin(), planets.end(), planet1) != planets.end();\n    bool isValidPlanet2 = find(planets.begin(), planets.end(), planet2) != planets.end();\n    \n    // If either planet1 or planet2 is not a valid planet name, return an empty vector\n    if (!isValidPlanet1 || !isValidPlanet2) {\n        return {};\n    }\n    \n    // Find the indices of planet1 and planet2 in the list\n    int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Extract the planets that lie between index1 and index2\n    vector<string> result(planets.begin() + index1 + 1, planets.begin() + index2);\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nint x_or_y(int n, int x, int y) {\n    // Handle edge case for numbers less than 2\n    if (n < 2) {\n        return y;\n    }\n    \n    // Check for primality\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return y; // n is not a prime number\n        }\n    }\n    \n    // If no divisors found, n is a prime number\n    return x;\n}\n\n// Example usage\n"}
{"task_id": "CPP/151", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   long long double_the_difference(vector<float> lst) {\n       long long sum = 0;\n       for (float num : lst) {\n           if (num > 0 && floor(num) == num) {  // Check if num is a positive integer\n               int intNum = static_cast<int>(num);\n               if (intNum % 2 != 0) {  // Check if num is odd\n                   sum += intNum * intNum;\n               }\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int cap = 0;\n        int sm = 0;\n\n        for (char c : ext) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n\n        int strength = cap - sm;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the second word with itself\n    string concatenated = b + b;\n    \n    // Check if the first word is a substring of the concatenated string\n    return concatenated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Convert the number to a string\n    string num_str = to_string(abs(num));\n    \n    // Iterate through each character in the string\n    for (char digit_char : num_str) {\n        // Convert the character to an integer\n        int digit = digit_char - '0';\n        \n        // Check if the digit is even or odd\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    // Return the counters as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Lookup table for Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the lookup table\n    for (const auto& symbol : romanSymbols) {\n        // While the number is greater than or equal to the current value\n        while (number >= symbol.first) {\n            // Subtract the value from the number\n            number -= symbol.first;\n            // Append the corresponding Roman numeral symbol to the result string\n            result += symbol.second;\n        }\n    }\n    \n    // Convert the result string to lowercase\n    transform(result.begin(), result.end(), result.begin(), ::tolower);\n    \n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Identify the hypotenuse (longest side)\n    float hypotenuse = max(a, max(b, c));\n    \n    // Determine the other two sides\n    float side1, side2;\n    if (hypotenuse == a) {\n        side1 = b;\n        side2 = c;\n    } else if (hypotenuse == b) {\n        side1 = a;\n        side2 = c;\n    } else {\n        side1 = a;\n        side2 = b;\n    }\n    \n    // Check the Pythagorean theorem\n    return (pow(side1, 2) + pow(side2, 2) == pow(hypotenuse, 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueChars = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueChars || (uniqueCount == maxUniqueChars && word < maxWord)) {\n            maxUniqueChars = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm> // for std::min\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_needed = number + need;\n    int actual_eaten = min(total_needed, remaining);\n    int carrots_left = remaining - actual_eaten;\n    return {number + actual_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n    \n    // Iterate through the operators and operands\n    for (int i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n        \n        // Apply the operator to the current result and the next operand\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            result /= next_operand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, next_operand); // Exponentiation\n        }\n    }\n    \n    // Return the final result\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   string solve(string s) {\n       bool has_letter = false;\n       for (char c : s) {\n           if (isalpha(c)) {\n               has_letter = true;\n               break;\n           }\n       }\n\n       if (has_letter) {\n           for (char &c : s) {\n               if (islower(c)) {\n                   c = toupper(c);\n               } else if (isupper(c)) {\n                   c = tolower(c);\n               }\n           }\n       } else {\n           reverse(s.begin(), s.end());\n       }\n\n       return s;\n   }\n   "}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check if the input string is empty\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    // Initialize the MD5 context\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update the MD5 context with the input string\n    MD5_Update(&md5Context, text.c_str(), text.size());\n\n    // Finalize the MD5 context to get the hash\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5_Final(result, &md5Context);\n\n    // Convert the hash to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << hex << setw(2) << setfill('0') << (int)result[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    for (int i = min_val; i <= max_val; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> separate_paren_groups(string paren_string) {\n       vector<string> result;\n       string current_group;\n       int balance_counter = 0;\n\n       for (char ch : paren_string) {\n           if (ch == ' ') continue; // Ignore spaces\n           current_group += ch;\n           if (ch == '(') {\n               balance_counter++;\n           } else if (ch == ')') {\n               balance_counter--;\n               if (balance_counter == 0) {\n                   result.push_back(current_group);\n                   current_group = \"\";\n               }\n           }\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number) {\n    // Calculate the integer part using floor\n    float integerPart = floor(number);\n    \n    // Calculate the decimal part by subtracting the integer part from the original number\n    float decimalPart = number - integerPart;\n    \n    // Return the decimal part\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_zero(vector<int> operations){\n       int balance = 0;\n       for (int operation : operations) {\n           balance += operation;\n           if (balance < 0) {\n               return true;\n           }\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/4", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   float mean_absolute_deviation(vector<float> numbers){\n       // Calculate the mean of the dataset\n       float sum = 0;\n       for (float number : numbers) {\n           sum += number;\n       }\n       float mean = sum / numbers.size();\n\n       // Calculate the sum of absolute differences\n       float sum_of_differences = 0;\n       for (float number : numbers) {\n           sum_of_differences += fabs(number - mean);\n       }\n\n       // Calculate the Mean Absolute Deviation\n       float mad = sum_of_differences / numbers.size();\n\n       return mad;\n   }\n   "}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<sstream>\n   #include<stack>\n   using namespace std;\n\n   vector<int> parse_nested_parens(string paren_string) {\n       vector<int> result;\n       stringstream ss(paren_string);\n       string group;\n       \n       while (ss >> group) {\n           stack<char> s;\n           int max_depth = 0;\n           int current_depth = 0;\n           \n           for (char c : group) {\n               if (c == '(') {\n                   s.push(c);\n                   current_depth++;\n                   if (current_depth > max_depth) {\n                       max_depth = current_depth;\n                   }\n               } else if (c == ')') {\n                   if (!s.empty()) {\n                       s.pop();\n                       current_depth--;\n                   }\n               }\n           }\n           \n           result.push_back(max_depth);\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/7", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_substring(vector<string> strings, string substring) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(substring) != string::npos) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/8", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> sum_product(vector<int> numbers){\n       int sum = 0;\n       int product = 1;\n\n       for(int number : numbers){\n           sum += number;\n           product *= number;\n       }\n\n       // Handle the case where the vector is empty\n       if(numbers.empty()){\n           sum = 0;\n           product = 1;\n       }\n\n       return {sum, product};\n   }\n   "}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> rollingMax;\n    int currentMax = numbers[0];\n    \n    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > currentMax) {\n            currentMax = numbers[i];\n        }\n        rollingMax.push_back(currentMax);\n    }\n    \n    return rollingMax;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    if (str.empty()) return \"\";\n    \n    for (int i = 0; i < str.size(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    \n    // If no palindrome suffix is found, reverse the entire string and append\n    string reversed_str(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == '0' && b[i] == '0') {\n            result += '0';\n        } else if (a[i] == '0' && b[i] == '1') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '0') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '1') {\n            result += '0';\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string longest(vector<string> strings){\n       if (strings.empty()) {\n           return \"\";\n       }\n       string longest_string = strings[0];\n       for (const string& str : strings) {\n           if (str.length() > longest_string.length()) {\n               longest_string = str;\n           }\n       }\n       return longest_string;\n   }\n   "}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Base case: if b is 0, then the GCD is a\n    if (b == 0) {\n        return a;\n    }\n    // Recursive case: call the function with b and a % b\n    return greatest_common_divisor(b, a % b);\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i) + \" \";\n    }\n    if (!result.empty()) {\n        result.pop_back(); // Remove the trailing space\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str){ \n    // Convert the string to lowercase\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Initialize a set to store unique characters\n    set<char> unique_chars;\n    \n    // Iterate through the string and insert each character into the set\n    for(char c : str) {\n        unique_chars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string){ \n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int how_many_times(string str, string substring) {\n       int count = 0;\n       int length_str = str.length();\n       int length_sub = substring.length();\n       \n       for (int i = 0; i <= length_str - length_sub; i++) {\n           if (str.substr(i, length_sub) == substring) {\n               count++;\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to associate each numeral with its integer value\n    map<string, int> numeralToValue = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    // Split the input string into a vector of numerals\n    vector<string> numeralList;\n    stringstream ss(numbers);\n    string numeral;\n    while (ss >> numeral) {\n        numeralList.push_back(numeral);\n    }\n    \n    // Sort the vector of numerals using the map to compare their integer values\n    sort(numeralList.begin(), numeralList.end(), [&](const string &a, const string &b) {\n        return numeralToValue[a] < numeralToValue[b];\n    });\n    \n    // Join the sorted vector back into a single string\n    string sortedNumbers;\n    for (const string &n : numeralList) {\n        if (!sortedNumbers.empty()) {\n            sortedNumbers += \" \";\n        }\n        sortedNumbers += n;\n    }\n    \n    return sortedNumbers;\n}\n"}
{"task_id": "CPP/20", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> find_closest_elements(vector<float> numbers) {\n       vector<float> closest_pair;\n       float min_diff = INFINITY;\n\n       for (int i = 0; i < numbers.size(); i++) {\n           for (int j = i + 1; j < numbers.size(); j++) {\n               float diff = abs(numbers[i] - numbers[j]);\n               if (diff < min_diff) {\n                   min_diff = diff;\n                   closest_pair = {numbers[i], numbers[j]};\n               }\n           }\n       }\n\n       if (closest_pair[0] > closest_pair[1]) {\n           swap(closest_pair[0], closest_pair[1]);\n       }\n\n       return closest_pair;\n   }\n   "}
{"task_id": "CPP/21", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<float> rescale_to_unit(vector<float> numbers){\n       float min_value = *min_element(numbers.begin(), numbers.end());\n       float max_value = *max_element(numbers.begin(), numbers.end());\n       float range = max_value - min_value;\n       vector<float> new_numbers;\n       for (float number : numbers) {\n           float new_value = (number - min_value) / range;\n           new_numbers.push_back(new_value);\n       }\n       return new_numbers;\n   }\n   "}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case: no divisors for numbers less than or equal to 1\n    int max_divisor = 1;\n    for (int i = n / 2; i > 1; --i) {\n        if (n % i == 0) {\n            max_divisor = i;\n            break;\n        }\n    }\n    return max_divisor;\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    // Step 1: Count occurrences of each element\n    unordered_map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    // Step 2: Construct the result vector with elements that occur only once\n    vector<int> result;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    // Step 3: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str){\n    string result = \"\";\n    for (char ch : str) {\n        if (islower(ch)) {\n            result += toupper(ch);\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_prefix(vector<string> strings, string prefix) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(prefix) == 0) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/30", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> get_positive(vector<float> l){\n       vector<float> positive_numbers;\n       for(float num : l){\n           if(num > 0){\n               positive_numbers.push_back(num);\n           }\n       }\n       return positive_numbers;\n   }\n   "}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// Function to evaluate polynomial using Horner's method\ndouble poly(vector<double> xs, double x) {\n    double result = 0;\n    for (int i = xs.size() - 1; i >= 0; i--) {\n        result = result * x + xs[i];\n    }\n    return result;\n}\n\n// Function to compute the derivative of the polynomial\ndouble poly_derivative(vector<double> xs, double x) {\n    double result = 0;\n    for (int i = xs.size() - 1; i > 0; i--) {\n        result = result * x + i * xs[i];\n    }\n    return result;\n}\n\n// Function to find a zero of the polynomial using Newton-Raphson method\ndouble find_zero(vector<double> xs) {\n    double x0 = 0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double fpx = poly_derivative(xs, x0);\n\n        if (fabs(fx) < tolerance) {\n            return x0; // Converged to a zero\n        }\n\n        x0 = x0 - fx / fpx; // Newton-Raphson update\n    }\n\n    return x0; // Return the last computed value if not converged\n}\n\n// Example usage\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l){\n    // Vector to store elements at indices divisible by 3\n    vector<int> third_elements;\n    \n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    sort(third_elements.begin(), third_elements.end());\n    \n    // Replace the elements at indices divisible by 3 with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = third_elements[index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Step 1: Initialize an empty set\n    set<int> uniqueSet;\n    \n    // Step 2: Iterate through the input vector and insert each element into the set\n    for(int num : l){\n        uniqueSet.insert(num);\n    }\n    \n    // Step 3: Convert the set to a vector\n    vector<int> result(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 4: Return the vector\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Initialize max_val with the first element of the vector\n    float max_val = l[0];\n    \n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < l.size(); i++) {\n        // If the current element is greater than max_val, update max_val\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    \n    // Return the maximum value found\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int fizz_buzz(int n) {\n       int count = 0;\n       for (int i = 0; i < n; ++i) {\n           if (i % 11 == 0 || i % 13 == 0) {\n               string numStr = to_string(i);\n               for (char c : numStr) {\n                   if (c == '7') {\n                       count++;\n                   }\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> l_prime;\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the new vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime.push_back(even_values[even_index++]);\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    string output;\n    int l = s.length();\n    int num = (l + 2) / 3;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2); // Reverse the cycling\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2;\n    if (n == 2) return 3;\n    \n    int count = 2;\n    int a = 2, b = 3;\n    \n    while (true) {\n        int c = a + b;\n        if (is_prime(c)) {\n            count += 1;\n            if (count == n) {\n                return c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> incr_list(vector<int> l){\n       vector<int> result;\n       for (int i = 0; i < l.size(); i++) {\n           result.push_back(l[i] + 1);\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int number : l) {\n        if (seen.find(-number) != seen.end()) {\n            return true;\n        }\n        seen.insert(number);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Special case for zero\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder to the result string\n        x /= base;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // Calculate the area using the formula 1/2 * base * height\n    float area = 0.5 * a * h;\n    // Return the calculated area\n    return area;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n < 0) return -1; // Invalid input\n\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four values\n    vector<int> fib4_values = {0, 0, 2, 0};\n\n    // Compute the Fib4 sequence iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        // Update the array by shifting values\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = next_value;\n    }\n\n    // Return the last computed value\n    return fib4_values[3];\n}\n\n// Example usage\n"}
{"task_id": "CPP/47", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   float median(vector<float> l){\n       // Sort the vector\n       sort(l.begin(), l.end());\n       \n       // Get the size of the vector\n       int n = l.size();\n       \n       // Check if the size is odd or even\n       if (n % 2 != 0) {\n           // If odd, return the middle element\n           return l[n/2];\n       } else {\n           // If even, return the average of the two middle elements\n           return (l[(n/2)-1] + l[n/2]) / 2.0;\n       }\n   }\n   "}
{"task_id": "CPP/48", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool is_palindrome(string text){\n       int left = 0;\n       int right = text.length() - 1;\n       while (left < right) {\n           if (text[left] != text[right]) {\n               return false;\n           }\n           left++;\n           right--;\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\n\nint modp(int n, int p) {\n    if (n == 0) {\n        return 1;\n    }\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string remove_vowels(string text){\n       string result = \"\";\n       string vowels = \"aeiouAEIOU\";\n       for (char c : text) {\n           if (vowels.find(c) == string::npos) {\n               result += c;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/52", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_threshold(vector<int> l, int t) {\n       for (int num : l) {\n           if (num >= t) {\n               return false;\n           }\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    \n    // Compare the sorted strings\n    return s0 == s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else if (c == '>') {\n            if (s.empty()) {\n                return false; // Unmatched closing bracket\n            }\n            s.pop();\n        }\n    }\n    return s.empty(); // True if all brackets matched, false otherwise\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   vector<int> common(vector<int> l1, vector<int> l2) {\n       unordered_set<int> set_l1(l1.begin(), l1.end());\n       vector<int> result;\n\n       for (int num : l2) {\n           if (set_l1.find(num) != set_l1.end()) {\n               result.push_back(num);\n               set_l1.erase(num); // Ensure uniqueness\n           }\n       }\n\n       sort(result.begin(), result.end());\n       return result;\n   }\n   "}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    \n    // Check for the smallest prime factor (2)\n    if (n % 2 == 0) {\n        largest_factor = 2;\n        while (n % 2 == 0) {\n            n = n / 2;\n        }\n    }\n    \n    // Check for odd factors from 3 onwards\n    int factor = 3;\n    while (n > 1) {\n        if (n % factor == 0) {\n            largest_factor = factor;\n            while (n % factor == 0) {\n                n = n / factor;\n            }\n        }\n        factor += 2;\n    }\n    \n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false; // Unmatched closing bracket\n            }\n            s.pop();\n        }\n    }\n    return s.empty(); // True if all brackets matched, false otherwise\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <vector>\n#include <stdexcept>\n\nint fibfib(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n\n    std::vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n"}
{"task_id": "CPP/64", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int vowels_count(string s) {\n       int count = 0;\n       transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n       for (int i = 0; i < s.length(); i++) {\n           if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n               count++;\n           } else if (s[i] == 'y' && i == s.length() - 1) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Perform the circular shift\n    string last_part = str_x.substr(len - shift);\n    string first_part = str_x.substr(0, len - shift);\n    \n    return last_part + first_part;\n}\n"}
{"task_id": "CPP/66", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digitSum(string s) {\n       int sum = 0;\n       for (char c : s) {\n           if (c >= 'A' && c <= 'Z') {\n               sum += c;\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Extract the number of apples\n    ss >> apples;\n    ss >> temp; // Skip the word \"apples\"\n    ss >> temp; // Skip the word \"and\"\n    \n    // Extract the number of oranges\n    ss >> oranges;\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    // Return the result\n    return mangoes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/68", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<limits.h> // For INT_MAX\n   using namespace std;\n\n   vector<int> pluck(vector<int> arr){\n       int smallest_even_value = INT_MAX;\n       int smallest_index = -1;\n\n       for (int i = 0; i < arr.size(); ++i) {\n           if (arr[i] % 2 == 0 && arr[i] < smallest_even_value) {\n               smallest_even_value = arr[i];\n               smallest_index = i;\n           }\n       }\n\n       if (smallest_index == -1) {\n           return {};\n       } else {\n           return {smallest_even_value, smallest_index};\n       }\n   }\n   "}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Create an unordered_map to store the frequency of each integer\n    unordered_map<int, int> frequencyMap;\n    \n    // Step 2: Populate the unordered_map by iterating through the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    // Step 3: Iterate through the unordered_map to find the greatest integer\n    // that meets the criteria\n    int result = -1;\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<int> strange_sort_list(vector<int> lst){\n       if (lst.empty()) {\n           return lst;\n       }\n       \n       sort(lst.begin(), lst.end());\n       vector<int> result;\n       int min_pointer = 0;\n       int max_pointer = lst.size() - 1;\n       bool toggle = true;\n       \n       while (min_pointer <= max_pointer) {\n           if (toggle) {\n               result.push_back(lst[min_pointer]);\n               min_pointer++;\n           } else {\n               result.push_back(lst[max_pointer]);\n               max_pointer--;\n           }\n           toggle = !toggle;\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(vector<int> q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/73", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int smallest_change(vector<int> arr) {\n       int change_count = 0;\n       int left_pointer = 0;\n       int right_pointer = arr.size() - 1;\n       \n       while (left_pointer < right_pointer) {\n           if (arr[left_pointer] != arr[right_pointer]) {\n               change_count++;\n           }\n           left_pointer++;\n           right_pointer--;\n       }\n       \n       return change_count;\n   }\n   "}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total number of characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total number of characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> generate_primes_less_than_100() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes_less_than_100();\n    int n = primes.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    int power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        // Handle negative numbers\n        int abs_a = -a;\n        int root = cbrt(abs_a);\n        return (root * root * root == abs_a);\n    } else {\n        // Handle non-negative numbers\n        int root = cbrt(a);\n        return (root * root * root == a);\n    }\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Initialize the counter\n    int count = 0;\n    \n    // Loop through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            // Increment the counter\n            count++;\n        }\n    }\n    \n    // Return the counter\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    \n    string binary_string = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary_string = to_string(remainder) + binary_string;\n        decimal = decimal / 2;\n    }\n    \n    return \"db\" + binary_string + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s){\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string, checking every set of 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    // If all sets of 3 consecutive characters are distinct, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true; // 2 is the only even prime number\n    if (n % 2 == 0) return false; // other even numbers are not prime\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\n#include<cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;  // Only the number 1 itself\n    }\n    int total_starting_with_1 = std::pow(10, n-1);\n    int total_ending_with_1 = 9 * std::pow(10, n-2);\n    int total_both_start_and_end_with_1 = std::pow(10, n-2);\n    int result = total_starting_with_1 + total_ending_with_1 - total_both_start_and_end_with_1;\n    return result;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    int temp = N;\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary;\n            sum /= 2;\n        }\n    }\n\n    // Step 3: Return the binary string\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string tempWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            if (!tempWord.empty()) {\n                sort(tempWord.begin(), tempWord.end());\n                result += tempWord;\n                tempWord = \"\";\n            }\n            result += c;\n        } else {\n            tempWord += c;\n        }\n    }\n    \n    if (!tempWord.empty()) {\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Find all occurrences of x and store their coordinates\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    // Sort the result vector\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are the same\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n    \n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<int> sort_array(vector<int> array) {\n       if (array.empty()) {\n           return array;\n       }\n       \n       int sum = array.front() + array.back();\n       vector<int> sorted_array = array;\n       \n       if (sum % 2 != 0) {\n           // Sort in ascending order\n           sort(sorted_array.begin(), sorted_array.end());\n       } else {\n           // Sort in descending order\n           sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n       }\n       \n       return sorted_array;\n   }\n   "}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char newChar = c + 4;\n            if (newChar > 'z') {\n                newChar -= 26;\n            }\n            result += newChar;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    int smallest = lst[0];\n    int second_smallest = lst[1];\n\n    if (smallest > second_smallest) {\n        swap(smallest, second_smallest);\n    }\n\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] < smallest) {\n            second_smallest = smallest;\n            smallest = lst[i];\n        } else if (lst[i] < second_smallest && lst[i] != smallest) {\n            second_smallest = lst[i];\n        }\n    }\n\n    if (second_smallest == smallest) {\n        return -1; // Return -1 to indicate None\n    }\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint is_bored(string S){\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n    vector<char> delimiters = {'.', '?', '!'};\n    \n    while (getline(ss, sentence, delimiters[0])) {\n        for (char delimiter : delimiters) {\n            size_t pos = sentence.find(delimiter);\n            if (pos != string::npos) {\n                sentence = sentence.substr(0, pos);\n                break;\n            }\n        }\n        // Trim leading and trailing spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        size_t end = sentence.find_last_not_of(\" \");\n        if (start != string::npos && end != string::npos) {\n            sentence = sentence.substr(start, end - start + 1);\n        }\n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence.substr(0, 1) == \"I\") {\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if any of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/93", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string encode(string message) {\n       string vowels = \"aeiouAEIOU\";\n       string result = \"\";\n       for (char &ch : message) {\n           if (vowels.find(ch) != string::npos) {\n               if (ch == 'u' || ch == 'U') {\n                   ch = (ch == 'u') ? 'a' : 'A';\n               } else if (ch == 'o' || ch == 'O') {\n                   ch = (ch == 'o') ? 'q' : 'Q';\n               } else {\n                   ch = ch + 2;\n               }\n           }\n           if (islower(ch)) {\n               ch = toupper(ch);\n           } else {\n               ch = tolower(ch);\n           }\n           result += ch;\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    \n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    \n    // If no prime number is found, return 0\n    if (largestPrime == -1) return 0;\n    \n    // Return the sum of the digits of the largest prime number\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   bool check_dict_case(map<string, string> dict) {\n       if (dict.empty()) {\n           return false;\n       }\n\n       bool is_lower = true;\n       bool is_upper = true;\n\n       for (const auto& pair : dict) {\n           const string& key = pair.first;\n\n           if (!islower(key[0]) && !isupper(key[0])) {\n               return false;\n           }\n\n           for (char c : key) {\n               if (!islower(c)) {\n                   is_lower = false;\n               }\n               if (!isupper(c)) {\n                   is_upper = false;\n               }\n           }\n\n           if (!is_lower && !is_upper) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    if (n < 2) return {};\n\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Calculate the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int count_upper(string s) {\n       int count = 0;\n       for (int i = 0; i < s.length(); i += 2) {\n           if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    double fractionalPart = num - floor(num);\n    if (fractionalPart == 0.5 || fractionalPart == -0.5) {\n        // Round away from zero\n        if (num > 0) {\n            return static_cast<int>(ceil(num));\n        } else {\n            return static_cast<int>(floor(num));\n        }\n    } else {\n        // Use the round function to get the closest integer\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> make_a_pile(int n) {\n       vector<int> pile;\n       int current_stones = n;\n       \n       for (int i = 0; i < n; ++i) {\n           pile.push_back(current_stones);\n           if (current_stones % 2 == 1) {\n               current_stones += 2; // Next odd number\n           } else {\n               current_stones += 2; // Next even number\n           }\n       }\n       \n       return pile;\n   }\n   "}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    string currentWord = \"\";\n    \n    for(char c : s) {\n        if(c == ' ' || c == ',') {\n            if(!currentWord.empty()) {\n                words.push_back(currentWord);\n                currentWord = \"\";\n            }\n        } else {\n            currentWord += c;\n        }\n    }\n    \n    if(!currentWord.empty()) {\n        words.push_back(currentWord);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    \n    int start;\n    if (x % 2 == 0) {\n        start = x;\n    } else {\n        start = x + 1;\n    }\n    \n    int largest_even = -1;\n    for (int i = start; i <= y; i += 2) {\n        if (i % 2 == 0) {\n            largest_even = i;\n        }\n    }\n    \n    return largest_even;\n}\n"}
{"task_id": "CPP/103", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   using namespace std;\n\n   string convert_to_binary(int number) {\n       if (number == 0) return \"0\";\n       string binary = \"\";\n       while (number > 0) {\n           binary = to_string(number % 2) + binary;\n           number /= 2;\n       }\n       return binary;\n   }\n\n   string rounded_avg(int n, int m) {\n       if (n > m) return \"-1\";\n       \n       int sum = 0;\n       int count = m - n + 1;\n       \n       for (int i = n; i <= m; ++i) {\n           sum += i;\n       }\n       \n       double average = static_cast<double>(sum) / count;\n       int rounded_average = floor(average);\n       \n       return convert_to_binary(rounded_average);\n   }\n   "}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x){\n    vector<int> result;\n    \n    for(int num : x){\n        string numStr = to_string(num);\n        bool hasEvenDigit = false;\n        \n        for(char ch : numStr){\n            if(ch == '0' || ch == '2' || ch == '4' || ch == '6' || ch == '8'){\n                hasEvenDigit = true;\n                break;\n            }\n        }\n        \n        if(!hasEvenDigit){\n            result.push_back(num);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<map>\n   #include<algorithm>\n   using namespace std;\n\n   vector<string> by_length(vector<int> arr) {\n       // Filter valid numbers (1 to 9)\n       vector<int> valid_numbers;\n       for (int num : arr) {\n           if (num >= 1 && num <= 9) {\n               valid_numbers.push_back(num);\n           }\n       }\n\n       // Sort the valid numbers\n       sort(valid_numbers.begin(), valid_numbers.end());\n\n       // Reverse the sorted list\n       reverse(valid_numbers.begin(), valid_numbers.end());\n\n       // Map each digit to its corresponding name\n       map<int, string> digit_names = {\n           {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n           {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n       };\n\n       // Create the result vector\n       vector<string> result;\n       for (int num : valid_numbers) {\n           result.push_back(digit_names[num]);\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/106", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> f(int n) {\n       vector<int> result(n);\n       for (int i = 1; i <= n; ++i) {\n           if (i % 2 == 0) {\n               // Calculate factorial of i\n               int factorial = 1;\n               for (int j = 1; j <= i; ++j) {\n                   factorial *= j;\n               }\n               result[i - 1] = factorial;\n           } else {\n               // Calculate sum of numbers from 1 to i\n               int sum = 0;\n               for (int j = 1; j <= i; ++j) {\n                   sum += j;\n               }\n               result[i - 1] = sum;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        string num_str = to_string(i);\n        string rev_str = num_str;\n        reverse(rev_str.begin(), rev_str.end());\n        \n        if (num_str == rev_str) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int count_nums(vector<int> n) {\n       int count = 0;\n       for (int num : n) {\n           int sum = 0;\n           bool is_negative = false;\n           if (num < 0) {\n               is_negative = true;\n               num = -num;\n           }\n           while (num > 0) {\n               int digit = num % 10;\n               if (is_negative) {\n                   sum -= digit;\n               } else {\n                   sum += digit;\n               }\n               num /= 10;\n           }\n           if (sum > 0) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int break_point = -1;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            if (break_point != -1) {\n                return false; // More than one break point found\n            }\n            break_point = i;\n        }\n    }\n\n    if (break_point == -1) return true; // Already sorted\n\n    // Check if the vector can be sorted by rotating around the break point\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[(break_point + 1 + i) % n] > arr[(break_point + 2 + i) % n]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even_lst2++;\n        }\n    }\n    \n    if (count_odd_lst1 <= count_even_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   map<char, int> histogram(string test) {\n       map<char, int> letterCounts;\n       \n       // Count occurrences of each letter\n       for (char ch : test) {\n           if (ch == ' ') continue; // Skip spaces\n           if (letterCounts.find(ch) == letterCounts.end()) {\n               letterCounts[ch] = 1;\n           } else {\n               letterCounts[ch]++;\n           }\n       }\n       \n       // Find the maximum count\n       int maxCount = 0;\n       for (const auto& pair : letterCounts) {\n           if (pair.second > maxCount) {\n               maxCount = pair.second;\n           }\n       }\n       \n       // Filter the map to include only letters with the maximum count\n       map<char, int> result;\n       for (const auto& pair : letterCounts) {\n           if (pair.second == maxCount) {\n               result[pair.first] = pair.second;\n           }\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set from characters in string c\n    unordered_set<char> charSet(c.begin(), c.end());\n    \n    // Initialize the result string\n    string result;\n    \n    // Iterate through each character in string s\n    for (char ch : s) {\n        // If the character is not in the set, append it to result\n        if (charSet.find(ch) == charSet.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    \n    // Determine if the result string is a palindrome\n    bool isPalindrome = (result == reversedResult);\n    \n    // Return the result vector\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& str : lst) {\n        int count = 0;\n        for (char ch : str) {\n            if (ch == '1' || ch == '3' || ch == '5' || ch == '7' || ch == '9') {\n                count++;\n            }\n        }\n        string formatted_string = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(formatted_string);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    // Initialize min_sum to a large value and current_sum to 0\n    long long min_sum = nums[0];\n    long long current_sum = 0;\n\n    // Iterate through each element in the vector\n    for (long long num : nums) {\n        // Update current_sum to be the minimum of the current element or the sum of current_sum and the current element\n        current_sum = min(num, current_sum + num);\n        // Update min_sum to be the minimum of min_sum and current_sum\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<cmath>\n   using namespace std;\n\n   int max_fill(vector<vector<int>> grid, int capacity) {\n       int total_lowers = 0;\n       for (const auto& row : grid) {\n           int water_units = 0;\n           for (const auto& cell : row) {\n               if (cell == 1) {\n                   water_units++;\n               }\n           }\n           int lowers_needed = ceil((double)water_units / capacity);\n           total_lowers += lowers_needed;\n       }\n       return total_lowers;\n   }\n   "}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Function to sort the array based on the number of ones in binary representation\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    auto comparator = [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b; // If number of ones is the same, sort by decimal value\n        }\n        return onesA < onesB; // Otherwise, sort by number of ones\n    };\n\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), comparator);\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    // Split the string into words\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    // Check each word for the number of consonants\n    for (const string& word : words) {\n        int consonantCount = 0;\n        for (char c : word) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string result = \"\";\n    string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n    \n    for (int i = n - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int count_open_1 = 0, count_close_1 = 0;\n    int count_open_2 = 0, count_close_2 = 0;\n    \n    // Count parentheses in the first string\n    for (char c : lst[0]) {\n        if (c == '(') count_open_1++;\n        else if (c == ')') count_close_1++;\n    }\n    \n    // Count parentheses in the second string\n    for (char c : lst[1]) {\n        if (c == '(') count_open_2++;\n        else if (c == ')') count_close_2++;\n    }\n    \n    int total_open = count_open_1 + count_open_2;\n    int total_close = count_close_1 + count_close_2;\n    \n    // If the total number of opening and closing parentheses are not equal, return \"No\"\n    if (total_open != total_close) {\n        return \"No\";\n    }\n    \n    // Check if we can arrange them to form a balanced string\n    if (count_open_1 > count_close_2 || count_open_2 > count_close_1) {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements\n    vector<int> max_k(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the k elements in ascending order\n    sort(max_k.begin(), max_k.end());\n    \n    // Step 4: Return the sorted k elements\n    return max_k;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0) { // Check if the index is even\n            if (lst[i] % 2 != 0) { // Check if the element is odd\n                sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int add_elements(vector<int> arr, int k) {\n       int sum = 0;\n       for (int i = 0; i < k; ++i) {\n           if (arr[i] >= 0 && arr[i] <= 99) {\n               sum += arr[i];\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence and collect odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If n is even\n            n = n / 2;\n        } else { // If n is odd\n            n = 3 * n + 1;\n        }\n    }\n    // Add the final 1 to the sequence\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool is_leap_year(int year) {\n       return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n   }\n\n   bool valid_date(string date) {\n       if (date.empty()) {\n           return false;\n       }\n\n       // Check if the date format is \"mm-dd-yyyy\"\n       if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n           return false;\n       }\n\n       // Extract month, day, year from the date string\n       int month = stoi(date.substr(0, 2));\n       int day = stoi(date.substr(3, 2));\n       int year = stoi(date.substr(6, 4));\n\n       // Validate month\n       if (month < 1 || month > 12) {\n           return false;\n       }\n\n       // Validate day based on month\n       if (month == 2) {\n           if (is_leap_year(year)) {\n               if (day < 1 || day > 29) {\n                   return false;\n               }\n           } else {\n               if (day < 1 || day > 28) {\n                   return false;\n               }\n           }\n       } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n           if (day < 1 || day > 30) {\n               return false;\n           }\n       } else {\n           if (day < 1 || day > 31) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    size_t pos = txt.find_first_of(\" \\t\\n\\r\");\n    if (pos != string::npos) {\n        size_t start = 0;\n        while ((pos = txt.find_first_of(\" \\t\\n\\r\", start)) != string::npos) {\n            result.push_back(txt.substr(start, pos - start));\n            start = pos + 1;\n        }\n        result.push_back(txt.substr(start));\n        return result;\n    }\n    \n    // Check for commas\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        size_t start = 0;\n        while ((pos = txt.find(',', start)) != string::npos) {\n            result.push_back(txt.substr(start, pos - start));\n            start = pos + 1;\n        }\n        result.push_back(txt.substr(start));\n        return result;\n    }\n    \n    // Count lowercase letters with odd order in the alphabet\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    \n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<unordered_map>\n   using namespace std;\n\n   bool is_sorted(vector<int> lst){\n       if (lst.size() <= 1) {\n           return true;\n       }\n\n       unordered_map<int, int> countMap;\n       for (size_t i = 0; i < lst.size() - 1; ++i) {\n           if (lst[i] > lst[i + 1]) {\n               return false;\n           }\n           countMap[lst[i]]++;\n           if (countMap[lst[i]] > 2) {\n               return false;\n           }\n       }\n       // Check the last element\n       countMap[lst.back()]++;\n       if (countMap[lst.back()] > 2) {\n           return false;\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart <= intersectionEnd) {\n        int intersectionLength = intersectionEnd - intersectionStart + 1;\n        if (isPrime(intersectionLength)) {\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int prod_signs(vector<int> arr){\n       if (arr.empty()) {\n           return -32768;\n       }\n\n       int sum_of_magnitudes = 0;\n       int product_of_signs = 1;\n\n       for (int number : arr) {\n           sum_of_magnitudes += abs(number);\n           if (number == 0) {\n               product_of_signs = 0;\n               break;\n           } else if (number < 0) {\n               product_of_signs *= -1;\n           }\n       }\n\n       return sum_of_magnitudes * product_of_signs;\n   }\n   "}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n    vector<int> current_path;\n\n    // Helper function to perform DFS\n    function<void(int, int, int)> dfs = [&](int x, int y, int length) {\n        if (length == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n            return;\n        }\n\n        // Directions for moving to neighbor cells (right, left, down, up)\n        vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        for (auto& dir : directions) {\n            int nx = x + dir.first;\n            int ny = y + dir.second;\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                current_path.push_back(grid[nx][ny]);\n                dfs(nx, ny, length + 1);\n                current_path.pop_back();\n            }\n        }\n    };\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            current_path = {grid[i][j]};\n            dfs(i, j, 1);\n        }\n    }\n\n    return min_path;\n}\n\n// Example usage\n"}
{"task_id": "CPP/130", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> tri(int n) {\n       vector<int> result(n + 1);\n       result[1] = 3;  // Base case\n       \n       for (int i = 2; i <= n; ++i) {\n           if (i % 2 == 0) {\n               result[i] = 1 + i / 2;\n           } else {\n               result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n           }\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/131", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digits(int n) {\n       string numStr = to_string(n);\n       int product = 1;\n       bool oddFound = false;\n\n       for (char ch : numStr) {\n           int digit = ch - '0';\n           if (digit % 2 != 0) {\n               product *= digit;\n               oddFound = true;\n           }\n       }\n\n       if (!oddFound) {\n           return 0;\n       }\n\n       return product;\n   }\n   "}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    int depth = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            s.push(ch);\n            depth++;\n        } else if (ch == ']') {\n            if (s.empty()) {\n                return false; // Invalid subsequence\n            }\n            s.pop();\n            depth--;\n            if (depth > 0) {\n                return true; // Found nesting\n            }\n        }\n    }\n\n    return !s.empty() ? false : (depth > 0);\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiling_num = ceil(num);  // Compute the ceiling of the number\n        sum += ceiling_num * ceiling_num;  // Square the ceiling value and add to sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool check_if_last_char_is_a_letter(string txt) {\n       if (txt.empty()) {\n           return false;\n       }\n       char last_char = txt.back();\n       if (!isalpha(last_char)) {\n           return false;\n       }\n       if (txt.length() == 1) {\n           return true;\n       }\n       char second_last_char = txt[txt.length() - 2];\n       if (isalpha(second_last_char)) {\n           return false;\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/135", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int can_arrange(vector<int> arr){\n       int largest_index = -1;\n       for (int i = 1; i < arr.size(); ++i) {\n           if (arr[i] < arr[i - 1]) {\n               largest_index = i;\n           }\n       }\n       return largest_index;\n   }\n   "}
{"task_id": "CPP/136", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> largest_smallest_integers(vector<int> lst) {\n       int largest_negative = 0;\n       int smallest_positive = 0;\n\n       for (int number : lst) {\n           if (number < 0) {\n               if (largest_negative == 0 || number > largest_negative) {\n                   largest_negative = number;\n               }\n           } else if (number > 0) {\n               if (smallest_positive == 0 || number < smallest_positive) {\n                   smallest_positive = number;\n               }\n           }\n       }\n\n       return {largest_negative, smallest_positive};\n   }\n   "}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/lexical_cast.hpp>\n#include<cctype>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        try {\n            if (val.type() == typeid(int)) {\n                return static_cast<double>(boost::any_cast<int>(val));\n            } else if (val.type() == typeid(float)) {\n                return static_cast<double>(boost::any_cast<float>(val));\n            } else if (val.type() == typeid(string)) {\n                string str = boost::any_cast<string>(val);\n                replace(str.begin(), str.end(), ',', '.');\n                return boost::lexical_cast<double>(str);\n            }\n        } catch (const boost::bad_any_cast&) {\n            throw runtime_error(\"Unsupported type\");\n        }\n        throw runtime_error(\"Unsupported type\");\n    };\n\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or if n is odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    \n    // Iterate through possible combinations of 4 even numbers\n    for (int i = 2; i <= n / 4; i += 2) {\n        for (int j = i; j <= n / 4; j += 2) {\n            for (int k = j; k <= n / 4; k += 2) {\n                for (int l = k; l <= n / 4; l += 2) {\n                    if (i + j + k + l == n) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count > 2) {\n                continue; // Skip adding more than 2 consecutive spaces\n            }\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count == 2) {\n                result += '_';\n            } else if (space_count > 2) {\n                result += '-';\n            }\n            result += ch;\n            space_count = 0;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count == 2) {\n        result += '_';\n    } else if (space_count > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   string file_name_check(string file_name) {\n       // Check if there is exactly one dot\n       size_t dot_pos = file_name.find('.');\n       if (dot_pos == string::npos || dot_pos != file_name.rfind('.')) {\n           return \"No\";\n       }\n\n       // Split the file name into two parts\n       string before_dot = file_name.substr(0, dot_pos);\n       string after_dot = file_name.substr(dot_pos + 1);\n\n       // Check if before_dot is not empty and starts with a Latin alphabet letter\n       if (before_dot.empty() || !isalpha(before_dot[0])) {\n           return \"No\";\n       }\n\n       // Check if after_dot is one of {'txt', 'exe', 'dll'}\n       if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n           return \"No\";\n       }\n\n       // Count digits in before_dot\n       int digit_count = 0;\n       for (char c : before_dot) {\n           if (isdigit(c)) {\n               digit_count++;\n           }\n           if (digit_count > 3) {\n               return \"No\";\n           }\n       }\n\n       return \"Yes\";\n   }\n   "}
{"task_id": "CPP/142", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int sum_squares(vector<int> lst) {\n       int sum = 0;\n       for (int i = 0; i < lst.size(); ++i) {\n           if (i % 3 == 0) {\n               lst[i] = lst[i] * lst[i];  // Square the element\n           } else if (i % 4 == 0 && i % 3 != 0) {\n               lst[i] = lst[i] * lst[i] * lst[i];  // Cube the element\n           }\n           sum += lst[i];  // Add the modified element to sum\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    // Split the sentence into words\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Collect words with prime lengths\n    vector<string> primeLengthWords;\n    for (const string& w : words) {\n        if (isPrime(w.length())) {\n            primeLengthWords.push_back(w);\n        }\n    }\n\n    // Join the collected words into a single string with spaces\n    string result;\n    for (size_t i = 0; i < primeLengthWords.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += primeLengthWords[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Helper function to parse the fraction string\n    auto parseFraction = [](const string& fraction) -> pair<int, int> {\n        size_t slashPos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, slashPos));\n        int denominator = stoi(fraction.substr(slashPos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the input fractions\n    auto [numerator1, denominator1] = parseFraction(x);\n    auto [numerator2, denominator2] = parseFraction(n);\n\n    // Calculate the product of the fractions\n    int productNumerator = numerator1 * numerator2;\n    int productDenominator = denominator1 * denominator2;\n\n    // Check if the product is a whole number\n    return productNumerator % productDenominator == 0;\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs (number, digit sum)\n    vector<pair<int, int>> numsWithSums;\n    for (int num : nums) {\n        numsWithSums.push_back({num, sumOfDigits(num)});\n    }\n\n    // Sort the vector of pairs based on the digit sum\n    stable_sort(numsWithSums.begin(), numsWithSums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    // Extract the sorted numbers\n    vector<int> sortedNums;\n    for (const auto& pair : numsWithSums) {\n        sortedNums.push_back(pair.first);\n    }\n\n    return sortedNums;\n}\n"}
{"task_id": "CPP/146", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   int specialFilter(vector<int> nums) {\n       int count = 0;\n       for (int num : nums) {\n           if (num > 10) {\n               string numStr = to_string(abs(num)); // Convert number to string\n               char first_digit = numStr[0];\n               char last_digit = numStr[numStr.size() - 1];\n               if ((first_digit == '1' || first_digit == '3' || first_digit == '5' || first_digit == '7' || first_digit == '9') &&\n                   (last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9')) {\n                   count++;\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/147", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int get_max_triples(int n) {\n       vector<int> a(n);\n       for (int i = 1; i <= n; ++i) {\n           a[i-1] = i * i - i + 1;\n       }\n       \n       int count = 0;\n       for (int i = 0; i < n-2; ++i) {\n           for (int j = i+1; j < n-1; ++j) {\n               for (int k = j+1; k < n; ++k) {\n                   if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                       count += 1;\n                   }\n               }\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/148", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> bf(string planet1, string planet2) {\n       vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n       vector<string> result;\n\n       // Check if both planets are valid\n       if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n           find(planets.begin(), planets.end(), planet2) == planets.end()) {\n           return result; // Return empty vector if either planet is invalid\n       }\n\n       // Find indices of planet1 and planet2\n       int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n       int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n       // Ensure index1 is less than index2\n       if (index1 > index2) {\n           swap(index1, index2);\n       }\n\n       // Extract the sublist\n       for (int i = index1; i <= index2; ++i) {\n           result.push_back(planets[i]);\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nint x_or_y(int n, int x, int y) {\n    // Handle edge case for numbers less than 2\n    if (n < 2) {\n        return y;\n    }\n    \n    // Check for primality\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return y; // n is not a prime number\n        }\n    }\n    \n    // If no divisors found, n is a prime number\n    return x;\n}\n\n// Example usage\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && floor(num) == num) { // Check if number is positive and an integer\n            int intNum = static_cast<int>(num);\n            if (intNum % 2 != 0) { // Check if number is odd\n                sum += intNum * intNum; // Add square of number to sum\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result(game.size());\n    for (int i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string Strongest_Extension(string class_name, vector<string> extensions) {\n       string strongest_extension = \"\";\n       int max_strength = INT_MIN;\n       \n       for (const string& extension : extensions) {\n           int CAP = 0;\n           int SM = 0;\n           \n           for (char c : extension) {\n               if (isupper(c)) {\n                   CAP++;\n               } else if (islower(c)) {\n                   SM++;\n               }\n           }\n           \n           int strength = CAP - SM;\n           \n           if (strength > max_strength) {\n               max_strength = strength;\n               strongest_extension = extension;\n           }\n       }\n       \n       return class_name + \".\" + strongest_extension;\n   }\n   "}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the second word with itself\n    string concatenated = b + b;\n    \n    // Check if the first word is a substring of the concatenated string\n    return concatenated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   #include<vector>\n   using namespace std;\n\n   vector<int> even_odd_count(int num){\n       // Handle negative numbers\n       if (num < 0) {\n           num = -num;\n       }\n       \n       // Convert number to string\n       string numStr = to_string(num);\n       \n       // Initialize counters\n       int even_count = 0;\n       int odd_count = 0;\n       \n       // Iterate through each character in the string\n       for (char ch : numStr) {\n           int digit = ch - '0'; // Convert character to integer\n           if (digit % 2 == 0) {\n               even_count++;\n           } else {\n               odd_count++;\n           }\n       }\n       \n       // Return the result as a vector\n       return {even_count, odd_count};\n   }\n   "}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Lookup table for Roman numerals and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the lookup table\n    for (const auto& pair : roman_numerals) {\n        int value = pair.first;\n        string symbol = pair.second;\n        \n        // Append the symbol to the result string while the value can be subtracted from the number\n        while (number >= value) {\n            number -= value;\n            result += symbol;\n        }\n    }\n    \n    // Convert the result string to lowercase\n    transform(result.begin(), result.end(), result.begin(), ::tolower);\n    \n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the hypotenuse\n    float sides[] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Apply the Pythagorean theorem\n    float a_squared = sides[0] * sides[0];\n    float b_squared = sides[1] * sides[1];\n    float c_squared = sides[2] * sides[2];\n    \n    // Check if a^2 + b^2 = c^2\n    return (a_squared + b_squared == c_squared);\n}\n"}
{"task_id": "CPP/158", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   string find_max(vector<string> words) {\n       int max_unique_count = 0;\n       string result_word = \"\";\n       \n       for (const string& word : words) {\n           unordered_set<char> unique_chars(word.begin(), word.end());\n           int unique_count = unique_chars.size();\n           \n           if (unique_count > max_unique_count) {\n               max_unique_count = unique_count;\n               result_word = word;\n           } else if (unique_count == max_unique_count) {\n               if (result_word.empty() || word < result_word) {\n                   result_word = word;\n               }\n           }\n       }\n       \n       return result_word;\n   }\n   "}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_needed = number + need;\n    int total_eaten, carrots_left;\n\n    if (remaining >= need) {\n        total_eaten = total_needed;\n        carrots_left = remaining - need;\n    } else {\n        total_eaten = number + remaining;\n        carrots_left = 0;\n    }\n\n    return {total_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n    \n    // Iterate through the operators and operands\n    for (int i = 0; i < operato.size(); ++i) {\n        // Get the next operand\n        int next_operand = operand[i + 1];\n        \n        // Apply the operator to the current result and the next operand\n        if (operato[i] == \"+\") {\n            result += next_operand;\n        } else if (operato[i] == \"-\") {\n            result -= next_operand;\n        } else if (operato[i] == \"*\") {\n            result *= next_operand;\n        } else if (operato[i] == \"//\") {\n            result /= next_operand; // Floor division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, next_operand); // Exponentiation\n        }\n    }\n    \n    // Return the final result\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   string solve(string s) {\n       int letter_count = 0;\n       string result = \"\";\n       \n       for (char c : s) {\n           if (isalpha(c)) {\n               letter_count++;\n               if (islower(c)) {\n                   result += toupper(c);\n               } else {\n                   result += tolower(c);\n               }\n           } else {\n               result += c;\n           }\n       }\n       \n       if (letter_count == 0) {\n           reverse(result.begin(), result.end());\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check if the input string is empty\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    // Initialize the MD5 context\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update the MD5 context with the input string\n    MD5_Update(&md5Context, text.c_str(), text.size());\n\n    // Finalize the MD5 context to get the hash\n    MD5_Final(result, &md5Context);\n\n    // Convert the binary hash to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << hex << setw(2) << setfill('0') << (int)result[i];\n    }\n\n    // Return the hexadecimal string\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    for (int i = min_val; i <= max_val; ++i) {\n        if (i >= 0 && i <= 8 && i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    stack<char> s;\n\n    for (char c : paren_string) {\n        if (c == ' ') {\n            continue; // Ignore spaces\n        }\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            if (!s.empty() && s.top() == '(') {\n                s.pop();\n                current_group += c;\n                if (s.empty()) {\n                    result.push_back(current_group);\n                    current_group.clear();\n                }\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    float integerPart = floor(number);\n    // Calculate the decimal part\n    float decimalPart = number - integerPart;\n    // Return the decimal part\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations){\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   float mean_absolute_deviation(vector<float> numbers) {\n       // Calculate the mean of the dataset\n       float sum = 0;\n       for (float number : numbers) {\n           sum += number;\n       }\n       float mean = sum / numbers.size();\n\n       // Calculate the sum of absolute differences\n       float sum_of_abs_diff = 0;\n       for (float number : numbers) {\n           sum_of_abs_diff += abs(number - mean);\n       }\n\n       // Calculate and return the Mean Absolute Deviation\n       float MAD = sum_of_abs_diff / numbers.size();\n       return MAD;\n   }\n   "}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<sstream>\n   using namespace std;\n\n   vector<int> parse_nested_parens(string paren_string) {\n       vector<int> result;\n       stringstream ss(paren_string);\n       string group;\n       \n       while (ss >> group) {\n           int max_depth = 0;\n           int current_depth = 0;\n           \n           for (char ch : group) {\n               if (ch == '(') {\n                   current_depth++;\n               } else if (ch == ')') {\n                   current_depth--;\n               }\n               if (current_depth > max_depth) {\n                   max_depth = current_depth;\n               }\n           }\n           \n           result.push_back(max_depth);\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/7", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_substring(vector<string> strings, string substring) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(substring) != string::npos) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/8", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> sum_product(vector<int> numbers){\n       int sum = 0;\n       int product = 1;\n       \n       for(int number : numbers){\n           sum += number;\n           product *= number;\n       }\n       \n       return {sum, product};\n   }\n   "}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    vector<int> result;\n    int current_max = numbers[0];\n    \n    for (int number : numbers) {\n        if (number > current_max) {\n            current_max = number;\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    if (str.empty()) return \"\";\n    \n    for (int i = 0; i < str.size(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    \n    // If no palindrome suffix is found, reverse the entire string and append\n    string reversed_str(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string longest(vector<string> strings){\n       if (strings.empty()) {\n           return \"\"; // Return empty string to represent None\n       }\n       string longest_string = strings[0];\n       for (const string& str : strings) {\n           if (str.length() > longest_string.length()) {\n               longest_string = str;\n           }\n       }\n       return longest_string;\n   }\n   "}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Base case: if b is 0, then the GCD is a\n    if (b == 0) {\n        return a;\n    }\n    // Recursive case: call the function with b and a % b\n    return greatest_common_divisor(b, a % b);\n}\n\n// Example usage\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n){\n    // Initialize a string stream\n    stringstream ss;\n    \n    // Loop from 0 to n\n    for(int i = 0; i <= n; ++i) {\n        // Append the number followed by a space\n        ss << i << \" \";\n    }\n    \n    // Convert the string stream to a string\n    string result = ss.str();\n    \n    // Remove the trailing space\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<set>\n   using namespace std;\n\n   int count_distinct_characters(string str){ \n       // Convert the string to lowercase\n       transform(str.begin(), str.end(), str.begin(), ::tolower);\n       \n       // Use a set to store unique characters\n       set<char> unique_chars;\n       \n       // Iterate through the string and add each character to the set\n       for(char c : str) {\n           unique_chars.insert(c);\n       }\n       \n       // The size of the set is the number of distinct characters\n       return unique_chars.size();\n   }\n   "}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string){ \n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0;\n    }\n    int count = 0;\n    int length_str = str.length();\n    int length_sub = substring.length();\n    for (int i = 0; i <= length_str - length_sub; ++i) {\n        if (str.substr(i, length_sub) == substring) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to associate numerals with their numerical values\n    map<string, int> numeralToValue = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    // Split the input string into individual numerals\n    vector<string> numeralList;\n    stringstream ss(numbers);\n    string numeral;\n    while (ss >> numeral) {\n        numeralList.push_back(numeral);\n    }\n    \n    // Sort the numerals based on their numerical values\n    sort(numeralList.begin(), numeralList.end(), [&](const string &a, const string &b) {\n        return numeralToValue[a] < numeralToValue[b];\n    });\n    \n    // Join the sorted numerals back into a single string\n    string sortedNumbers;\n    for (const string &num : numeralList) {\n        if (!sortedNumbers.empty()) {\n            sortedNumbers += \" \";\n        }\n        sortedNumbers += num;\n    }\n    \n    return sortedNumbers;\n}\n"}
{"task_id": "CPP/20", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> find_closest_elements(vector<float> numbers) {\n       vector<float> closestPair;\n       float minDiff = INFINITY;\n\n       for (int i = 0; i < numbers.size(); i++) {\n           for (int j = i + 1; j < numbers.size(); j++) {\n               float diff = abs(numbers[i] - numbers[j]);\n               if (diff < minDiff) {\n                   minDiff = diff;\n                   closestPair = {numbers[i], numbers[j]};\n               }\n           }\n       }\n\n       if (closestPair[0] > closestPair[1]) {\n           swap(closestPair[0], closestPair[1]);\n       }\n\n       return closestPair;\n   }\n   "}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    // Initialize min and max values\n    float min_value = numbers[0];\n    float max_value = numbers[0];\n    \n    // Find the actual min and max values\n    for (float num : numbers) {\n        if (num < min_value) {\n            min_value = num;\n        }\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n    \n    // Calculate the range\n    float range = max_value - min_value;\n    \n    // Create a new vector to store the transformed values\n    vector<float> transformed_numbers;\n    \n    // Transform each number\n    for (float num : numbers) {\n        float new_value = (num - min_value) / range;\n        transformed_numbers.push_back(new_value);\n    }\n    \n    // Return the transformed vector\n    return transformed_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case: no divisors for n <= 1 other than 1\n    int max_divisor = 1;\n    for (int i = n / 2; i > 1; --i) {\n        if (n % i == 0) {\n            max_divisor = i;\n            break;\n        }\n    }\n    return max_divisor;\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    // Step 1: Count occurrences of each element\n    unordered_map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    // Step 2: Construct the result vector with elements that occur only once\n    vector<int> result;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    // Step 3: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str){\n    string result = \"\";\n    for (char ch : str) {\n        if (islower(ch)) {\n            result += toupper(ch);\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else {\n            result += ch; // if it's not a letter, just append it as is\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_prefix(vector<string> strings, string prefix) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(prefix) == 0) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/30", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> get_positive(vector<float> l){\n       vector<float> result;\n       for(float num : l){\n           if(num > 0){\n               result.push_back(num);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle special cases\n    if (n <= 1) return false;\n    if (n == 2) return true; // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Other even numbers are not prime\n\n    // Check divisibility from 3 to sqrt(n)\n    long long limit = static_cast<long long>(sqrt(n));\n    for (long long i = 3; i <= limit; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\n// Function to evaluate polynomial using Horner's method\ndouble poly(vector<double> xs, double x) {\n    double result = 0;\n    for (int i = xs.size() - 1; i >= 0; i--) {\n        result = result * x + xs[i];\n    }\n    return result;\n}\n\n// Function to evaluate the derivative of the polynomial\ndouble poly_derivative(vector<double> xs, double x) {\n    double result = 0;\n    for (int i = xs.size() - 1; i > 0; i--) {\n        result = result * x + i * xs[i];\n    }\n    return result;\n}\n\n// Function to find a zero of the polynomial using Newton-Raphson method\ndouble find_zero(vector<double> xs) {\n    double x0 = 0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double fpx = poly_derivative(xs, x0);\n\n        if (fpx == 0) {\n            // Avoid division by zero\n            break;\n        }\n\n        double x1 = x0 - fx / fpx;\n\n        if (abs(x1 - x0) < tolerance) {\n            // Convergence achieved\n            return x1;\n        }\n\n        x0 = x1;\n    }\n\n    // Return the last computed value if convergence is not achieved\n    return x0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l){\n    // Step 1: Collect elements at indices divisible by 3\n    vector<int> third_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    \n    // Step 2: Sort the collected elements\n    sort(third_elements.begin(), third_elements.end());\n    \n    // Step 3: Replace the elements at indices divisible by 3 with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = third_elements[index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Step 1: Initialize an empty set\n    set<int> uniqueSet;\n    \n    // Step 2: Insert each element from the input vector into the set\n    for(int num : l){\n        uniqueSet.insert(num);\n    }\n    \n    // Step 3: Convert the set to a vector\n    vector<int> result(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 4: Sort the vector (although the set is already sorted, this step ensures the order)\n    sort(result.begin(), result.end());\n    \n    // Step 5: Return the sorted vector\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    // Initialize max_val with the first element of the vector\n    float max_val = l[0];\n    \n    // Iterate through the vector starting from the second element\n    for(int i = 1; i < l.size(); i++){\n        // If the current element is greater than max_val, update max_val\n        if(l[i] > max_val){\n            max_val = l[i];\n        }\n    }\n    \n    // Return the maximum value found\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint fizz_buzz(int n){\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> l_prime;\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the new vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime.push_back(even_values[even_index++]);\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    string output;\n    int l = s.length();\n    int num = (l + 2) / 3;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2); // Reverse the cycling\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2;\n    if (n == 2) return 3;\n    \n    int count = 2;\n    int a = 2, b = 3;\n    \n    while (true) {\n        int c = a + b;\n        if (is_prime(c)) {\n            count += 1;\n            if (count == n) {\n                return c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> incr_list(vector<int> l){\n       vector<int> result;\n       for (int i = 0; i < l.size(); i++) {\n           result.push_back(l[i] + 1);\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int number : l) {\n        if (seen.find(-number) != seen.end()) {\n            return true;\n        }\n        seen.insert(number);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Special case for zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x = x / base;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // Calculate the area using the formula 1/2 * base * height\n    float area = 0.5 * a * h;\n    // Return the calculated area\n    return area;\n}\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n < 4) {\n        return (n == 0 || n == 1) ? 0 : (n == 2 ? 2 : 0);\n    }\n    \n    vector<int> fib4_values = {0, 0, 2, 0};\n    \n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        fib4_values.erase(fib4_values.begin());\n        fib4_values.push_back(next_value);\n    }\n    \n    return fib4_values.back();\n}\n"}
{"task_id": "CPP/47", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   float median(vector<float> l){\n       // Sort the vector\n       sort(l.begin(), l.end());\n       \n       // Get the length of the vector\n       int n = l.size();\n       \n       // Check if the length is odd or even\n       if (n % 2 != 0) {\n           // If odd, return the middle element\n           return l[n / 2];\n       } else {\n           // If even, return the average of the two middle elements\n           return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n       }\n   }\n   "}
{"task_id": "CPP/48", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool is_palindrome(string text){\n       int left = 0;\n       int right = text.length() - 1;\n       while (left < right) {\n           if (text[left] != text[right]) {\n               return false;\n           }\n           left++;\n           right--;\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\n\nint modp(int n, int p) {\n    if (n == 0) {\n        return 1;\n    }\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string remove_vowels(string text){\n       string result = \"\";\n       string vowels = \"aeiouAEIOU\";\n       for (char c : text) {\n           if (vowels.find(c) == string::npos) {\n               result += c;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/52", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_threshold(vector<int> l, int t) {\n       for (int num : l) {\n           if (num >= t) {\n               return false;\n           }\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Initialize frequency arrays\n    int freq0[256] = {0};\n    int freq1[256] = {0};\n    \n    // Populate frequency array for s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    \n    // Populate frequency array for s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n    \n    // Compare frequency arrays\n    for (int i = 0; i < 256; i++) {\n        if (freq0[i] != freq1[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int a = 0;\n    int b = 1;\n    int temp;\n    \n    for (int i = 2; i <= n; ++i) {\n        temp = a + b;\n        a = b;\n        b = temp;\n    }\n    \n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            counter++;\n        } else if (bracket == '>') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false;\n        }\n    }\n    return counter == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (int i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create a set to store unique elements from the first vector\n    unordered_set<int> unique_elements(l1.begin(), l1.end());\n    \n    // Create a vector to store the result\n    vector<int> result;\n    \n    // Iterate through the second vector and check for common elements\n    for (int num : l2) {\n        if (unique_elements.find(num) != unique_elements.end()) {\n            result.push_back(num);\n            // Remove the element from the set to ensure uniqueness in the result\n            unique_elements.erase(num);\n        }\n    }\n    \n    // Sort the result vector\n    sort(result.begin(), result.end());\n    \n    // Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    \n    // Check for the smallest prime factor (2)\n    if (n % 2 == 0) {\n        largest_factor = 2;\n        while (n % 2 == 0) {\n            n = n / 2;\n        }\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int factor = 3; factor * factor <= n; factor += 2) {\n        while (n % factor == 0) {\n            largest_factor = factor;\n            n = n / factor;\n        }\n    }\n    \n    // If n is still greater than 1, then it is a prime factor\n    if (n > 1) {\n        largest_factor = n;\n    }\n    \n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n"}
{"task_id": "CPP/64", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int vowels_count(string s) {\n       int count = 0;\n       transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n       for (int i = 0; i < s.length(); i++) {\n           if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n               count++;\n           } else if (s[i] == 'y' && i == s.length() - 1) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Perform the circular shift\n    string end_part = str_x.substr(len - shift);\n    string start_part = str_x.substr(0, len - shift);\n    \n    // Concatenate the end part and the start part\n    return end_part + start_part;\n}\n"}
{"task_id": "CPP/66", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digitSum(string s) {\n       int sum = 0;\n       for (char c : s) {\n           if (c >= 'A' && c <= 'Z') {\n               sum += c;\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0, mangoes = 0;\n    \n    // Extract the number of apples\n    size_t pos = s.find(\" apples\");\n    if (pos != string::npos) {\n        apples = stoi(s.substr(0, pos));\n    }\n    \n    // Extract the number of oranges\n    pos = s.find(\" oranges\");\n    if (pos != string::npos) {\n        oranges = stoi(s.substr(s.find(\"and \") + 4, pos - (s.find(\"and \") + 4)));\n    }\n    \n    // Calculate the number of mangoes\n    mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<limits.h> // For INT_MAX\n   using namespace std;\n\n   vector<int> pluck(vector<int> arr){\n       int smallest_even_value = INT_MAX;\n       int smallest_index = -1;\n\n       for (int i = 0; i < arr.size(); ++i) {\n           if (arr[i] % 2 == 0 && arr[i] < smallest_even_value) {\n               smallest_even_value = arr[i];\n               smallest_index = i;\n           }\n       }\n\n       if (smallest_index == -1) {\n           return {};\n       } else {\n           return {smallest_even_value, smallest_index};\n       }\n   }\n   "}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Create an unordered_map to store the frequency of each integer\n    unordered_map<int, int> frequencyMap;\n    \n    // Step 2: Populate the unordered_map by iterating through the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    // Step 3: Iterate through the unordered_map to find the greatest integer\n    // that meets the criteria\n    int result = -1;\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    if (lst.empty()) {\n        return lst;\n    }\n    \n    sort(lst.begin(), lst.end());\n    vector<int> result;\n    int min_pointer = 0;\n    int max_pointer = lst.size() - 1;\n    \n    while (min_pointer <= max_pointer) {\n        if (min_pointer <= max_pointer) {\n            result.push_back(lst[min_pointer]);\n            min_pointer++;\n        }\n        \n        if (min_pointer <= max_pointer) {\n            result.push_back(lst[max_pointer]);\n            max_pointer--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool will_it_fly(vector<int> q, int w) {\n       // Check if the vector is palindromic\n       bool is_palindromic = true;\n       int n = q.size();\n       for (int i = 0; i < n / 2; ++i) {\n           if (q[i] != q[n - 1 - i]) {\n               is_palindromic = false;\n               break;\n           }\n       }\n       \n       // Calculate the sum of the elements in q\n       int sum = 0;\n       for (int element : q) {\n           sum += element;\n       }\n       \n       // Check if the sum is less than or equal to w\n       if (is_palindromic && sum <= w) {\n           return true;\n       } else {\n           return false;\n       }\n   }\n   "}
{"task_id": "CPP/73", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int smallest_change(vector<int> arr) {\n       int change_count = 0;\n       int left_pointer = 0;\n       int right_pointer = arr.size() - 1;\n\n       while (left_pointer < right_pointer) {\n           if (arr[left_pointer] != arr[right_pointer]) {\n               change_count++;\n           }\n           left_pointer++;\n           right_pointer--;\n       }\n\n       return change_count;\n   }\n   "}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total number of characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total number of characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate all prime numbers less than 100\nvector<int> generatePrimes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = generatePrimes();\n    int n = primes.size();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    int power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle negative numbers\n    bool isNegative = a < 0;\n    if (isNegative) {\n        a = -a;\n    }\n\n    // Compute the cube root\n    double cubeRoot = cbrt(a);\n\n    // Convert to integer and check if it's a perfect cube\n    int intCubeRoot = static_cast<int>(cubeRoot);\n    if (intCubeRoot * intCubeRoot * intCubeRoot == a) {\n        return true;\n    }\n\n    // If the cube root is not an integer, check the next integer\n    intCubeRoot++;\n    if (intCubeRoot * intCubeRoot * intCubeRoot == a) {\n        return true;\n    }\n\n    // If neither is a perfect cube, return false\n    return false;\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Initialize the counter\n    int count = 0;\n    \n    // Loop through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            // Increment the counter\n            count++;\n        }\n    }\n    \n    // Return the counter\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\"; // Special case for 0\n\n    string binary = \"\";\n    while (decimal > 0) {\n        binary += to_string(decimal % 2); // Append the remainder\n        decimal /= 2; // Update decimal to be the quotient\n    }\n\n    reverse(binary.begin(), binary.end()); // Reverse the string to get correct binary order\n    return \"db\" + binary + \"db\"; // Prepend and append \"db\"\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check the next 3 characters\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    // If no duplicates were found, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\n#include<cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers\n\n    int count_start_with_1 = std::pow(10, n - 1);\n    int count_end_with_1 = 9 * std::pow(10, n - 2);\n    int count_both_start_and_end_with_1 = std::pow(10, n - 2);\n\n    int total_count = count_start_with_1 + count_end_with_1 - count_both_start_and_end_with_1;\n\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\n#include<bitset>\n\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    int temp = N;\n    while (temp > 0) {\n        sum += temp % 10;  // Add the last digit to sum\n        temp /= 10;        // Remove the last digit\n    }\n\n    // Step 2: Convert the sum to binary\n    string binarySum = bitset<32>(sum).to_string();  // Convert to 32-bit binary string\n    size_t pos = binarySum.find('1');  // Find the first '1' to trim leading zeros\n    if (pos != string::npos) {\n        binarySum = binarySum.substr(pos);  // Trim leading zeros\n    } else {\n        binarySum = \"0\";  // If sum is 0, binary representation is \"0\"\n    }\n\n    // Step 3: Return the binary string\n    return binarySum;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string tempWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // Sort the temporary word and append it to the result\n            sort(tempWord.begin(), tempWord.end());\n            result += tempWord + ' ';\n            tempWord = \"\"; // Reset temporary word\n        } else {\n            tempWord += c; // Add character to temporary word\n        }\n    }\n    \n    // Sort and append the last word\n    if (!tempWord.empty()) {\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Step 1: Find all occurrences of x and store their coordinates\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    // Step 2: Sort the result vector\n    // First by rows in ascending order\n    // Then by columns in descending order for the same row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1];\n        }\n        return a[0] < b[0];\n    });\n    \n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.size() <= 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Create a copy of the original vector\n    vector<int> sorted_array = array;\n\n    // Determine the sorting order based on the sum\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Return the sorted vector\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char newChar = c + 4;\n            if (newChar > 'z') {\n                newChar -= 26;\n            }\n            result += newChar;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    int smallest = lst[0];\n    int second_smallest = lst[1];\n\n    if (smallest > second_smallest) {\n        swap(smallest, second_smallest);\n    }\n\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] < smallest) {\n            second_smallest = smallest;\n            smallest = lst[i];\n        } else if (lst[i] < second_smallest && lst[i] != smallest) {\n            second_smallest = lst[i];\n        }\n    }\n\n    if (second_smallest == smallest) {\n        return -1; // Return -1 to indicate None\n    }\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint is_bored(string S){\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n    vector<char> delimiters = {'.', '?', '!'};\n    \n    while (getline(ss, sentence, delimiters[0])) {\n        for (char delimiter : delimiters) {\n            size_t pos = sentence.find(delimiter);\n            if (pos != string::npos) {\n                sentence = sentence.substr(0, pos);\n                break;\n            }\n        }\n        // Trim leading and trailing spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        size_t end = sentence.find_last_not_of(\" \");\n        if (start != string::npos && end != string::npos) {\n            sentence = sentence.substr(start, end - start + 1);\n        }\n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence[0] == 'I') {\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if any of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/93", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string encode(string message) {\n       string vowels = \"aeiouAEIOU\";\n       string result = \"\";\n       for (char &ch : message) {\n           if (vowels.find(ch) != string::npos) {\n               char newChar = ch + 2;\n               if ((islower(ch) && newChar > 'z') || (isupper(ch) && newChar > 'Z')) {\n                   newChar -= 26;\n               }\n               ch = newChar;\n           }\n           ch = islower(ch) ? toupper(ch) : tolower(ch);\n           result += ch;\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int number : lst) {\n        if (isPrime(number) && number > largestPrime) {\n            largestPrime = number;\n        }\n    }\n    if (largestPrime == -1) {\n        return 0;\n    }\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   bool check_dict_case(map<string, string> dict) {\n       if (dict.empty()) {\n           return false;\n       }\n\n       bool is_lower = true;\n       bool is_upper = true;\n\n       for (const auto& pair : dict) {\n           const string& key = pair.first;\n\n           if (!islower(key[0]) && !isupper(key[0])) {\n               return false;\n           }\n\n           for (char c : key) {\n               if (!islower(c)) {\n                   is_lower = false;\n               }\n               if (!isupper(c)) {\n                   is_upper = false;\n               }\n           }\n\n           if (!is_lower && !is_upper) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    if (n <= 2) return {};\n\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Calculate the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    string vowels = \"AEIOU\";\n    \n    for (int i = 0; i < s.length(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a float\n    float num = stof(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1.0) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    } else {\n        // Use the round function for normal rounding\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> make_a_pile(int n){\n       vector<int> stones;\n       int current_stones = n;\n       for (int i = 0; i < n; i++) {\n           stones.push_back(current_stones);\n           if (current_stones % 2 == 1) {\n               current_stones += 2; // Next odd number\n           } else {\n               current_stones += 2; // Next even number\n           }\n       }\n       return stones;\n   }\n   "}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string currentWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!currentWord.empty()) {\n                words.push_back(currentWord);\n                currentWord = \"\";\n            }\n        } else {\n            currentWord += c;\n        }\n    }\n    \n    // Add the last word if there is any\n    if (!currentWord.empty()) {\n        words.push_back(currentWord);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is invalid\n    if (x > y) {\n        return -1;\n    }\n    \n    // Start from y and move downwards to x\n    for (int i = y; i >= x; --i) {\n        // Check if the current number is even\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n    \n    // If no even number is found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   using namespace std;\n\n   string rounded_avg(int n, int m) {\n       if (n > m) {\n           return \"-1\";\n       }\n\n       int sum = 0;\n       int count = m - n + 1;\n       for (int i = n; i <= m; ++i) {\n           sum += i;\n       }\n\n       double average = static_cast<double>(sum) / count;\n       int rounded_average = floor(average);\n\n       // Convert rounded_average to binary\n       string binary_representation;\n       if (rounded_average == 0) {\n           binary_representation = \"0\";\n       } else {\n           while (rounded_average > 0) {\n               binary_representation = to_string(rounded_average % 2) + binary_representation;\n               rounded_average /= 2;\n           }\n       }\n\n       return binary_representation;\n   }\n   "}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x){\n    vector<int> result;\n    \n    for(int num : x){\n        string numStr = to_string(num);\n        bool hasEvenDigit = false;\n        \n        for(char ch : numStr){\n            if(ch == '0' || ch == '2' || ch == '4' || ch == '6' || ch == '8'){\n                hasEvenDigit = true;\n                break;\n            }\n        }\n        \n        if(!hasEvenDigit){\n            result.push_back(num);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to convert digits to their corresponding names\n    map<int, string> digitToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the input vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Replace each integer with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(digitToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> f(int n) {\n       vector<int> result(n);\n       for (int i = 1; i <= n; ++i) {\n           if (i % 2 == 0) {\n               // Calculate factorial of i\n               int factorial = 1;\n               for (int j = 1; j <= i; ++j) {\n                   factorial *= j;\n               }\n               result[i - 1] = factorial;\n           } else {\n               // Calculate sum of numbers from 1 to i\n               int sum = 0;\n               for (int j = 1; j <= i; ++j) {\n                   sum += j;\n               }\n               result[i - 1] = sum;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        string s = to_string(i);\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        \n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                ++even_count;\n            } else {\n                ++odd_count;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        int sum_of_digits = 0;\n        int abs_number = abs(number);\n        while (abs_number > 0) {\n            int digit = abs_number % 10;\n            if (number < 0) {\n                digit = -digit;\n            }\n            sum_of_digits += digit;\n            abs_number /= 10;\n        }\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isSorted(vector<int> arr) {\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i-1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.size() == 0) {\n        return true;\n    }\n    if (isSorted(arr)) {\n        return true;\n    }\n    for (int i = 0; i < arr.size(); i++) {\n        // Perform right shift\n        int last = arr[arr.size() - 1];\n        for (int j = arr.size() - 1; j > 0; j--) {\n            arr[j] = arr[j-1];\n        }\n        arr[0] = last;\n        if (isSorted(arr)) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n    \n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd_lst1++;\n        }\n    }\n    \n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even_lst2++;\n        }\n    }\n    \n    // Determine if we can make lst1 all even\n    if (count_odd_lst1 <= count_even_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCounts;\n    int maxCount = 0;\n\n    // Count occurrences of each letter\n    for (char c : test) {\n        if (isalpha(c)) {\n            letterCounts[c]++;\n            if (letterCounts[c] > maxCount) {\n                maxCount = letterCounts[c];\n            }\n        }\n    }\n\n    // Collect letters with the maximum count\n    map<char, int> result;\n    for (const auto& pair : letterCounts) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set from characters in string c\n    unordered_set<char> charsToRemove(c.begin(), c.end());\n    \n    // Initialize the result string\n    string result;\n    \n    // Iterate through each character in string s\n    for (char ch : s) {\n        // If the character is not in the set, append it to result\n        if (charsToRemove.find(ch) == charsToRemove.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    \n    // Determine if the result string is a palindrome\n    bool isPalindrome = (result == reversedResult);\n    \n    // Return the result vector\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    string format_string = \"the number of odd elements %dn the str%dng %d of the %dnput.\";\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char ch : lst[i]) {\n            if ((ch - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        char buffer[100];\n        snprintf(buffer, sizeof(buffer), format_string.c_str(), odd_count, odd_count, odd_count, odd_count);\n        result.push_back(buffer);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    // Initialize min_sum to a large value and current_sum to 0\n    long long min_sum = nums[0];\n    long long current_sum = 0;\n\n    // Iterate through each element in the vector\n    for (long long num : nums) {\n        // Update current_sum to be the minimum of the current element or the sum of current_sum and the current element\n        current_sum = min(num, current_sum + num);\n        // Update min_sum to be the minimum of min_sum and current_sum\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath> // for ceil function\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            if (cell == 1) {\n                water_units++;\n            }\n        }\n        int lowers_needed = ceil((double)water_units / capacity);\n        total_lowers += lowers_needed;\n    }\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Function to sort the array based on the number of ones in binary representation\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    auto comparator = [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b; // If number of ones is the same, sort by decimal value\n        }\n        return onesA < onesB; // Otherwise, sort by number of ones\n    };\n\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), comparator);\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant (not a vowel and is a letter)\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z') && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    // Split the string into words\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                // Count consonants in the word\n                int consonantCount = count_if(word.begin(), word.end(), isConsonant);\n                if (consonantCount == n) {\n                    result.push_back(word);\n                }\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    // Check the last word if the string does not end with a space\n    if (!word.empty()) {\n        int consonantCount = count_if(word.begin(), word.end(), isConsonant);\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string result = \"\";\n    string vowels = \"AEIOUaeiou\";\n    int n = word.size();\n    \n    for (int i = n - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the character before and after are consonants\n            bool prev_is_consonant = find(vowels.begin(), vowels.end(), word[i - 1]) == vowels.end();\n            bool next_is_consonant = find(vowels.begin(), vowels.end(), word[i + 1]) == vowels.end();\n            \n            if (prev_is_consonant && next_is_consonant) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int count_open_1 = 0, count_close_1 = 0;\n    int count_open_2 = 0, count_close_2 = 0;\n    \n    // Count '(' and ')' in the first string\n    for (char c : lst[0]) {\n        if (c == '(') count_open_1++;\n        if (c == ')') count_close_1++;\n    }\n    \n    // Count '(' and ')' in the second string\n    for (char c : lst[1]) {\n        if (c == '(') count_open_2++;\n        if (c == ')') count_close_2++;\n    }\n    \n    int total_open = count_open_1 + count_open_2;\n    int total_close = count_close_1 + count_close_2;\n    \n    if (total_open == total_close) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Take the first k elements\n    vector<int> max_k(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort these k elements in ascending order\n    sort(max_k.begin(), max_k.end());\n    \n    // Step 4: Return the sorted k elements\n    return max_k;\n}\n"}
{"task_id": "CPP/121", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int solution(vector<int> lst) {\n       int sum = 0;\n       for (int i = 0; i < lst.size(); ++i) {\n           if (i % 2 == 0) { // Check if the position is even\n               if (lst[i] % 2 != 0) { // Check if the element is odd\n                   sum += lst[i];\n               }\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/122", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int add_elements(vector<int> arr, int k) {\n       int sum = 0;\n       for (int i = 0; i < k; ++i) {\n           if (arr[i] >= 0 && arr[i] < 100) {\n               sum += arr[i];\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence and collect odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If n is even\n            n = n / 2;\n        } else { // If n is odd\n            n = 3 * n + 1;\n        }\n    }\n    // Add the final 1 to the odd numbers list\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<sstream>\n   #include<vector>\n   using namespace std;\n\n   bool isLeapYear(int year) {\n       return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n   }\n\n   bool valid_date(string date) {\n       // Check if the date string is in the correct format\n       if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n           return false;\n       }\n\n       // Split the date string into month, day, and year\n       stringstream ss(date);\n       string item;\n       vector<string> tokens;\n       while (getline(ss, item, '-')) {\n           tokens.push_back(item);\n       }\n\n       if (tokens.size() != 3) {\n           return false;\n       }\n\n       int month = stoi(tokens[0]);\n       int day = stoi(tokens[1]);\n       int year = stoi(tokens[2]);\n\n       // Validate month\n       if (month < 1 || month > 12) {\n           return false;\n       }\n\n       // Validate day based on month\n       int maxDays;\n       if (month == 2) {\n           maxDays = isLeapYear(year) ? 29 : 28;\n       } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n           maxDays = 30;\n       } else {\n           maxDays = 31;\n       }\n\n       if (day < 1 || day > maxDays) {\n           return false;\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespaces\n    if (txt.find(' ') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        result.push_back(txt.substr(start, end - start));\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start, end - start));\n        return result;\n    }\n    \n    // Count lowercase letters with odd order in the alphabet\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    \n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) return true; // A single element or empty list is trivially sorted\n\n    unordered_map<int, int> countMap;\n\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        countMap[lst[i]]++;\n        if (countMap[lst[i]] > 2) return false; // More than twice\n        if (lst[i] > lst[i + 1]) return false; // Not in ascending order\n    }\n\n    // Check the last element\n    countMap[lst.back()]++;\n    if (countMap[lst.back()] > 2) return false; // More than twice\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int prod_signs(vector<int> arr){\n       if (arr.empty()) {\n           return -32768;\n       }\n       int sum_of_magnitudes = 0;\n       int product_of_signs = 1;\n       for (int num : arr) {\n           sum_of_magnitudes += abs(num);\n           if (num > 0) {\n               product_of_signs *= 1;\n           } else if (num < 0) {\n               product_of_signs *= -1;\n           } else {\n               product_of_signs *= 0;\n           }\n       }\n       return sum_of_magnitudes * product_of_signs;\n   }\n   "}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n    vector<int> current_path;\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Helper function to perform DFS\n    function<void(int, int, int)> dfs = [&](int x, int y, int depth) {\n        current_path.push_back(grid[x][y]);\n        if (depth == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            for (auto& dir : directions) {\n                int nx = x + dir.first;\n                int ny = y + dir.second;\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                    dfs(nx, ny, depth + 1);\n                }\n            }\n        }\n        current_path.pop_back();\n    };\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dfs(i, j, 1);\n        }\n    }\n\n    return min_path;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result;\n    if (n < 1) return result; // Handle edge case where n is less than 1\n\n    // Initialize the first element\n    result.push_back(3);\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Even case\n            result.push_back(1 + i / 2);\n        } else {\n            // Odd case\n            int nextValue = result[i - 2] + result[i - 3] + (1 + (i + 1) / 2);\n            result.push_back(nextValue);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert the integer to a string\n    string n_str = to_string(n);\n    \n    // Initialize product to 1\n    int product = 1;\n    \n    // Flag to check if any odd digit is found\n    bool odd_found = false;\n    \n    // Iterate over each character in the string\n    for (char ch : n_str) {\n        // Convert character to integer\n        int digit = ch - '0';\n        \n        // Check if the digit is odd\n        if (digit % 2 != 0) {\n            // Multiply the digit to the product\n            product *= digit;\n            // Set the flag to true\n            odd_found = true;\n        }\n    }\n    \n    // If no odd digit was found, return 0\n    if (!odd_found) {\n        return 0;\n    }\n    \n    // Return the product of odd digits\n    return product;\n}\n"}
{"task_id": "CPP/132", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<stack>\n   using namespace std;\n\n   bool is_nested(string str) {\n       stack<char> s;\n       for (char ch : str) {\n           if (ch == '[') {\n               s.push(ch);\n           } else if (ch == ']') {\n               if (!s.empty()) {\n                   s.pop();\n                   if (!s.empty()) {\n                       return true; // Found nesting\n                   }\n               } else {\n                   return false; // Invalid sequence\n               }\n           }\n       }\n       return false; // No nesting found\n   }\n   "}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiling_num = ceil(num);  // Compute the ceiling of the number\n        sum += ceiling_num * ceiling_num;  // Square the ceiling value and add to sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool check_if_last_char_is_a_letter(string txt) {\n       if (txt.empty()) {\n           return false;\n       }\n       char last_char = txt.back();\n       if (!isalpha(last_char)) {\n           return false;\n       }\n       if (txt.size() == 1 || txt[txt.size() - 2] == ' ') {\n           return true;\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largest_index = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            largest_index = i;\n        }\n    }\n    return largest_index;\n}\n"}
{"task_id": "CPP/136", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> largest_smallest_integers(vector<int> lst) {\n       int largest_negative = 0;\n       int smallest_positive = 0;\n\n       for (int num : lst) {\n           if (num < 0) {\n               if (largest_negative == 0 || num > largest_negative) {\n                   largest_negative = num;\n               }\n           } else if (num > 0) {\n               if (smallest_positive == 0 || num < smallest_positive) {\n                   smallest_positive = num;\n               }\n           }\n       }\n\n       return {largest_negative, smallest_positive};\n   }\n   "}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/lexical_cast.hpp>\n#include<cctype>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        try {\n            if (val.type() == typeid(int)) {\n                return boost::any_cast<int>(val);\n            } else if (val.type() == typeid(float)) {\n                return boost::any_cast<float>(val);\n            } else if (val.type() == typeid(double)) {\n                return boost::any_cast<double>(val);\n            } else if (val.type() == typeid(string)) {\n                string str = boost::any_cast<string>(val);\n                replace(str.begin(), str.end(), ',', '.');\n                return boost::lexical_cast<double>(str);\n            }\n        } catch (const boost::bad_any_cast&) {\n            throw runtime_error(\"Unsupported type\");\n        }\n        throw runtime_error(\"Unsupported type\");\n    };\n\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return \"None\";\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and at least 8\n    if (n % 2 == 0 && n >= 8) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text){\n    string result = \"\";\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count > 2) {\n                result += '-';\n                space_count = 0; // Reset counter after adding hyphen\n            }\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += ch;\n            space_count = 0; // Reset counter after adding character\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    int dot_index = -1;\n\n    // Count digits and find the dot\n    for (int i = 0; i < file_name.size(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n\n    // Check digit count and dot count\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the string into two parts\n    string before_dot = file_name.substr(0, dot_index);\n    string after_dot = file_name.substr(dot_index + 1);\n\n    // Check if before_dot is not empty and starts with a Latin alphabet letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if after_dot is one of the allowed extensions\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int sum_squares(vector<int> lst) {\n       int sum = 0;\n       for (int i = 0; i < lst.size(); ++i) {\n           if (i % 3 == 0) {\n               lst[i] = lst[i] * lst[i]; // Square the element\n           } else if (i % 4 == 0 && i % 3 != 0) {\n               lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n           }\n           sum += lst[i]; // Add the modified element to sum\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    // Split the sentence into words\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Collect words with prime lengths\n    vector<string> primeLengthWords;\n    for (const string& w : words) {\n        if (isPrime(w.length())) {\n            primeLengthWords.push_back(w);\n        }\n    }\n\n    // Join the collected words into a single string with spaces\n    string result;\n    for (size_t i = 0; i < primeLengthWords.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += primeLengthWords[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Helper function to parse the fraction\n    auto parseFraction = [](const string& fraction) -> pair<int, int> {\n        size_t pos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, pos));\n        int denominator = stoi(fraction.substr(pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [numerator1, denominator1] = parseFraction(x);\n    auto [numerator2, denominator2] = parseFraction(n);\n\n    // Multiply the fractions\n    int resultNumerator = numerator1 * numerator2;\n    int resultDenominator = denominator1 * denominator2;\n\n    // Check if the result is a whole number\n    return resultNumerator % resultDenominator == 0;\n}\n\n// Example usage\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sumOfDigits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs (number, digit sum)\n    vector<pair<int, int>> numsWithSums;\n    for (int i = 0; i < nums.size(); ++i) {\n        numsWithSums.push_back({nums[i], sumOfDigits(nums[i])});\n    }\n    \n    // Sort the vector of pairs based on the digit sum\n    sort(numsWithSums.begin(), numsWithSums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.second == b.second) {\n            return false; // Maintain original order for equal sums\n        }\n        return a.second < b.second;\n    });\n    \n    // Extract the sorted numbers\n    vector<int> sortedNums;\n    for (const auto& pair : numsWithSums) {\n        sortedNums.push_back(pair.first);\n    }\n    \n    return sortedNums;\n}\n"}
{"task_id": "CPP/146", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   int specialFilter(vector<int> nums) {\n       int count = 0;\n       for (int num : nums) {\n           if (num > 10) {\n               string numStr = to_string(abs(num)); // Use abs to handle negative numbers\n               char first_digit = numStr[0];\n               char last_digit = numStr[numStr.size() - 1];\n               if ((first_digit == '1' || first_digit == '3' || first_digit == '5' || first_digit == '7' || first_digit == '9') &&\n                   (last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9')) {\n                   count++;\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/147", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int get_max_triples(int n) {\n       vector<int> a(n);\n       for (int i = 1; i <= n; ++i) {\n           a[i-1] = i * i - i + 1;\n       }\n       \n       int count = 0;\n       for (int i = 0; i < n-2; ++i) {\n           for (int j = i+1; j < n-1; ++j) {\n               for (int k = j+1; k < n; ++k) {\n                   if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                       ++count;\n                   }\n               }\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/148", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> bf(string planet1, string planet2) {\n       vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n       vector<string> result;\n\n       // Check if both planets are valid\n       if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n           find(planets.begin(), planets.end(), planet2) == planets.end()) {\n           return result; // Return empty vector if either planet is invalid\n       }\n\n       // Find indices of planet1 and planet2\n       int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n       int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n       // Extract planets between the indices\n       if (index1 < index2) {\n           for (int i = index1 + 1; i < index2; ++i) {\n               result.push_back(planets[i]);\n           }\n       } else {\n           for (int i = index2 + 1; i < index1; ++i) {\n               result.push_back(planets[i]);\n           }\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nint x_or_y(int n, int x, int y) {\n    // Handle edge case for numbers less than 2\n    if (n < 2) {\n        return y;\n    }\n    \n    // Check for primality\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return y; // n is not a prime number\n        }\n    }\n    \n    // If no divisors found, n is a prime number\n    return x;\n}\n\n// Example usage\n"}
{"task_id": "CPP/151", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   long long double_the_difference(vector<float> lst) {\n       long long sum = 0;\n       for (float num : lst) {\n           if (num > 0 && floor(num) == num) {  // Check if num is a positive integer\n               int intNum = static_cast<int>(num);\n               if (intNum % 2 != 0) {  // Check if num is odd\n                   sum += intNum * intNum;\n               }\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result(game.size());\n    for (int i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int cap = 0, sm = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : ext) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n\n        // Calculate strength\n        int strength = cap - sm;\n\n        // Update strongest extension if current one is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the second word with itself\n    string concatenated = b + b;\n    \n    // Check if the first word is a substring of the concatenated string\n    if (concatenated.find(a) != string::npos) {\n        return true;\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Convert the number to a string\n    string num_str = to_string(abs(num));\n    \n    // Iterate through each character in the string\n    for (char digit_char : num_str) {\n        // Convert the character to an integer\n        int digit = digit_char - '0';\n        \n        // Check if the digit is even or odd\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    // Return the counters as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Lookup table for Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the lookup table\n    for (const auto& symbol : romanSymbols) {\n        while (number >= symbol.first) {\n            number -= symbol.first;\n            result += symbol.second;\n        }\n    }\n    \n    // Convert the result string to lowercase\n    transform(result.begin(), result.end(), result.begin(), ::tolower);\n    \n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the hypotenuse\n    float sides[] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Apply the Pythagorean theorem\n    float a_squared = sides[0] * sides[0];\n    float b_squared = sides[1] * sides[1];\n    float c_squared = sides[2] * sides[2];\n    \n    // Check if a^2 + b^2 = c^2\n    return (a_squared + b_squared == c_squared);\n}\n"}
{"task_id": "CPP/158", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   string find_max(vector<string> words) {\n       int max_unique_count = 0;\n       string result_word = \"\";\n       \n       for (const string& word : words) {\n           unordered_set<char> unique_chars(word.begin(), word.end());\n           int unique_count = unique_chars.size();\n           \n           if (unique_count > max_unique_count) {\n               max_unique_count = unique_count;\n               result_word = word;\n           } else if (unique_count == max_unique_count) {\n               if (result_word.empty() || word < result_word) {\n                   result_word = word;\n               }\n           }\n       }\n       \n       return result_word;\n   }\n   "}
{"task_id": "CPP/159", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> eat(int number, int need, int remaining) {\n       int total_needed = number + need;\n       int total_eaten, carrots_left;\n\n       if (total_needed <= remaining) {\n           total_eaten = total_needed;\n           carrots_left = remaining - total_needed;\n       } else {\n           total_eaten = number + remaining;\n           carrots_left = 0;\n       }\n\n       return {total_eaten, carrots_left};\n   }\n   "}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0];\n    for (int i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int nextOperand = operand[i + 1];\n        if (op == \"+\") {\n            result += nextOperand;\n        } else if (op == \"-\") {\n            result -= nextOperand;\n        } else if (op == \"*\") {\n            result *= nextOperand;\n        } else if (op == \"//\") {\n            if (nextOperand == 0) {\n                // Handle division by zero error\n                printf(\"Error: Division by zero\\n\");\n                return -1; // or some error code\n            } else {\n                result = floor(result / nextOperand);\n            }\n        } else if (op == \"**\") {\n            result = pow(result, nextOperand);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   string solve(string s) {\n       int letter_count = 0;\n       string result = \"\";\n       \n       for (char c : s) {\n           if (isalpha(c)) {\n               letter_count++;\n               if (islower(c)) {\n                   result += toupper(c);\n               } else {\n                   result += tolower(c);\n               }\n           } else {\n               result += c;\n           }\n       }\n       \n       if (letter_count == 0) {\n           reverse(result.begin(), result.end());\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check if the input string is empty\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    // Initialize the MD5 context\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update the MD5 context with the input string\n    MD5_Update(&md5Context, text.c_str(), text.size());\n\n    // Finalize the MD5 context to get the hash\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5_Final(result, &md5Context);\n\n    // Convert the hash to a hexadecimal string\n    string md5String;\n    char buffer[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        sprintf(buffer, \"%02x\", result[i]);\n        md5String += buffer;\n    }\n\n    // Return the hexadecimal string\n    return md5String;\n}\n"}
{"task_id": "CPP/163", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> generate_integers(int a, int b) {\n       // Ensure a is less than or equal to b\n       if (a > b) {\n           swap(a, b);\n       }\n\n       vector<int> result;\n       for (int i = a; i <= b; ++i) {\n           if (i >= 0 && i <= 8 && i % 2 == 0) {\n               result.push_back(i);\n           }\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Check for edge cases\n    if (numbers.size() < 2 || threshold <= 0) {\n        return false;\n    }\n\n    // Iterate through each pair of numbers\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            // Calculate the absolute difference\n            float diff = abs(numbers[i] - numbers[j]);\n            // Check if the difference is less than the threshold\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n\n    // If no pairs are found that meet the condition, return false\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    stack<char> s;\n\n    for (char c : paren_string) {\n        if (c == ' ') {\n            continue; // Ignore spaces\n        }\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            if (!s.empty() && s.top() == '(') {\n                s.pop();\n                current_group += c;\n                if (s.empty()) {\n                    result.push_back(current_group);\n                    current_group.clear();\n                }\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Calculate the integer part of the number\n    float integerPart = floor(number);\n    \n    // Calculate the decimal part by subtracting the integer part from the original number\n    float decimalPart = number - integerPart;\n    \n    // Return the decimal part\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_zero(vector<int> operations){\n       int balance = 0;\n       for (int operation : operations) {\n           balance += operation;\n           if (balance < 0) {\n               return true;\n           }\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/4", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   float mean_absolute_deviation(vector<float> numbers){\n       // Calculate the mean of the dataset\n       float sum = 0;\n       for(float number : numbers) {\n           sum += number;\n       }\n       float mean = sum / numbers.size();\n       \n       // Initialize sum of absolute differences\n       float sum_abs_diff = 0;\n       \n       // Compute the absolute difference for each element\n       for(float number : numbers) {\n           sum_abs_diff += abs(number - mean);\n       }\n       \n       // Calculate the Mean Absolute Deviation\n       float MAD = sum_abs_diff / numbers.size();\n       \n       return MAD;\n   }\n   "}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<sstream>\n   using namespace std;\n\n   vector<int> parse_nested_parens(string paren_string) {\n       vector<int> results;\n       stringstream ss(paren_string);\n       string group;\n       \n       while (ss >> group) {\n           int max_depth = 0;\n           int current_depth = 0;\n           \n           for (char ch : group) {\n               if (ch == '(') {\n                   current_depth++;\n                   if (current_depth > max_depth) {\n                       max_depth = current_depth;\n                   }\n               } else if (ch == ')') {\n                   current_depth--;\n               }\n           }\n           \n           results.push_back(max_depth);\n       }\n       \n       return results;\n   }\n   "}
{"task_id": "CPP/7", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_substring(vector<string> strings, string substring) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(substring) != string::npos) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/8", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> sum_product(vector<int> numbers){\n       int sum = 0;\n       int product = 1;\n       \n       for(int number : numbers){\n           sum += number;\n           product *= number;\n       }\n       \n       return {sum, product};\n   }\n   "}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    vector<int> result;\n    int current_max = numbers[0];\n    \n    for (int number : numbers) {\n        if (number > current_max) {\n            current_max = number;\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    string s(str.rbegin(),str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    int n = str.length();\n    if (n == 0) return \"\";\n\n    for (int i = 0; i < n; i++) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            string reversed_prefix = string(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, reverse the entire string and append\n    string reversed_str = string(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        return \"Error: Input strings must be of the same length.\";\n    }\n    \n    string result = \"\";\n    \n    // Perform XOR operation on each character\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == '0' && b[i] == '0') {\n            result += '0';\n        } else if (a[i] == '0' && b[i] == '1') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '0') {\n            result += '1';\n        } else if (a[i] == '1' && b[i] == '1') {\n            result += '0';\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string longest(vector<string> strings){\n       if (strings.empty()) {\n           return \"\"; // Return empty string to represent None\n       }\n       string longest_string = strings[0];\n       for (const string& str : strings) {\n           if (str.length() > longest_string.length()) {\n               longest_string = str;\n           }\n       }\n       return longest_string;\n   }\n   "}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Base case: if b is 0, then the GCD is a\n    if (b == 0) {\n        return a;\n    }\n    // Recursive case: call the function with b and a % b\n    return greatest_common_divisor(b, a % b);\n}\n\n// Example usage\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n){\n    // Initialize a string stream\n    stringstream ss;\n    \n    // Loop from 0 to n\n    for(int i = 0; i <= n; ++i){\n        // Append the number followed by a space\n        ss << i << \" \";\n    }\n    \n    // Convert the string stream to a string\n    string result = ss.str();\n    \n    // Remove the trailing space\n    if(!result.empty() && result.back() == ' '){\n        result.pop_back();\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str){ \n    // Convert the string to lowercase\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Initialize a set to store unique characters\n    set<char> unique_chars;\n    \n    // Iterate through each character in the string\n    for(char c : str) {\n        // Insert the character into the set\n        unique_chars.insert(c);\n    }\n    \n    // Return the size of the set, which is the number of distinct characters\n    return unique_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string){ \n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0;\n    }\n    int count = 0;\n    int length_str = str.length();\n    int length_sub = substring.length();\n    for (int i = 0; i <= length_str - length_sub; ++i) {\n        if (str.substr(i, length_sub) == substring) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to associate numerals with their integer values\n    map<string, int> numeralToValue = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    // Split the input string into individual numerals\n    vector<string> numeralList;\n    stringstream ss(numbers);\n    string numeral;\n    while (ss >> numeral) {\n        numeralList.push_back(numeral);\n    }\n    \n    // Sort the numerals based on their integer values\n    sort(numeralList.begin(), numeralList.end(), [&](const string &a, const string &b) {\n        return numeralToValue[a] < numeralToValue[b];\n    });\n    \n    // Join the sorted numerals back into a single string\n    string sortedNumbers;\n    for (const string &num : numeralList) {\n        if (!sortedNumbers.empty()) {\n            sortedNumbers += \" \";\n        }\n        sortedNumbers += num;\n    }\n    \n    return sortedNumbers;\n}\n"}
{"task_id": "CPP/20", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   vector<float> find_closest_elements(vector<float> numbers) {\n       vector<float> closest_pair;\n       float min_diff = INFINITY;\n\n       for (int i = 0; i < numbers.size(); i++) {\n           for (int j = i + 1; j < numbers.size(); j++) {\n               float diff = abs(numbers[i] - numbers[j]);\n               if (diff < min_diff) {\n                   min_diff = diff;\n                   closest_pair = {numbers[i], numbers[j]};\n               }\n           }\n       }\n\n       if (closest_pair[0] > closest_pair[1]) {\n           swap(closest_pair[0], closest_pair[1]);\n       }\n\n       return closest_pair;\n   }\n   "}
{"task_id": "CPP/21", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<float> rescale_to_unit(vector<float> numbers){\n       float min_value = *min_element(numbers.begin(), numbers.end());\n       float max_value = *max_element(numbers.begin(), numbers.end());\n       float range = max_value - min_value;\n       vector<float> transformed_numbers;\n       for (float number : numbers) {\n           float transformed_value = (number - min_value) / range;\n           transformed_numbers.push_back(transformed_value);\n       }\n       return transformed_numbers;\n   }\n   "}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        try {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        } catch (const boost::bad_any_cast&) {\n            // Ignore non-integer values\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    // Step 1: Count occurrences of each element\n    unordered_map<int, int> countMap;\n    for(int num : numbers) {\n        countMap[num]++;\n    }\n    \n    // Step 2: Construct the result vector with elements that occur only once\n    vector<int> result;\n    for(int num : numbers) {\n        if(countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    // Step 3: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str){\n    string result = \"\";\n    for (char ch : str) {\n        if (islower(ch)) {\n            result += toupper(ch);\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else {\n            result += ch; // If it's not a letter, just append it as is\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> filter_by_prefix(vector<string> strings, string prefix) {\n       vector<string> result;\n       for (const string& str : strings) {\n           if (str.find(prefix) == 0) {\n               result.push_back(str);\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_numbers;\n    for(float num : l){\n        if(num > 0){\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    double tolerance = 1e-7;\n    int max_iterations = 1000;\n    double x_n = 0.0;\n    for (int iteration = 0; iteration < max_iterations; iteration++) {\n        double f_x_n = poly(xs, x_n);\n        double f_prime_x_n = poly_derivative(xs, x_n);\n        if (abs(f_prime_x_n) < tolerance) {\n            break;\n        }\n        double x_n1 = x_n - f_x_n / f_prime_x_n;\n        if (abs(x_n1 - x_n) < tolerance) {\n            return x_n1;\n        }\n        x_n = x_n1;\n    }\n    return x_n;\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l){\n    // Step 1: Collect elements at indices divisible by 3\n    vector<int> third_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    \n    // Step 2: Sort the collected elements\n    sort(third_elements.begin(), third_elements.end());\n    \n    // Step 3: Replace the elements at indices divisible by 3 with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = third_elements[index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Step 1: Initialize an empty set\n    set<int> uniqueSet;\n    \n    // Step 2: Iterate through the input vector and insert each element into the set\n    for(int num : l){\n        uniqueSet.insert(num);\n    }\n    \n    // Step 3: Convert the set to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 4: Sort the vector (although the set is already sorted, this step is redundant but kept for clarity)\n    sort(uniqueVector.begin(), uniqueVector.end());\n    \n    // Step 5: Return the sorted vector\n    return uniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    // Initialize max_val with the first element of the vector\n    float max_val = l[0];\n    \n    // Iterate through the vector starting from the second element\n    for(int i = 1; i < l.size(); i++){\n        // Update max_val if the current element is greater\n        if(l[i] > max_val){\n            max_val = l[i];\n        }\n    }\n    \n    // Return the maximum element found\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> l_prime;\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the new vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime.push_back(even_values[even_index++]);\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    string output;\n    int l = s.length();\n    int num = (l + 2) / 3;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2;\n    if (n == 2) return 3;\n    \n    int count = 2;\n    int a = 2, b = 3;\n    \n    while (true) {\n        int c = a + b;\n        if (is_prime(c)) {\n            count += 1;\n            if (count == n) {\n                return c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Calculate the number of collisions\n    int collisions = n * n;\n    // Return the result\n    return collisions;\n}\n"}
{"task_id": "CPP/42", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> incr_list(vector<int> l){\n       vector<int> result;\n       for (int i = 0; i < l.size(); i++) {\n           result.push_back(l[i] + 1);\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int number : l) {\n        if (seen.find(-number) != seen.end()) {\n            return true;\n        }\n        seen.insert(number);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Special case for zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result += to_string(remainder); // Append the remainder to the result string\n        x /= base; // Update x to be the quotient\n    }\n\n    // Reverse the result string to get the correct base representation\n    reverse(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // Calculate the area using the formula 1/2 * base * height\n    float area = 0.5 * a * h;\n    // Return the calculated area\n    return area;\n}\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    vector<int> fib4_values = {0, 0, 2, 0};\n\n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        fib4_values.erase(fib4_values.begin());\n        fib4_values.push_back(next_value);\n    }\n\n    return fib4_values.back();\n}\n"}
{"task_id": "CPP/47", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   float median(vector<float> l){\n       // Sort the vector\n       sort(l.begin(), l.end());\n       \n       // Get the size of the vector\n       int n = l.size();\n       \n       // Check if the size is odd or even\n       if (n % 2 != 0) {\n           // If odd, return the middle element\n           return l[n / 2];\n       } else {\n           // If even, return the average of the two middle elements\n           return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n       }\n   }\n   "}
{"task_id": "CPP/48", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool is_palindrome(string text){\n       int left = 0;\n       int right = text.length() - 1;\n       while (left < right) {\n           if (text[left] != text[right]) {\n               return false;\n           }\n           left++;\n           right--;\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\n\nint modp(int n, int p) {\n    if (n == 0) {\n        return 1;\n    }\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_shift(string s){\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        // Calculate the new character by shifting it backward by 5 positions\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   string remove_vowels(string text){\n       unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n       string result = \"\";\n       for (char ch : text) {\n           if (vowels.find(ch) == vowels.end()) {\n               result += ch;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/52", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   bool below_threshold(vector<int> l, int t) {\n       for (int num : l) {\n           if (num >= t) {\n               return false;\n           }\n       }\n       return true;\n   }\n   "}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    \n    // Compare the sorted strings\n    return s0 == s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool correct_bracketing(string brackets) {\n       int counter = 0;\n       for (char bracket : brackets) {\n           if (bracket == '<') {\n               counter++;\n           } else if (bracket == '>') {\n               counter--;\n           }\n           if (counter < 0) {\n               return false;\n           }\n       }\n       return counter == 0;\n   }\n   "}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   vector<int> common(vector<int> l1, vector<int> l2) {\n       unordered_set<int> set_l1(l1.begin(), l1.end());\n       vector<int> result;\n\n       for (int num : l2) {\n           if (set_l1.find(num) != set_l1.end()) {\n               result.push_back(num);\n               set_l1.erase(num); // Ensure uniqueness\n           }\n       }\n\n       sort(result.begin(), result.end());\n       return result;\n   }\n   "}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    \n    // Handle the case where n is even\n    if (n % 2 == 0) {\n        largest_factor = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n    }\n    \n    // Check for odd factors\n    for (int factor = 3; factor * factor <= n; factor += 2) {\n        while (n % factor == 0) {\n            largest_factor = factor;\n            n /= factor;\n        }\n    }\n    \n    // If n is still greater than 2, then n itself is a prime factor\n    if (n > 2) {\n        largest_factor = n;\n    }\n    \n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            counter++;\n        } else if (ch == ')') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false;\n        }\n    }\n    return counter == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n < 0) {\n        // Handle negative input appropriately\n        return -1; // or throw an exception\n    }\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n// Example usage\n"}
{"task_id": "CPP/64", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int vowels_count(string s) {\n       int count = 0;\n       transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n       for (int i = 0; i < s.length(); i++) {\n           if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n               count++;\n           } else if (s[i] == 'y' && i == s.length() - 1) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Perform the circular shift\n    string suffix = str_x.substr(len - shift);\n    string prefix = str_x.substr(0, len - shift);\n    string result = suffix + prefix;\n    \n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   int digitSum(string s) {\n       int sum = 0;\n       for (char c : s) {\n           if (c >= 'A' && c <= 'Z') {\n               sum += c;\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Extract the number of apples\n    ss >> apples;\n    ss >> temp; // Skip the word \"apples\"\n    ss >> temp; // Skip the word \"and\"\n    \n    // Extract the number of oranges\n    ss >> oranges;\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    // Return the result\n    return mangoes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h> // For INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_even == INT_MAX) {\n        return {};\n    }\n    \n    return {smallest_even, smallest_index};\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Create an unordered_map to store the frequency of each integer\n    unordered_map<int, int> frequencyMap;\n    \n    // Step 2: Populate the unordered_map by iterating through the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    // Step 3: Iterate through the unordered_map to find the greatest integer\n    // where the frequency is greater than or equal to the integer itself\n    int result = -1;\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<int> strange_sort_list(vector<int> lst){\n       if (lst.empty()) {\n           return lst;\n       }\n       \n       sort(lst.begin(), lst.end());\n       vector<int> result;\n       int min_pointer = 0;\n       int max_pointer = lst.size() - 1;\n       bool toggle = true;\n       \n       while (min_pointer <= max_pointer) {\n           if (toggle) {\n               result.push_back(lst[min_pointer]);\n               min_pointer++;\n           } else {\n               result.push_back(lst[max_pointer]);\n               max_pointer--;\n           }\n           toggle = !toggle;\n       }\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(vector<int> q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/73", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int smallest_change(vector<int> arr) {\n       int change_count = 0;\n       int left_pointer = 0;\n       int right_pointer = arr.size() - 1;\n       \n       while (left_pointer < right_pointer) {\n           if (arr[left_pointer] != arr[right_pointer]) {\n               change_count++;\n           }\n           left_pointer++;\n           right_pointer--;\n       }\n       \n       return change_count;\n   }\n   "}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        totalChars1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        totalChars2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (totalChars1 <= totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to generate all prime numbers less than 100 using Sieve of Eratosthenes\nvector<int> generatePrimes() {\n    const int limit = 100;\n    vector<bool> isPrime(limit, true);\n    isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i < limit; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < limit; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    vector<int> primes;\n    for (int i = 2; i < limit; ++i) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = generatePrimes();\n    int n = primes.size();\n    \n    // Check all combinations of three different primes\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/76", "generation": "   #include<stdio.h>\n   #include<math.h>\n   using namespace std;\n\n   bool is_simple_power(int x, int n) {\n       if (n == 1) {\n           return x == 1;\n       }\n       if (x == 1) {\n           return true;\n       }\n       int int_val = 0;\n       while (true) {\n           int power = pow(n, int_val);\n           if (power == x) {\n               return true;\n           }\n           if (power > x) {\n               return false;\n           }\n           int_val++;\n       }\n   }\n   "}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    \n    bool isNegative = false;\n    if (a < 0) {\n        a = -a;\n        isNegative = true;\n    }\n    \n    double cubeRoot = cbrt(a);\n    int intCubeRoot = static_cast<int>(cubeRoot);\n    \n    if (isNegative) {\n        intCubeRoot = -intCubeRoot;\n    }\n    \n    if (intCubeRoot * intCubeRoot * intCubeRoot == a) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> primeDigits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Initialize the counter\n    int count = 0;\n    \n    // Loop through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime digits\n        if (primeDigits.find(c) != primeDigits.end()) {\n            // Increment the counter\n            count++;\n        }\n    }\n    \n    // Return the counter\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\"; // Special case for 0\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary += to_string(remainder);\n        decimal /= 2;\n    }\n\n    // Reverse the binary string to get the correct order\n    reverse(binary.begin(), binary.end());\n\n    // Add the \"db\" prefix and suffix\n    binary = \"db\" + binary + \"db\";\n\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string\n    for (int i = 0; i < s.length() - 2; ++i) {\n        // Check the next 3 characters\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no duplicates were found, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int length = str.length();\n    if (length < 2) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\n#include<cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Special case: only one number (1)\n    }\n    int count_start_with_1 = pow(10, n - 1);\n    int count_end_with_1 = pow(10, n - 1);\n    int count_both = pow(10, n - 2);\n    return count_start_with_1 + count_end_with_1 - count_both;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of the digits of N\n    int sum = 0;\n    int temp = N;\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n\n    // Step 2: Convert the sum to binary\n    if (sum == 0) return \"0\"; // Special case for sum = 0\n\n    string binary = \"\";\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nstring anti_shuffle(string s){\n    // Split the string into words\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Sort characters in each word\n    for (string& word : words) {\n        sort(word.begin(), word.end());\n    }\n\n    // Reconstruct the string with sorted words\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        result += words[i];\n        if (i != words.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n       vector<vector<int>> result;\n       \n       // Iterate through each row and each column to find occurrences of x\n       for (int i = 0; i < lst.size(); ++i) {\n           for (int j = 0; j < lst[i].size(); ++j) {\n               if (lst[i][j] == x) {\n                   result.push_back({i, j});\n               }\n           }\n       }\n       \n       // Sort the result vector\n       sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n           if (a[0] == b[0]) {\n               return a[1] > b[1]; // Sort by column in descending order if rows are the same\n           }\n           return a[0] < b[0]; // Sort by row in ascending order\n       });\n       \n       return result;\n   }\n   "}
{"task_id": "CPP/88", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<algorithm>\n   using namespace std;\n\n   vector<int> sort_array(vector<int> array) {\n       if (array.empty()) {\n           return {};\n       }\n       \n       int sum = array[0] + array[array.size() - 1];\n       vector<int> sorted_array = array;\n       \n       if (sum % 2 != 0) {\n           sort(sorted_array.begin(), sorted_array.end());\n       } else {\n           sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n       }\n       \n       return sorted_array;\n   }\n   "}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    int shift = 4; // 2 * 2 = 4\n\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char newChar = c + shift;\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around if it goes past 'z'\n            }\n            result += newChar;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    int smallest = lst[0];\n    int second_smallest = lst[1];\n\n    if (smallest > second_smallest) {\n        swap(smallest, second_smallest);\n    }\n\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] < smallest) {\n            second_smallest = smallest;\n            smallest = lst[i];\n        } else if (lst[i] < second_smallest && lst[i] != smallest) {\n            second_smallest = lst[i];\n        }\n    }\n\n    if (second_smallest == smallest) {\n        return -1; // Return -1 to indicate None\n    }\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint is_bored(string S){\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n    vector<char> delimiters = {'.', '?', '!'};\n    \n    while (getline(ss, sentence, delimiters[0])) {\n        for (char delimiter : delimiters) {\n            size_t pos = sentence.find(delimiter);\n            if (pos != string::npos) {\n                sentence = sentence.substr(0, pos);\n                break;\n            }\n        }\n        // Trim leading and trailing spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        size_t end = sentence.find_last_not_of(\" \");\n        if (start != string::npos && end != string::npos) {\n            sentence = sentence.substr(start, end - start + 1);\n        }\n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence[0] == 'I') {\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "   #include<stdio.h>\n   #include<math.h>\n   using namespace std;\n\n   bool any_int(float a, float b, float c) {\n       // Check if all three numbers are integers\n       if (floor(a) != a || floor(b) != b || floor(c) != c) {\n           return false;\n       }\n\n       // Calculate the sums\n       float sum_ab = a + b;\n       float sum_ac = a + c;\n       float sum_bc = b + c;\n\n       // Check if any number is equal to the sum of the other two\n       if (a == sum_bc || b == sum_ac || c == sum_ab) {\n           return true;\n       }\n\n       return false;\n   }\n   "}
{"task_id": "CPP/93", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   string encode(string message) {\n       string vowels = \"aeiouAEIOU\";\n       string result = \"\";\n       for (char &ch : message) {\n           char new_char = ch;\n           if (vowels.find(ch) != string::npos) {\n               if (islower(ch)) {\n                   new_char = ch + 2;\n                   if (new_char > 'z') {\n                       new_char = 'a' + (new_char - 'z' - 1);\n                   }\n               } else {\n                   new_char = ch + 2;\n                   if (new_char > 'Z') {\n                       new_char = 'A' + (new_char - 'Z' - 1);\n                   }\n               }\n           }\n           if (islower(ch)) {\n               new_char = toupper(new_char);\n           } else {\n               new_char = tolower(new_char);\n           }\n           result += new_char;\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    \n    // Find the largest prime in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    \n    // If no prime is found, return 0\n    if (largestPrime == -1) return 0;\n    \n    // Return the sum of the digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<map>\n   using namespace std;\n\n   bool check_dict_case(map<string, string> dict) {\n       if (dict.empty()) {\n           return false;\n       }\n\n       bool is_lower = true;\n       bool is_upper = true;\n\n       for (const auto& pair : dict) {\n           const string& key = pair.first;\n\n           if (!islower(key[0]) && !isupper(key[0])) {\n               return false;\n           }\n\n           for (char c : key) {\n               if (!islower(c)) {\n                   is_lower = false;\n               }\n               if (!isupper(c)) {\n                   is_upper = false;\n               }\n           }\n\n           if (!is_lower && !is_upper) {\n               return false;\n           }\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    if (n <= 2) return {};\n\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Calculate the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<algorithm>\n   using namespace std;\n\n   int count_upper(string s) {\n       int count = 0;\n       for (int i = 0; i < s.length(); i += 2) {\n           char ch = s[i];\n           if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a floating-point number\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    double fractional_part = num - floor(num);\n    if (fractional_part == 0.5 || fractional_part == -0.5) {\n        // Round away from zero\n        if (num >= 0) {\n            return static_cast<int>(ceil(num));\n        } else {\n            return static_cast<int>(floor(num));\n        }\n    } else {\n        // Use the round function to get the closest integer\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> make_a_pile(int n) {\n       vector<int> pile;\n       int current_stones = n;\n       for (int i = 0; i < n; ++i) {\n           pile.push_back(current_stones);\n           if (current_stones % 2 == 1) {\n               current_stones += 2; // Next odd number\n           } else {\n               current_stones += 2; // Next even number\n           }\n       }\n       return pile;\n   }\n   "}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string currentWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!currentWord.empty()) {\n                words.push_back(currentWord);\n                currentWord = \"\";\n            }\n        } else {\n            currentWord += c;\n        }\n    }\n    \n    // Add the last word if it exists\n    if (!currentWord.empty()) {\n        words.push_back(currentWord);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // If x is greater than y, the range is invalid\n    if (x > y) {\n        return -1;\n    }\n    \n    // Iterate from y down to x to find the largest even number\n    for (int i = y; i >= x; --i) {\n        // Check if the current number is even\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n    \n    // If no even number is found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   using namespace std;\n\n   string convert_to_binary(int number) {\n       if (number == 0) return \"0\";\n       string binary = \"\";\n       while (number > 0) {\n           binary = to_string(number % 2) + binary;\n           number /= 2;\n       }\n       return binary;\n   }\n\n   string rounded_avg(int n, int m) {\n       if (n > m) return \"-1\";\n       \n       int sum = 0;\n       int count = m - n + 1;\n       \n       for (int i = n; i <= m; ++i) {\n           sum += i;\n       }\n       \n       double average = static_cast<double>(sum) / count;\n       int rounded_average = floor(average);\n       \n       return convert_to_binary(rounded_average);\n   }\n   "}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x){\n    vector<int> result;\n    \n    for(int num : x){\n        string numStr = to_string(num);\n        bool hasEvenDigit = false;\n        \n        for(char ch : numStr){\n            if(ch == '0' || ch == '2' || ch == '4' || ch == '6' || ch == '8'){\n                hasEvenDigit = true;\n                break;\n            }\n        }\n        \n        if(!hasEvenDigit){\n            result.push_back(num);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<map>\n   #include<algorithm>\n   using namespace std;\n\n   vector<string> by_length(vector<int> arr) {\n       // Map of integers to their corresponding names\n       map<int, string> numToName = {\n           {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n           {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n       };\n\n       // Filter the array to keep only integers between 1 and 9\n       vector<int> filteredArr;\n       for (int num : arr) {\n           if (num >= 1 && num <= 9) {\n               filteredArr.push_back(num);\n           }\n       }\n\n       // Sort the filtered array\n       sort(filteredArr.begin(), filteredArr.end());\n\n       // Reverse the sorted array\n       reverse(filteredArr.begin(), filteredArr.end());\n\n       // Map each integer to its corresponding name\n       vector<string> result;\n       for (int num : filteredArr) {\n           result.push_back(numToName[num]);\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/106", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> f(int n){\n       vector<int> result(n);\n       for (int i = 1; i <= n; ++i) {\n           if (i % 2 == 0) {\n               // Calculate factorial of i\n               int factorial = 1;\n               for (int j = 1; j <= i; ++j) {\n                   factorial *= j;\n               }\n               result[i-1] = factorial;\n           } else {\n               // Calculate sum of numbers from 1 to i\n               int sum = 0;\n               for (int j = 1; j <= i; ++j) {\n                   sum += j;\n               }\n               result[i-1] = sum;\n           }\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/107", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   bool isPalindrome(int num) {\n       string str = to_string(num);\n       int len = str.length();\n       for (int i = 0; i < len / 2; ++i) {\n           if (str[i] != str[len - i - 1]) {\n               return false;\n           }\n       }\n       return true;\n   }\n\n   vector<int> even_odd_palindrome(int n) {\n       int even_count = 0;\n       int odd_count = 0;\n\n       for (int i = 1; i <= n; ++i) {\n           if (isPalindrome(i)) {\n               if (i % 2 == 0) {\n                   ++even_count;\n               } else {\n                   ++odd_count;\n               }\n           }\n       }\n\n       return {even_count, odd_count};\n   }\n   "}
{"task_id": "CPP/108", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int count_nums(vector<int> n) {\n       int count = 0;\n       for (int number : n) {\n           int sum_of_digits = 0;\n           int abs_number = abs(number);\n           while (abs_number > 0) {\n               int digit = abs_number % 10;\n               if (number < 0) {\n                   digit = -digit;\n               }\n               sum_of_digits += digit;\n               abs_number /= 10;\n           }\n           if (sum_of_digits > 0) {\n               count++;\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isSorted(const vector<int>& arr) {\n    for (int i = 0; i < arr.size() - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> rightShift(vector<int> arr) {\n    if (arr.empty()) return arr;\n    int lastElement = arr.back();\n    arr.pop_back();\n    arr.insert(arr.begin(), lastElement);\n    return arr;\n}\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    if (isSorted(arr)) return true;\n    for (int i = 0; i < arr.size(); ++i) {\n        arr = rightShift(arr);\n        if (isSorted(arr)) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n    \n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd_lst1++;\n        }\n    }\n    \n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even_lst2++;\n        }\n    }\n    \n    // Determine if we can make lst1 all even\n    if (count_odd_lst1 <= count_even_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCounts;\n    \n    // Count occurrences of each letter\n    for (char c : test) {\n        if (c != ' ') {\n            letterCounts[c]++;\n        }\n    }\n    \n    // Determine the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCounts) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Create a map with only the letters having the maximum count\n    map<char, int> result;\n    for (const auto& pair : letterCounts) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   #include<algorithm>\n   #include<unordered_set>\n   using namespace std;\n\n   vector<string> reverse_delete(string s, string c) {\n       // Create a set from characters in c for efficient lookup\n       unordered_set<char> charSet(c.begin(), c.end());\n       \n       // Initialize an empty result string\n       string result = \"\";\n       \n       // Iterate through string s and construct the result string\n       for (char ch : s) {\n           if (charSet.find(ch) == charSet.end()) {\n               result += ch;\n           }\n       }\n       \n       // Check if the result string is a palindrome\n       string reversedResult = result;\n       reverse(reversedResult.begin(), reversedResult.end());\n       \n       // Determine if the result string is a palindrome\n       bool isPalindrome = (result == reversedResult);\n       \n       // Return the result vector\n       return {result, isPalindrome ? \"True\" : \"False\"};\n   }\n   "}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& str : lst) {\n        int count = 0;\n        for (char ch : str) {\n            if ((ch - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        string formatted_string = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(formatted_string);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Edge case: empty vector\n\n    long long min_sum = nums[0]; // Initialize with the first element\n    long long current_sum = nums[0]; // Initialize with the first element\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath> // for ceil function\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    \n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (const auto& cell : row) {\n            if (cell == 1) {\n                water_units++;\n            }\n        }\n        // Calculate the number of times the bucket needs to be lowered\n        total_lowers += ceil((double)water_units / capacity);\n    }\n    \n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint countOnes(int num) {\n    return bitset<32>(num).count();\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n    if (onesA == onesB) {\n        return a < b; // If number of ones is the same, sort by decimal value\n    }\n    return onesA < onesB; // Otherwise, sort by number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z') && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    // Split the string into words\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    // Check each word for the number of consonants\n    for (const string& word : words) {\n        int consonantCount = 0;\n        for (char c : word) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string result = \"\";\n    string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n    \n    for (int i = n - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int count_open_1 = 0, count_close_1 = 0;\n    int count_open_2 = 0, count_close_2 = 0;\n    \n    // Count '(' and ')' in the first string\n    for (char c : lst[0]) {\n        if (c == '(') count_open_1++;\n        if (c == ')') count_close_1++;\n    }\n    \n    // Count '(' and ')' in the second string\n    for (char c : lst[1]) {\n        if (c == '(') count_open_2++;\n        if (c == ')') count_close_2++;\n    }\n    \n    int total_open = count_open_1 + count_open_2;\n    int total_close = count_close_1 + count_close_2;\n    \n    if (total_open == total_close) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements\n    vector<int> max_k(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the k elements in ascending order\n    sort(max_k.begin(), max_k.end());\n    \n    // Step 4: Return the sorted k elements\n    return max_k;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence and collect odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If n is even\n            n = n / 2;\n        } else { // If n is odd\n            n = 3 * n + 1;\n        }\n    }\n    // Add the final 1 to the sequence\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<iomanip>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n    \n    // Check if the date string matches the format \"mm-dd-yyyy\"\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    // Extract month, day, and year from the date string\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n    \n    // Validate the format and extracted values\n    if (dash1 != '-' || dash2 != '-' || ss.fail()) return false;\n    \n    // Validate month\n    if (month < 1 || month > 12) return false;\n    \n    // Validate day based on the month\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            if (day < 1 || day > 31) return false;\n            break;\n        case 4: case 6: case 9: case 11:\n            if (day < 1 || day > 30) return false;\n            break;\n        case 2:\n            if (isLeapYear(year)) {\n                if (day < 1 || day > 29) return false;\n            } else {\n                if (day < 1 || day > 28) return false;\n            }\n            break;\n        default:\n            return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespaces\n    if (txt.find(' ') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        result.push_back(txt.substr(start, end - start));\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start, end - start));\n        return result;\n    }\n    \n    // Count lowercase letters with odd order in the alphabet\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<unordered_map>\n   using namespace std;\n\n   bool is_sorted(vector<int> lst){\n       if (lst.size() <= 1) {\n           return true;\n       }\n\n       unordered_map<int, int> countMap;\n       for (size_t i = 0; i < lst.size() - 1; ++i) {\n           if (lst[i] > lst[i + 1]) {\n               return false;\n           }\n           countMap[lst[i]]++;\n           if (countMap[lst[i]] > 2) {\n               return false;\n           }\n       }\n       // Check the last element\n       countMap[lst.back()]++;\n       if (countMap[lst.back()] > 2) {\n           return false;\n       }\n\n       return true;\n   }\n   "}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart <= intersectionEnd) {\n        int intersectionLength = intersectionEnd - intersectionStart + 1;\n        if (isPrime(intersectionLength)) {\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int prod_signs(vector<int> arr){\n       if (arr.empty()) {\n           return -32768;\n       }\n       int sum_of_magnitudes = 0;\n       int product_of_signs = 1;\n       for (int number : arr) {\n           sum_of_magnitudes += abs(number);\n           if (number == 0) {\n               product_of_signs = 0;\n               break;\n           } else if (number < 0) {\n               product_of_signs *= -1;\n           }\n       }\n       return sum_of_magnitudes * product_of_signs;\n   }\n   "}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> bestPath;\n    bool firstPath = true;\n\n    // Directions for moving in the grid (right, left, down, up)\n    vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    // BFS function to explore paths\n    auto bfs = [&](int startX, int startY) {\n        queue<pair<vector<int>, pair<int, int>>> q;\n        q.push({{grid[startX][startY]}, {startX, startY}});\n\n        while (!q.empty()) {\n            auto current = q.front();\n            q.pop();\n\n            vector<int> currentPath = current.first;\n            int x = current.second.first;\n            int y = current.second.second;\n\n            if (currentPath.size() == k) {\n                if (firstPath || currentPath < bestPath) {\n                    bestPath = currentPath;\n                    firstPath = false;\n                }\n                continue;\n            }\n\n            for (auto dir : directions) {\n                int newX = x + dir.first;\n                int newY = y + dir.second;\n\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                    vector<int> newPath = currentPath;\n                    newPath.push_back(grid[newX][newY]);\n                    q.push({newPath, {newX, newY}});\n                }\n            }\n        }\n    };\n\n    // Start BFS from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            bfs(i, j);\n        }\n    }\n\n    return bestPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result;\n    if (n < 1) return result; // Handle edge case where n is less than 1\n\n    // Initialize the first element\n    result.push_back(3);\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // For even i\n            result.push_back(1 + i / 2);\n        } else {\n            // For odd i\n            int next_value = result[i - 2] + result[i - 3] + (1 + (i + 1) / 2);\n            result.push_back(next_value);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert the integer to a string\n    string numStr = to_string(n);\n    \n    // Initialize product to 1\n    int product = 1;\n    \n    // Flag to check if any odd digit is found\n    bool found_odd = false;\n    \n    // Iterate over each character in the string\n    for (char ch : numStr) {\n        // Convert character to integer\n        int digit = ch - '0';\n        \n        // Check if the digit is odd\n        if (digit % 2 != 0) {\n            // Multiply it to the product\n            product *= digit;\n            // Set the flag to true\n            found_odd = true;\n        }\n    }\n    \n    // If no odd digit was found, set product to 0\n    if (!found_odd) {\n        product = 0;\n    }\n    \n    // Return the product\n    return product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    int depth = 0;\n    \n    for (char ch : str) {\n        if (ch == '[') {\n            s.push(ch);\n        } else if (ch == ']') {\n            if (!s.empty()) {\n                s.pop();\n                depth++;\n                if (depth > 0) {\n                    return true;\n                }\n            } else {\n                // Invalid sequence, but we continue to check for nesting\n                return false;\n            }\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/133", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   int sum_squares(vector<float> lst){\n       int sum = 0;\n       for (float num : lst) {\n           int rounded_num = ceil(num);\n           sum += rounded_num * rounded_num;\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/134", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   bool check_if_last_char_is_a_letter(string txt) {\n       if (txt.empty()) {\n           return false;\n       }\n       char last_char = txt.back();\n       if (!isalpha(last_char)) {\n           return false;\n       }\n       if (txt.size() == 1) {\n           return true;\n       }\n       if (txt[txt.size() - 2] == ' ') {\n           return true;\n       }\n       return false;\n   }\n   "}
{"task_id": "CPP/135", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int can_arrange(vector<int> arr){\n       int largest_index = -1;\n       for (int i = 1; i < arr.size(); ++i) {\n           if (arr[i] < arr[i - 1]) {\n               largest_index = i;\n           }\n       }\n       return largest_index;\n   }\n   "}
{"task_id": "CPP/136", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> largest_smallest_integers(vector<int> lst) {\n       int largest_negative = 0;\n       int smallest_positive = 0;\n       bool found_negative = false;\n       bool found_positive = false;\n\n       for (int num : lst) {\n           if (num < 0) {\n               if (largest_negative == 0 || num > largest_negative) {\n                   largest_negative = num;\n                   found_negative = true;\n               }\n           }\n           if (num > 0) {\n               if (smallest_positive == 0 || num < smallest_positive) {\n                   smallest_positive = num;\n                   found_positive = true;\n               }\n           }\n       }\n\n       if (!found_negative) {\n           largest_negative = 0;\n       }\n       if (!found_positive) {\n           smallest_positive = 0;\n       }\n\n       return {largest_negative, smallest_positive};\n   }\n   "}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/lexical_cast.hpp>\n#include<boost/algorithm/string.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to float\n    auto to_float = [](const boost::any& value) -> float {\n        try {\n            if (value.type() == typeid(int)) {\n                return static_cast<float>(boost::any_cast<int>(value));\n            } else if (value.type() == typeid(float)) {\n                return boost::any_cast<float>(value);\n            } else if (value.type() == typeid(string)) {\n                string str = boost::any_cast<string>(value);\n                boost::replace_all(str, \",\", \".\");\n                return boost::lexical_cast<float>(str);\n            }\n        } catch (const boost::bad_any_cast&) {\n            throw runtime_error(\"Unsupported type\");\n        }\n        throw runtime_error(\"Unsupported type\");\n    };\n\n    // Convert both values to float\n    float float_a = to_float(a);\n    float float_b = to_float(b);\n\n    // Compare the float values\n    if (float_a > float_b) {\n        return a;\n    } else if (float_b > float_a) {\n        return b;\n    } else {\n        return \"None\";\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    if (n % 2 != 0) {\n        return false;\n    }\n    int half_n = n / 2;\n    for (int a = 1; a <= half_n; ++a) {\n        for (int b = 1; b <= half_n; ++b) {\n            for (int c = 1; c <= half_n; ++c) {\n                int d = half_n - a - b - c;\n                if (d > 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text){\n    string result = \"\";\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count <= 2) {\n                result += '_';\n            }\n        } else {\n            if (space_count > 2) {\n                result += '-';\n            }\n            result += ch;\n            space_count = 0;\n        }\n    }\n\n    if (space_count > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    int dot_index = -1;\n\n    // Iterate through the string to count digits and dots\n    for (int i = 0; i < file_name.size(); i++) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n\n    // Check if there are more than three digits or more than one dot\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the string into two parts\n    string before_dot = file_name.substr(0, dot_index);\n    string after_dot = file_name.substr(dot_index + 1);\n\n    // Check if the part before the dot is not empty and starts with a Latin alphabet letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if the part after the dot is one of {'txt', 'exe', 'dll'}\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    // If all conditions are met, return \"Yes\"\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int sum_squares(vector<int> lst) {\n       int sum = 0;\n       for (int i = 0; i < lst.size(); ++i) {\n           if (i % 3 == 0) {\n               lst[i] = lst[i] * lst[i];  // Square the element\n           } else if (i % 4 == 0 && i % 3 != 0) {\n               lst[i] = lst[i] * lst[i] * lst[i];  // Cube the element\n           }\n           sum += lst[i];  // Add the modified element to sum\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/143", "generation": "   #include<stdio.h>\n   #include<string>\n   #include<vector>\n   #include<sstream>\n   #include<cmath>\n   using namespace std;\n\n   bool isPrime(int n) {\n       if (n <= 1) return false;\n       for (int i = 2; i <= sqrt(n); ++i) {\n           if (n % i == 0) return false;\n       }\n       return true;\n   }\n\n   string words_in_sentence(string sentence) {\n       vector<string> words;\n       string word;\n       stringstream ss(sentence);\n       while (ss >> word) {\n           if (isPrime(word.length())) {\n               words.push_back(word);\n           }\n       }\n       string result;\n       for (size_t i = 0; i < words.size(); ++i) {\n           if (i != 0) result += \" \";\n           result += words[i];\n       }\n       return result;\n   }\n   "}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Helper function to parse the fraction\n    auto parseFraction = [](const string& fraction) -> pair<int, int> {\n        size_t pos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, pos));\n        int denominator = stoi(fraction.substr(pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [numerator1, denominator1] = parseFraction(x);\n    auto [numerator2, denominator2] = parseFraction(n);\n\n    // Multiply the fractions\n    int resultNumerator = numerator1 * numerator2;\n    int resultDenominator = denominator1 * denominator2;\n\n    // Check if the result is a whole number\n    return resultNumerator % resultDenominator == 0;\n}\n\n// Example usage\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs (number, sum of digits)\n    vector<pair<int, int>> numsWithSums;\n    for (int num : nums) {\n        numsWithSums.push_back({num, sumOfDigits(num)});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    stable_sort(numsWithSums.begin(), numsWithSums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    // Extract the sorted numbers\n    vector<int> sortedNums;\n    for (const auto& pair : numsWithSums) {\n        sortedNums.push_back(pair.first);\n    }\n\n    return sortedNums;\n}\n"}
{"task_id": "CPP/146", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   int specialFilter(vector<int> nums) {\n       int count = 0;\n       for (int num : nums) {\n           if (num > 10) {\n               string numStr = to_string(abs(num)); // Convert number to string\n               char first_digit = numStr[0];\n               char last_digit = numStr[numStr.size() - 1];\n               if ((first_digit == '1' || first_digit == '3' || first_digit == '5' || first_digit == '7' || first_digit == '9') &&\n                   (last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9')) {\n                   count++;\n               }\n           }\n       }\n       return count;\n   }\n   "}
{"task_id": "CPP/147", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   int get_max_triples(int n) {\n       vector<int> a(n);\n       for (int i = 1; i <= n; ++i) {\n           a[i-1] = i * i - i + 1;\n       }\n       \n       int count = 0;\n       for (int i = 0; i < n-2; ++i) {\n           for (int j = i+1; j < n-1; ++j) {\n               for (int k = j+1; k < n; ++k) {\n                   if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                       ++count;\n                   }\n               }\n           }\n       }\n       \n       return count;\n   }\n   "}
{"task_id": "CPP/148", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   vector<string> bf(string planet1, string planet2) {\n       vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n       vector<string> result;\n\n       // Check if both planets are valid\n       if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n           find(planets.begin(), planets.end(), planet2) == planets.end()) {\n           return result; // Return empty vector if either planet is invalid\n       }\n\n       int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n       int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n       // Ensure index1 is less than index2\n       if (index1 > index2) {\n           swap(index1, index2);\n       }\n\n       // Extract planets between index1 and index2 (exclusive of index2)\n       for (int i = index1 + 1; i < index2; ++i) {\n           result.push_back(planets[i]);\n       }\n\n       return result;\n   }\n   "}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nint x_or_y(int n, int x, int y) {\n    // Handle edge case for numbers less than 2\n    if (n < 2) {\n        return y;\n    }\n    \n    // Check for divisors from 2 to sqrt(n)\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return y; // n is not a prime number\n        }\n    }\n    \n    // If no divisors found, n is a prime number\n    return x;\n}\n\n// Example usage\n"}
{"task_id": "CPP/151", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<vector>\n   using namespace std;\n\n   long long double_the_difference(vector<float> lst) {\n       long long sum = 0;\n       for (float num : lst) {\n           if (num > 0 && floor(num) == num) {  // Check if num is a positive integer\n               int intNum = static_cast<int>(num);\n               if (intNum % 2 != 0) {  // Check if num is odd\n                   sum += intNum * intNum;\n               }\n           }\n       }\n       return sum;\n   }\n   "}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "   #include<stdio.h>\n   #include<vector>\n   #include<string>\n   using namespace std;\n\n   string Strongest_Extension(string class_name, vector<string> extensions) {\n       string strongest_extension = \"\";\n       int max_strength = INT_MIN;\n       \n       for (const string& extension : extensions) {\n           int CAP = 0;\n           int SM = 0;\n           \n           for (char c : extension) {\n               if (isupper(c)) {\n                   CAP++;\n               } else if (islower(c)) {\n                   SM++;\n               }\n           }\n           \n           int strength = CAP - SM;\n           \n           if (strength > max_strength) {\n               max_strength = strength;\n               strongest_extension = extension;\n           }\n       }\n       \n       return class_name + \".\" + strongest_extension;\n   }\n   "}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the second word with itself\n    string concatenated = b + b;\n    \n    // Check if the first word is a substring of the concatenated string\n    return concatenated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "   #include<stdio.h>\n   #include<math.h>\n   #include<string>\n   #include<vector>\n   using namespace std;\n\n   vector<int> even_odd_count(int num) {\n       if (num < 0) {\n           num = abs(num);\n       }\n       string num_str = to_string(num);\n       int even_count = 0;\n       int odd_count = 0;\n       for (char ch : num_str) {\n           int digit = ch - '0';  // Convert character to integer\n           if (digit % 2 == 0) {\n               even_count++;\n           } else {\n               odd_count++;\n           }\n       }\n       return {even_count, odd_count};\n   }\n   "}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<utility>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // List of tuples containing Roman numeral symbols and their corresponding integer values\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the list from the largest to the smallest value\n    for (const auto& pair : roman_map) {\n        int value = pair.first;\n        string symbol = pair.second;\n        \n        // While the number is greater than or equal to the current value\n        while (number >= value) {\n            // Subtract the value from the number\n            number -= value;\n            // Append the corresponding Roman numeral symbol to the result string\n            result += symbol;\n        }\n    }\n    \n    // Convert the result string to lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the hypotenuse\n    float sides[] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Apply the Pythagorean theorem\n    float a_squared = sides[0] * sides[0];\n    float b_squared = sides[1] * sides[1];\n    float c_squared = sides[2] * sides[2];\n    \n    // Check if a^2 + b^2 = c^2\n    return (a_squared + b_squared == c_squared);\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words){\n    string maxWord = \"\";\n    int maxUniqueChars = 0;\n\n    for(const string& word : words){\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if(uniqueCount > maxUniqueChars || (uniqueCount == maxUniqueChars && word < maxWord)){\n            maxUniqueChars = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> eat(int number, int need, int remaining) {\n       int total_needed = number + need;\n       int total_eaten, carrots_left;\n\n       if (total_needed <= remaining) {\n           total_eaten = total_needed;\n           carrots_left = remaining - total_needed;\n       } else {\n           total_eaten = number + remaining;\n           carrots_left = 0;\n       }\n\n       return {total_eaten, carrots_left};\n   }\n   "}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    stack<int> s;\n    s.push(operand[0]);\n\n    for (int i = 0; i < operato.size(); ++i) {\n        int next_operand = operand[i + 1];\n        string op = operato[i];\n\n        if (op == \"+\") {\n            s.push(next_operand);\n        } else if (op == \"-\") {\n            s.push(-next_operand);\n        } else if (op == \"*\") {\n            int prev_operand = s.top();\n            s.pop();\n            s.push(prev_operand * next_operand);\n        } else if (op == \"//\") {\n            int prev_operand = s.top();\n            s.pop();\n            s.push(prev_operand / next_operand);\n        } else if (op == \"**\") {\n            int prev_operand = s.top();\n            s.pop();\n            s.push(pow(prev_operand, next_operand));\n        }\n    }\n\n    int result = 0;\n    while (!s.empty()) {\n        result += s.top();\n        s.pop();\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "   #include<stdio.h>\n   #include<string>\n   using namespace std;\n\n   string solve(string s) {\n       bool hasLetter = false;\n       for (char &c : s) {\n           if (isalpha(c)) {\n               hasLetter = true;\n               if (islower(c)) {\n                   c = toupper(c);\n               } else {\n                   c = tolower(c);\n               }\n           }\n       }\n       if (!hasLetter) {\n           reverse(s.begin(), s.end());\n       }\n       return s;\n   }\n   "}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check if the input string is empty\n    if (text.empty()) {\n        return \"\";\n    }\n\n    // Initialize the MD5 context\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update the MD5 context with the input string\n    MD5_Update(&md5Context, text.c_str(), text.size());\n\n    // Finalize the MD5 context to get the hash\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5_Final(result, &md5Context);\n\n    // Convert the binary hash to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << hex << setw(2) << setfill('0') << (int)result[i];\n    }\n\n    // Return the hexadecimal string\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "   #include<stdio.h>\n   #include<vector>\n   using namespace std;\n\n   vector<int> generate_integers(int a, int b) {\n       if (a > b) {\n           swap(a, b);\n       }\n       vector<int> result;\n       for (int i = a; i <= b; ++i) {\n           if (i == 0 || i == 2 || i == 4 || i == 6 || i == 8) {\n               result.push_back(i);\n           }\n       }\n       return result;\n   }\n   "}
