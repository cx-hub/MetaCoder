{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string cleaned_string;\n    \n    // Step 1.2: Remove all spaces from the input string\n    cleaned_string.reserve(paren_string.size());\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned_string.push_back(c);\n        }\n    }\n    \n    // Step 2.1: Initialize an empty vector to store the extracted groups\n    stack<char> paren_stack;\n    string current_group;\n    \n    // Step 2.2: Traverse the cleaned input string character by character\n    for (char c : cleaned_string) {\n        current_group.push_back(c);\n        \n        if (c == '(') {\n            // Step 2.3: Push each '(' onto the stack\n            paren_stack.push(c);\n        } else if (c == ')') {\n            // Step 2.3: Pop the stack when a ')' is encountered\n            paren_stack.pop();\n            \n            // Step 2.3: If the stack is empty after a ')' is processed, it indicates a balanced group\n            if (paren_stack.empty()) {\n                // Step 2.4: Extract the balanced group and add it to the vector\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n    \n    // Step 3.1: Return the vector containing all the extracted balanced parentheses groups\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Extract the integer part\n    float integer_part = floor(number);\n    \n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    \n    // Return the decimal part\n    return decimal_part;\n}\n\n// Example usage\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        // Handle the edge case where the input vector is empty\n        return 0.0f; // or throw an exception, depending on the requirements\n    }\n\n    // Step 1: Calculate the mean of the dataset\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute differences\n    float absolute_differences_sum = 0.0f;\n    for (float number : numbers) {\n        absolute_differences_sum += abs(number - mean);\n    }\n\n    // Step 3: Compute the Mean Absolute Deviation\n    float mad = absolute_differences_sum / numbers.size();\n\n    // Step 4: Return the result\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    istringstream iss(paren_string);\n    string group;\n\n    while (iss >> group) {\n        int current_level = 0;\n        int max_level = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_level++;\n                max_level = max(max_level, current_level);\n            } else if (ch == ')') {\n                current_level--;\n            }\n        }\n\n        result.push_back(max_level);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    \n    // Input validation\n    if (strings.empty() || substring.empty()) {\n        return result;\n    }\n    \n    // String matching and filtering\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Input Validation\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Sum Calculation\n    int sum = 0;\n    for (int num : numbers) {\n        sum += num;\n    }\n\n    // Product Calculation\n    int product = 1;\n    for (int num : numbers) {\n        product *= num;\n    }\n\n    // Result Packaging\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring find_longest_palindromic_suffix(string str) {\n    // Find the longest suffix of str that is a palindrome\n    for (int i = 0; i < str.length(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            return suffix;\n        }\n    }\n    return \"\";\n}\n\nstring make_palindrome(string str) {\n    // Find the shortest palindrome that begins with the supplied string\n    string longest_palindromic_suffix = find_longest_palindromic_suffix(str);\n    string prefix = str.substr(0, str.length() - longest_palindromic_suffix.length());\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\n#include <stdexcept>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Input validation\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must be of the same length.\");\n    }\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input strings must contain only '0's and '1's.\");\n        }\n    }\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input strings must contain only '0's and '1's.\");\n        }\n    }\n\n    // Binary XOR operation\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        char xor_result = (a[i] == b[i]) ? '0' : '1';\n        result += xor_result;\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\";\n    }\n\n    string longest_string = strings[0];\n    int max_length = strings[0].length();\n\n    for (const string& str : strings) {\n        if (str.length() > max_length) {\n            longest_string = str;\n            max_length = str.length();\n        }\n    }\n\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b) {\n    // Handle edge cases where one of the inputs is zero\n    if (a == 0) return b;\n    if (b == 0) return a;\n    \n    // Ensure a is the larger number for the Euclidean Algorithm\n    if (a < b) {\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n    \n    // Implement the Euclidean Algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    \n    return a;\n}\n\n// Test cases\n"}
{"task_id": "CPP/14", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {};\n    }\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n#include <sstream>\n#include <vector>\n\nstd::string string_sequence(int n) {\n    // Step 1: Generate the sequence of numbers\n    std::vector<int> numbers;\n    for (int i = 0; i <= n; ++i) {\n        numbers.push_back(i);\n    }\n\n    // Step 2: Convert numbers to strings and concatenate with spaces\n    std::ostringstream result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result << numbers[i];\n        if (i < numbers.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    // Step 3: Return the concatenated string\n    return result.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nint count_distinct_characters(std::string str) {\n    // Normalize the string to lowercase\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use an unordered_set to track distinct characters\n    std::unordered_set<char> distinct_chars;\n    \n    // Iterate through the string and add characters to the set\n    for (char ch : str) {\n        distinct_chars.insert(ch);\n    }\n    \n    // Return the number of distinct characters\n    return distinct_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string current_note = \"\";\n\n    for (char c : music_string) {\n        if (c == ' ') {\n            // Process the current note\n            if (current_note == \"o\") {\n                beats.push_back(4);\n            } else if (current_note == \"o|\") {\n                beats.push_back(2);\n            } else if (current_note == \".|\") {\n                beats.push_back(1);\n            }\n            // Reset current_note\n            current_note = \"\";\n        } else {\n            // Accumulate characters for the current note\n            current_note += c;\n        }\n    }\n\n    // Process the last note if the string does not end with a space\n    if (!current_note.empty()) {\n        if (current_note == \"o\") {\n            beats.push_back(4);\n        } else if (current_note == \"o|\") {\n            beats.push_back(2);\n        } else if (current_note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i <= str.length() - substring.length(); i++) {\n        if (str.substr(i, substring.length()) == substring) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 3: Mapping Words to Numbers\n    map<string, int> wordToNum = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 5: Mapping Numbers Back to Words\n    map<int, string> numToWord = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Step 2: Tokenization\n    vector<string> tokens;\n    stringstream ss(numbers);\n    string token;\n    while (ss >> token) {\n        tokens.push_back(token);\n    }\n\n    // Step 4: Sorting\n    vector<int> nums;\n    for (const string& word : tokens) {\n        if (wordToNum.find(word) != wordToNum.end()) {\n            nums.push_back(wordToNum[word]);\n        }\n    }\n    sort(nums.begin(), nums.end());\n\n    // Step 6: Output Generation\n    vector<string> sortedWords;\n    for (int num : nums) {\n        sortedWords.push_back(numToWord[num]);\n    }\n\n    string result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        result += sortedWords[i];\n        if (i < sortedWords.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.size() < 2) {\n        // Handle the error, e.g., return an empty vector or throw an exception\n        return {};\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(numbers.begin(), numbers.end());\n\n    // Step 3: Finding the Closest Pair\n    std::vector<float> closest_pair = {numbers[0], numbers[1]};\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    // Step 4: Returning the Result\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Input vector must have at least two elements.\");\n    }\n\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n\n    if (min_value == max_value) {\n        return vector<float>(numbers.size(), 0.0);\n    }\n\n    vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\n    for (float number : numbers) {\n        rescaled_numbers.push_back((number - min_value) / (max_value - min_value));\n    }\n\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    if (str.empty()) {\n        return 0;\n    }\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    int max_divisor = 1; // Initialize with the smallest possible divisor\n    for (int i = 1; i < n; i++) {\n        if (n % i == 0) {\n            max_divisor = i; // Update max_divisor if a larger divisor is found\n        }\n    }\n    return max_divisor;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Input validation\n    if (n <= 0) {\n        // Handle error, e.g., return an empty vector\n        return factors;\n    }\n    \n    // Prime factorization\n    int divisor = 2;\n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Track occurrences of each element\n    unordered_map<int, int> count_map;\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Step 2: Filter unique elements\n    vector<int> result;\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 3: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char& c : str) {\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool starts_with(const string& str, const string& prefix) {\n    if (prefix.size() > str.size()) return false;\n    return str.compare(0, prefix.size(), prefix) == 0;\n}\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    if (prefix.empty()) return strings;\n\n    vector<string> result;\n    for (const string& str : strings) {\n        if (starts_with(str, prefix)) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    if (l.empty()) {\n        return vector<float>();\n    }\n\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    // Step 1: Input validation\n    if (n < 2) {\n        return false;\n    }\n    \n    // Step 2: Handle the special case for n == 2\n    if (n == 2) {\n        return true;\n    }\n    \n    // Step 3: Prime check loop\n    for (long long i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    \n    // Step 4: If no divisors found, return true\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += xs[i] * i * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    double max_coeff = 0;\n    for (double coeff : xs) {\n        if (abs(coeff) > max_coeff) {\n            max_coeff = abs(coeff);\n        }\n    }\n    if (max_coeff == 0) {\n        throw invalid_argument(\"The largest non-zero coefficient must be non-zero.\");\n    }\n\n    // Newton-Raphson Method\n    double x0 = 0; // Initial guess\n    double tolerance = 1e-7;\n    double x1;\n    do {\n        x1 = x0 - poly(xs, x0) / derivative(xs, x0);\n        if (abs(x1 - x0) < tolerance) {\n            break;\n        }\n        x0 = x1;\n    } while (true);\n\n    return x1;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> values_to_sort;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {  // Indices are 1-based and divisible by 3\n            values_to_sort.push_back(l[i]);\n        }\n    }\n\n    sort(values_to_sort.begin(), values_to_sort.end());\n\n    vector<int> l_prime(l.size());\n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l_prime[i] = values_to_sort[sort_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 3: Remove duplicates by converting to a set\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Step 4: Convert back to vector and sort\n    vector<int> sortedUniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 5: Return the sorted unique vector\n    return sortedUniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            int count7 = 0;\n            for (char digit : numStr) {\n                if (digit == '7') {\n                    count7++;\n                }\n            }\n            totalCount += count7;\n        }\n    }\n    \n    return totalCount;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Step 1: Input Validation\n    if (l.empty()) {\n        return {};\n    }\n\n    // Step 2: Extract and Sort Values at Even Indices\n    vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n    sort(even_values.begin(), even_values.end());\n\n    // Step 3: Construct the Output Vector l'\n    vector<float> l_prime(l.size());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime[i] = even_values[even_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Step 4: Return the Output Vector l'\n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int number);\n\nint prime_fib(int n) {\n    if (n == 1) return 2;\n    if (n == 2) return 3;\n\n    int current_fib = 1;\n    int previous_fib = 0;\n    int prime_count = 0;\n\n    while (true) {\n        int next_fib = current_fib + previous_fib;\n        previous_fib = current_fib;\n        current_fib = next_fib;\n\n        if (is_prime(current_fib)) {\n            prime_count++;\n            if (prime_count == n) {\n                return current_fib;\n            }\n        }\n    }\n}\n\nbool is_prime(int number) {\n    if (number <= 1) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    for (int i = 3; i * i <= number; i += 2) {\n        if (number % i == 0) return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Step 1: Input Validation\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Step 2: Triple Combination Generation\n    for (int i = 0; i < l.size() - 2; ++i) {\n        for (int j = i + 1; j < l.size() - 1; ++j) {\n            for (int k = j + 1; k < l.size(); ++k) {\n                // Step 3: Sum Calculation and Comparison\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // Step 4: Result Determination\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Calculate the number of collisions\n    int collisions = n * n;\n    \n    // Return the number of collisions\n    return collisions;\n}\n\n// Example usage\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(const vector<int>& input_vector) {\n    vector<int> result_vector;\n    for (int element : input_vector) {\n        result_vector.push_back(element + 1);\n    }\n    return result_vector;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <string>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Input validation\n    if (base >= 10) {\n        throw invalid_argument(\"Base must be less than 10.\");\n    }\n\n    // Edge case: if x is 0, return \"0\"\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Base conversion logic\n    string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result += to_string(remainder);\n        x /= base;\n    }\n\n    // Reverse the result string to get the correct order\n    reverse(result.begin(), result.end());\n\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nfloat triangle_area(float base, float height) {\n    // Input Validation\n    if (base <= 0 || height <= 0) {\n        cerr << \"Error: Base and height must be positive numbers.\" << endl;\n        return -1; // Return an error code\n    }\n    \n    // Area Calculation\n    float area = 0.5 * base * height;\n    \n    // Return the Result\n    return area;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\n\nint fib4(int n) {\n    if (n < 0) {\n        // Handle negative input (optional: return -1 or throw an exception)\n        return -1;\n    }\n\n    if (n < 4) {\n        // Return precomputed values for n < 4\n        int precomputed[] = {0, 0, 2, 0};\n        return precomputed[n];\n    }\n\n    int fib4_values[4] = {0, 0, 2, 0}; // Initialize the first four values\n    int result = 0;\n\n    for (int i = 4; i <= n; i++) {\n        result = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        // Shift the values to the left\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = result;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    sort(l.begin(), l.end());\n\n    size_t n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true;\n    }\n    string reversed_text = text;\n    reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function for Exponentiation by Squaring\nlong long power(long long base, int exp, int mod) {\n    if (exp == 0) return 1;\n    long long half = power(base, exp / 2, mod);\n    long long result = (half * half) % mod;\n    if (exp % 2 == 1) result = (result * base) % mod;\n    return result;\n}\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    return power(2, n, p);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the set of vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Result string to store non-vowel characters\n    string result = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : text) {\n        // If the character is not a vowel, append it to the result string\n        if (vowels.find(c) == vowels.end()) {\n            result += c;\n        }\n    }\n    \n    // Return the result string\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    if (l.empty()) return true;\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n#include <stdlib.h>\n\n// Function to add two integers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Edge case: If either string is empty, return false unless both are empty\n    if (s0.empty() || s1.empty()) {\n        return s0.empty() && s1.empty();\n    }\n\n    // Create hash maps to count character frequencies\n    unordered_map<char, int> freq0, freq1;\n\n    // Populate the first hash map with character frequencies from s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n\n    // Populate the second hash map with character frequencies from s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n\n    // Compare the two hash maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdexcept>\n\nint fib(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    \n    int a = 0;\n    int b = 1;\n    int result = 0;\n    \n    for (int i = 2; i <= n; ++i) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] < l[i - 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] > l[i - 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Input Validation\n    if (l1.empty() || l2.empty()) {\n        return {};\n    }\n\n    // Step 2: Identify Common Elements\n    set<int> set1(l1.begin(), l1.end());\n    vector<int> result;\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 3: Remove Duplicates\n    set<int> unique_result(result.begin(), result.end());\n    result.assign(unique_result.begin(), unique_result.end());\n\n    // Step 4: Sort the Result\n    sort(result.begin(), result.end());\n\n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int factor = 2;\n\n    while (n > 1) {\n        if (n % factor == 0) {\n            largest_factor = factor;\n            while (n % factor == 0) {\n                n /= factor;\n            }\n        }\n        factor++;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\n// Function to calculate the sum of integers from 1 to n\nint sum_to_n(int n) {\n    // Step 1: Input Validation\n    if (n <= 0) {\n        // Handle invalid input (e.g., return -1)\n        return -1;\n    }\n\n    // Step 2: Sum Calculation using the formula\n    int sum = n * (n + 1) / 2;\n\n    // Step 3: Return the result\n    return sum;\n}\n\n// Main function to test the sum_to_n function\n"}
{"task_id": "CPP/61", "generation": "#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If balance goes negative, there's an unmatched closing bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If balance is zero, all brackets are matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Input validation\n    if (xs.empty() || xs.size() == 1) {\n        return {};\n    }\n\n    // Derivative calculation\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n\n    // Output construction\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize variables for iterative computation\n    int a = 0, b = 0, c = 1;\n    int result = 0;\n\n    // Iterate from 3 to n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c;\n        a = b;\n        b = c;\n        c = result;\n    }\n\n    // Return the result\n    return result;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint vowels_count(string s) {\n    // Define the set of vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    \n    // Initialize the count of vowels\n    int count = 0;\n    \n    // Iterate through the string\n    for (int i = 0; i < s.length(); ++i) {\n        char c = tolower(s[i]); // Convert character to lowercase for case-insensitive comparison\n        \n        // Check if the character is a vowel\n        if (vowels.find(c) != vowels.end()) {\n            count++;\n        }\n        \n        // Special case for 'y' at the end of the word\n        if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    \n    // Return the count of vowels\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm> // for reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Step 1: Convert the integer to a string\n    string str_x = to_string(x);\n    \n    // Step 2: Calculate the number of digits\n    int num_digits = str_x.length();\n    \n    // Step 3: Handle edge cases\n    if (shift >= num_digits) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Step 4: Perform the circular shift\n    int effective_shift = shift % num_digits;\n    string shifted_part = str_x.substr(num_digits - effective_shift);\n    string remaining_part = str_x.substr(0, num_digits - effective_shift);\n    string result = shifted_part + remaining_part;\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Step 1: Parse the input string to extract the number of apples and oranges\n    size_t pos_apples = s.find(\"apples\");\n    size_t pos_oranges = s.find(\"oranges\");\n    \n    string apples_str = s.substr(0, pos_apples - 1);\n    string oranges_str = s.substr(pos_apples + 7, pos_oranges - (pos_apples + 7) - 1);\n    \n    // Step 2: Convert the extracted strings to integers\n    int number_of_apples = stoi(apples_str);\n    int number_of_oranges = stoi(oranges_str);\n    \n    // Step 3: Calculate the number of mangoes\n    int number_of_mangoes = n - number_of_apples - number_of_oranges;\n    \n    // Step 4: Return the result\n    return number_of_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits.h>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallestEven = INT_MAX;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallestEven || (arr[i] == smallestEven && i < smallestIndex)) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestIndex == -1) {\n        return {};\n    }\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 2: Frequency Calculation\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Step 3: Filter and Validate\n    std::vector<int> validIntegers;\n    for (const auto& pair : frequencyMap) {\n        if (pair.second >= pair.first) {\n            validIntegers.push_back(pair.first);\n        }\n    }\n\n    // Step 4: Determine the Greatest Valid Integer\n    if (validIntegers.empty()) {\n        return -1; // Step 5: Return -1 if no valid integer is found\n    }\n\n    int maxValidInteger = *std::max_element(validIntegers.begin(), validIntegers.end());\n    return maxValidInteger; // Step 5: Return the greatest valid integer\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Sort the input vector\n    sort(lst.begin(), lst.end());\n    \n    // Step 2: Initialize result vector and pointers\n    vector<int> result;\n    int start = 0;\n    int end = lst.size() - 1;\n    \n    // Step 3: Alternating extraction\n    while (start <= end) {\n        if (start <= end) {\n            result.push_back(lst[start]);\n            start++;\n        }\n        if (start <= end) {\n            result.push_back(lst[end]);\n            end--;\n        }\n    }\n    \n    // Step 4: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool is_valid_triangle(float a, float b, float c) {\n    return (a + b > c) && (a + c > b) && (b + c > a);\n}\n\nfloat calculate_area(float a, float b, float c) {\n    float s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\nfloat triangle_area(float a, float b, float c) {\n    if (!is_valid_triangle(a, b, c)) {\n        return -1;\n    }\n    float area = calculate_area(a, b, c);\n    return round(area * 100) / 100; // Round to 2 decimal places\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // for std::accumulate\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\n// Helper function to check if the vector is palindromic\nbool is_palindromic(vector<int> q) {\n    vector<int> reversed_q = q;\n    reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n\n// Helper function to calculate the sum of elements in the vector\nint sum_of_elements(vector<int> q) {\n    return accumulate(q.begin(), q.end(), 0);\n}\n\n// Main function to determine if the object will fly\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    bool is_balanced = is_palindromic(q);\n    \n    // Calculate the sum of the vector elements\n    int sum = sum_of_elements(q);\n    \n    // Check if the sum is less than or equal to the maximum weight\n    bool can_fly = (sum <= w);\n    \n    // Return true if both conditions are satisfied\n    return is_balanced && can_fly;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    // Initialize pointers and mismatch counter\n    int left = 0;\n    int right = arr.size() - 1;\n    int mismatch_count = 0;\n\n    // Loop to compare elements from both ends\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            mismatch_count++;\n        }\n        left++;\n        right--;\n    }\n\n    // Return the number of mismatches\n    return mismatch_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate the total number of characters in a vector of strings\nint calculate_total_chars(const vector<string>& lst) {\n    int total_chars = 0;\n    for (const string& str : lst) {\n        total_chars += str.length();\n    }\n    return total_chars;\n}\n\n// Main function to compare two vectors of strings based on total number of characters\nvector<string> total_match(const vector<string>& lst1, const vector<string>& lst2) {\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n    \n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else if (total_chars_lst2 < total_chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\n// Function to generate primes less than 100 using Sieve of Eratosthenes\nstd::vector<int> generatePrimes() {\n    std::vector<bool> isPrime(100, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < 100; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < 100; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime[i]) primes.push_back(i);\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of exactly three primes\nbool is_multiply_prime(int a) {\n    if (a < 8) return false; // Smallest product of three primes is 30\n    \n    std::vector<int> primes = generatePrimes();\n    std::vector<int> factors;\n    \n    for (int prime : primes) {\n        while (a % prime == 0) {\n            factors.push_back(prime);\n            a /= prime;\n        }\n    }\n    \n    if (a > 1) return false; // If a is still greater than 1, it means it has a prime factor greater than 100\n    \n    return factors.size() == 3;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool is_simple_power(int x, int n) {\n    // Input validation\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    \n    // Power calculation loop\n    int power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    \n    // If power exceeds x, return false\n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool iscube(int a) {\n    double cube_root = cbrt(a);\n    int int_cube_root = (int)cube_root;\n    return cube_root == int_cube_root;\n}\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nint hex_key(string num) {\n    const set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    int primeCount = 0;\n    \n    for (char c : num) {\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            primeCount++;\n        }\n    }\n    \n    return primeCount;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <string>\n#include <algorithm> // for std::reverse\n\nstd::string decimal_to_binary(int decimal) {\n    // Step 1: Convert decimal to binary\n    std::string binary_str;\n    if (decimal == 0) {\n        binary_str = \"0\";\n    } else {\n        while (decimal > 0) {\n            binary_str += (decimal % 2 == 0) ? '0' : '1';\n            decimal /= 2;\n        }\n        std::reverse(binary_str.begin(), binary_str.end());\n    }\n\n    // Step 2: Format the binary string\n    std::string formatted_str = \"db\" + binary_str + \"db\";\n\n    // Step 3: Return the result\n    return formatted_str;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Step 1: Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Step 2: Iterate through the string\n    for (int i = 0; i < s.length() - 2; i++) {\n        // Step 3: Extract the 3 consecutive characters\n        char char1 = s[i];\n        char char2 = s[i + 1];\n        char char3 = s[i + 2];\n\n        // Step 4: Check if all 3 characters are distinct\n        if (char1 == char2 || char1 == char3 || char2 == char3) {\n            return false; // Found a set of 3 consecutive characters with duplicates\n        }\n    }\n\n    // Step 5: If no duplicates were found, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to convert a single GPA to a letter grade\nstring convert_gpa_to_letter_grade(float gpa) {\n    if (gpa == 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\n// Main function to convert a vector of GPAs to a vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(convert_gpa_to_letter_grade(gpa));\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // Step 2: Determine the range of n-digit numbers\n    int smallest_n_digit = pow(10, n - 1);\n    int largest_n_digit = pow(10, n) - 1;\n    \n    // Step 3: Count numbers starting with '1'\n    int count_starts_with_1 = largest_n_digit / 10 + 1;\n    \n    // Step 4: Count numbers ending with '1'\n    int count_ends_with_1 = (largest_n_digit - smallest_n_digit) / 10 + 1;\n    \n    // Step 5: Adjust for overlap\n    int count_starts_and_ends_with_1 = (n == 1) ? 1 : 0; // Only 1 if n is 1\n    \n    // Step 6: Combine the counts\n    int total_count = count_starts_with_1 + count_ends_with_1 - count_starts_and_ends_with_1;\n    \n    // Step 7: Output the result\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Sum of Digits Calculation\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    // Step 2: Binary Conversion\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary;\n            sum /= 2;\n        }\n    }\n\n    // Step 3: Return the Result\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <string>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    vector<string> parts;\n    stringstream ss(s);\n    string item;\n\n    // Step 1: Split the input string into words and spaces\n    while (getline(ss, item, ' ')) {\n        parts.push_back(item);\n        parts.push_back(\" \"); // Preserve the space\n    }\n    parts.pop_back(); // Remove the last extra space\n\n    // Step 2: Sort the characters of each word\n    for (size_t i = 0; i < parts.size(); ++i) {\n        if (parts[i] != \" \") {\n            sort(parts[i].begin(), parts[i].end());\n        }\n    }\n\n    // Step 3: Reconstruct the output string\n    string result;\n    for (const auto& part : parts) {\n        result += part;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Traverse the nested vector\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    // Sorting\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort columns in descending order\n        }\n        return a[0] < b[0]; // Sort rows in ascending order\n    });\n    \n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first_element = array.front();\n    int last_element = array.back();\n    int sum = first_element + last_element;\n\n    bool ascending = (sum % 2 != 0); // True if sum is odd, False if sum is even\n\n    vector<int> sorted_array = array; // Create a copy\n    if (ascending) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateCharacter(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return 'a' + (c - 'a' + 4) % 26;\n    } else if (c >= 'A' && c <= 'Z') {\n        return 'A' + (c - 'A' + 4) % 26;\n    } else {\n        return c; // Non-alphabet characters remain unchanged\n    }\n}\n\n// Main encryption function\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        result += rotateCharacter(c);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) return -1; // Return -1 to represent None\n\n    int smallest = INT_MAX;\n    int next_smallest = INT_MAX;\n\n    // Find the smallest element\n    for (int num : lst) {\n        if (num < smallest) {\n            smallest = num;\n        }\n    }\n\n    // Find the next smallest element\n    for (int num : lst) {\n        if (num > smallest && num < next_smallest) {\n            next_smallest = num;\n        }\n    }\n\n    // If next_smallest is still INT_MAX, return None\n    return (next_smallest == INT_MAX) ? -1 : next_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nint is_bored(std::string S) {\n    std::vector<std::string> sentences;\n    std::stringstream ss(S);\n    std::string sentence;\n    int boredom_count = 0;\n\n    // Step 3: Split the input string into sentences\n    while (std::getline(ss, sentence, '.')) {\n        sentences.push_back(sentence);\n    }\n\n    // Step 5: Iterate through each sentence\n    for (const auto& s : sentences) {\n        // Step 6: Check if the sentence starts with \"I\"\n        if (s.find(\"I \") == 0 || s == \"I\") {\n            // Step 7: Increment the boredom counter\n            boredom_count++;\n        }\n    }\n\n    // Step 8: Return the boredom counter\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all inputs are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Check if any one of the numbers is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    // If none of the conditions are met, return false\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = message;\n    \n    for (char &ch : encodedMessage) {\n        // Swap case\n        if (islower(ch)) {\n            ch = toupper(ch);\n        } else if (isupper(ch)) {\n            ch = tolower(ch);\n        }\n        \n        // Replace vowels\n        if (ch == 'a' || ch == 'A' || ch == 'e' || ch == 'E' || ch == 'i' || ch == 'I' || ch == 'o' || ch == 'O' || ch == 'u' || ch == 'U') {\n            char base = islower(ch) ? 'a' : 'A';\n            ch = base + (ch - base + 2) % 26;\n        }\n    }\n    \n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to solve the problem\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    \n    // Step 1: Identify prime numbers in the vector\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n    }\n    \n    // Step 2: If no prime found, return 0 (or handle as needed)\n    if (largestPrime == -1) return 0;\n    \n    // Step 3: Calculate the sum of digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<string>\n#include<map>\n#include<cctype>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n    bool first_key = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (first_key) {\n            all_lower = all_of(key.begin(), key.end(), ::islower);\n            all_upper = all_of(key.begin(), key.end(), ::isupper);\n            first_key = false;\n        } else {\n            if (all_lower && !all_of(key.begin(), key.end(), ::islower)) {\n                return false;\n            }\n            if (all_upper && !all_of(key.begin(), key.end(), ::isupper)) {\n                return false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\n\nint multiply(int a, int b) {\n    // Step 1: Extract the unit digit of 'a'\n    int unit_digit_a = abs(a) % 10;\n    \n    // Step 2: Extract the unit digit of 'b'\n    int unit_digit_b = abs(b) % 10;\n    \n    // Step 3: Compute the product of the unit digits\n    int product = unit_digit_a * unit_digit_b;\n    \n    // Step 4: Return the product\n    return product;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\n#include <stdexcept>\n\nint closest_integer(const std::string& value) {\n    // Step 1: Validate Input\n    try {\n        double num = std::stod(value);\n        \n        // Step 2: Calculate the Closest Integer\n        double rounded = std::round(num);\n        \n        // Step 3: Handle Equidistant Values\n        if (std::abs(num - rounded) == 0.5) {\n            rounded = std::copysign(rounded, num);\n        }\n        \n        // Step 4: Return the Result\n        return static_cast<int>(rounded);\n    } catch (const std::invalid_argument&) {\n        throw std::invalid_argument(\"Input string is not a valid number\");\n    } catch (const std::out_of_range&) {\n        throw std::out_of_range(\"Input number is out of range for a double\");\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones_pile;\n    stones_pile.push_back(n);  // First level has n stones\n\n    for (int i = 1; i < n; ++i) {\n        int last_stone_count = stones_pile.back();\n        int next_stone_count = last_stone_count + 2;  // Always add 2 to get the next odd or even number\n        stones_pile.push_back(next_stone_count);\n    }\n\n    return stones_pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string temp;\n    bool inWord = false;\n\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (inWord) {\n                result.push_back(temp);\n                temp.clear();\n                inWord = false;\n            }\n        } else {\n            temp += c;\n            inWord = true;\n        }\n    }\n\n    if (inWord) {\n        result.push_back(temp);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\n\nint choose_num(int x, int y) {\n    // Step 1: Input Validation\n    if (x <= 0 || y <= 0 || x > y) {\n        return -1;\n    }\n\n    // Step 2: Identify the Range\n    int max_even = -1;\n\n    // Step 3: Iterate Through the Range\n    for (int i = x; i <= y; i++) {\n        if (i % 2 == 0) {\n            if (max_even == -1 || i > max_even) {\n                max_even = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    return max_even;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int n, int m) {\n    // Step 1: Input Validation\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Calculate the Average\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Step 3: Round the Average\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Step 4: Convert to Binary\n    std::string binary_representation = std::bitset<32>(rounded_average).to_string();\n    binary_representation = binary_representation.erase(0, binary_representation.find_first_not_of('0'));\n\n    // Step 5: Return the Result\n    return binary_representation;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number contains any even digit\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\n// Main function to filter and sort the vector\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    // Filter out elements with even digits\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the filtered elements\n    sort(result.begin(), result.end());\n    \n    // Return the sorted vector\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter and validate input\n    vector<int> valid_numbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            valid_numbers.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the validated vector\n    sort(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 4: Map digits to corresponding names\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n    for (int num : valid_numbers) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    // Step 5: Handle edge cases (already handled by filtering)\n\n    // Step 6: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = str;\n    reverse(revStr.begin(), revStr.end());\n    return str == revStr;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    // Iterate through each integer in the vector\n    for (int num : n) {\n        // Calculate the sum of digits\n        int digit_sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            digit_sum += temp % 10;\n            temp /= 10;\n        }\n        // If the number is negative, subtract the sum of digits instead of adding\n        if (num < 0) {\n            digit_sum = -digit_sum;\n        }\n        // Compare the digit sum with 0\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    // Return the count of integers with digit sum > 0\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n    \n    int N = arr.size();\n    for (int i = 0; i < N; ++i) {\n        vector<int> rotated_arr(arr.begin() + i, arr.end());\n        rotated_arr.insert(rotated_arr.end(), arr.begin(), arr.begin() + i);\n        \n        if (rotated_arr == sorted_arr) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountLst1 = 0;\n    int evenCountLst2 = 0;\n\n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    // Determine feasibility\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> frequencyMap;\n    map<char, int> resultMap;\n    int maxFrequency = 0;\n\n    // Step 1: Parse the input string to extract individual letters\n    stringstream ss(test);\n    string letter;\n    while (ss >> letter) {\n        for (char c : letter) {\n            // Step 2: Count the frequency of each letter\n            frequencyMap[c]++;\n            // Step 3: Determine the maximum frequency\n            maxFrequency = max(maxFrequency, frequencyMap[c]);\n        }\n    }\n\n    // Step 4: Filter letters by maximum frequency\n    for (const auto& pair : frequencyMap) {\n        if (pair.second == maxFrequency) {\n            resultMap[pair.first] = pair.second;\n        }\n    }\n\n    // Step 5: Handle edge cases (already handled by the logic above)\n\n    // Step 6: Output the result\n    return resultMap;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Step 2.1: Initialize an empty string to store the result of the deletion\n    string result;\n    \n    // Step 2.2: Iterate through each character in s\n    for (char ch : s) {\n        // Step 2.3: Check if the character is present in c\n        if (c.find(ch) == string::npos) {\n            // Step 2.4: If the character is not in c, append it to the result string\n            result += ch;\n        }\n    }\n    \n    // Step 3.1: Reverse the resulting string from the deletion step\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    \n    // Step 3.2: Compare the original string with its reversed version\n    bool is_palindrome = (result == reversed_result);\n    \n    // Step 4.1: Create a vector of strings\n    vector<string> result_vector;\n    \n    // Step 4.2: Add the resulting string from the deletion step as the first element\n    result_vector.push_back(result);\n    \n    // Step 4.3: Add \"True\" or \"False\" based on the palindrome check as the second element\n    result_vector.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    // Step 5.1: Return the vector containing the result string and the palindrome check result\n    return result_vector;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        int odd_count = 0;\n        \n        // Count odd digits in the string\n        for (char ch : str) {\n            if (ch == '1' || ch == '3' || ch == '5' || ch == '7' || ch == '9') {\n                odd_count++;\n            }\n        }\n        \n        // Generate the output string\n        stringstream ss;\n        ss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(ss.str());\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) {\n        return LLONG_MAX; // Return a large value if the vector is empty\n    }\n\n    long long minSum = LLONG_MAX;\n    long long currentSum = 0;\n\n    for (long long num : nums) {\n        currentSum += num;\n        if (currentSum < minSum) {\n            minSum = currentSum;\n        }\n        if (currentSum > 0) {\n            currentSum = 0;\n        }\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n\n    // Iterate over each well (row in the grid)\n    for (const auto& well : grid) {\n        int water_in_well = 0;\n\n        // Calculate the total amount of water in the well\n        for (int unit : well) {\n            water_in_well += unit;\n        }\n\n        // Calculate the number of times the bucket needs to be lowered\n        int lowerings_for_well = (water_in_well + capacity - 1) / capacity; // Integer division rounding up\n        total_lowerings += lowerings_for_well;\n    }\n\n    return total_lowerings;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator function to compare two integers based on the number of ones in their binary representation\nbool compare_by_ones_and_value(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\n// Function to sort the vector based on the number of ones in the binary representation of its elements\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare_by_ones_and_value);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) {\n        return vector<string>();\n    }\n\n    vector<string> words;\n    vector<string> result;\n    string word;\n\n    // Extract words from the string\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    // Count consonants and select words\n    for (const string& w : words) {\n        int consonantCount = 0;\n        for (char c : w) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(w);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Edge case: word length less than 3\n    if (word.length() < 3) return \"\";\n    \n    // Variables to track the last two consonants\n    char last_consonant = '\\0', second_last_consonant = '\\0';\n    \n    // Traverse the word from right to left\n    for (int i = word.length() - 1; i >= 0; --i) {\n        char ch = word[i];\n        \n        if (vowels.find(ch) == vowels.end()) { // Consonant\n            second_last_consonant = last_consonant;\n            last_consonant = ch;\n        } else { // Vowel\n            if (last_consonant != '\\0' && second_last_consonant != '\\0') {\n                return string(1, ch);\n            }\n        }\n    }\n    \n    // No valid vowel found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count open and close parentheses\nvoid count_parens(const string& s, int& open, int& close) {\n    open = close = 0;\n    for (char c : s) {\n        if (c == '(') open++;\n        if (c == ')') close++;\n    }\n}\n\n// Helper function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        if (c == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Count parentheses in both strings\n    int open1, close1, open2, close2;\n    count_parens(lst[0], open1, close1);\n    count_parens(lst[1], open2, close2);\n\n    // Check if total open and close parentheses are equal\n    if (open1 + open2 != close1 + close2) return \"No\";\n\n    // Concatenate the strings in both possible orders and check for balance\n    string concat1 = lst[0] + lst[1];\n    string concat2 = lst[1] + lst[0];\n\n    if (is_balanced(concat1) || is_balanced(concat2)) return \"Yes\";\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Input validation\n    if (k < 0 || k > arr.size()) {\n        return {};\n    }\n\n    // Sort the vector in ascending order\n    sort(arr.begin(), arr.end());\n\n    // Extract the last k elements\n    vector<int> result(arr.end() - k, arr.end());\n\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;  // Initialize sum to 0\n    \n    // Loop through the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        // Check if the index is even\n        if (i % 2 == 0) {\n            // Check if the element at the even index is odd\n            if (lst[i] % 2 != 0) {\n                // Add the odd element to the sum\n                sum += lst[i];\n            }\n        }\n    }\n    \n    // Return the sum of odd elements at even positions\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (arr.empty() || k < 1 || k > arr.size()) {\n        return -1; // or handle error appropriately\n    }\n\n    int sum = 0;\n\n    // Step 2: Extract the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Step 3: Identify elements with at most two digits\n        if (arr[i] < 100) {\n            // Step 4: Sum the valid elements\n            sum += arr[i];\n        }\n    }\n\n    // Step 5: Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add the final 1 to the sequence\n\n    // Filter odd numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <regex>\nusing namespace std;\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    // Step 1: Input Validation\n    if (date.empty()) return false;\n    regex date_format(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n    if (!regex_match(date, date_format)) return false;\n\n    // Step 2: Date Component Extraction\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Step 3: Month Validation\n    if (month < 1 || month > 12) return false;\n\n    // Step 4: Day Validation\n    if (day < 1) return false;\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            if (day > 31) return false;\n            break;\n        case 4: case 6: case 9: case 11:\n            if (day > 30) return false;\n            break;\n        case 2:\n            if (is_leap_year(year)) {\n                if (day > 29) return false;\n            } else {\n                if (day > 28) return false;\n            }\n            break;\n        default:\n            return false;\n    }\n\n    // Step 5: Return the Result\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Step 1: Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n    }\n    // Step 2: Check for commas\n    else if (txt.find(',') != string::npos) {\n        // Split on commas\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt);\n    }\n    // Step 3: Count lowercase letters with odd alphabet order\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 != 0) {\n                count++;\n            }\n        }\n        result.push_back(to_string(count));\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for sorted order\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Check for duplicate elements\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false;\n        }\n    }\n\n    // Both checks passed\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals and check if the length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Calculate the start and end of the intersection\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n    \n    // If intervals do not intersect\n    if (start_intersection > end_intersection) {\n        return \"NO\";\n    }\n    \n    // Calculate the length of the intersection\n    int length_intersection = end_intersection - start_intersection + 1;\n    \n    // Check if the length is prime\n    if (isPrime(length_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n\n    for (int num : arr) {\n        int sign = (num > 0) ? 1 : (num < 0) ? -1 : 0;\n        product_of_signs *= sign;\n        sum_of_magnitudes += abs(num);\n    }\n\n    int result = sum_of_magnitudes * product_of_signs;\n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n    vector<int> current_path;\n\n    // Helper function to generate paths\n    function<void(int, int, int)> generatePaths = [&](int x, int y, int length) {\n        if (length == k) {\n            if (min_path.empty() || lexicographical_compare(current_path.begin(), current_path.end(), min_path.begin(), min_path.end())) {\n                min_path = current_path;\n            }\n            return;\n        }\n\n        // Explore neighbors\n        int dx[] = {0, 0, 1, -1};\n        int dy[] = {1, -1, 0, 0};\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                current_path.push_back(grid[nx][ny]);\n                generatePaths(nx, ny, length + 1);\n                current_path.pop_back();\n            }\n        }\n    };\n\n    // Start generating paths from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            current_path.clear();\n            current_path.push_back(grid[i][j]);\n            generatePaths(i, j, 1);\n        }\n    }\n\n    return min_path;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> memo(1001, -1); // Assuming n will not exceed 1000\n\nint triHelper(int n) {\n    if (n == 1) return 3;\n    if (n % 2 == 0) return 1 + n / 2;\n    if (memo[n] != -1) return memo[n];\n\n    memo[n] = triHelper(n - 1) + triHelper(n - 2) + triHelper(n + 1);\n    return memo[n];\n}\n\nvector<int> generateTribonacciSequence(int n) {\n    vector<int> sequence(n + 1);\n    for (int i = 1; i <= n + 1; ++i) {\n        sequence[i - 1] = triHelper(i);\n    }\n    return sequence;\n}\n\nvector<int> tri(int n) {\n    return generateTribonacciSequence(n);\n}\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10;\n    }\n\n    return hasOddDigit ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    // Step 1: Input Validation\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            return false;\n        }\n    }\n\n    // Step 2: Stack-Based Traversal\n    stack<char> s;\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']') {\n            if (s.empty()) {\n                continue; // Invalid subsequence\n            }\n            s.pop();\n            if (s.size() > 0) {\n                return true; // Nested brackets found\n            }\n        }\n    }\n\n    // Step 3: Final Check\n    return false;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Step 1: Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Step 2: Get the last character\n    char last_char = txt.back();\n\n    // Step 3: Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Step 4: Check if the last character is not part of a word\n    if (txt.size() == 1 || txt[txt.size() - 2] == ' ') {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.size() <= 1) {\n        return -1;\n    }\n\n    // Step 2: Initialize largest_index to -1\n    int largest_index = -1;\n\n    // Step 3: Iterate through the vector\n    for (int i = 1; i < arr.size(); ++i) {\n        // Step 4: Compare current element with the preceding element\n        if (arr[i] < arr[i - 1]) {\n            // Step 5: Update largest_index if condition is met\n            largest_index = i;\n        }\n    }\n\n    // Step 6: Return the result\n    return largest_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Step 1: Identify and convert types\n    float val_a, val_b;\n    bool is_a_string = false, is_b_string = false;\n    string orig_a, orig_b;\n\n    if (a.type() == typeid(int)) {\n        val_a = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val_a = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        is_a_string = true;\n        orig_a = boost::any_cast<string>(a);\n        replace(orig_a.begin(), orig_a.end(), ',', '.');\n        val_a = stof(orig_a);\n    } else {\n        throw invalid_argument(\"Invalid input type for a\");\n    }\n\n    if (b.type() == typeid(int)) {\n        val_b = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val_b = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        is_b_string = true;\n        orig_b = boost::any_cast<string>(b);\n        replace(orig_b.begin(), orig_b.end(), ',', '.');\n        val_b = stof(orig_b);\n    } else {\n        throw invalid_argument(\"Invalid input type for b\");\n    }\n\n    // Step 2: Compare values\n    if (val_a == val_b) {\n        return \"None\";\n    } else if (val_a > val_b) {\n        if (is_a_string) return orig_a;\n        else if (a.type() == typeid(int)) return static_cast<int>(val_a);\n        else return val_a;\n    } else {\n        if (is_b_string) return orig_b;\n        else if (b.type() == typeid(int)) return static_cast<int>(val_b);\n        else return val_b;\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Early return for invalid cases\n    if (n < 8) return false;\n\n    // Iterate through all combinations of four positive even numbers\n    for (int a = 2; a <= n; a += 2) {\n        for (int b = 2; b <= n; b += 2) {\n            for (int c = 2; c <= n; c += 2) {\n                for (int d = 2; d <= n; d += 2) {\n                    if (a + b + c + d == n) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    // No combination found\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long brazilian_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    if (text.empty()) {\n        return text;\n    }\n\n    string result;\n    int consecutive_spaces = 0;\n\n    for (size_t i = 0; i < text.size(); ++i) {\n        if (text[i] == ' ') {\n            if (i > 0 && text[i - 1] != ' ') {\n                result += '_';\n            } else {\n                consecutive_spaces++;\n                if (consecutive_spaces > 2) {\n                    result += '-';\n                    consecutive_spaces = 0; // Reset counter after replacing\n                }\n            }\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces == 1) {\n                    result += '_';\n                } else if (consecutive_spaces > 1) {\n                    result += '-';\n                }\n                consecutive_spaces = 0; // Reset counter after non-space character\n            }\n            result += text[i];\n        }\n    }\n\n    // Handle trailing spaces\n    if (consecutive_spaces == 1) {\n        result += '_';\n    } else if (consecutive_spaces > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    if (file_name.empty()) return \"No\";\n\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || dot_pos != file_name.rfind('.')) return \"No\";\n\n    string before_dot = file_name.substr(0, dot_pos);\n    if (before_dot.empty() || !isalpha(before_dot[0])) return \"No\";\n\n    string after_dot = file_name.substr(dot_pos + 1);\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n            if (digit_count > 3) return \"No\";\n        }\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];  // Square the element\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];  // Cube the element\n        }\n        sum += lst[i];\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split a sentence into words\nvector<string> splitSentence(const string& sentence) {\n    vector<string> words;\n    istringstream stream(sentence);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to filter words by prime length\nstring words_in_sentence(string sentence) {\n    vector<string> words = splitSentence(sentence);\n    vector<string> primeLengthWords;\n    \n    for (const string& word : words) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    ostringstream result;\n    for (size_t i = 0; i < primeLengthWords.size(); ++i) {\n        if (i != 0) result << \" \";\n        result << primeLengthWords[i];\n    }\n    \n    return result.str();\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Step 1: Parse the input strings\n    size_t pos_x = x.find('/');\n    size_t pos_n = n.find('/');\n    \n    int numerator_x = stoi(x.substr(0, pos_x));\n    int denominator_x = stoi(x.substr(pos_x + 1));\n    \n    int numerator_n = stoi(n.substr(0, pos_n));\n    int denominator_n = stoi(n.substr(pos_n + 1));\n    \n    // Step 2: Compute the product of the fractions\n    int new_numerator = numerator_x * numerator_n;\n    int new_denominator = denominator_x * denominator_n;\n    \n    // Step 3: Check if the result is a whole number\n    bool is_whole_number = (new_numerator % new_denominator == 0);\n    \n    // Step 4: Return the result\n    return is_whole_number;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    if (nums.empty()) {\n        return nums;\n    }\n\n    vector<pair<int, int>> num_with_sums;\n    for (int num : nums) {\n        num_with_sums.push_back({num, sum_of_digits(num)});\n    }\n\n    stable_sort(num_with_sums.begin(), num_with_sums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    vector<int> sorted_nums;\n    for (const auto& pair : num_with_sums) {\n        sorted_nums.push_back(pair.first);\n    }\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            // Extract first and last digits\n            int absNum = abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            \n            // Check if both digits are odd\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    // Step 2: Count valid triples\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Step 3: Return the count of valid triples\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nbool isValidPlanet(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) != planets.end();\n}\n\nint getPlanetIndex(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) - planets.begin();\n}\n\nvoid ensureOrder(string& planet1, string& planet2) {\n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n    if (index1 > index2) {\n        swap(planet1, planet2);\n    }\n}\n\nvector<string> collectPlanetsBetween(const string& planet1, const string& planet2) {\n    vector<string> result;\n    int startIndex = getPlanetIndex(planet1);\n    int endIndex = getPlanetIndex(planet2);\n    for (int i = startIndex + 1; i < endIndex; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}\n\nvector<string> bf(string planet1, string planet2) {\n    if (!isValidPlanet(planet1) || !isValidPlanet(planet2)) {\n        return {};\n    }\n    ensureOrder(planet1, planet2);\n    return collectPlanetsBetween(planet1, planet2);\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Ascending order by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath>\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n    \n    for (float num : lst) {\n        // Check if the number is non-negative and an integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                // Calculate the square and add to the sum\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n    \n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Input Validation\n    if (game.size() != guess.size()) {\n        // Handle error: vectors must be of equal length\n        return vector<int>();\n    }\n\n    // Initialize result vector\n    vector<int> result(game.size());\n\n    // Comparison and Difference Calculation\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <string>\n#include <vector>\n#include <cctype>\n#include <climits>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n        for (char c : ext) {\n            if (isupper(c)) CAP++;\n            else if (islower(c)) SM++;\n        }\n        int strength = CAP - SM;\n\n        if (strength > max_strength || (strength == max_strength && ext < strongest_extension)) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Input validation\n    if (a.empty() || b.empty()) return false;\n\n    // Generate all rotations of b\n    string b_rotated = b + b;\n    int b_length = b.length();\n\n    // Check each rotation\n    for (int i = 0; i < b_length; ++i) {\n        string rotation = b_rotated.substr(i, b_length);\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n\n    // No rotation found as a substring\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <cmath> // for abs()\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Handle negative numbers\n    num = abs(num);\n    \n    // Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Extract and classify digits\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n    \n    // Return the result\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Step 1: Define the Roman numeral mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n\n    // Step 2: Initialize the result string\n    string result = \"\";\n\n    // Step 3: Iterate through the mapping and build the Roman numeral\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n\n    // Step 4: Convert the result to lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n\n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::max\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return false;\n    }\n\n    // Step 2: Identify the Hypotenuse\n    float hypotenuse = std::max({a, b, c});\n    float side1, side2;\n    if (hypotenuse == a) {\n        side1 = b;\n        side2 = c;\n    } else if (hypotenuse == b) {\n        side1 = a;\n        side2 = c;\n    } else {\n        side1 = a;\n        side2 = b;\n    }\n\n    // Step 3: Apply the Pythagorean Theorem\n    float square_hypotenuse = hypotenuse * hypotenuse;\n    float square_side1 = side1 * side1;\n    float square_side2 = side2 * side2;\n\n    // Step 4: Return the Result\n    return (square_hypotenuse == square_side1 + square_side2);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to count unique characters in a string\nint count_unique_characters(const string& word) {\n    unordered_set<char> unique_chars(word.begin(), word.end());\n    return unique_chars.size();\n}\n\n// Helper function to compare two strings based on unique character count\nbool compare_strings(const string& str1, const string& str2) {\n    int unique_count1 = count_unique_characters(str1);\n    int unique_count2 = count_unique_characters(str2);\n    \n    if (unique_count1 > unique_count2) {\n        return true;\n    } else if (unique_count1 == unique_count2) {\n        return str1 < str2;\n    } else {\n        return false;\n    }\n}\n\n// Main function to find the word with the maximum number of unique characters\nstring find_max(vector<string> words) {\n    if (words.empty()) return \"\";\n    \n    string max_word = words[0];\n    \n    for (const string& word : words) {\n        if (compare_strings(word, max_word)) {\n            max_word = word;\n        }\n    }\n    \n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Step 1: Input Validation\n    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n        // Handle invalid input (e.g., return an error vector)\n        return {-1, -1}; // Placeholder for error handling\n    }\n\n    // Step 2: Calculate Total Carrots Eaten\n    int totalEaten = number + need;\n\n    // Step 3: Determine Carrots Left\n    int carrotsLeft = 0;\n    if (totalEaten <= remaining) {\n        carrotsLeft = remaining - totalEaten;\n    }\n\n    // Step 4: Handle Insufficient Carrots\n    // If totalEaten > remaining, carrotsLeft is already set to 0\n\n    // Step 5: Return the Result\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<stack>\n#include<stdexcept>\nusing namespace std;\n\nint evaluate_expression(string expression);\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Input Validation\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Invalid input: operator and operand sizes do not match.\");\n    }\n    for (int num : operand) {\n        if (num < 0) {\n            throw invalid_argument(\"Invalid input: operand contains negative integers.\");\n        }\n    }\n    for (string op : operato) {\n        if (op != \"+\" && op != \"-\" && op != \"*\" && op != \"//\" && op != \"**\") {\n            throw invalid_argument(\"Invalid input: operator contains invalid operations.\");\n        }\n    }\n\n    // Step 2: Expression Construction\n    string expression = to_string(operand[0]);\n    for (size_t i = 0; i < operato.size(); ++i) {\n        expression += operato[i] + to_string(operand[i + 1]);\n    }\n\n    // Step 3: Expression Evaluation\n    return evaluate_expression(expression);\n}\n\nint evaluate_expression(string expression) {\n    stack<int> operands;\n    stack<string> operators;\n    string current_number = \"\";\n\n    auto apply_operator = [&]() {\n        string op = operators.top();\n        operators.pop();\n        int b = operands.top();\n        operands.pop();\n        int a = operands.top();\n        operands.pop();\n        if (op == \"+\") operands.push(a + b);\n        else if (op == \"-\") operands.push(a - b);\n        else if (op == \"*\") operands.push(a * b);\n        else if (op == \"//\") operands.push(a / b);\n        else if (op == \"**\") operands.push(pow(a, b));\n    };\n\n    for (char ch : expression) {\n        if (isdigit(ch)) {\n            current_number += ch;\n        } else {\n            if (!current_number.empty()) {\n                operands.push(stoi(current_number));\n                current_number = \"\";\n            }\n            string op(1, ch);\n            while (!operators.empty() && \n                   ((op == \"+\" || op == \"-\") && (operators.top() == \"*\" || operators.top() == \"//\" || operators.top() == \"**\")) ||\n                   ((op == \"*\" || op == \"//\") && (operators.top() == \"**\"))) {\n                apply_operator();\n            }\n            operators.push(op);\n        }\n    }\n    if (!current_number.empty()) {\n        operands.push(stoi(current_number));\n    }\n    while (!operators.empty()) {\n        apply_operator();\n    }\n\n    return operands.top();\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    string result = \"\";\n    bool hasLetters = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetters) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    string md5_string;\n    char buf[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(buf, \"%02x\", result[i]);\n        md5_string += buf;\n    }\n\n    return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Step 1: Input Validation\n    if (a <= 0 || b <= 0) {\n        return {};\n    }\n\n    // Step 2: Range Determination\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n\n    // Step 3: Digit Extraction\n    vector<int> digits;\n    for (int i = min_val; i <= max_val; ++i) {\n        string str_i = to_string(i);\n        for (char c : str_i) {\n            digits.push_back(c - '0'); // Convert char to int\n        }\n    }\n\n    // Step 4: Even Digit Filtering\n    vector<int> even_digits;\n    for (int digit : digits) {\n        if (digit % 2 == 0 && digit < 10) {\n            even_digits.push_back(digit);\n        }\n    }\n\n    // Step 5: Sorting\n    sort(even_digits.begin(), even_digits.end());\n\n    // Step 6: Output\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Input validation\n    if (numbers.empty() || threshold <= 0) {\n        return false;\n    }\n\n    // Pairwise comparison\n    for (size_t i = 0; i < numbers.size(); i++) {\n        for (size_t j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    // No close elements found\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string cleaned_string;\n    \n    // Step 1.2: Remove all spaces from the input string\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned_string += c;\n        }\n    }\n    \n    stack<int> s;\n    string current_group;\n    \n    // Step 2.2: Traverse the cleaned input string character by character\n    for (char c : cleaned_string) {\n        current_group += c;\n        \n        if (c == '(') {\n            // Step 2.3.1: Push each opening parenthesis '(' onto the stack\n            s.push(1);\n        } else if (c == ')') {\n            // Step 2.3.2: When encountering a closing parenthesis ')', pop from the stack\n            if (!s.empty()) {\n                s.pop();\n                if (s.empty()) {\n                    // Step 2.3.3: If a balanced group is found, extract it and add it to the vector\n                    result.push_back(current_group);\n                    current_group.clear();\n                }\n            }\n        }\n    }\n    \n    // Step 3.1: Ensure that the stack is empty after processing the entire string\n    // (This step is implicitly handled by the above logic, assuming balanced input)\n    \n    // Step 4.1: Return the vector containing all the balanced parentheses groups\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Step 1: Extract the integer part\n    float integer_part = floor(number);\n    \n    // Step 2: Calculate the decimal part\n    float decimal_part = number - integer_part;\n    \n    // Step 3: Return the decimal part\n    return decimal_part;\n}\n\n// Example usage\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int current_balance = 0;\n    for (int operation : operations) {\n        current_balance += operation;\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat calculate_mean(const vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f;\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    return sum / numbers.size();\n}\n\nvector<float> calculate_absolute_differences(const vector<float>& numbers, float mean) {\n    vector<float> absolute_differences;\n    for (float number : numbers) {\n        absolute_differences.push_back(abs(number - mean));\n    }\n    return absolute_differences;\n}\n\nfloat calculate_mean_of_absolute_differences(const vector<float>& absolute_differences) {\n    if (absolute_differences.empty()) return 0.0f;\n    float sum = accumulate(absolute_differences.begin(), absolute_differences.end(), 0.0f);\n    return sum / absolute_differences.size();\n}\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float mean = calculate_mean(numbers);\n    vector<float> absolute_differences = calculate_absolute_differences(numbers, mean);\n    return calculate_mean_of_absolute_differences(absolute_differences);\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nvector<string> split_by_spaces(const string& paren_string) {\n    vector<string> groups;\n    istringstream stream(paren_string);\n    string group;\n    while (getline(stream, group, ' ')) {\n        groups.push_back(group);\n    }\n    return groups;\n}\n\nint calculate_max_depth(const string& paren_group) {\n    int max_depth = 0;\n    int current_depth = 0;\n    for (char ch : paren_group) {\n        if (ch == '(') {\n            current_depth++;\n            if (current_depth > max_depth) {\n                max_depth = current_depth;\n            }\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n    return max_depth;\n}\n\nvector<int> parse_nested_parens(const string& paren_string) {\n    vector<string> groups = split_by_spaces(paren_string);\n    vector<int> depths;\n    for (const string& group : groups) {\n        depths.push_back(calculate_max_depth(group));\n    }\n    return depths;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Input Validation\n    if (strings.empty()) {\n        return {};\n    }\n    if (substring.empty()) {\n        return strings;\n    }\n\n    // Result Collection\n    vector<string> result;\n\n    // String Matching\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n\n    // Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Input Validation\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Sum Calculation\n    int sum = 0;\n    for (int num : numbers) {\n        sum += num;\n    }\n\n    // Product Calculation\n    int product = 1;\n    for (int num : numbers) {\n        product *= num;\n    }\n\n    // Result Packaging\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring find_longest_palindromic_suffix(const string& str) {\n    for (size_t i = 0; i < str.size(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            return str.substr(i);\n        }\n    }\n    return \"\";\n}\n\nstring make_palindrome(const string& str) {\n    // Find the longest palindromic suffix of str\n    string longest_suffix = find_longest_palindromic_suffix(str);\n    \n    // Identify the prefix that comes before the longest palindromic suffix\n    string prefix = str.substr(0, str.size() - longest_suffix.size());\n    \n    // Reverse the prefix\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    \n    // Append the reversed prefix to the end of the original string\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Input validation\n    if (a.length() != b.length()) {\n        return \"Error: Input strings must be of the same length.\";\n    }\n    \n    // Result string\n    string result = \"\";\n    \n    // Perform XOR operation\n    for (size_t i = 0; i < a.length(); ++i) {\n        char xor_result = (a[i] - '0') ^ (b[i] - '0') + '0';\n        result += xor_result;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    // Input Validation\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    // Initialization\n    string longest_string = strings[0];\n    size_t max_length = strings[0].length();\n\n    // Iteration and Comparison\n    for (const string& str : strings) {\n        if (str.length() > max_length) {\n            longest_string = str;\n            max_length = str.length();\n        }\n    }\n\n    // Return the Result\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <algorithm> // For std::abs\n\nint greatest_common_divisor(int a, int b) {\n    // Convert negative inputs to positive\n    a = std::abs(a);\n    b = std::abs(b);\n\n    // Handle the case where either a or b is 0\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    // Euclidean Algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {};\n    }\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    // Edge case: if n is 0, return \"0\"\n    if (n == 0) {\n        return \"0\";\n    }\n\n    // Initialize an empty result string\n    string result;\n\n    // Iterate from 0 to n (inclusive)\n    for (int i = 0; i <= n; ++i) {\n        // Convert the current number to a string and append it to the result\n        result += to_string(i);\n        \n        // If this is not the last number, append a space\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    // Return the final concatenated string\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <string>\n#include <set>\n#include <algorithm>\n\nint count_distinct_characters(std::string str) {\n    // Step 1: Normalize the string to lowercase\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Step 2: Create a set to store distinct characters\n    std::set<char> distinct_chars;\n    \n    // Step 3: Populate the set with characters from the normalized string\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // Step 4: Return the size of the set\n    return distinct_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    // Step 1: Input Validation\n    if (music_string.empty()) {\n        return {};\n    }\n\n    // Step 2: Tokenization\n    vector<string> tokens;\n    stringstream ss(music_string);\n    string token;\n    while (ss >> token) {\n        tokens.push_back(token);\n    }\n\n    // Step 3: Mapping Notes to Beats\n    unordered_map<string, int> note_to_beats = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n\n    // Step 4: Conversion to Vector of Integers\n    vector<int> beats;\n    for (const string& note : tokens) {\n        if (note_to_beats.find(note) != note_to_beats.end()) {\n            beats.push_back(note_to_beats[note]);\n        } else {\n            // Handle unexpected tokens (e.g., log an error, skip, or throw an exception)\n            // For now, we'll skip the token\n        }\n    }\n\n    // Step 5: Return the Result\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        ++pos; // Move to the next position to check for overlapping matches\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Step 1: Define the mapping\nmap<string, int> numberMap = {\n    {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n    {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n};\n\n// Step 2: Input validation function\nbool isValidInput(const string& input) {\n    istringstream stream(input);\n    string word;\n    while (stream >> word) {\n        if (numberMap.find(word) == numberMap.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Step 3: Splitting function\nvector<string> splitString(const string& input) {\n    vector<string> words;\n    istringstream stream(input);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Step 4: Sorting function\nvector<string> sortWords(const vector<string>& words) {\n    vector<int> numbers;\n    for (const auto& word : words) {\n        numbers.push_back(numberMap[word]);\n    }\n    sort(numbers.begin(), numbers.end());\n    \n    vector<string> sortedWords;\n    for (const auto& num : numbers) {\n        for (const auto& pair : numberMap) {\n            if (pair.second == num) {\n                sortedWords.push_back(pair.first);\n                break;\n            }\n        }\n    }\n    return sortedWords;\n}\n\n// Step 5: Main function\nstring sort_numbers(string numbers) {\n    if (!isValidInput(numbers)) {\n        return \"Invalid input\";\n    }\n    \n    vector<string> words = splitString(numbers);\n    vector<string> sortedWords = sortWords(words);\n    \n    ostringstream result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        if (i != 0) {\n            result << \" \";\n        }\n        result << sortedWords[i];\n    }\n    \n    return result.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.size() < 2) {\n        return {}; // or throw an exception\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(numbers.begin(), numbers.end());\n\n    // Step 3: Finding the Closest Pair\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i] - numbers[i + 1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    // Step 4: Returning the Result\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Input vector must have at least two elements.\");\n    }\n\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n\n    if (min_value == max_value) {\n        return vector<float>(numbers.size(), 0.0);\n    }\n\n    vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\n    for (float number : numbers) {\n        rescaled_numbers.push_back((number - min_value) / (max_value - min_value));\n    }\n\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    if (str.empty()) {\n        return 0;\n    }\n    \n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    \n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n#include <vector>\n\nint largest_divisor(int n) {\n    // Input validation\n    if (n <= 1) {\n        return 1; // Edge case: n is 1 or less\n    }\n\n    // Finding divisors\n    std::vector<int> divisors;\n    for (int i = 1; i < n; ++i) {\n        if (n % i == 0) {\n            divisors.push_back(i);\n        }\n    }\n\n    // Selecting the largest divisor\n    int max_divisor = 1; // Default to 1 in case no divisors are found\n    for (int divisor : divisors) {\n        if (divisor > max_divisor) {\n            max_divisor = divisor;\n        }\n    }\n\n    return max_divisor;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n\n    for (int p = 2; p <= n; ++p) {\n        while (n % p == 0) {\n            factors.push_back(p);\n            n /= p;\n        }\n    }\n\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Track occurrences of each element\n    unordered_map<int, int> count_map;\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Step 2: Filter unique elements\n    vector<int> result;\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 3: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    \n    for (char c : str) {\n        if (isupper(c)) {\n            result += tolower(c);\n        } else if (islower(c)) {\n            result += toupper(c);\n        } else {\n            result += c;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    \n    if (strings.empty()) {\n        return result; // Return an empty vector if the input vector is empty\n    }\n    \n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            result.push_back(str); // Add the string to the result vector\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    // Input Validation\n    if (l.empty()) {\n        return {}; // Return an empty vector if the input is empty\n    }\n\n    // Iteration and Filtering\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    // Output Construction\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n < 2) return false;\n    if (n == 2) return true;\n    \n    // Check for even numbers greater than 2\n    if (n % 2 == 0) return false;\n    \n    // Check for prime by testing divisibility from 3 to sqrt(n)\n    long long limit = static_cast<long long>(sqrt(n));\n    for (long long i = 3; i <= limit; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    // If no divisors found, n is prime\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    // Find the largest non-zero coefficient\n    double max_coeff = 0;\n    for (double coeff : xs) {\n        if (abs(coeff) > abs(max_coeff)) {\n            max_coeff = coeff;\n        }\n    }\n\n    if (max_coeff == 0) {\n        throw invalid_argument(\"The largest coefficient must be non-zero.\");\n    }\n\n    // Implementing the Bisection Method\n    double a = -100.0; // Arbitrary starting point\n    double b = 100.0;  // Arbitrary ending point\n    double tol = 1e-7; // Tolerance for convergence\n    double c;\n\n    if (poly(xs, a) * poly(xs, b) >= 0) {\n        throw runtime_error(\"The Bisection Method requires f(a) and f(b) to have opposite signs.\");\n    }\n\n    while ((b - a) >= tol) {\n        c = (a + b) / 2;\n        if (poly(xs, c) == 0.0) {\n            break;\n        } else if (poly(xs, c) * poly(xs, a) < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Identify indices divisible by three\n    vector<int> indices;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        indices.push_back(i);\n    }\n\n    // Step 2: Extract values at these indices\n    vector<int> values;\n    for (int index : indices) {\n        values.push_back(l[index]);\n    }\n\n    // Step 3: Sort the extracted values\n    sort(values.begin(), values.end());\n\n    // Step 4: Reconstruct the output vector\n    vector<int> l_prime = l;\n    for (size_t i = 0; i < indices.size(); ++i) {\n        l_prime[indices[i]] = values[i];\n    }\n\n    // Step 5: Return the result\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Remove duplicates using a set\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 3: Sort the vector\n    sort(uniqueVector.begin(), uniqueVector.end());\n    \n    // Step 4: Return the sorted vector\n    return uniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            for (char digit : numStr) {\n                if (digit == '7') {\n                    totalCount++;\n                }\n            }\n        }\n    }\n    \n    return totalCount;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Step 1: Extract values at even indices\n    vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort the extracted values\n    sort(even_values.begin(), even_values.end());\n\n    // Step 3: Construct the output vector\n    vector<float> l_prime(l.size());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime[i] = even_values[even_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Step 4: Return the output vector\n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i * 3 < l; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i * 3 < l; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2; // Special case for the first prime Fibonacci number\n    int a = 1, b = 1;\n    int count = 1; // Start counting from 1 since we already handled the first prime Fibonacci number (2)\n    while (true) {\n        int next_fib = a + b;\n        a = b;\n        b = next_fib;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Step 1: Input Validation\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Step 2: Triple Combination Generation\n    for (int i = 0; i < l.size() - 2; i++) {\n        for (int j = i + 1; j < l.size() - 1; j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                // Step 3: Sum Calculation and Comparison\n                if (l[i] + l[j] + l[k] == 0) {\n                    // Step 4: Result Determination\n                    return true;\n                }\n            }\n        }\n    }\n\n    // Step 4: Result Determination\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Calculate the number of collisions\n    int collisions = n * n;\n    \n    // Return the number of collisions\n    return collisions;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); i++) {\n        int incremented_value = l[i] + 1;\n        result.push_back(incremented_value);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <string>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Step 1: Input Validation\n    if (base < 2 || base > 9) {\n        return \"Invalid base\"; // or throw an exception\n    }\n\n    // Step 2: Handle edge case for x == 0\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Step 3: Initialize variables\n    string result;\n    bool isNegative = x < 0;\n    x = abs(x); // Work with the absolute value of x\n\n    // Step 4: Base Conversion Logic\n    while (x > 0) {\n        int remainder = x % base;\n        result += to_string(remainder); // Append the remainder to the result string\n        x /= base;\n    }\n\n    // Step 5: Reverse the string to get the correct order\n    reverse(result.begin(), result.end());\n\n    // Step 6: Handle negative numbers\n    if (isNegative) {\n        result = \"-\" + result;\n    }\n\n    // Step 7: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nfloat triangle_area(float base, float height) {\n    // Input Validation\n    if (base <= 0 || height <= 0) {\n        cerr << \"Error: Base and height must be positive numbers.\" << endl;\n        return -1; // Return an error code\n    }\n    \n    // Area Calculation\n    float area = 0.5 * base * height;\n    \n    // Return the Result\n    return area;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\n\nint fib4(int n) {\n    // Initial values for the Fib4 sequence\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four values\n    int fib4_0 = 0, fib4_1 = 0, fib4_2 = 2, fib4_3 = 0;\n    int fib4_n;\n\n    // Iteratively compute the Fib4 sequence from the 4th element onwards\n    for (int i = 4; i <= n; i++) {\n        fib4_n = fib4_0 + fib4_1 + fib4_2 + fib4_3;\n        fib4_0 = fib4_1;\n        fib4_1 = fib4_2;\n        fib4_2 = fib4_3;\n        fib4_3 = fib4_n;\n    }\n\n    return fib4_n;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector in ascending order\n    std::sort(l.begin(), l.end());\n    \n    // Determine the size of the vector\n    int n = l.size();\n    \n    // Calculate the median based on the size of the vector\n    if (n % 2 == 1) {\n        // If the size is odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true;\n    }\n    string reversed_text = text;\n    reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <stdexcept>\n\nint modp(int n, int p) {\n    // Input validation\n    if (p <= 0) {\n        throw std::invalid_argument(\"Modulus p must be a positive integer.\");\n    }\n\n    // Edge cases\n    if (n == 0) {\n        return 1;\n    }\n    if (p == 1) {\n        return 0;\n    }\n\n    // Exponentiation by squaring\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i)\n    {\n        if (islower(s[i])) {\n            int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n            out += (char)w;\n        } else if (isupper(s[i])) {\n            int w = ((int)s[i] + 5 - (int)'A') % 26 + (int)'A';   \n            out += (char)w;\n        } else {\n            out += s[i]; // Non-alphabet characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i)\n    {\n        if (islower(s[i])) {\n            int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n            out += (char)w;\n        } else if (isupper(s[i])) {\n            int w = ((int)s[i] - 5 - (int)'A' + 26) % 26 + (int)'A';   \n            out += (char)w;\n        } else {\n            out += s[i]; // Non-alphabet characters remain unchanged\n        }\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    for (char c : text) {\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Step 1: Input Validation\n    if (l.empty()) {\n        return true; // An empty vector satisfies the condition\n    }\n\n    // Step 2: Iteration Over the Vector\n    for (int i = 0; i < l.size(); i++) {\n        // Step 3: Comparison with Threshold\n        if (l[i] >= t) {\n            return false; // If any element is >= t, return false\n        }\n    }\n\n    // Step 4: Result Determination\n    return true; // If all elements are < t, return true\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Step 1: Input Validation\n    if (s0.empty() || s1.empty()) {\n        return s0.empty() && s1.empty();\n    }\n\n    // Step 2: Character Frequency Counting\n    unordered_map<char, int> freq0, freq1;\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    for (char c : s1) {\n        freq1[c]++;\n    }\n\n    // Step 3: Comparison of Character Frequencies\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdexcept>\n\nint fib(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    int a = 0;\n    int b = 1;\n    int result = 0;\n    for (int i = 2; i <= n; ++i) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    // Step 1: Input Validation\n    for (char c : brackets) {\n        if (c != '<' && c != '>') {\n            return false; // Invalid input\n        }\n    }\n\n    // Step 2: Counting and Matching Brackets\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else if (c == '>') {\n            if (s.empty() || s.top() != '<') {\n                return false; // Unmatched closing bracket\n            }\n            s.pop();\n        }\n    }\n\n    // Step 3: Check if all brackets are matched\n    return s.empty();\n}\n\n// Example usage\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.empty()) return false;\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\n\nstd::vector<int> common(std::vector<int> l1, std::vector<int> l2) {\n    // Step 1: Input Validation\n    if (l1.empty() || l2.empty()) {\n        return {};\n    }\n\n    // Step 2: Intersection Calculation\n    std::set<int> set1(l1.begin(), l1.end());\n    std::set<int> resultSet;\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            resultSet.insert(num);\n        }\n    }\n\n    // Step 3: Conversion to Vector\n    std::vector<int> result(resultSet.begin(), resultSet.end());\n\n    // Step 4: Sorting (already sorted since using set)\n\n    // Step 5: Return Result\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int factor = 2;\n\n    while (n > 1) {\n        if (n % factor == 0) {\n            largest_factor = factor;\n            while (n % factor == 0) {\n                n /= factor;\n            }\n        }\n        factor++;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    if (n < 1) {\n        return 0; // Handle cases where n is less than 1\n    }\n    return n * (n + 1) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            count++;\n        } else if (bracket == ')') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all opening brackets are matched\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Check if the input vector is empty\n    if (xs.empty()) {\n        return {};\n    }\n\n    // Initialize the result vector\n    vector<float> result;\n\n    // Loop through the input vector starting from the second element (index 1)\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Compute the derivative coefficient as i * xs[i]\n        result.push_back(i * xs[i]);\n    }\n\n    // Return the result vector containing the coefficients of the derivative polynomial\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <vector>\n#include <iostream>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<int> memo(n + 1, 0);\n    memo[0] = 0;\n    memo[1] = 0;\n    memo[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        memo[i] = memo[i - 1] + memo[i - 2] + memo[i - 3];\n    }\n\n    return memo[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint vowels_count(string s) {\n    // Step 1: Define the set of vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    \n    // Step 2: Initialize the count\n    int count = 0;\n    \n    // Step 3: Iterate through the string\n    for (char c : s) {\n        // Convert character to lowercase for case-insensitive comparison\n        c = tolower(c);\n        \n        // Check if the character is a vowel\n        if (vowels.find(c) != vowels.end()) {\n            count++;\n        }\n    }\n    \n    // Step 4: Check if 'y' is at the end of the word\n    if (!s.empty() && tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    // Step 5: Return the count\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm> // for reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Step 1: Convert the integer to a string\n    string str_x = to_string(x);\n    \n    // Step 2: Calculate the number of digits\n    int num_digits = str_x.length();\n    \n    // Step 3: Handle edge case where shift > number of digits\n    if (shift > num_digits) {\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Step 4: Perform the circular shift\n    int effective_shift = shift % num_digits;\n    string shifted_part = str_x.substr(num_digits - effective_shift);\n    string remaining_part = str_x.substr(0, num_digits - effective_shift);\n    string result = shifted_part + remaining_part;\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n#include <cctype> // for isupper\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += c; // Add the ASCII value of the uppercase character to the sum\n        }\n    }\n\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Step 1: Parse the input string to extract the number of apples and oranges\n    size_t pos_apples = s.find(\"apples\");\n    size_t pos_oranges = s.find(\"oranges\");\n    \n    string apples_str = s.substr(0, pos_apples - 1);\n    string oranges_str = s.substr(pos_apples + 7, pos_oranges - (pos_apples + 7) - 1);\n    \n    // Step 2: Convert the extracted strings to integers\n    int number_of_apples = stoi(apples_str);\n    int number_of_oranges = stoi(oranges_str);\n    \n    // Step 3: Calculate the number of mangoes\n    int number_of_mangoes = n - number_of_apples - number_of_oranges;\n    \n    // Step 4: Return the result\n    return number_of_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits.h>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Step 2: Initialization\n    int smallestEven = INT_MAX;\n    int smallestIndex = -1;\n\n    // Step 3: Iterate Through the Vector\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallestEven || (arr[i] == smallestEven && i < smallestIndex)) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    if (smallestIndex == -1) {\n        return {};\n    } else {\n        return {smallestEven, smallestIndex};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 2: Frequency Counting\n    unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Step 3: Filter and Validate Integers\n    vector<int> validIntegers;\n    for (const auto& pair : frequencyMap) {\n        if (pair.second >= pair.first) {\n            validIntegers.push_back(pair.first);\n        }\n    }\n\n    // Step 4: Determine the Greatest Valid Integer\n    if (validIntegers.empty()) {\n        return -1;\n    } else {\n        return *max_element(validIntegers.begin(), validIntegers.end());\n    }\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 2: Sorting the Vector\n    sort(lst.begin(), lst.end());\n\n    // Step 3: Alternating Extraction\n    vector<int> result;\n    int i = 0;\n    int j = lst.size() - 1;\n\n    while (i <= j) {\n        result.push_back(lst[i]);\n        if (i != j) {\n            result.push_back(lst[j]);\n        }\n        i++;\n        j--;\n    }\n\n    // Step 4: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (!(a + b > c && a + c > b && b + c > a)) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = std::round(area * 100) / 100;\n\n    return area;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool is_palindromic(vector<int> q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint sum_of_elements(vector<int> q) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum;\n}\n\nbool is_sum_within_limit(int sum, int w) {\n    return sum <= w;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = sum_of_elements(q);\n    return is_palindromic(q) && is_sum_within_limit(sum, w);\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    // Input validation\n    if (arr.size() <= 1) {\n        return 0;\n    }\n\n    // Initialize counters\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    // Iterate through the vector\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    // Return the result\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate the total number of characters in a vector of strings\nint calculate_total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\n// Main function to compare two vectors of strings and return the one with fewer total characters\nvector<string> total_match(const vector<string>& lst1, const vector<string>& lst2) {\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else if (total_chars_lst2 < total_chars_lst1) {\n        return lst2;\n    } else {\n        return lst1; // If both have the same number of characters, return the first vector\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> generate_primes_less_than_100() {\n    std::vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    if (a <= 0) return false;\n\n    std::vector<int> primes = generate_primes_less_than_100();\n    int n = primes.size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool is_simple_power(int x, int n) {\n    // Special case handling\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return n != 0;\n    }\n\n    // Power calculation\n    int power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>  // For cbrt function\n\nbool iscube(int a) {\n    // Compute the cube root of 'a'\n    double cubeRoot = cbrt(a);\n    \n    // Check if the cube root is an integer\n    int intCubeRoot = static_cast<int>(cubeRoot);\n    \n    // Return true if the cube root is an integer, false otherwise\n    return (intCubeRoot * intCubeRoot * intCubeRoot == a);\n}\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nconst unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\";\n\n    string binary_str = \"\";\n    while (decimal > 0) {\n        binary_str = to_string(decimal % 2) + binary_str;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary_str + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Input validation: Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // Extract the three consecutive characters\n        char first = s[i];\n        char second = s[i + 1];\n        char third = s[i + 2];\n\n        // Check if all three characters are distinct\n        if (first == second || first == third || second == third) {\n            return false;\n        }\n    }\n\n    // If no non-distinct sets of 3 consecutive characters were found, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring convert_gpa_to_letter_grade(float gpa) {\n    if (gpa == 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(convert_gpa_to_letter_grade(gpa));\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    return is_prime(str.length());\n}\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n <= 0) {\n        return 0; // Handle invalid input\n    }\n\n    int min_n_digit = std::pow(10, n - 1);\n    int max_n_digit = std::pow(10, n) - 1;\n\n    int count_start_with_1 = min_n_digit;\n    int count_end_with_1 = 9 * std::pow(10, n - 2);\n    int count_start_and_end_with_1 = std::pow(10, n - 2);\n\n    int final_count = count_start_with_1 + count_end_with_1 - count_start_and_end_with_1;\n\n    return final_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    if (N == 0) return \"0\";\n\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    string binary = \"\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Step 1: Split the input string into words using spaces as delimiters\n    istringstream iss(s);\n    vector<string> words;\n    string word;\n    while (iss >> word) {\n        // Step 2: Store the words in a list or vector, preserving the order and the spaces between them\n        words.push_back(word);\n    }\n\n    // Step 3: Iterate through each word in the list\n    for (string& w : words) {\n        // Step 4: For each word, sort the characters in ascending order based on ASCII values\n        sort(w.begin(), w.end());\n    }\n\n    // Step 5: Reconstruct the output string\n    ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            oss << \" \"; // Preserve spaces between words\n        }\n        oss << words[i];\n    }\n\n    // Step 6: Return the reconstructed string as the output\n    return oss.str();\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 2: Initialize a List to Store Coordinates\n    vector<vector<int>> coordinates;\n\n    // Step 3: Iterate Through the Nested Vectors\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Step 4: Sort the List of Coordinates\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1];\n        }\n        return a[0] < b[0];\n    });\n\n    // Step 5: Return the Sorted List\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first_element = array.front();\n    int last_element = array.back();\n    int sum = first_element + last_element;\n\n    bool ascending = (sum % 2 != 0); // True if sum is odd, False if sum is even\n\n    vector<int> sorted_array = array; // Create a copy\n    if (ascending) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\n// Function to map a single character to its rotated counterpart\nchar rotateCharacter(char c) {\n    // Determine if the character is uppercase or lowercase\n    bool isUpper = isupper(c);\n    // Calculate the new character position\n    char base = isUpper ? 'A' : 'a';\n    char rotatedChar = (c - base + 4) % 26 + base;\n    return rotatedChar;\n}\n\n// Main encryption function\nstring encrypt(string s) {\n    string encryptedString = \"\";\n    for (char c : s) {\n        encryptedString += rotateCharacter(c);\n    }\n    return encryptedString;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <limits>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) return -1; // Return -1 to represent None\n\n    int smallest = lst[0];\n    int second_smallest = numeric_limits<int>::max(); // A very large value\n\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < smallest) {\n            second_smallest = smallest;\n            smallest = lst[i];\n        } else if (lst[i] > smallest && lst[i] < second_smallest) {\n            second_smallest = lst[i];\n        }\n    }\n\n    return (second_smallest == numeric_limits<int>::max()) ? -1 : second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Step 1: Input Handling\n    if (S.empty()) return 0;\n\n    // Step 2: Sentence Segmentation\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    while (getline(ss, sentence, '.')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '?')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '!')) {\n        sentences.push_back(sentence);\n    }\n\n    // Step 3: Sentence Classification and Counting Boredoms\n    int boredomCount = 0;\n    for (string& s : sentences) {\n        // Trim leading/trailing whitespace\n        s.erase(0, s.find_first_not_of(' '));\n        s.erase(s.find_last_not_of(' ') + 1);\n\n        // Check if the sentence starts with \"I\"\n        if (!s.empty() && s.substr(0, 1) == \"I\") {\n            boredomCount++;\n        }\n    }\n\n    // Step 4: Output the Result\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (std::floor(a) != a || std::floor(b) != b || std::floor(c) != c) {\n        return false;\n    }\n\n    // Step 2: Sum Calculation and Comparison\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    // Step 3: Return Result\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/93", "generation": "#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    // Initialize an empty string to store the encoded message\n    string encodedMessage = \"\";\n\n    // Loop through each character in the input message\n    for (char& c : message) {\n        // Swap case\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n\n        // Replace vowels\n        if (c == 'a' || c == 'A') c = 'c';\n        else if (c == 'e' || c == 'E') c = 'g';\n        else if (c == 'i' || c == 'I') c = 'k';\n        else if (c == 'o' || c == 'O') c = 'q';\n        else if (c == 'u' || c == 'U') c = 'w';\n\n        // Append the transformed character to the encoded message\n        encodedMessage += c;\n    }\n\n    // Return the final encoded string\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<vector>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0;\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    // Step 1: Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Step 2: Iterate through the map\n    auto it = dict.begin();\n    bool all_lower = std::all_of(it->first.begin(), it->first.end(), ::islower);\n    bool all_upper = std::all_of(it->first.begin(), it->first.end(), ::isupper);\n\n    // Step 3: Check if all keys are strings and match the case\n    for (const auto& pair : dict) {\n        if (!std::all_of(pair.first.begin(), pair.first.end(), ::islower) &&\n            !std::all_of(pair.first.begin(), pair.first.end(), ::isupper)) {\n            return false;\n        }\n        if ((all_lower && !std::all_of(pair.first.begin(), pair.first.end(), ::islower)) ||\n            (all_upper && !std::all_of(pair.first.begin(), pair.first.end(), ::isupper))) {\n            return false;\n        }\n    }\n\n    // Step 4: Return the result\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\n\nint multiply(int a, int b) {\n    // Step 1: Extract the unit digits\n    int unit_digit_a = abs(a) % 10;\n    int unit_digit_b = abs(b) % 10;\n    \n    // Step 2: Compute the product of the unit digits\n    int result = unit_digit_a * unit_digit_b;\n    \n    // Step 3: Return the result\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include<string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\n#include <stdexcept>\n\nint closest_integer(const std::string& value) {\n    // Step 1: Parse the input string to a double\n    double num;\n    try {\n        num = std::stod(value);\n    } catch (const std::invalid_argument&) {\n        throw std::invalid_argument(\"Input is not a valid number\");\n    }\n\n    // Step 2: Check if the number is an integer\n    if (num == static_cast<int>(num)) {\n        return static_cast<int>(num);\n    }\n\n    // Step 3: Calculate the fractional part\n    double fractional_part = num - static_cast<int>(num);\n\n    // Step 4: Implement rounding logic\n    if (fractional_part == 0.5 || fractional_part == -0.5) {\n        // Round away from zero\n        return static_cast<int>(num) + (num > 0 ? 1 : -1);\n    } else {\n        // Normal rounding\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        result.push_back(current_stones);\n        if (current_stones % 2 == 0) {\n            current_stones += 2;\n        } else {\n            current_stones += 2;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string temp;\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!temp.empty()) {\n                words.push_back(temp);\n                temp.clear();\n            }\n        } else {\n            temp += c;\n        }\n    }\n    \n    if (!temp.empty()) {\n        words.push_back(temp);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Input Validation\n    if (x > y) {\n        return -1;\n    }\n\n    // Step 2: Initialize Variables\n    int largest_even = -1;\n\n    // Step 3: Iterate Through the Range\n    for (int i = x; i <= y; i++) {\n        if (i % 2 == 0) {  // Check if i is even\n            if (largest_even == -1 || i > largest_even) {\n                largest_even = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    return largest_even;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Step 1: Input Validation\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Calculate the Average\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Step 3: Round the Average\n    int rounded_average = floor(average);\n\n    // Step 4: Convert to Binary\n    string binary_representation = bitset<32>(rounded_average).to_string();\n    binary_representation = binary_representation.erase(0, binary_representation.find_first_not_of('0'));\n\n    // Step 5: Return the Result\n    return binary_representation;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number contains any even digit\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\n// Main function to filter and sort the vector\nvector<int> unique_digits(vector<int> x) {\n    vector<int> filtered;\n    \n    // Filter out elements with even digits\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            filtered.push_back(num);\n        }\n    }\n    \n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n    \n    // Return the sorted vector\n    return filtered;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter and Validate Input\n    vector<int> valid_numbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            valid_numbers.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the Validated Vector\n    sort(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 3: Reverse the Sorted Vector\n    reverse(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 4: Map Digits to Corresponding Names\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n    for (int num : valid_numbers) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    // Step 5: Handle Edge Cases (already handled by the initial filtering)\n\n    // Step 6: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nint factorial(int i) {\n    int fact = 1;\n    for (int j = 1; j <= i; ++j) {\n        fact *= j;\n    }\n    return fact;\n}\n\nint sum(int i) {\n    int sum = 0;\n    for (int j = 1; j <= i; ++j) {\n        sum += j;\n    }\n    return sum;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sum(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    // Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Loop through each number from 1 to n\n    for (int i = 1; i <= n; ++i) {\n        // Convert number to string\n        string num_str = to_string(i);\n        \n        // Check if the number is a palindrome\n        if (num_str == string(num_str.rbegin(), num_str.rend())) {\n            // Check if the number is even or odd\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    // Return the result as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            digit_sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            digit_sum = -digit_sum;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n\n    int n = arr.size();\n    int break_point = -1;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != sorted_arr[i]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    vector<int> concatenated_arr = arr;\n    concatenated_arr.insert(concatenated_arr.end(), arr.begin(), arr.end());\n\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n        bool is_sorted = true;\n        for (int j = 0; j < n; j++) {\n            if (concatenated_arr[i + j] != sorted_arr[j]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) {\n            found = true;\n            break;\n        }\n    }\n\n    return found;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCount = 0;\n\n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Determine if we can make lst1 all even\n    if (evenCount >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Step 1: Parse the input string\n    vector<string> letters;\n    stringstream ss(test);\n    string letter;\n    while (ss >> letter) {\n        letters.push_back(letter);\n    }\n\n    // Step 2: Count the frequency of each letter\n    map<char, int> frequency_map;\n    for (const string& l : letters) {\n        frequency_map[l[0]]++;\n    }\n\n    // Step 3: Determine the maximum frequency\n    int max_frequency = 0;\n    for (const auto& pair : frequency_map) {\n        if (pair.second > max_frequency) {\n            max_frequency = pair.second;\n        }\n    }\n\n    // Step 4: Filter letters by maximum frequency\n    map<char, int> result_map;\n    for (const auto& pair : frequency_map) {\n        if (pair.second == max_frequency) {\n            result_map[pair.first] = pair.second;\n        }\n    }\n\n    // Step 5: Return the result map\n    return result_map;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Step 1: Initialize result string\n    string result = \"\";\n    \n    // Step 2: Remove characters from s that are in c\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n    \n    // Step 3: Check if the result string is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n    \n    // Step 4: Prepare the output vector\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_odd_digit(char c) {\n    return c == '1' || c == '3' || c == '5' || c == '7' || c == '9';\n}\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        int odd_count = count_if(str.begin(), str.end(), is_odd_digit);\n        string formatted_string = \"the number of odd elements \" + to_string(odd_count) + \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) + \" of the \" + to_string(odd_count) + \"nput.\";\n        result.push_back(formatted_string);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    // Step 1: Input Validation\n    if (nums.empty()) {\n        // Handle empty vector case\n        return 0; // or throw an error\n    }\n\n    // Step 2: Initialization\n    long long minSum = LONG_LONG_MAX;\n\n    // Step 3: Iterate Through the Vector\n    for (int start = 0; start < nums.size(); ++start) {\n        long long currentSum = 0;\n        for (int end = start; end < nums.size(); ++end) {\n            // Step 4: Calculate Sub-Vector Sums\n            currentSum += nums[end];\n            // Step 5: Update Minimum Sum\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n        }\n    }\n\n    // Step 6: Return the Result\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate over each well (row in the grid)\n    for (const auto& well : grid) {\n        int total_water = 0;\n        \n        // Calculate the total water in the well\n        for (int unit : well) {\n            if (unit == 1) {\n                total_water++;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        if (total_water > 0) {\n            total_lowerings += (total_water + capacity - 1) / capacity; // Equivalent to ceil(total_water / capacity)\n        }\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int num) {\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator function\nbool compare_by_ones_and_value(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\n// Main function to sort the array\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare_by_ones_and_value);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nbool isConsonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z') && (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) {\n        return {};\n    }\n\n    vector<string> words;\n    istringstream iss(s);\n    string word;\n\n    while (iss >> word) {\n        int consonantCount = 0;\n        for (char c : word) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            words.push_back(word);\n        }\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define vowels and consonants\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    unordered_set<char> consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'};\n    \n    // Traverse the word from right to left\n    for (int i = word.size() - 1; i > 0; --i) {\n        if (vowels.find(word[i]) != vowels.end()) {\n            // Check if the vowel is between two consonants\n            if (i > 0 && i < word.size() - 1 && consonants.find(word[i - 1]) != consonants.end() && consonants.find(word[i + 1]) != consonants.end()) {\n                return string(1, word[i]);\n            }\n        }\n    }\n    \n    // If no valid vowel is found, return an empty string\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count parentheses\nvoid count_parens(const string& s, int& open, int& close) {\n    open = close = 0;\n    for (char c : s) {\n        if (c == '(') open++;\n        if (c == ')') close++;\n    }\n}\n\n// Helper function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        if (c == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    int open1, close1, open2, close2;\n    count_parens(lst[0], open1, close1);\n    count_parens(lst[1], open2, close2);\n\n    // Check if total open and close parentheses are equal\n    if (open1 + open2 != close1 + close2) return \"No\";\n\n    // Check if any concatenation is balanced\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) return \"Yes\";\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (k < 0 || k > arr.size()) {\n        return {}; // Return an empty vector if k is out of range\n    }\n\n    // Step 2: Sorting the Vector\n    sort(arr.begin(), arr.end());\n\n    // Step 3: Extracting the Top k Elements\n    vector<int> result(arr.end() - k, arr.end());\n\n    // Step 4: Returning the Result\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (arr.empty() || k < 1 || k > arr.size()) {\n        return -1; // or handle error appropriately\n    }\n\n    int sum = 0;\n\n    // Step 2: Extract the first k elements\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n\n        // Step 3: Identify elements with at most two digits\n        if (to_string(num).length() <= 2) {\n            // Step 4: Sum the valid elements\n            sum += num;\n        }\n    }\n\n    // Step 5: Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add the final 1 to the sequence\n\n    // Filter odd numbers\n    for (int term : collatz_sequence) {\n        if (term % 2 != 0) {\n            odd_numbers.push_back(term);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <regex>\nusing namespace std;\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    // Step 1: Check if the input string is empty\n    if (date.empty()) return false;\n\n    // Step 2: Validate the format using regex\n    regex date_format(\"^\\\\d{2}-\\\\d{2}-\\\\d{4}$\");\n    if (!regex_match(date, date_format)) return false;\n\n    // Step 3: Extract month, day, and year\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Step 4: Month Validation\n    if (month < 1 || month > 12) return false;\n\n    // Step 5: Day Validation\n    if (day < 1) return false;\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            if (day > 31) return false;\n            break;\n        case 4: case 6: case 9: case 11:\n            if (day > 30) return false;\n            break;\n        case 2:\n            if (is_leap_year(year)) {\n                if (day > 29) return false;\n            } else {\n                if (day > 28) return false;\n            }\n            break;\n        default:\n            return false;\n    }\n\n    // Step 6: Combine Results\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nstd::vector<std::string> split_words(const std::string& txt) {\n    // Step 1: Check for whitespace\n    if (txt.find(' ') != std::string::npos) {\n        std::istringstream iss(txt);\n        std::vector<std::string> words;\n        std::string word;\n        while (iss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n    \n    // Step 2: Check for commas\n    if (txt.find(',') != std::string::npos) {\n        std::vector<std::string> words;\n        size_t start = 0, end = 0;\n        while ((end = txt.find(',', start)) != std::string::npos) {\n            words.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        words.push_back(txt.substr(start));\n        return words;\n    }\n    \n    // Step 3: Check for only lowercase letters\n    if (std::all_of(txt.begin(), txt.end(), ::islower)) {\n        int count = 0;\n        for (char c : txt) {\n            if ((c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return {std::to_string(count)};\n    }\n    \n    // Default case: return an empty vector if none of the conditions are met\n    return {};\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the vector is sorted in ascending order\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Check for duplicate elements\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false;\n        }\n    }\n\n    // If both checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Check if intervals intersect\n    if (end1 < start2 || end2 < start1) {\n        return \"NO\";\n    }\n    \n    // Calculate intersection interval\n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    // Calculate length of intersection\n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    // Check if length is prime\n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int sum_of_magnitudes = 0;\n\n    for (int num : arr) {\n        int sign = (num > 0) ? 1 : (num < 0) ? -1 : 0;\n        sign_product *= sign;\n        sum_of_magnitudes += abs(num);\n    }\n\n    return sum_of_magnitudes * sign_product;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Path {\npublic:\n    vector<int> values;\n    bool operator<(const Path& other) const {\n        return values < other.values;\n    }\n};\n\nvector<pair<int, int>> getNeighbors(int x, int y, int N) {\n    vector<pair<int, int>> neighbors;\n    if (x > 0) neighbors.push_back({x - 1, y});\n    if (x < N - 1) neighbors.push_back({x + 1, y});\n    if (y > 0) neighbors.push_back({x, y - 1});\n    if (y < N - 1) neighbors.push_back({x, y + 1});\n    return neighbors;\n}\n\nvoid generatePaths(vector<vector<int>>& grid, int k, int x, int y, Path& currentPath, vector<Path>& allPaths) {\n    currentPath.values.push_back(grid[x][y]);\n    if (currentPath.values.size() == k) {\n        allPaths.push_back(currentPath);\n    } else {\n        for (auto& neighbor : getNeighbors(x, y, grid.size())) {\n            generatePaths(grid, k, neighbor.first, neighbor.second, currentPath, allPaths);\n        }\n    }\n    currentPath.values.pop_back();\n}\n\nPath minPath(vector<Path>& allPaths) {\n    Path minPath = allPaths[0];\n    for (const auto& path : allPaths) {\n        if (path < minPath) {\n            minPath = path;\n        }\n    }\n    return minPath;\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<Path> allPaths;\n    int N = grid.size();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            Path currentPath;\n            generatePaths(grid, k, i, j, currentPath, allPaths);\n        }\n    }\n    return minPath(allPaths).values;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n < 1) return {}; // Handle edge case where n is less than 1\n\n    vector<int> sequence(n + 1);\n    sequence[1] = 3; // Base case\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            sequence[i] = 1 + i / 2;\n        } else {\n            // Handle the recursive case for odd i\n            if (i + 1 <= n) {\n                sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1];\n            } else {\n                // If i + 1 is out of bounds, use the even formula for i + 1\n                sequence[i] = sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2);\n            }\n        }\n    }\n\n    return sequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        n /= 10;\n        \n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n    }\n    \n    if (!hasOddDigit) {\n        return 0;\n    }\n    \n    return product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    // Step 1: Input Validation\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            return false;\n        }\n    }\n\n    // Step 2: Identify Valid Subsequences\n    stack<char> s;\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']') {\n            if (!s.empty() && s.top() == '[') {\n                s.pop();\n            }\n        }\n    }\n\n    // If stack is not empty, there are unmatched brackets, so return false\n    if (!s.empty()) {\n        return false;\n    }\n\n    // Step 3: Check for Nested Brackets\n    int depth = 0;\n    for (char c : str) {\n        if (c == '[') {\n            depth++;\n            if (depth > 1) {\n                return true; // Found nested brackets\n            }\n        } else if (c == ']') {\n            depth--;\n        }\n    }\n\n    // No nested brackets found\n    return false;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        int squared_num = rounded_num * rounded_num;\n        sum += squared_num;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Step 1: Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Step 2: Extract the last character\n    char last_char = txt.back();\n\n    // Step 3: Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Step 4: Check if the last character is part of a word\n    size_t last_space_pos = txt.find_last_of(' ');\n    if (last_space_pos < txt.length() - 1) {\n        return true;\n    }\n\n    // Step 5: Return false if the last character is not part of a word\n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.size() <= 1) {\n        return -1;\n    }\n\n    // Step 2: Initialize largest_index to -1\n    int largest_index = -1;\n\n    // Step 3: Iterate through the vector\n    for (int i = 1; i < arr.size(); ++i) {\n        // Step 4: Condition Check\n        if (arr[i] < arr[i - 1]) {\n            // Step 5: Update largest_index if the current index is larger\n            if (i > largest_index) {\n                largest_index = i;\n            }\n        }\n    }\n\n    // Step 6: Return the result\n    return largest_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <stdexcept>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Step 1: Type Identification and Conversion\n    float val_a, val_b;\n    bool is_a_string = false, is_b_string = false;\n    boost::any original_a = a, original_b = b;\n\n    if (a.type() == typeid(int)) {\n        val_a = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val_a = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(std::string)) {\n        is_a_string = true;\n        std::string str_a = boost::any_cast<std::string>(a);\n        std::replace(str_a.begin(), str_a.end(), ',', '.');\n        try {\n            val_a = std::stof(str_a);\n        } catch (const std::invalid_argument&) {\n            throw std::invalid_argument(\"Invalid string representation for input a\");\n        }\n    } else {\n        throw std::invalid_argument(\"Invalid type for input a\");\n    }\n\n    if (b.type() == typeid(int)) {\n        val_b = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val_b = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(std::string)) {\n        is_b_string = true;\n        std::string str_b = boost::any_cast<std::string>(b);\n        std::replace(str_b.begin(), str_b.end(), ',', '.');\n        try {\n            val_b = std::stof(str_b);\n        } catch (const std::invalid_argument&) {\n            throw std::invalid_argument(\"Invalid string representation for input b\");\n        }\n    } else {\n        throw std::invalid_argument(\"Invalid type for input b\");\n    }\n\n    // Step 2: Comparison Logic\n    if (val_a > val_b) {\n        return is_a_string ? original_a : boost::any(val_a);\n    } else if (val_b > val_a) {\n        return is_b_string ? original_b : boost::any(val_b);\n    } else {\n        return std::string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    if (n < 8) {\n        return false;\n    }\n\n    for (int even1 = 2; even1 <= n; even1 += 2) {\n        for (int even2 = 2; even2 <= n - even1; even2 += 2) {\n            for (int even3 = 2; even3 <= n - even1 - even2; even3 += 2) {\n                int even4 = n - (even1 + even2 + even3);\n                if (even4 > 0 && even4 % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(int n) {\n    if (n <= 1) return 1;\n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            if (consecutive_spaces_count == 0) {\n                result += \"_\";\n            } else {\n                consecutive_spaces_count++;\n                if (consecutive_spaces_count == 2) {\n                    result += \"-\";\n                    consecutive_spaces_count = 0;\n                }\n            }\n        } else {\n            result += ch;\n            consecutive_spaces_count = 0;\n        }\n    }\n\n    if (consecutive_spaces_count > 0) {\n        result += \"-\";\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype>\n#include <unordered_set>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Step 1: Input Validation\n    if (file_name.empty()) return \"No\";\n\n    // Step 2: Count Digits\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) digit_count++;\n        if (digit_count > 3) return \"No\";\n    }\n\n    // Step 3: Count Dots\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (c == '.') dot_count++;\n    }\n    if (dot_count != 1) return \"No\";\n\n    // Step 4: Extract and Validate Substring Before the Dot\n    size_t dot_pos = file_name.find('.');\n    string before_dot = file_name.substr(0, dot_pos);\n    if (before_dot.empty() || !isalpha(before_dot[0])) return \"No\";\n\n    // Step 5: Extract and Validate Substring After the Dot\n    string after_dot = file_name.substr(dot_pos + 1);\n    unordered_set<string> allowed_extensions = {\"txt\", \"exe\", \"dll\"};\n    if (allowed_extensions.find(after_dot) == allowed_extensions.end()) return \"No\";\n\n    // Step 6: Return the Result\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        int element = lst[i];\n        if (i % 3 == 0) {\n            element = element * element; // Square the element\n        } else if (i % 4 == 0) {\n            element = element * element * element; // Cube the element\n        }\n        sum += element;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split a string into words\nvector<string> split(const string& sentence) {\n    vector<string> words;\n    istringstream stream(sentence);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Function to join a list of words into a single string\nstring join(const vector<string>& words) {\n    return accumulate(words.begin(), words.end(), string(),\n                      [](const string& a, const string& b) {\n                          return a.empty() ? b : a + \" \" + b;\n                      });\n}\n\n// Main function to process the sentence\nstring words_in_sentence(string sentence) {\n    vector<string> words = split(sentence);\n    vector<string> primeLengthWords;\n    \n    for (const string& word : words) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    return join(primeLengthWords);\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <algorithm>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    // Step 1: Parse the input strings\n    size_t pos1 = x.find('/');\n    size_t pos2 = n.find('/');\n    \n    int num1 = std::stoi(x.substr(0, pos1));\n    int den1 = std::stoi(x.substr(pos1 + 1));\n    \n    int num2 = std::stoi(n.substr(0, pos2));\n    int den2 = std::stoi(n.substr(pos2 + 1));\n    \n    // Step 2: Compute the product of the fractions\n    int num_product = num1 * num2;\n    int den_product = den1 * den2;\n    \n    // Step 3: Simplify the resulting fraction\n    int gcd_value = gcd(num_product, den_product);\n    num_product /= gcd_value;\n    den_product /= gcd_value;\n    \n    // Step 4: Check if the resulting fraction is a whole number\n    bool is_whole_number = (num_product % den_product == 0);\n    \n    // Step 5: Return the result\n    return is_whole_number;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\n// Main function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    if (nums.empty()) return {};\n\n    // Create a vector of pairs (integer, sum of digits)\n    vector<pair<int, int>> num_sum_pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_sum_pairs.push_back({nums[i], sum_of_digits(nums[i])});\n    }\n\n    // Sort the vector of pairs\n    sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.second == b.second) {\n            return &a < &b; // Sort by original index if sums are equal\n        }\n        return a.second < b.second;\n    });\n\n    // Extract the sorted integers\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.first);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = abs(num) % 10;\n            bool isFirstDigitOdd = (firstDigit % 2 != 0);\n            bool isLastDigitOdd = (lastDigit % 2 != 0);\n            if (isFirstDigitOdd && isLastDigitOdd) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    // Step 2: Count valid triples\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Step 3: Return the result\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Step 1: Define the list of valid planets\n    const vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Step 2: Validate input planets\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() ||\n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n    \n    // Step 3: Determine the order of planets\n    int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n    \n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Step 4: Collect planets between the two given planets\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true; // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Other even numbers are not prime\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n    \n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n    \n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    if (game.size() != guess.size()) {\n        return vector<int>(); // Handle error\n    }\n\n    vector<int> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <string>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n        for (char c : ext) {\n            if (isupper(c)) CAP++;\n            else if (islower(c)) SM++;\n        }\n        int strength = CAP - SM;\n\n        if (strength > max_strength || (strength == max_strength && ext < strongest_extension)) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Input validation\n    if (a.empty() || b.empty()) return false;\n\n    // Generate all rotations of b\n    string b_rotated = b + b;\n    int b_len = b.length();\n\n    // Check each rotation\n    for (int i = 0; i < b_len; ++i) {\n        string rotation = b_rotated.substr(i, b_len);\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n\n    // No rotation found as a substring\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <cmath> // for abs()\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Step 1: Handle negative numbers\n    num = abs(num);\n\n    // Step 2: Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Step 3: Extract and classify digits\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    // Step 4: Return the result\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Step 1: Define the Roman Numeral Mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n\n    // Step 2: Initialize the result string\n    string result = \"\";\n\n    // Step 3: Implement the Conversion Logic\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n\n    // Step 4: Convert the Result to Lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n\n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return false;\n    }\n\n    // Step 2: Identify the Hypotenuse\n    float hypotenuse, side1, side2;\n    if (a >= b && a >= c) {\n        hypotenuse = a;\n        side1 = b;\n        side2 = c;\n    } else if (b >= a && b >= c) {\n        hypotenuse = b;\n        side1 = a;\n        side2 = c;\n    } else {\n        hypotenuse = c;\n        side1 = a;\n        side2 = b;\n    }\n\n    // Step 3: Apply the Pythagorean Theorem\n    if (hypotenuse * hypotenuse == side1 * side1 + side2 * side2) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_unique_count = 0;\n    string max_unique_string = \"\";\n    \n    for (const string& word : words) {\n        set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n        \n        if (unique_count > max_unique_count) {\n            max_unique_count = unique_count;\n            max_unique_string = word;\n        } else if (unique_count == max_unique_count) {\n            if (word < max_unique_string) {\n                max_unique_string = word;\n            }\n        }\n    }\n    \n    return max_unique_string;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Input validation\n    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n        return {0, 0}; // Return default values if inputs are invalid\n    }\n\n    // Calculate total carrots eaten\n    int total_eaten = number + need;\n    if (total_eaten > remaining) {\n        total_eaten = remaining;\n    }\n\n    // Calculate remaining carrots\n    int remaining_carrots = remaining - total_eaten;\n\n    // Return the result\n    return {total_eaten, remaining_carrots};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <stdexcept>\n#include <cmath>\n\nusing namespace std;\n\nint evaluateExpression(const string& expression);\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Input Validation\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Invalid input: operator and operand vector lengths do not match.\");\n    }\n    for (int num : operand) {\n        if (num < 0) {\n            throw invalid_argument(\"Invalid input: operand vector contains negative integers.\");\n        }\n    }\n\n    // Step 2: Expression Construction\n    string expression;\n    for (size_t i = 0; i < operato.size(); ++i) {\n        expression += to_string(operand[i]) + \" \" + operato[i] + \" \";\n    }\n    expression += to_string(operand.back());\n\n    // Step 3: Expression Evaluation\n    int result = evaluateExpression(expression);\n\n    // Step 4: Return the Result\n    return result;\n}\n\nint evaluateExpression(const string& expression) {\n    stack<int> operands;\n    stack<string> operators;\n    string token;\n    for (char ch : expression) {\n        if (ch == ' ') {\n            if (!token.empty()) {\n                if (isdigit(token[0])) {\n                    operands.push(stoi(token));\n                } else {\n                    while (!operators.empty() && \n                           (token == \"+\" || token == \"-\") && \n                           (operators.top() == \"*\" || operators.top() == \"/\" || operators.top() == \"**\")) {\n                        int b = operands.top(); operands.pop();\n                        int a = operands.top(); operands.pop();\n                        string op = operators.top(); operators.pop();\n                        if (op == \"+\") operands.push(a + b);\n                        else if (op == \"-\") operands.push(a - b);\n                        else if (op == \"*\") operands.push(a * b);\n                        else if (op == \"/\") operands.push(a / b);\n                        else if (op == \"**\") operands.push(pow(a, b));\n                    }\n                    operators.push(token);\n                }\n                token.clear();\n            }\n        } else {\n            token += ch;\n        }\n    }\n    if (!token.empty()) {\n        operands.push(stoi(token));\n    }\n\n    while (!operators.empty()) {\n        int b = operands.top(); operands.pop();\n        int a = operands.top(); operands.pop();\n        string op = operators.top(); operators.pop();\n        if (op == \"+\") operands.push(a + b);\n        else if (op == \"-\") operands.push(a - b);\n        else if (op == \"*\") operands.push(a * b);\n        else if (op == \"/\") operands.push(a / b);\n        else if (op == \"**\") operands.push(pow(a, b));\n    }\n\n    return operands.top();\n}\n"}
{"task_id": "CPP/161", "generation": "#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring solve(string s) {\n    string modified;\n    bool hasLetters = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            if (islower(c)) {\n                modified += toupper(c);\n            } else {\n                modified += tolower(c);\n            }\n        } else {\n            modified += c;\n        }\n    }\n\n    if (!hasLetters) {\n        reverse(modified.begin(), modified.end());\n    }\n\n    return modified;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Step 1: Input Validation\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    // Step 2: MD5 Hash Calculation\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    // Step 3: Convert to Hexadecimal String\n    char md5string[33];\n    for (int i = 0; i < 16; ++i) {\n        sprintf(&md5string[i*2], \"%02x\", (unsigned int)result[i]);\n    }\n\n    // Step 4: Return the Result\n    return string(md5string);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm> // for sort\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int i = start; i <= end; ++i) {\n        int num = i;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && digit < 10) {\n                even_digits.push_back(digit);\n            }\n            num /= 10;\n        }\n    }\n\n    sort(even_digits.begin(), even_digits.end());\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Step 1: Input Validation\n    if (numbers.empty() || threshold <= 0) {\n        return false;\n    }\n\n    // Step 2: Pairwise Comparison\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true; // Found a pair closer than the threshold\n            }\n        }\n    }\n\n    // Step 3: Result Determination\n    return false; // No pair found closer than the threshold\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string cleaned_string;\n    \n    // Step 1: Input Parsing and Cleaning\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned_string += c;\n        }\n    }\n    \n    // Step 2: Parentheses Group Identification\n    stack<int> s;\n    string current_group;\n    for (char c : cleaned_string) {\n        if (c == '(') {\n            if (s.empty()) {\n                if (!current_group.empty()) {\n                    result.push_back(current_group);\n                    current_group.clear();\n                }\n            }\n            s.push(c);\n        } else if (c == ')') {\n            if (!s.empty() && s.top() == '(') {\n                s.pop();\n                if (s.empty()) {\n                    current_group += c;\n                    result.push_back(current_group);\n                    current_group.clear();\n                } else {\n                    current_group += c;\n                }\n            }\n        }\n        if (!s.empty() && c != ')') {\n            current_group += c;\n        }\n    }\n    \n    // Step 3: Balanced Parentheses Validation (implicit in the stack-based approach)\n    \n    // Step 4: Result Collection (already done during extraction)\n    \n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Step 1: Extract the integer part\n    float integer_part = floor(number);\n    \n    // Step 2: Calculate the decimal part\n    float decimal_part = number - integer_part;\n    \n    // Step 3: Return the decimal part\n    return decimal_part;\n}\n\n// Example usage\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    // Initialize the current balance to 0\n    int current_balance = 0;\n    \n    // Iterate through each operation in the vector\n    for (int operation : operations) {\n        // Update the current balance\n        current_balance += operation;\n        \n        // Check if the balance has fallen below zero\n        if (current_balance < 0) {\n            return true; // Balance fell below zero\n        }\n    }\n    \n    // If the loop completes without the balance falling below zero, return false\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the Mean of the Input Vector\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the Absolute Differences from the Mean\n    vector<float> abs_diffs;\n    for (float num : numbers) {\n        abs_diffs.push_back(abs(num - mean));\n    }\n\n    // Step 3: Calculate the Mean of the Absolute Differences\n    float abs_diffs_sum = accumulate(abs_diffs.begin(), abs_diffs.end(), 0.0f);\n    float mad = abs_diffs_sum / abs_diffs.size();\n\n    // Step 4: Return the Result\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    istringstream iss(paren_string);\n    string group;\n    \n    while (iss >> group) {\n        int current_level = 0;\n        int max_level = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_level++;\n                if (current_level > max_level) {\n                    max_level = current_level;\n                }\n            } else if (c == ')') {\n                current_level--;\n            }\n        }\n        \n        result.push_back(max_level);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    if (strings.empty()) {\n        return {};\n    }\n    if (substring.empty()) {\n        return strings;\n    }\n\n    vector<string> result;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Input Validation\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Sum Calculation\n    int sum = 0;\n    for (int num : numbers) {\n        sum += num;\n    }\n\n    // Product Calculation\n    int product = 1;\n    for (int num : numbers) {\n        product *= num;\n    }\n\n    // Result Packaging\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        current_max = max(current_max, num);\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring find_longest_palindromic_suffix(string str) {\n    for (int i = 0; i < str.length(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            return str.substr(i);\n        }\n    }\n    return \"\";\n}\n\nstring make_palindrome(string str) {\n    // Find the longest palindromic suffix of str\n    string palindromic_suffix = find_longest_palindromic_suffix(str);\n    \n    // Identify the prefix that comes before the palindromic suffix\n    string prefix = str.substr(0, str.length() - palindromic_suffix.length());\n    \n    // Reverse the prefix\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    \n    // Append the reversed prefix to the end of the original string\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\n#include <stdexcept>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Input Validation\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must be of the same length.\");\n    }\n\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input string a contains invalid characters.\");\n        }\n    }\n\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input string b contains invalid characters.\");\n        }\n    }\n\n    // Binary XOR Operation\n    string result;\n    result.reserve(a.length());\n\n    for (size_t i = 0; i < a.length(); ++i) {\n        result.push_back((a[i] - '0') ^ (b[i] - '0') + '0');\n    }\n\n    // Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longest_string = strings[0];\n    size_t max_length = strings[0].length();\n\n    for (const string& str : strings) {\n        if (str.length() > max_length) {\n            longest_string = str;\n            max_length = str.length();\n        }\n    }\n\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <cmath>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure both a and b are non-negative\n    a = std::abs(a);\n    b = std::abs(b);\n\n    // Euclidean Algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {};\n    }\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n#include <sstream>\n\nstd::string string_sequence(int n) {\n    // Step 1: Input Validation\n    if (n < 0) {\n        return \"\"; // or handle error as needed\n    }\n\n    // Step 2: Generate the Sequence and Convert Numbers to Strings\n    std::ostringstream result;\n    for (int i = 0; i <= n; ++i) {\n        result << i;\n        if (i < n) {\n            result << \" \";\n        }\n    }\n\n    // Step 3: Return the Result\n    return result.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Normalization: Convert the string to lowercase\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Unique Character Identification: Use a set to store unique characters\n    set<char> unique_chars(str.begin(), str.end());\n    \n    // Counting Unique Characters: Get the size of the set\n    int distinct_count = unique_chars.size();\n    \n    // Return the Result\n    return distinct_count;\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    // Step 1: Input Validation\n    if (music_string.empty()) {\n        return {};\n    }\n\n    // Step 2: Tokenization\n    vector<string> tokens;\n    stringstream ss(music_string);\n    string token;\n    while (ss >> token) {\n        tokens.push_back(token);\n    }\n\n    // Step 3: Mapping Notes to Beats\n    unordered_map<string, int> note_to_beats = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n\n    // Step 4: Conversion to Vector of Integers\n    vector<int> beats;\n    for (const string& note : tokens) {\n        beats.push_back(note_to_beats[note]);\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n\n    int count = 0;\n    for (size_t i = 0; i <= str.length() - substring.length(); ++i) {\n        if (str.substr(i, substring.length()) == substring) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Define the mapping\n    map<string, int> numeral_to_int = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 2: Input Validation (simplified for brevity)\n    // (Assume input is always valid for this example)\n\n    // Step 3: Parse the Input String\n    vector<string> numeral_words;\n    istringstream iss(numbers);\n    string word;\n    while (iss >> word) {\n        numeral_words.push_back(word);\n    }\n\n    // Step 4: Convert Numerals to Integers\n    vector<int> int_values;\n    for (const string& numeral : numeral_words) {\n        int_values.push_back(numeral_to_int[numeral]);\n    }\n\n    // Step 5: Sort the Integers\n    sort(int_values.begin(), int_values.end());\n\n    // Step 6: Convert Integers Back to Numerals\n    vector<string> sorted_numerals;\n    for (int value : int_values) {\n        for (const auto& pair : numeral_to_int) {\n            if (pair.second == value) {\n                sorted_numerals.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Step 7: Reconstruct the Output String\n    ostringstream oss;\n    for (size_t i = 0; i < sorted_numerals.size(); ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << sorted_numerals[i];\n    }\n\n    // Step 8: Return the Result\n    return oss.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <limits>\n#include <stdexcept>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must contain at least two elements.\");\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(numbers.begin(), numbers.end());\n\n    // Step 3: Finding the Closest Pair\n    float min_diff = std::numeric_limits<float>::infinity();\n    std::vector<float> closest_pair;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    // Step 4: Returning the Result\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Input vector must have at least two elements.\");\n    }\n\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n\n    if (min_value == max_value) {\n        return vector<float>(numbers.size(), 0.0);\n    }\n\n    vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\n    for (float number : numbers) {\n        rescaled_numbers.push_back((number - min_value) / (max_value - min_value));\n    }\n\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    if (str.empty()) {\n        return 0;\n    }\n    \n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    \n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n#include <vector>\n\nint largest_divisor(int n) {\n    // Step 1: Input Validation\n    if (n <= 1) {\n        // Handle invalid input (e.g., non-positive integers)\n        return -1; // or throw an exception\n    }\n\n    // Step 2: Finding Divisors\n    std::vector<int> divisors;\n    for (int i = 1; i < n; ++i) {\n        if (n % i == 0) {\n            divisors.push_back(i);\n        }\n    }\n\n    // Step 3: Selecting the Largest Divisor\n    int max_divisor = 1; // Initialize with the smallest possible divisor\n    for (int divisor : divisors) {\n        if (divisor > max_divisor) {\n            max_divisor = divisor;\n        }\n    }\n\n    // Step 4: Return the Result\n    return max_divisor;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Input validation\n    if (n <= 0) {\n        return factors; // Return an empty vector for invalid input\n    }\n    \n    // Prime factorization\n    int divisor = 2;\n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Initialize data structures\n    unordered_map<int, int> count_map;\n    vector<int> result;\n\n    // Step 2: Count element occurrences\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Step 3: Filter unique elements\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    for (char c : str) {\n        if (isupper(c)) {\n            result += tolower(c);\n        } else if (islower(c)) {\n            result += toupper(c);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize the result string\n    string result = \"\";\n    \n    // Iterate through each string in the vector\n    for (const string& str : strings) {\n        // Append the current string to the result\n        result += str;\n    }\n    \n    // Return the concatenated result\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Input validation\n    if (strings.empty()) {\n        return {};\n    }\n    if (prefix.empty()) {\n        return strings;\n    }\n\n    // Filtering\n    vector<string> result;\n    for (const string& str : strings) {\n        if (str.compare(0, prefix.size(), prefix) == 0) {\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    if (l.empty()) {\n        return vector<float>();\n    }\n\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true; // 2 is the smallest prime number\n    }\n    if (n % 2 == 0) {\n        return false; // Even numbers greater than 2 are not prime\n    }\n    for (long long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, so it's not prime\n        }\n    }\n    return true; // n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    double x0 = 0; // Initial guess\n    double tolerance = 1e-7;\n    int max_iterations = 1000;\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double fx = poly(xs, x0);\n        double dfx = derivative(xs, x0);\n\n        if (abs(fx) < tolerance) {\n            return x0;\n        }\n\n        x0 = x0 - fx / dfx;\n    }\n\n    throw runtime_error(\"Failed to converge to a root within the maximum number of iterations.\");\n}\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Identify indices divisible by three\n    vector<int> indices;\n    for (int i = 2; i < l.size(); i += 3) {\n        indices.push_back(i);\n    }\n\n    // Step 2: Extract values at these indices\n    vector<int> values;\n    for (int index : indices) {\n        values.push_back(l[index]);\n    }\n\n    // Step 3: Sort the extracted values\n    sort(values.begin(), values.end());\n\n    // Step 4: Reconstruct the output vector\n    vector<int> l_prime = l;\n    for (int i = 0; i < indices.size(); ++i) {\n        l_prime[indices[i]] = values[i];\n    }\n\n    // Step 5: Return the result\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Remove duplicates using a set\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> result(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 3: Return the sorted vector of unique elements\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int currentNumber = i;\n            while (currentNumber > 0) {\n                if (currentNumber % 10 == 7) {\n                    totalCount++;\n                }\n                currentNumber /= 10;\n            }\n        }\n    }\n    \n    return totalCount;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Step 1: Extract values at even indices\n    vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort the extracted values\n    sort(even_values.begin(), even_values.end());\n\n    // Step 3: Construct the output vector\n    vector<float> l_prime(l.size());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime[i] = even_values[even_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Step 4: Return the output vector\n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // reverse cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int a = 1, b = 1; // Initial Fibonacci numbers\n    int count = 0; // Counter for prime Fibonacci numbers\n    \n    while (true) {\n        int next_fib = a + b;\n        a = b;\n        b = next_fib;\n        \n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Input Validation\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Sorting the Vector\n    sort(l.begin(), l.end());\n\n    // Finding Triplets using Two-Pointer Technique\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n\n    // Returning the Result\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Since each car in the left-to-right set will collide with exactly one car in the right-to-left set,\n    // the number of collisions is simply n.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(const vector<int>& l) {\n    vector<int> result;\n    result.reserve(l.size()); // Reserve space to avoid multiple reallocations\n\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <string>\n#include <stdexcept>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Step 1: Input Validation\n    if (base >= 10) {\n        throw invalid_argument(\"Base must be less than 10.\");\n    }\n\n    // Step 2: Base Conversion\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;  // Prepend the remainder\n        x = x / base;\n    }\n\n    // Step 3: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nfloat triangle_area(float base, float height) {\n    // Input Validation\n    if (base <= 0 || height <= 0) {\n        cerr << \"Error: Base and height must be positive numbers.\" << endl;\n        return -1; // Return an error code\n    }\n    \n    // Area Calculation\n    float area = 0.5 * base * height;\n    \n    // Return the Result\n    return area;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n\nint fib4(int n) {\n    // Initial values for the first four Fib4 numbers\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four Fib4 numbers\n    int fib4_0 = 0, fib4_1 = 0, fib4_2 = 2, fib4_3 = 0;\n    int fib4_n;\n\n    // Iterate to compute the Fib4 numbers for n >= 4\n    for (int i = 4; i <= n; ++i) {\n        fib4_n = fib4_0 + fib4_1 + fib4_2 + fib4_3;\n        fib4_0 = fib4_1;\n        fib4_1 = fib4_2;\n        fib4_2 = fib4_3;\n        fib4_3 = fib4_n;\n    }\n\n    return fib4_n;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 != 0) {\n        return l[n / 2];\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true;\n    }\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <stdexcept>\n\nint modp(int n, int p) {\n    if (p == 0) {\n        throw std::invalid_argument(\"Modulo by zero is undefined\");\n    }\n    \n    if (n == 0) {\n        return 1;\n    }\n    \n    int result = 1;\n    int base = 2;\n    \n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Step 1: Define the set of vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Step 2: Initialize the result string\n    string result = \"\";\n    \n    // Step 3: Iterate through the input string\n    for (char c : text) {\n        // Step 4: Check if the character is not a vowel\n        if (vowels.find(c) == vowels.end()) {\n            // Step 5: Append non-vowel characters to the result string\n            result += c;\n        }\n    }\n    \n    // Step 6: Return the result string\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    if (l.empty()) {\n        return true;\n    }\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "/*\nAdd two numbers x and y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function to add two integers and return the result\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Edge case: If both strings are empty, return true\n    if (s0.empty() && s1.empty()) return true;\n    \n    // Edge case: If one string is empty and the other is not, return false\n    if (s0.empty() || s1.empty()) return false;\n    \n    // Create hash maps to count character frequencies\n    unordered_map<char, int> freq0, freq1;\n    \n    // Populate the frequency map for s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    \n    // Populate the frequency map for s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n    \n    // Compare the frequency maps\n    if (freq0.size() != freq1.size()) return false;\n    \n    for (auto& pair : freq0) {\n        if (freq1[pair.first] != pair.second) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdexcept>\n\nint fib(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n\n    int a = 0;\n    int b = 1;\n    int result = 0;\n\n    for (int i = 2; i <= n; ++i) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    // Input Validation: Ensure the string contains only '<' and '>'\n    for (char c : brackets) {\n        if (c != '<' && c != '>') {\n            return false;\n        }\n    }\n\n    // Counting Brackets: Initialize counters\n    int openCount = 0, closeCount = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            openCount++;\n        } else if (c == '>') {\n            closeCount++;\n        }\n    }\n\n    // Compare counts: If they are not equal, return false\n    if (openCount != closeCount) {\n        return false;\n    }\n\n    // Matching Brackets: Use a stack to track '<'\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else if (c == '>') {\n            if (s.empty()) {\n                return false; // Closing bracket without a corresponding opening bracket\n            }\n            s.pop();\n        }\n    }\n\n    // After traversal, if the stack is empty, return true\n    return s.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.empty()) {\n        return false;\n    }\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Input Validation\n    if (l1.empty() || l2.empty()) {\n        return {};\n    }\n\n    // Step 2: Identify Common Elements\n    set<int> set1(l1.begin(), l1.end());\n    vector<int> result;\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 3: Remove Duplicates\n    set<int> unique_result(result.begin(), result.end());\n    result.assign(unique_result.begin(), unique_result.end());\n\n    // Step 4: Sort the Result\n    sort(result.begin(), result.end());\n\n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int i = 2;\n\n    while (n > 1) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n        i++;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    // Input Validation\n    if (n < 1) {\n        return 0;\n    }\n\n    // Sum Calculation using formula\n    int sum = n * (n + 1) / 2;\n\n    // Return the Result\n    return sum;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    // Step 1: Input Validation\n    for (char c : brackets) {\n        if (c != '(' && c != ')') {\n            return false;\n        }\n    }\n\n    // Step 2: Count Matching Pairs\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        // Step 3: Order Validation\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Step 4: Final Check\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Step 1: Input Validation\n    if (xs.empty()) {\n        return {};\n    }\n\n    // Step 2: Derivative Calculation\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n\n    // Step 3: Output Preparation\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <vector>\n#include <stdexcept>\n\nint fibfib(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n\n    std::vector<int> memo(n + 1, -1);\n    memo[0] = 0;\n    memo[1] = 0;\n    memo[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        memo[i] = memo[i - 1] + memo[i - 2] + memo[i - 3];\n    }\n\n    return memo[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c, bool is_last_char) {\n    // Convert character to lowercase\n    c = tolower(c);\n    // Check if the character is a vowel\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n        return true;\n    }\n    // Check if 'y' is at the end of the word\n    if (c == 'y' && is_last_char) {\n        return true;\n    }\n    return false;\n}\n\nint vowels_count(string s) {\n    int count = 0;\n    int len = s.length();\n    \n    for (int i = 0; i < len; i++) {\n        if (is_vowel(s[i], i == len - 1)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    \n    // Calculate the number of digits\n    int num_digits = str_x.length();\n    \n    // Handle the shift operation\n    if (shift <= num_digits) {\n        // Perform a circular right shift\n        string shifted_part = str_x.substr(num_digits - shift);\n        string remaining_part = str_x.substr(0, num_digits - shift);\n        return shifted_part + remaining_part;\n    } else {\n        // Reverse the string\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += c; // Add the ASCII value of the uppercase character to the sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nint fruit_distribution(std::string s, int n) {\n    // Step 1: Parse the input string\n    size_t apples_pos = s.find(\"apples\");\n    size_t oranges_pos = s.find(\"oranges\");\n    \n    std::string apples_str = s.substr(0, apples_pos);\n    std::string oranges_str = s.substr(apples_pos + 7, oranges_pos - apples_pos - 7);\n    \n    // Step 2: Convert to integers\n    int apples = std::stoi(apples_str);\n    int oranges = std::stoi(oranges_str);\n    \n    // Step 3: Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    // Step 4: Return the result\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even == -1 || arr[i] < smallest_even || (arr[i] == smallest_even && i < smallest_index)) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) return {};\n    return {smallest_even, smallest_index};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 2: Frequency Counting\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Step 3: Filtering and Validation\n    std::vector<int> validIntegers;\n    for (const auto& pair : frequencyMap) {\n        if (pair.second >= pair.first) {\n            validIntegers.push_back(pair.first);\n        }\n    }\n\n    // Step 4: Finding the Greatest Valid Integer\n    if (validIntegers.empty()) {\n        return -1; // Step 5: Return -1 if no valid integer is found\n    }\n\n    int maxValidInteger = *std::max_element(validIntegers.begin(), validIntegers.end());\n    return maxValidInteger; // Step 5: Return the greatest valid integer\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 2: Sorting the Vector\n    sort(lst.begin(), lst.end());\n\n    // Step 3: Alternating Extraction\n    vector<int> result;\n    int i = 0;\n    int j = lst.size() - 1;\n\n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n\n    // Step 4: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nfloat triangle_area(float a, float b, float c) {\n    // Step 1: Validate the triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Step 2: Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Step 3: Calculate the area using Heron's formula\n    float area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Step 4: Round the area to 2 decimal places\n    area = std::round(area * 100) / 100;\n\n    // Step 5: Return the result\n    return area;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\n// Function to check if the vector is palindromic\nbool is_palindromic(vector<int> q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to calculate the sum of the vector elements\nint sum_of_elements(vector<int> q) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum;\n}\n\n// Function to check if the sum is within the limit\nbool is_sum_within_limit(int sum, int w) {\n    return sum <= w;\n}\n\n// Main function to determine if the object will fly\nbool will_it_fly(vector<int> q, int w) {\n    if (q.empty()) return false;\n    \n    bool is_balanced = is_palindromic(q);\n    int sum = sum_of_elements(q);\n    bool is_within_weight = is_sum_within_limit(sum, w);\n    \n    return is_balanced && is_within_weight;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int mismatch_count = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            mismatch_count++;\n        }\n        left++;\n        right--;\n    }\n\n    return mismatch_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate total number of characters in a vector of strings\nint calculate_total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\n// Main function to compare two vectors of strings and return the one with fewer total characters\nvector<string> total_match(const vector<string>& lst1, const vector<string>& lst2) {\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <unordered_set>\n#include <cmath>\n\n// Function to generate all prime numbers less than 100\nstd::vector<int> generatePrimes() {\n    std::vector<int> primes;\n    std::vector<bool> isPrime(100, true);\n    isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j < 100; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\n// Function to factorize the given number using the list of prime numbers\nstd::vector<int> factorize(int a, const std::vector<int>& primes) {\n    std::vector<int> factors;\n    for (int prime : primes) {\n        if (a % prime == 0) {\n            factors.push_back(prime);\n            while (a % prime == 0) {\n                a /= prime;\n            }\n        }\n        if (a == 1) break;\n    }\n    return factors;\n}\n\n// Function to count the number of unique prime factors\nint countUniquePrimeFactors(const std::vector<int>& factors) {\n    std::unordered_set<int> uniqueFactors(factors.begin(), factors.end());\n    return uniqueFactors.size();\n}\n\n// Main function to determine if the number is a multiplication of 3 prime numbers\nbool is_multiply_prime(int a) {\n    if (a < 2) return false; // A number less than 2 cannot be a product of 3 primes\n\n    std::vector<int> primes = generatePrimes();\n    std::vector<int> factors = factorize(a, primes);\n    int uniqueFactorCount = countUniquePrimeFactors(factors);\n\n    return uniqueFactorCount == 3;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool is_simple_power(int x, int n) {\n    // Input validation\n    if (n == 1) return false;\n    if (n <= 0) return false;\n\n    // Special case for x == 1\n    if (x == 1) return (n != 0 && n != 1);\n\n    // Power calculation\n    int power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) return true;\n    }\n\n    // Comparison\n    return false;\n}\n\n// Test cases\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool iscube(int a) {\n    // Step 1: Convert the input to its absolute value\n    int abs_a = abs(a);\n    \n    // Step 2: Compute the cube root of the absolute value\n    double cube_root = cbrt(abs_a);\n    \n    // Step 3: Check if the cube root is an integer\n    if (cube_root == static_cast<int>(cube_root)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count prime hexadecimal digits\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    \n    for (char c : num) {\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            int decimal_value;\n            if (c >= '0' && c <= '9') {\n                decimal_value = c - '0';\n            } else {\n                decimal_value = 10 + (c - 'A');\n            }\n            if (is_prime(decimal_value)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/79", "generation": "#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\";\n\n    string binary_str = \"\";\n    while (decimal > 0) {\n        binary_str = to_string(decimal % 2) + binary_str;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary_str + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Input Validation: Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Loop Through the String\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // Check Consecutive Characters\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // Return Result\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring convert_gpa_to_letter_grade(float gpa) {\n    if (gpa == 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(convert_gpa_to_letter_grade(gpa));\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // Step 1: Input validation\n    if (n <= 0) {\n        return 0; // or handle error as needed\n    }\n\n    // Step 2: Calculate the range of n-digit numbers\n    int min_n_digit = 1;\n    for (int i = 1; i < n; ++i) {\n        min_n_digit *= 10;\n    }\n    int max_n_digit = min_n_digit * 10 - 1;\n\n    // Step 3: Count numbers starting with 1\n    int count_start_1 = max_n_digit / 10;\n\n    // Step 4: Count numbers ending with 1\n    int count_end_1 = max_n_digit / 10;\n\n    // Step 5: Adjust for overlap (numbers that start and end with 1)\n    int count_start_and_end_1 = n > 1 ? 9 * (n - 1) : 1; // Special case for n = 1\n\n    // Step 6: Combine counts and return the result\n    return count_start_1 + count_end_1 - count_start_and_end_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    int temp = N;\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary_str = \"\";\n    while (sum > 0) {\n        binary_str = to_string(sum % 2) + binary_str;\n        sum /= 2;\n    }\n\n    // Handle the case where the sum is 0\n    if (binary_str.empty()) {\n        binary_str = \"0\";\n    }\n\n    // Step 3: Return the binary string\n    return binary_str;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        // Handle empty vector case\n        return -1; // or throw an exception\n    }\n\n    int sum = 0;\n\n    // Step 2: Iterate Through the Vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int element = lst[i];\n\n        // Step 3: Check Even Elements\n        if (element % 2 == 0) {\n            // Step 4: Check Odd Indices\n            if (i % 2 != 0) {\n                // Step 5: Filter and Sum\n                sum += element;\n            }\n        }\n    }\n\n    // Step 6: Return the Sum\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    vector<string> words;\n    string temp;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!temp.empty()) {\n                words.push_back(temp);\n                temp.clear();\n            }\n            words.push_back(\" \");\n        } else {\n            temp += c;\n        }\n    }\n    if (!temp.empty()) {\n        words.push_back(temp);\n    }\n\n    for (string &word : words) {\n        if (word != \" \") {\n            sort(word.begin(), word.end());\n        }\n    }\n\n    string result;\n    for (const string &part : words) {\n        result += part;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort columns in descending order if rows are the same\n        }\n        return a[0] < b[0]; // Sort rows in ascending order\n    });\n    \n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int sum = array.front() + array.back();\n    bool ascending = (sum % 2 != 0); // True if sum is odd, False if sum is even\n\n    vector<int> sorted_array = array; // Create a copy\n    if (ascending) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    int shift = 4; // 2 * 2\n\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + shift) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + shift) % 26;\n        }\n        result += c;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty() || lst.size() < 2) {\n        return -1; // Return -1 to represent None\n    }\n\n    // Step 2: Finding the Smallest and Second Smallest Elements\n    int smallest = INT_MAX;\n    int second_smallest = INT_MAX;\n\n    // Find the smallest element\n    for (int num : lst) {\n        if (num < smallest) {\n            smallest = num;\n        }\n    }\n\n    // Find the second smallest element\n    for (int num : lst) {\n        if (num != smallest && num < second_smallest) {\n            second_smallest = num;\n        }\n    }\n\n    // Step 3: Return the Result\n    return (second_smallest == INT_MAX) ? -1 : second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Step 1: Sentence Segmentation\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    while (getline(ss, sentence, '.')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '?')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '!')) {\n        sentences.push_back(sentence);\n    }\n\n    // Step 2: Sentence Classification and Counting Boredoms\n    int boredom_count = 0;\n    for (string &s : sentences) {\n        // Trim leading and trailing whitespace\n        s.erase(0, s.find_first_not_of(' '));\n        s.erase(s.find_last_not_of(' ') + 1);\n        \n        // Check if the sentence starts with \"I\"\n        if (s.find(\"I \") == 0) {\n            boredom_count++;\n        }\n    }\n\n    // Step 3: Output the Result\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all inputs are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers for comparison\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n\n    // Check the conditions\n    if (int_a == int_b + int_c || int_b == int_a + int_c || int_c == int_a + int_b) {\n        return true;\n    }\n\n    // If none of the conditions are met\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    // Step 1: Case Swapping\n    for (char &c : message) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    \n    // Step 2: Vowel Replacement\n    string vowels = \"aeiouAEIOU\";\n    for (char &c : message) {\n        if (vowels.find(c) != string::npos) {\n            char base = isupper(c) ? 'A' : 'a';\n            c = (c - base + 2) % 26 + base;\n        }\n    }\n    \n    // Step 3: Return the encoded message\n    return message;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0; // No prime found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Step 1: Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Step 2: Iterate through the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Step 3: Key Type Check (implicitly checked by the map type)\n\n        // Step 4: Key Case Consistency Check\n        bool is_all_lower = all_of(key.begin(), key.end(), ::islower);\n        bool is_all_upper = all_of(key.begin(), key.end(), ::isupper);\n\n        if (!is_all_lower && !is_all_upper) {\n            return false;\n        }\n    }\n\n    // Step 5: Return the final result\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\n\nint multiply(int a, int b) {\n    // Step 1: Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Step 2: Compute the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    \n    // Step 3: Return the product\n    return product;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Loop through the string, considering only even indices\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    // Return the final count\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\n#include <stdexcept>\n\nint closest_integer(const std::string& value) {\n    // Step 1: Input Validation\n    if (value.empty()) {\n        throw std::invalid_argument(\"Input string is empty.\");\n    }\n\n    try {\n        // Step 2: String to Number Conversion\n        double number = std::stod(value);\n\n        // Step 3: Determine the Closest Integer\n        double fractional_part = number - std::floor(number);\n        if (fractional_part == 0.5) {\n            // Round away from zero\n            if (number > 0) {\n                return static_cast<int>(std::ceil(number));\n            } else {\n                return static_cast<int>(std::floor(number));\n            }\n        } else {\n            // Round to the nearest integer\n            return static_cast<int>(std::round(number));\n        }\n    } catch (const std::invalid_argument& e) {\n        throw std::invalid_argument(\"Input string is not a valid number.\");\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    stones.push_back(n);\n    \n    int current_stones = n;\n    for (int i = 1; i < n; ++i) {\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n        stones.push_back(current_stones);\n    }\n    \n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    // Remove consecutive delimiters\n    s.erase(unique(s.begin(), s.end(), [](char a, char b) {\n        return (a == ' ' || a == ',') && (b == ' ' || b == ',');\n    }), s.end());\n\n    // Replace commas with spaces to simplify splitting\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Use stringstream to split the string by spaces\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Input Validation\n    if (x <= 0 || y <= 0 || x > y) {\n        return -1;\n    }\n\n    // Step 2: Identify the Range\n    // The range is already defined as [x, y]\n\n    // Step 3: Find the Largest Even Number\n    int max_even = -1;\n    for (int i = x; i <= y; ++i) {\n        if (i % 2 == 0) {\n            if (i > max_even) {\n                max_even = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    return max_even;\n}\n\n// Example usage\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Step 1: Input Validation\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Average Calculation\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Step 3: Rounding\n    int rounded_average = floor(average);\n\n    // Step 4: Binary Conversion\n    if (rounded_average == 0) {\n        return \"0\";\n    }\n\n    string binary_result = \"\";\n    while (rounded_average > 0) {\n        binary_result = to_string(rounded_average % 2) + binary_result;\n        rounded_average /= 2;\n    }\n\n    // Step 5: Return the Result\n    return binary_result;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number contains any even digit\nbool hasEvenDigit(int num) {\n    string numStr = to_string(num);\n    for (char digit : numStr) {\n        if (digit == '0' || digit == '2' || digit == '4' || digit == '6' || digit == '8') {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Main function to filter and sort the input vector\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    // Filter out elements with even digits\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the filtered elements\n    sort(result.begin(), result.end());\n    \n    // Return the sorted vector\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter and Validate Input\n    vector<int> valid_numbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            valid_numbers.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the Validated Vector\n    sort(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 3: Reverse the Sorted Vector\n    reverse(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 4: Map Digits to Corresponding Names\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n    for (int num : valid_numbers) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    // Step 5: Handle Edge Cases\n    // If the input vector is empty, result will already be empty\n\n    // Step 6: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nint factorial(int num) {\n    int result = 1;\n    for (int j = 1; j <= num; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\nint sum(int num) {\n    int result = 0;\n    for (int j = 1; j <= num; ++j) {\n        result += j;\n    }\n    return result;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sum(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string rev_str = str;\n    reverse(rev_str.begin(), rev_str.end());\n    return str == rev_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            digit_sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            digit_sum = -digit_sum;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n\n    // Step 2: Identify Potential Sorted Positions\n    for (int i = 0; i < n; ++i) {\n        // Check if arr[i] is the smallest element\n        if (arr[i] == *min_element(arr.begin(), arr.end())) {\n            // Step 3: Check for Non-Decreasing Order\n            bool isSorted = true;\n            for (int j = 1; j < n; ++j) {\n                if (arr[(i + j) % n] < arr[(i + j - 1) % n]) {\n                    isSorted = false;\n                    break;\n                }\n            }\n            if (isSorted) {\n                return true;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Step 1: Count odd elements in lst1\n    int oddCountLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    // Step 2: Count even elements in lst2\n    int evenCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    // Step 3: Compare counts and return result\n    if (evenCountLst2 >= oddCountLst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Step 1: Input Parsing\n    vector<char> letters;\n    stringstream ss(test);\n    char letter;\n    while (ss >> letter) {\n        letters.push_back(letter);\n    }\n\n    // Step 2: Frequency Counting\n    map<char, int> frequency_map;\n    for (char l : letters) {\n        frequency_map[l]++;\n    }\n\n    // Step 3: Determine Maximum Frequency\n    int max_frequency = 0;\n    vector<char> max_frequency_letters;\n    for (const auto& pair : frequency_map) {\n        if (pair.second > max_frequency) {\n            max_frequency = pair.second;\n            max_frequency_letters.clear();\n            max_frequency_letters.push_back(pair.first);\n        } else if (pair.second == max_frequency) {\n            max_frequency_letters.push_back(pair.first);\n        }\n    }\n\n    // Step 4: Generate the Result\n    map<char, int> result;\n    for (char l : max_frequency_letters) {\n        result[l] = max_frequency;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isPalindrome(string s) {\n    int n = s.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (s[i] != s[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Step 2: Character Deletion\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n    \n    // Step 3: Palindrome Check\n    bool palindrome = isPalindrome(s);\n    \n    // Step 4: Result Packaging\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(palindrome ? \"True\" : \"False\");\n    \n    // Step 5: Return the Result\n    return result;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& str : lst) {\n        int oddCount = 0;\n        for (char ch : str) {\n            if (ch == '1' || ch == '3' || ch == '5' || ch == '7' || ch == '9') {\n                oddCount++;\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(oddCount) + \"n the str\" + to_string(oddCount) + \"ng \" + to_string(oddCount) + \" of the \" + to_string(oddCount) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <limits.h> // For LLONG_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    // Step 1: Input Validation\n    if (nums.empty()) {\n        // Handle empty vector case\n        return 0; // or throw an error\n    }\n\n    // Step 2: Initialization\n    long long minSum = LLONG_MAX;\n\n    // Step 3: Iterate Through the Vector\n    for (size_t i = 0; i < nums.size(); ++i) {\n        long long currentSum = 0;\n        for (size_t j = i; j < nums.size(); ++j) {\n            // Step 4: Calculate Sub-Vector Sums\n            currentSum += nums[j];\n            \n            // Step 5: Update Minimum Sum\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n        }\n    }\n\n    // Step 6: Return the Result\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate over each well (row in the grid)\n    for (const auto& well : grid) {\n        int total_water = 0;\n        \n        // Calculate the total amount of water in the well\n        for (int unit : well) {\n            total_water += unit;\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        int lowerings = (total_water + capacity - 1) / capacity;\n        \n        // Add to the total number of lowerings\n        total_lowerings += lowerings;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int num) {\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator function\nbool compare_by_ones_and_value(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b; // If number of ones is the same, compare by decimal value\n    }\n    return ones_a < ones_b; // Otherwise, compare by number of ones\n}\n\n// Main function to sort the array\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare_by_ones_and_value);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (isalpha(c) && !strchr(\"aeiouAEIOU\", c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) return {};\n\n    vector<string> words;\n    istringstream iss(s);\n    string word;\n    while (iss >> word) {\n        if (count_consonants(word) == n) {\n            words.push_back(word);\n        }\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Traverse the word from right to left\n    bool last_was_consonant = false;\n    for (int i = word.size() - 1; i >= 0; --i) {\n        char ch = word[i];\n        \n        // Check if the character is a vowel\n        if (vowels.find(ch) != vowels.end()) {\n            // Check if it is between two consonants\n            if (last_was_consonant && i > 0 && vowels.find(word[i - 1]) == vowels.end()) {\n                return string(1, ch);\n            }\n        } else {\n            // Update the flag if the character is a consonant\n            last_was_consonant = true;\n        }\n    }\n    \n    // Return empty string if no valid vowel is found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a string is balanced\nbool isBalanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n\n// Helper function to count open parentheses\nint countOpenParentheses(const string& s) {\n    int count = 0;\n    for (char c : s) {\n        if (c == '(') count++;\n    }\n    return count;\n}\n\n// Helper function to count close parentheses\nint countCloseParentheses(const string& s) {\n    int count = 0;\n    for (char c : s) {\n        if (c == ')') count++;\n    }\n    return count;\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    int open1 = countOpenParentheses(s1);\n    int close1 = countCloseParentheses(s1);\n    int open2 = countOpenParentheses(s2);\n    int close2 = countCloseParentheses(s2);\n\n    // Check if the total number of open parentheses equals the total number of close parentheses\n    if (open1 + open2 != close1 + close2) {\n        return \"No\";\n    }\n\n    // Check if the strings can be concatenated without causing an imbalance\n    if (open1 >= close2 && open2 >= close1) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> maximum(std::vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (k < 0 || k > arr.size()) {\n        return {}; // or handle error appropriately\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(arr.begin(), arr.end());\n\n    // Step 3: Extracting the Top k Elements\n    std::vector<int> result(arr.end() - k, arr.end());\n\n    // Step 4: Returning the Result\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even indices\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        // Check if the element at the even index is odd\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (arr.empty() || k < 1 || k > arr.size()) {\n        // Handle error (e.g., return -1 or throw an exception)\n        return -1;\n    }\n\n    // Step 2: Extract the first k elements\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        // Step 3: Identify elements with at most two digits\n        if (arr[i] < 100) {\n            // Step 4: Sum the valid elements\n            sum += arr[i];\n        }\n    }\n\n    // Step 5: Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add the final 1 to the sequence\n\n    // Filter odd numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <regex>\nusing namespace std;\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    // Step 1: Check if the input string is empty\n    if (date.empty()) return false;\n\n    // Step 2: Validate the format using regex\n    regex date_format(\"^\\\\d{2}-\\\\d{2}-\\\\d{4}$\");\n    if (!regex_match(date, date_format)) return false;\n\n    // Step 3: Extract components\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Step 4: Month validation\n    if (month < 1 || month > 12) return false;\n\n    // Step 5: Day validation\n    if (day < 1) return false;\n    if (month == 2) {\n        if (is_leap_year(year)) {\n            if (day > 29) return false;\n        } else {\n            if (day > 28) return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day > 30) return false;\n    } else {\n        if (day > 31) return false;\n    }\n\n    // Step 6: Return the final result\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt);\n        return result;\n    }\n\n    // Check for only lowercase letters\n    if (all_of(txt.begin(), txt.end(), ::islower)) {\n        int count = 0;\n        for (char ch : txt) {\n            if ((ch - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        result.push_back(to_string(count));\n        return result;\n    }\n\n    // Default case (should not reach here)\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Edge case: If the vector has only one element or is empty, return true\n    if (lst.size() <= 1) return true;\n\n    // Step 1: Check if the vector is sorted in ascending order\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Step 2: Check for duplicate elements\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false;\n        }\n    }\n\n    // If both conditions are satisfied, return true\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    // If intervals do not intersect\n    if (start > end) {\n        return \"NO\";\n    }\n    \n    // Calculate the length of the intersection\n    int length = end - start + 1;\n    \n    // Check if the length is prime\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            sign_product *= 1;\n        } else if (num < 0) {\n            sign_product *= -1;\n        } else {\n            sign_product *= 0;\n        }\n        magnitude_sum += abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate all possible paths of length k starting from a given cell\nvoid generatePaths(vector<vector<int>>& grid, int k, int x, int y, vector<int>& currentPath, vector<vector<int>>& allPaths) {\n    // Base case: if the path length is k, add it to allPaths\n    if (currentPath.size() == k) {\n        allPaths.push_back(currentPath);\n        return;\n    }\n\n    // Move in all 4 possible directions (up, down, left, right)\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size()) {\n            currentPath.push_back(grid[nx][ny]);\n            generatePaths(grid, k, nx, ny, currentPath, allPaths);\n            currentPath.pop_back();\n        }\n    }\n}\n\n// Function to find the minimum path of length k in the grid\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<vector<int>> allPaths;\n\n    // Generate all possible paths starting from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath = {grid[i][j]};\n            generatePaths(grid, k, i, j, currentPath, allPaths);\n        }\n    }\n\n    // Find the lexicographically smallest path\n    vector<int> minPath = allPaths[0];\n    for (const auto& path : allPaths) {\n        if (path < minPath) {\n            minPath = path;\n        }\n    }\n\n    return minPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n < 1) return {};\n\n    vector<int> result(n + 1);\n    result[0] = 1; // Placeholder for index 0, not used in the sequence\n    result[1] = 3; // Base case\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return vector<int>(result.begin() + 1, result.end());\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert the integer to a string to easily iterate over digits\n    string numStr = to_string(n);\n    \n    int product = 1;\n    bool hasOddDigit = false;\n    \n    // Iterate over each character in the string\n    for (char digitChar : numStr) {\n        int digit = digitChar - '0';  // Convert char to int\n        if (digit % 2 != 0) {  // Check if the digit is odd\n            product *= digit;  // Multiply the product by the odd digit\n            hasOddDigit = true;\n        }\n    }\n    \n    // If no odd digits were found, return 0\n    if (!hasOddDigit) {\n        return 0;\n    }\n    \n    return product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    // Step 1: Input Validation\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            return false;\n        }\n    }\n\n    // Step 2: Identify Valid Subsequences and Check for Nesting\n    stack<char> s;\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']') {\n            if (!s.empty() && s.top() == '[') {\n                s.pop();\n            } else {\n                s.push(c); // Invalid sequence, but we continue to check for nesting\n            }\n        }\n        // Check for nesting\n        if (s.size() > 1) {\n            return true;\n        }\n    }\n\n    // Step 3: Final Check\n    return false;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;  // Initialize sum to 0\n\n    // Iterate through each element in the vector\n    for (float num : lst) {\n        // Apply ceiling function to round to the nearest upper integer\n        int rounded_num = ceil(num);\n        \n        // Square the rounded integer\n        int squared_num = rounded_num * rounded_num;\n        \n        // Accumulate the squared value\n        sum += squared_num;\n    }\n\n    // Return the final sum of squared values\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character\n    char last_char = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Check if the last character is not part of a word\n    size_t last_space_pos = txt.find_last_of(' ');\n    if (last_space_pos == string::npos || last_space_pos == txt.size() - 1) {\n        return true;\n    }\n\n    // Check if the character after the last space is the last character\n    if (last_space_pos + 1 == txt.size() - 1) {\n        return true;\n    }\n\n    // If the last character is part of a word\n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.empty()) {\n        return -1;\n    }\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Step 1: Identify and convert types\n    float val1, val2;\n    bool is_val1_string = false, is_val2_string = false;\n\n    if (a.type() == typeid(int)) {\n        val1 = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val1 = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(std::string)) {\n        std::string str1 = boost::any_cast<std::string>(a);\n        std::replace(str1.begin(), str1.end(), ',', '.');\n        val1 = std::stof(str1);\n        is_val1_string = true;\n    } else {\n        throw std::invalid_argument(\"Invalid type for input a\");\n    }\n\n    if (b.type() == typeid(int)) {\n        val2 = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val2 = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(std::string)) {\n        std::string str2 = boost::any_cast<std::string>(b);\n        std::replace(str2.begin(), str2.end(), ',', '.');\n        val2 = std::stof(str2);\n        is_val2_string = true;\n    } else {\n        throw std::invalid_argument(\"Invalid type for input b\");\n    }\n\n    // Step 2: Compare\n    if (val1 == val2) {\n        return \"None\";\n    } else if (val1 > val2) {\n        if (is_val1_string) {\n            return boost::any_cast<std::string>(a);\n        } else if (a.type() == typeid(int)) {\n            return boost::any_cast<int>(a);\n        } else {\n            return boost::any_cast<float>(a);\n        }\n    } else {\n        if (is_val2_string) {\n            return boost::any_cast<std::string>(b);\n        } else if (b.type() == typeid(int)) {\n            return boost::any_cast<int>(b);\n        } else {\n            return boost::any_cast<float>(b);\n        }\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <vector>\n\nbool is_equal_to_sum_even(int n) {\n    // Step 1: Input validation\n    if (n < 8) {\n        return false;\n    }\n\n    // Step 2: Generate even numbers\n    std::vector<int> evenNumbers;\n    for (int i = 2; i <= n; i += 2) {\n        evenNumbers.push_back(i);\n    }\n\n    // Step 3: Check combinations\n    int size = evenNumbers.size();\n    for (int i = 0; i < size; ++i) {\n        for (int j = i + 1; j < size; ++j) {\n            for (int k = j + 1; k < size; ++k) {\n                for (int l = k + 1; l < size; ++l) {\n                    if (evenNumbers[i] + evenNumbers[j] + evenNumbers[k] + evenNumbers[l] == n) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Step 4: Return result\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(int n) {\n    if (n <= 1) return 1;\n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long product_of_factorials(int n) {\n    long long product = 1;\n    for (int i = n; i >= 1; --i) {\n        product *= factorial(i);\n    }\n    return product;\n}\n\nlong long special_factorial(int n) {\n    if (n <= 0) return 0; // Handle invalid input\n    return product_of_factorials(n);\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces == 1) {\n                result += '_';\n            } else if (consecutive_spaces > 1) {\n                // Do nothing, we will handle this case later\n            }\n        } else {\n            if (consecutive_spaces > 1) {\n                result += '-';\n            }\n            result += c;\n            consecutive_spaces = 0;\n        }\n    }\n\n    if (consecutive_spaces > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Step 1: Check for exactly one dot\n    size_t first_dot = file_name.find('.');\n    size_t last_dot = file_name.rfind('.');\n    if (first_dot == string::npos || first_dot != last_dot) {\n        return \"No\";\n    }\n\n    // Step 2: Validate the prefix (before the dot)\n    string prefix = file_name.substr(0, first_dot);\n    if (prefix.empty() || !isalpha(prefix[0])) {\n        return \"No\";\n    }\n\n    // Step 3: Validate the suffix (after the dot)\n    string suffix = file_name.substr(first_dot + 1);\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\") {\n        return \"No\";\n    }\n\n    // Step 4: Count the digits\n    int digit_count = count_if(file_name.begin(), file_name.end(), ::isdigit);\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // All checks passed\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split a string into words\nvector<string> splitSentence(const string& sentence) {\n    vector<string> words;\n    istringstream stream(sentence);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to process the sentence\nstring words_in_sentence(string sentence) {\n    vector<string> words = splitSentence(sentence);\n    vector<string> primeLengthWords;\n    \n    for (const string& word : words) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    // Join the words back into a single string\n    string result = accumulate(primeLengthWords.begin(), primeLengthWords.end(), string(),\n                               [](const string& a, const string& b) {\n                                   return a.empty() ? b : a + \" \" + b;\n                               });\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to compute the GCD of two numbers\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool simplify(string x, string n) {\n    // Step 1: Parse the input strings\n    int num1, den1, num2, den2;\n    sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n    sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n    // Step 2: Multiply the fractions\n    int new_num = num1 * num2;\n    int new_den = den1 * den2;\n\n    // Step 3: Simplify the resulting fraction\n    int common_divisor = gcd(new_num, new_den);\n    new_num /= common_divisor;\n    new_den /= common_divisor;\n\n    // Step 4: Check if the result is a whole number\n    return new_den == 1;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    if (nums.empty()) return {};\n\n    // Create a vector of pairs to store the integer and its sum of digits\n    vector<pair<int, int>> num_sum_pairs;\n    for (int num : nums) {\n        num_sum_pairs.push_back({num, sum_of_digits(num)});\n    }\n\n    // Sort the vector of pairs based on the sum of digits (stable sort)\n    stable_sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    // Extract the sorted integers from the data structure and return them as a new vector\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.first);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <cmath> // For abs()\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            int absNum = abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            \n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            \n            if (firstDigit % 2 == 1 && lastDigit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 2: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    // Step 4: Count valid triples\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Step 5: Output the result\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nbool isValidPlanet(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) != planets.end();\n}\n\nint getPlanetIndex(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) - planets.begin();\n}\n\nvector<string> bf(string planet1, string planet2) {\n    if (!isValidPlanet(planet1) || !isValidPlanet(planet2)) {\n        return {};\n    }\n    \n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n    \n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Ascending order by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to return x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num >= 0 && floor(num) == num) {  // Check if num is a non-negative integer\n            int int_num = static_cast<int>(num);\n            if (int_num % 2 != 0) {  // Check if num is odd\n                sum_of_squares += int_num * int_num;  // Add the square of the odd number to the sum\n            }\n        }\n    }\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Input Validation\n    if (game.size() != guess.size()) {\n        // Handle error: return an empty vector\n        return vector<int>();\n    }\n\n    // Initialization of Result Vector\n    vector<int> result(game.size());\n\n    // Comparison Loop\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = abs(game[i] - guess[i]);\n        }\n    }\n\n    // Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n        for (char c : ext) {\n            if (isupper(c)) CAP++;\n            else if (islower(c)) SM++;\n        }\n        int strength = CAP - SM;\n\n        if (strength > max_strength || (strength == max_strength && ext < strongest_extension)) {\n            strongest_extension = ext;\n            max_strength = strength;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Helper function to generate all rotations of a string\nvector<string> generate_rotations(string b) {\n    vector<string> rotations;\n    int n = b.length();\n    for (int i = 0; i < n; ++i) {\n        rotations.push_back(b.substr(i) + b.substr(0, i));\n    }\n    return rotations;\n}\n\n// Helper function to check if a string is a substring of another\nbool is_substring(string a, string rotation) {\n    return a.find(rotation) != string::npos;\n}\n\n// Main function to check cyclic pattern\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n    if (b.empty()) return true;\n\n    vector<string> rotations = generate_rotations(b);\n    for (string rotation : rotations) {\n        if (is_substring(a, rotation)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    if (num < 0) {\n        num = abs(num);\n    }\n\n    int even_count = 0;\n    int odd_count = 0;\n\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Step 1: Define the Roman numeral mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    string result = \"\";\n    \n    // Step 2: Iterate through the integer values\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    \n    // Step 4: Convert to lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <algorithm> // For std::sort\n#include <cmath>     // For std::pow\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n    if (!(a + b > c && a + c > b && b + c > a)) {\n        return false;\n    }\n\n    // Step 2: Sorting the Sides\n    float sides[] = {a, b, c};\n    std::sort(sides, sides + 3);\n\n    // Step 3: Applying the Pythagorean Theorem\n    float a_squared = std::pow(sides[0], 2);\n    float b_squared = std::pow(sides[1], 2);\n    float c_squared = std::pow(sides[2], 2);\n\n    return c_squared == a_squared + b_squared;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_characters(const string& word) {\n    set<char> unique_chars(word.begin(), word.end());\n    return unique_chars.size();\n}\n\n// Comparison function\nint compare_strings(const string& a, const string& b) {\n    int unique_a = count_unique_characters(a);\n    int unique_b = count_unique_characters(b);\n    \n    if (unique_a != unique_b) {\n        return unique_a < unique_b ? -1 : 1;\n    }\n    return a < b ? -1 : (a > b ? 1 : 0);\n}\n\n// Main function to find the word with maximum unique characters\nstring find_max(const vector<string>& words) {\n    if (words.empty()) return \"\";\n    \n    string best_word = words[0];\n    for (const string& word : words) {\n        if (compare_strings(best_word, word) < 0) {\n            best_word = word;\n        }\n    }\n    return best_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Step 1: Input Validation\n    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n        // Handle invalid input (e.g., return an error vector or throw an exception)\n        return {-1, -1}; // Example error handling\n    }\n\n    // Step 2: Calculate Total Carrots Eaten\n    int total_eaten = number + need;\n    if (total_eaten > remaining) {\n        total_eaten = remaining;\n    }\n\n    // Step 3: Determine Carrots Left\n    int carrots_left = remaining - total_eaten;\n    if (carrots_left < 0) {\n        carrots_left = 0;\n    }\n\n    // Step 4: Return the Result\n    return {total_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cmath>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n\nint evaluate_expression(const string& expression) {\n    stack<int> operands;\n    stack<string> operators;\n    unordered_map<string, int> precedence = {\n        {\"**\", 3},\n        {\"*\", 2}, {\"//\", 2},\n        {\"+\", 1}, {\"-\", 1}\n    };\n\n    auto apply_operator = [&]() {\n        int b = operands.top(); operands.pop();\n        int a = operands.top(); operands.pop();\n        string op = operators.top(); operators.pop();\n        int result = 0;\n        if (op == \"+\") result = a + b;\n        else if (op == \"-\") result = a - b;\n        else if (op == \"*\") result = a * b;\n        else if (op == \"//\") result = a / b;\n        else if (op == \"**\") result = pow(a, b);\n        operands.push(result);\n    };\n\n    stringstream ss(expression);\n    string token;\n    while (ss >> token) {\n        if (isdigit(token[0])) {\n            operands.push(stoi(token));\n        } else if (token == \"(\") {\n            operators.push(token);\n        } else if (token == \")\") {\n            while (!operators.empty() && operators.top() != \"(\") {\n                apply_operator();\n            }\n            operators.pop(); // Pop the \"(\"\n        } else {\n            while (!operators.empty() && precedence[operators.top()] >= precedence[token]) {\n                apply_operator();\n            }\n            operators.push(token);\n        }\n    }\n\n    while (!operators.empty()) {\n        apply_operator();\n    }\n\n    return operands.top();\n}\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Input Validation\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Invalid input: operator and operand sizes do not match.\");\n    }\n    for (int op : operand) {\n        if (op < 0) {\n            throw invalid_argument(\"Invalid input: operand contains negative integers.\");\n        }\n    }\n    for (string op : operato) {\n        if (op != \"+\" && op != \"-\" && op != \"*\" && op != \"//\" && op != \"**\") {\n            throw invalid_argument(\"Invalid input: operator contains invalid operations.\");\n        }\n    }\n\n    // Step 2: Expression Construction\n    string expression;\n    for (size_t i = 0; i < operand.size(); ++i) {\n        expression += to_string(operand[i]);\n        if (i < operato.size()) {\n            expression += \" \" + operato[i] + \" \";\n        }\n    }\n\n    // Step 3: Expression Evaluation\n    int result = evaluate_expression(expression);\n\n    // Step 4: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    string result = \"\";\n    bool hasLetters = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetters) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Step 1: Input Validation\n    if (text.empty()) {\n        return \"None\"; // or return an empty string or throw an exception\n    }\n\n    // Step 2: MD5 Hash Calculation\n    MD5_CTX ctx;\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    string result;\n\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.c_str(), text.length());\n    MD5_Final(hash, &ctx);\n\n    // Step 3: Convert binary hash to hexadecimal string\n    char hex[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(hex, \"%02x\", hash[i]);\n        result += hex;\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Step 1: Input Validation\n    if (a <= 0 || b <= 0) {\n        return {}; // Return an empty vector if inputs are invalid\n    }\n\n    // Step 2: Range Determination\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n\n    // Step 3: Digit Extraction\n    set<int> digits; // Use a set to automatically handle duplicates\n    for (int num = min_val; num <= max_val; ++num) {\n        int temp = num;\n        while (temp > 0) {\n            int digit = temp % 10;\n            digits.insert(digit);\n            temp /= 10;\n        }\n    }\n\n    // Step 4: Even Digit Filtering\n    vector<int> even_digits;\n    for (int digit : digits) {\n        if (digit % 2 == 0 && digit < 10) {\n            even_digits.push_back(digit);\n        }\n    }\n\n    // Step 5: Sorting and Deduplication (already handled by set)\n    // Step 6: Output the Result\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Input validation\n    if (numbers.empty() || threshold <= 0) {\n        return false;\n    }\n\n    // Pairwise comparison\n    for (size_t i = 0; i < numbers.size(); i++) {\n        for (size_t j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    // No close elements found\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string no_spaces;\n    \n    // Step 1.1: Remove all spaces from the input string\n    for (char c : paren_string) {\n        if (c != ' ') {\n            no_spaces += c;\n        }\n    }\n    \n    stack<char> s;\n    string current_group;\n    \n    // Step 2.2: Traverse the input string character by character\n    for (char c : no_spaces) {\n        current_group += c;\n        \n        if (c == '(') {\n            // Step 2.3.1: Push each opening parenthesis '(' onto the stack\n            s.push(c);\n        } else if (c == ')') {\n            // Step 2.3.2: When encountering a closing parenthesis ')', pop from the stack\n            s.pop();\n            \n            // Step 2.3.3: If the stack is empty after popping, it indicates the end of a balanced group\n            if (s.empty()) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n    \n    // Step 3.1: Ensure that the stack is empty after processing the entire input string\n    if (!s.empty()) {\n        // Handle unbalanced input (optional: throw an error or ignore the unbalanced part)\n        result.clear();\n    }\n    \n    // Step 4.1: Return the vector containing the separated groups of parentheses\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;  // Initialize the balance to zero\n\n    for (int operation : operations) {\n        balance += operation;  // Update the balance with the current operation\n\n        if (balance < 0) {\n            return true;  // If balance falls below zero, return true\n        }\n    }\n\n    return false;  // If no balance falls below zero, return false\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n#include <numeric> // For std::accumulate\n#include <stdexcept> // For std::invalid_argument\n\nusing namespace std;\n\n// Function to calculate the mean of a vector\nfloat calculate_mean(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0);\n    return sum / numbers.size();\n}\n\n// Function to calculate the absolute differences from the mean\nvector<float> calculate_absolute_differences(const vector<float>& numbers, float mean) {\n    vector<float> abs_diffs;\n    for (float num : numbers) {\n        abs_diffs.push_back(abs(num - mean));\n    }\n    return abs_diffs;\n}\n\n// Function to calculate the mean of the absolute differences\nfloat calculate_mean_of_abs_diffs(const vector<float>& abs_diffs) {\n    float sum = accumulate(abs_diffs.begin(), abs_diffs.end(), 0.0);\n    return sum / abs_diffs.size();\n}\n\n// Main function to calculate Mean Absolute Deviation\nfloat mean_absolute_deviation(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    // Step 1: Calculate the mean of the dataset\n    float mean = calculate_mean(numbers);\n    \n    // Step 2: Calculate the absolute differences from the mean\n    vector<float> abs_diffs = calculate_absolute_differences(numbers, mean);\n    \n    // Step 3: Calculate the mean of the absolute differences\n    return calculate_mean_of_abs_diffs(abs_diffs);\n}\n"}
{"task_id": "CPP/5", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <limits.h>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN;\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring find_longest_palindromic_suffix(const string& str) {\n    for (size_t i = 0; i < str.size(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            return str.substr(i);\n        }\n    }\n    return \"\";\n}\n\nstring make_palindrome(const string& str) {\n    // Find the longest palindromic suffix\n    string palindromic_suffix = find_longest_palindromic_suffix(str);\n    \n    // Identify the prefix that comes before the palindromic suffix\n    string prefix = str.substr(0, str.size() - palindromic_suffix.size());\n    \n    // Reverse the prefix and append it to the end of the original string\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\n#include <stdexcept>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Input Validation\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must be of the same length.\");\n    }\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input string a contains invalid characters.\");\n        }\n    }\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input string b contains invalid characters.\");\n        }\n    }\n\n    // Binary XOR Operation\n    string result;\n    result.reserve(a.length());\n    for (size_t i = 0; i < a.length(); ++i) {\n        result.push_back((a[i] == b[i]) ? '0' : '1');\n    }\n\n    // Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // or return an empty string \"\" to represent None\n    }\n\n    string longest_string = strings[0]; // Assume the first string is the longest initially\n    int max_length = strings[0].length();\n\n    for (const string& str : strings) {\n        if (str.length() > max_length) {\n            longest_string = str;\n            max_length = str.length();\n        }\n        // If str.length() == max_length, do nothing (keep the first longest string)\n    }\n\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <algorithm> // For std::abs\n\nint greatest_common_divisor(int a, int b) {\n    // Step 1: Handle edge cases where a or b is zero\n    if (a == 0) return std::abs(b);\n    if (b == 0) return std::abs(a);\n\n    // Step 2: Use the Euclidean algorithm to calculate the GCD\n    a = std::abs(a);\n    b = std::abs(b);\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    // Step 3: Return the GCD\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {}; // Return an empty vector if the input string is empty\n    }\n\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n#include <sstream>\n#include <vector>\n\nstd::string string_sequence(int n) {\n    // Edge case: if n is 0, return \"0\"\n    if (n == 0) {\n        return \"0\";\n    }\n\n    // Generate the sequence of numbers\n    std::vector<int> numbers;\n    for (int i = 0; i <= n; ++i) {\n        numbers.push_back(i);\n    }\n\n    // Convert the sequence to a string\n    std::stringstream result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result << numbers[i];\n        if (i < numbers.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    // Return the final string\n    return result.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include <string>\n#include <algorithm>\n#include <set>\n\nint count_distinct_characters(std::string str) {\n    // Step 1: Normalize the string to lowercase\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Step 2: Identify distinct characters using a set\n    std::set<char> distinct_chars;\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // Step 3: Return the count of distinct characters\n    return distinct_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    // Step 1: Input Validation\n    if (music_string.empty()) {\n        return {};\n    }\n\n    // Step 2: Tokenization\n    vector<string> tokens;\n    size_t start = 0, end = 0;\n    while ((end = music_string.find(' ', start)) != string::npos) {\n        tokens.push_back(music_string.substr(start, end - start));\n        start = end + 1;\n    }\n    tokens.push_back(music_string.substr(start));\n\n    // Step 3: Mapping Notes to Beats\n    unordered_map<string, int> note_to_beats = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n\n    // Step 4: Conversion to Vector of Integers\n    vector<int> beats;\n    for (const auto& token : tokens) {\n        if (note_to_beats.find(token) != note_to_beats.end()) {\n            beats.push_back(note_to_beats[token]);\n        }\n    }\n\n    // Step 5: Return the Result\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n\n    int count = 0;\n    int pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next position to check for overlapping\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Define the mapping\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 2: Validate and split the input\n    istringstream iss(numbers);\n    string word;\n    vector<string> words;\n    while (iss >> word) {\n        if (wordToNumber.find(word) == wordToNumber.end()) {\n            throw invalid_argument(\"Invalid word in input: \" + word);\n        }\n        words.push_back(word);\n    }\n\n    // Step 3: Convert words to numbers\n    vector<int> nums;\n    for (const string& w : words) {\n        nums.push_back(wordToNumber[w]);\n    }\n\n    // Step 4: Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Step 5: Convert numbers back to words\n    map<int, string> numberToWord = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    vector<string> sortedWords;\n    for (int num : nums) {\n        sortedWords.push_back(numberToWord[num]);\n    }\n\n    // Step 6: Reconstruct the output string\n    ostringstream oss;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << sortedWords[i];\n    }\n\n    // Step 7: Return the result\n    return oss.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Input Validation\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    // Sorting the Vector\n    std::sort(numbers.begin(), numbers.end());\n\n    // Finding the Closest Pair\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    vector<float> closest_pair = {numbers[0], numbers[1]};\n\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    // Returning the Result\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.size() < 2) {\n        // Handle the edge case (e.g., return an empty vector)\n        return {};\n    }\n\n    // Step 2: Find the Minimum and Maximum Values\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n\n    // Step 3: Compute the Scaling Factor\n    float scale_factor = max_value - min_value;\n\n    // Step 4: Apply the Linear Transformation\n    vector<float> rescaled_numbers;\n    for (float num : numbers) {\n        float transformed_value = (num - min_value) / scale_factor;\n        rescaled_numbers.push_back(transformed_value);\n    }\n\n    // Step 5: Return the Transformed Vector\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\nstd::vector<int> filter_integers(std::list<boost::any> values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    if (str.empty()) {\n        return 0;\n    }\n    \n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    \n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n#include <vector>\n\nint largest_divisor(int n) {\n    // Input validation\n    if (n <= 1) {\n        return 1; // Edge case: n is 1 or less\n    }\n\n    // Finding divisors\n    std::vector<int> divisors;\n    for (int i = 1; i < n; ++i) {\n        if (n % i == 0) {\n            divisors.push_back(i);\n        }\n    }\n\n    // Selecting the largest divisor\n    int max_divisor = 1;\n    for (int divisor : divisors) {\n        if (divisor > max_divisor) {\n            max_divisor = divisor;\n        }\n    }\n\n    return max_divisor;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Input validation\n    if (n <= 0) {\n        return factors; // Return an empty vector for non-positive inputs\n    }\n    \n    // Prime factorization\n    for (int i = 2; i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Track occurrences\n    unordered_map<int, int> count_map;\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Step 2: Filter unique elements\n    vector<int> result;\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 3: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    \n    for (char c : str) {\n        if (islower(c)) {\n            result += toupper(c);\n        } else if (isupper(c)) {\n            result += tolower(c);\n        } else {\n            result += c;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    \n    // Input validation\n    if (strings.empty()) {\n        return result;\n    }\n    \n    // Handle empty prefix case\n    if (prefix.empty()) {\n        return strings;\n    }\n    \n    // String comparison and filtering\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) {\n            result.push_back(str);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    if (l.empty()) {\n        return {};\n    }\n\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    long long limit = static_cast<long long>(std::sqrt(n));\n    for (long long i = 3; i <= limit; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\nvector<double> poly_derivative(const vector<double>& xs) {\n    vector<double> derivative;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        derivative.push_back(i * xs[i]);\n    }\n    return derivative;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    double x = 0; // Initial guess\n    double threshold = 1e-6;\n    vector<double> derivative = poly_derivative(xs);\n\n    while (abs(poly(xs, x)) > threshold) {\n        double fx = poly(xs, x);\n        double fpx = poly(derivative, x);\n        if (fpx == 0) {\n            throw runtime_error(\"Derivative is zero, Newton-Raphson method failed.\");\n        }\n        x = x - fx / fpx;\n    }\n\n    return x;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    // Step 1: Input Validation\n    if (l.empty()) return {};\n\n    // Step 2: Identify and Extract Values\n    std::vector<int> extracted_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            extracted_values.push_back(l[i]);\n        }\n    }\n\n    // Step 3: Sort the Extracted Values\n    std::sort(extracted_values.begin(), extracted_values.end());\n\n    // Step 4: Reconstruct the Output Vector\n    std::vector<int> l_prime(l.size());\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l_prime[i] = extracted_values[sorted_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Step 5: Return the Output Vector\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> uniqueSet(l.begin(), l.end());\n    vector<int> sortedUnique(uniqueSet.begin(), uniqueSet.end());\n    return sortedUnique;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <stdexcept>\n#include <limits>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string num_str = std::to_string(i);\n            for (char digit : num_str) {\n                if (digit == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Step 1: Extract values at even indices\n    vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort the extracted values\n    sort(even_values.begin(), even_values.end());\n\n    // Step 3: Construct the output vector l'\n    vector<float> l_prime(l.size());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime[i] = even_values[even_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Step 4: Return the output vector\n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n == 1) return 2; // Special case for the first prime Fibonacci number\n    int a = 1, b = 1;\n    int count = 1; // Start from 1 because 2 is already counted\n    while (true) {\n        int next_fib = a + b;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n        a = b;\n        b = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Input validation: Ensure the vector has at least three elements\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Sort the vector to facilitate triplet search\n    sort(l.begin(), l.end());\n\n    // Iterate through each element in the vector\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        // Use two pointers to find the remaining two elements that sum to the negative of the current element\n        size_t left = i + 1;\n        size_t right = l.size() - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                // Found a triplet that sums to zero\n                return true;\n            } else if (sum < 0) {\n                // Sum is less than zero, move the left pointer to the right\n                ++left;\n            } else {\n                // Sum is greater than zero, move the right pointer to the left\n                --right;\n            }\n        }\n    }\n\n    // No valid triplet found\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\n\nint car_race_collision(int n) {\n    // Calculate the number of collisions\n    int collisions = n * n;\n    \n    // Return the number of collisions\n    return collisions;\n}\n\n// Example usage\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); i++) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base >= 10) {\n        return \"Invalid base\";\n    }\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    bool is_negative = x < 0;\n    x = abs(x);\n\n    string result;\n    while (x > 0) {\n        result += to_string(x % base);\n        x /= base;\n    }\n\n    if (is_negative) {\n        result += '-';\n    }\n\n    reverse(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nfloat triangle_area(float base, float height) {\n    // Input Validation\n    if (base <= 0 || height <= 0) {\n        cerr << \"Error: Base and height must be positive numbers.\" << endl;\n        return -1; // Return an error value\n    }\n\n    // Area Calculation\n    float area = 0.5 * base * height;\n\n    // Return the Result\n    return area;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Initialization\n    if (n < 4) {\n        // Edge Case Handling\n        int predefined[] = {0, 0, 2, 0};\n        return predefined[n];\n    }\n\n    // Initialization of the first four Fib4 numbers\n    int fib4_values[4] = {0, 0, 2, 0};\n\n    // Iterative Computation\n    for (int i = 4; i <= n; ++i) {\n        int next_fib4 = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        // Shift the values to the left\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = next_fib4;\n    }\n\n    // Return the result\n    return fib4_values[3];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nfloat median(std::vector<float> l) {\n    // Step 1: Input Validation\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(l.begin(), l.end());\n\n    // Step 3: Determine the Number of Elements\n    size_t size = l.size();\n    size_t mid = size / 2;\n\n    // Step 4: Calculate the Median\n    if (size % 2 == 1) {\n        // Odd number of elements\n        return l[mid];\n    } else {\n        // Even number of elements\n        return (l[mid - 1] + l[mid]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true;\n    }\n\n    string reversed_text = \"\";\n    for (int i = text.length() - 1; i >= 0; i--) {\n        reversed_text += text[i];\n    }\n\n    if (text == reversed_text) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    // Handle edge cases\n    if (n == 0) return 1;\n    if (p == 1) return 0;\n\n    // Initialize result\n    int result = 1;\n    int base = 2;\n\n    // Exponentiation by squaring with modular arithmetic\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = (c - base + 5) % 26 + base;\n        }\n        out += c;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = (c - base - 5 + 26) % 26 + base;\n        }\n        out += c;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the set of vowels\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Result string to store non-vowel characters\n    string result = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : text) {\n        // If the character is not a vowel, append it to the result string\n        if (vowels.find(c) == vowels.end()) {\n            result += c;\n        }\n    }\n    \n    // Return the result string\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    if (l.empty()) {\n        return true;\n    }\n\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    int sum = x + y;\n    return sum;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\n// Helper function to count character frequencies\nunordered_map<char, int> count_chars(const string& s) {\n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    return freq;\n}\n\nbool same_chars(string s0, string s1) {\n    // Edge case: Different lengths\n    if (s0.length() != s1.length()) {\n        return false;\n    }\n\n    // Count frequencies of characters in both strings\n    unordered_map<char, int> freq0 = count_chars(s0);\n    unordered_map<char, int> freq1 = count_chars(s1);\n\n    // Compare the frequency maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    // Base Case Implementation\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    // Recursive Calculation\n    return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.empty()) return false;\n    if (l.size() == 1) return true;\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\n\nstd::vector<int> common(std::vector<int> l1, std::vector<int> l2) {\n    // Step 1: Input Validation\n    if (l1.empty() || l2.empty()) {\n        return {};\n    }\n\n    // Step 2: Identify Common Elements\n    std::set<int> set1(l1.begin(), l1.end());\n    std::vector<int> result;\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 3: Remove Duplicates\n    std::set<int> unique_result(result.begin(), result.end());\n    result.assign(unique_result.begin(), unique_result.end());\n\n    // Step 4: Sort the Result\n    std::sort(result.begin(), result.end());\n\n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int factor = 2;\n\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            largest_factor = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n\n    if (n > 1) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nint sum_to_n(int n) {\n    // Step 2: Input Handling\n    if (n < 1) {\n        // Handle invalid input (e.g., return -1)\n        return -1;\n    }\n\n    // Step 3: Sum Calculation Logic\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n\n    // Step 4: Return the Result\n    return sum;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Input validation\n    if (xs.empty()) {\n        return {};\n    }\n    if (xs.size() == 1) {\n        return {0};\n    }\n\n    // Derivative calculation\n    vector<float> ys;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        ys.push_back(i * xs[i]);\n    }\n\n    // Return the result\n    return ys;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <vector>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n\n    std::vector<int> fibfib_numbers(n + 1);\n    fibfib_numbers[0] = 0;\n    fibfib_numbers[1] = 0;\n    fibfib_numbers[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfib_numbers[i] = fibfib_numbers[i - 1] + fibfib_numbers[i - 2] + fibfib_numbers[i - 3];\n    }\n\n    return fibfib_numbers[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    // Convert the string to lowercase\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Initialize the counter\n    int count = 0;\n    \n    // Iterate through each character in the string\n    for (char c : s) {\n        // Check if the character is a vowel\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y'\n    if (s.back() == 'y') {\n        count++;\n    }\n    \n    // Return the count\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm> // for reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Step 1: Convert the integer to a string\n    string str_x = to_string(x);\n    \n    // Step 2: Calculate the number of digits\n    int num_digits = str_x.length();\n    \n    // Step 3: Check the shift condition\n    if (shift >= num_digits) {\n        // Reverse the string\n        reverse(str_x.begin(), str_x.end());\n    } else {\n        // Perform the circular right shift\n        string shifted_part = str_x.substr(num_digits - shift);\n        string remaining_part = str_x.substr(0, num_digits - shift);\n        str_x = shifted_part + remaining_part;\n    }\n    \n    // Step 4: Return the result\n    return str_x;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += c; // Add the ASCII value of the uppercase character to the sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Step 1: Extract the number of apples\n    size_t apple_pos = s.find(\"apples\");\n    string apple_str = s.substr(0, apple_pos);\n    int apples = stoi(apple_str);\n    \n    // Step 2: Extract the number of oranges\n    size_t orange_pos = s.find(\"oranges\");\n    string orange_str = s.substr(apple_pos + 7, orange_pos - apple_pos - 7);\n    int oranges = stoi(orange_str);\n    \n    // Step 3: Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    // Step 4: Return the result\n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Step 2: Initialization\n    int smallestEven = INT_MAX;\n    int smallestIndex = -1;\n    bool evenFound = false;\n\n    // Step 3: Iterate Through the Vector\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (!evenFound || arr[i] < smallestEven || (arr[i] == smallestEven && i < smallestIndex)) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n                evenFound = true;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    if (!evenFound) {\n        return {};\n    }\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 2: Frequency Counting\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Step 3: Filtering and Validation\n    std::vector<int> validIntegers;\n    for (const auto& pair : frequencyMap) {\n        if (pair.second >= pair.first) {\n            validIntegers.push_back(pair.first);\n        }\n    }\n\n    // Step 4: Finding the Maximum Valid Integer\n    if (validIntegers.empty()) {\n        return -1; // Step 5: Return -1 if no valid integer exists\n    }\n\n    int maxValidInteger = *std::max_element(validIntegers.begin(), validIntegers.end());\n    return maxValidInteger; // Step 5: Return the maximum valid integer\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 2: Sorting the Vector\n    sort(lst.begin(), lst.end());\n\n    // Step 3: Alternating Extraction\n    vector<int> result;\n    int i = 0;\n    int j = lst.size() - 1;\n\n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n\n    // Step 4: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal places\n    area = std::round(area * 100) / 100;\n\n    return area;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // for std::accumulate\nusing namespace std;\n\n// Helper function to check if the vector is palindromic\nbool is_palindromic(vector<int> q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper function to calculate the sum of vector elements\nint calculate_sum(vector<int> q) {\n    return accumulate(q.begin(), q.end(), 0);\n}\n\n// Main function to determine if the object will fly\nbool will_it_fly(vector<int> q, int w) {\n    if (q.empty()) return false; // Optional: Handle empty vector case\n    \n    bool is_balanced = is_palindromic(q);\n    int sum = calculate_sum(q);\n    \n    return is_balanced && (sum <= w);\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    // Initialize pointers and mismatch counter\n    int left = 0;\n    int right = arr.size() - 1;\n    int mismatch_count = 0;\n\n    // Loop to compare elements from both ends\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            mismatch_count++;\n        }\n        left++;\n        right--;\n    }\n\n    // Return the number of mismatches\n    return mismatch_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& s : lst) {\n        total += s.length();\n    }\n    return total;\n}\n\n// Main function to compare two vectors of strings and return the one with fewer total characters\nvector<string> total_match(const vector<string>& lst1, const vector<string>& lst2) {\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n    \n    if (total1 < total2) {\n        return lst1;\n    } else if (total1 > total2) {\n        return lst2;\n    } else {\n        return lst1; // If totals are equal, return the first vector\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> generate_primes_less_than_100() {\n    std::vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    if (a < 6) return false; // The smallest product of three primes is 2 * 3 * 5 = 30\n\n    std::vector<int> primes = generate_primes_less_than_100();\n    int n = primes.size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool is_simple_power(int x, int n) {\n    // Input validation\n    if (n == 1) {\n        return false;\n    }\n    \n    // Special case handling\n    if (x == 1) {\n        return (n == 1);\n    }\n    \n    // Power calculation\n    int k = 0;\n    int power = 1;\n    while (power < x) {\n        k++;\n        power = pow(n, k);\n        if (power == x) {\n            return true;\n        }\n    }\n    \n    // Comparison\n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    \n    double cube_root = cbrt(a);\n    int int_cube_root = static_cast<int>(cube_root);\n    \n    return int_cube_root * int_cube_root * int_cube_root == a;\n}\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <set>\nusing namespace std;\n\nint hex_key(string num) {\n    const std::set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (char c : num) {\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\";\n\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = (decimal % 2 == 0 ? '0' : '1') + binary;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        string letter_grade;\n        \n        if (gpa == 4.0) letter_grade = \"A+\";\n        else if (gpa > 3.7) letter_grade = \"A\";\n        else if (gpa > 3.3) letter_grade = \"A-\";\n        else if (gpa > 3.0) letter_grade = \"B+\";\n        else if (gpa > 2.7) letter_grade = \"B\";\n        else if (gpa > 2.3) letter_grade = \"B-\";\n        else if (gpa > 2.0) letter_grade = \"C+\";\n        else if (gpa > 1.7) letter_grade = \"C\";\n        else if (gpa > 1.3) letter_grade = \"C-\";\n        else if (gpa > 1.0) letter_grade = \"D+\";\n        else if (gpa > 0.7) letter_grade = \"D\";\n        else if (gpa > 0.0) letter_grade = \"D-\";\n        else if (gpa == 0.0) letter_grade = \"E\";\n        else letter_grade = \"Invalid GPA\"; // Handle invalid GPA values\n        \n        letter_grades.push_back(letter_grade);\n    }\n    \n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    return is_prime(str.length());\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n <= 0) {\n        // Handle invalid input\n        return 0;\n    }\n\n    int start = 1;\n    int end = 9;\n    for (int i = 1; i < n; ++i) {\n        start *= 10;\n        end = end * 10 + 9;\n    }\n\n    int count_start_with_1 = 0;\n    int count_end_with_1 = 0;\n    int count_both_1 = 0;\n\n    for (int num = start; num <= end; ++num) {\n        if (num % 10 == 1) {\n            count_end_with_1++;\n        }\n        if (num / start == 1) {\n            count_start_with_1++;\n        }\n        if (num % 10 == 1 && num / start == 1) {\n            count_both_1++;\n        }\n    }\n\n    int total_count = count_start_with_1 + count_end_with_1 - count_both_1;\n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <string>\n#include <bitset>\n\nstd::string solve(int N) {\n    // Step 1: Sum of Digits Calculation\n    std::string N_str = std::to_string(N);\n    int sum = 0;\n    for (char digit : N_str) {\n        sum += digit - '0'; // Convert char to int\n    }\n\n    // Step 2: Binary Conversion\n    std::string binary_sum = std::bitset<32>(sum).to_string();\n\n    // Remove leading zeros\n    size_t pos = binary_sum.find_first_not_of('0');\n    if (pos != std::string::npos) {\n        binary_sum = binary_sum.substr(pos);\n    } else {\n        binary_sum = \"0\"; // In case sum is 0\n    }\n\n    // Step 3: Return the Binary String\n    return binary_sum;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        // Handle empty vector case\n        return -1; // or throw an exception\n    }\n\n    int sum = 0;\n\n    // Step 2: Iterate Through the Vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Step 3: Check Even Elements\n        if (lst[i] % 2 == 0) {\n            // Step 4: Check Odd Indices\n            if (i % 2 != 0) {\n                // Step 5: Filter and Sum\n                sum += lst[i];\n            }\n        }\n    }\n\n    // Step 6: Return the Sum\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    vector<string> words;\n    vector<string> spaces;\n    string currentWord = \"\";\n    string currentSpace = \"\";\n\n    // Step 1: Parse the input string into words and spaces\n    for (char c : s) {\n        if (c == ' ') {\n            if (!currentWord.empty()) {\n                words.push_back(currentWord);\n                currentWord = \"\";\n            }\n            currentSpace += c;\n        } else {\n            if (!currentSpace.empty()) {\n                spaces.push_back(currentSpace);\n                currentSpace = \"\";\n            }\n            currentWord += c;\n        }\n    }\n    if (!currentWord.empty()) {\n        words.push_back(currentWord);\n    }\n    if (!currentSpace.empty()) {\n        spaces.push_back(currentSpace);\n    }\n\n    // Step 2: Sort characters in each word\n    for (string& word : words) {\n        sort(word.begin(), word.end());\n    }\n\n    // Step 3: Reconstruct the output string\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        result += words[i];\n        if (i < spaces.size()) {\n            result += spaces[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 2: Search and Record Coordinates\n    vector<vector<int>> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Step 3: Sorting the Coordinates\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1];\n        }\n        return a[0] < b[0];\n    });\n\n    // Step 4: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first_element = array.front();\n    int last_element = array.back();\n    int sum = first_element + last_element;\n    bool ascending = (sum % 2 != 0); // True if sum is odd, False if sum is even\n\n    vector<int> sorted_array = array; // Create a copy\n    if (ascending) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    int shift = 4; // 2 * 2\n\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + shift) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + shift) % 26;\n        }\n        result += c;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty() || lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 2: Finding the Smallest Element\n    int smallest = INT_MAX;\n    for (int num : lst) {\n        if (num < smallest) {\n            smallest = num;\n        }\n    }\n\n    // Step 3: Finding the 2nd Smallest Element\n    int second_smallest = INT_MAX;\n    for (int num : lst) {\n        if (num < second_smallest && num != smallest) {\n            second_smallest = num;\n        }\n    }\n\n    // Step 4: Returning the Result\n    return (second_smallest == INT_MAX) ? -1 : second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Step 1: Split the string into sentences\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    while (getline(ss, sentence, '.')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '?')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '!')) {\n        sentences.push_back(sentence);\n    }\n\n    // Step 2: Check each sentence for starting with \"I\"\n    int boredom_count = 0;\n    for (string &s : sentences) {\n        // Trim leading and trailing whitespace\n        s.erase(0, s.find_first_not_of(' '));\n        s.erase(s.find_last_not_of(' ') + 1);\n        \n        // Check if the sentence starts with \"I\"\n        if (s.find(\"I \") == 0) {\n            boredom_count++;\n        }\n    }\n\n    // Step 3: Return the count of boredoms\n    return boredom_count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Input Validation\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Sum Calculation and Comparison\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    // Return Result\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/93", "generation": "#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    for (char &c : message) {\n        // Swap case\n        if (isupper(c)) {\n            c = tolower(c);\n        } else {\n            c = toupper(c);\n        }\n\n        // Identify and replace vowels\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            char newChar = c + 2;\n            if ((islower(c) && newChar > 'z') || (isupper(c) && newChar > 'Z')) {\n                newChar -= 26; // Wrap around for both lowercase and uppercase\n            }\n            c = newChar;\n        }\n    }\n    return message;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    \n    // Find the largest prime in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    \n    // If no prime is found, return 0 (or handle as needed)\n    if (largestPrime == -1) return 0;\n    \n    // Return the sum of the digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Step 1: Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Step 2: Iterate through each key-value pair\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Step 3: Check if all characters in the key are either lower case or upper case\n        bool all_lower = all_of(key.begin(), key.end(), ::islower);\n        bool all_upper = all_of(key.begin(), key.end(), ::isupper);\n\n        // If the key is neither all lower case nor all upper case, return false\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    // Step 4: If all keys pass the checks, return true\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unit_digit_a = abs(a) % 10;\n    int unit_digit_b = abs(b) % 10;\n    \n    // Compute the product of the unit digits\n    int product = unit_digit_a * unit_digit_b;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Step 1.2: Convert the string to a floating-point number using std::stod\n    double num = stod(value);\n\n    // Step 2.1: Use the round function to get the closest integer\n    double rounded = round(num);\n\n    // Step 2.2: Check if the number is exactly halfway between two integers\n    if (fabs(num - rounded) == 0.5) {\n        // Step 3.1: Use copysign to determine the direction of rounding (away from zero)\n        rounded = copysign(rounded + 0.5, num);\n    }\n\n    // Step 4.1: Convert the final integer value to an int type\n    int result = static_cast<int>(rounded);\n\n    // Step 4.2: Return the integer value\n    return result;\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    stones.push_back(n);\n    \n    int current_stones = n;\n    for (int i = 1; i < n; ++i) {\n        if (current_stones % 2 == 0) {\n            // Next even number\n            current_stones += 2;\n        } else {\n            // Next odd number\n            current_stones += 2;\n        }\n        stones.push_back(current_stones);\n    }\n    \n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use a loop to extract words based on delimiters\n    while (getline(ss, word, ',')) {\n        // Remove leading/trailing spaces from the word\n        word.erase(remove(word.begin(), word.end(), ' '), word.end());\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n    }\n    \n    // Handle spaces as delimiters\n    ss.clear();\n    ss.str(s);\n    while (getline(ss, word, ' ')) {\n        word.erase(remove(word.begin(), word.end(), ','), word.end());\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n    }\n    \n    // Remove duplicates and sort the words\n    sort(words.begin(), words.end());\n    words.erase(unique(words.begin(), words.end()), words.end());\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Input Validation\n    if (x <= 0 || y <= 0) {\n        return -1;  // Invalid input\n    }\n\n    // Step 2: Range Adjustment\n    if (x > y) {\n        return -1;  // Invalid range\n    }\n\n    // Step 3: Finding the Biggest Even Number\n    int max_even = -1;\n    for (int i = x; i <= y; i++) {\n        if (i % 2 == 0) {  // Check if i is even\n            if (i > max_even) {\n                max_even = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    return max_even;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Step 1: Input Validation\n    if (n > m) return \"-1\";\n\n    // Step 2: Calculate the Sum of the Range\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n\n    // Step 3: Compute the Average\n    double average = static_cast<double>(sum) / (m - n + 1);\n\n    // Step 4: Round the Average\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Step 5: Convert to Binary\n    string binary_representation = \"\";\n    int temp = rounded_average;\n    if (temp == 0) {\n        binary_representation = \"0\";\n    } else {\n        while (temp > 0) {\n            binary_representation = to_string(temp % 2) + binary_representation;\n            temp /= 2;\n        }\n    }\n\n    // Step 6: Return the Binary String\n    return binary_representation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number contains any even digit\nbool hasEvenDigit(int num) {\n    string numStr = to_string(num);\n    for (char digit : numStr) {\n        if (digit == '0' || digit == '2' || digit == '4' || digit == '6' || digit == '8') {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Main function to filter and sort the vector\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    // Filter out elements with even digits\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the filtered vector\n    sort(result.begin(), result.end());\n    \n    // Return the sorted vector\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter and validate input\n    vector<int> valid_numbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            valid_numbers.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the valid vector\n    sort(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 4: Map digits to corresponding names\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n    for (int num : valid_numbers) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    // Step 5: Handle edge cases (already handled by the above steps)\n\n    // Step 6: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nint factorial(int num) {\n    int result = 1;\n    for (int j = 1; j <= num; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\nint sum(int num) {\n    int result = 0;\n    for (int j = 1; j <= num; ++j) {\n        result += j;\n    }\n    return result;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i-1] = factorial(i);\n        } else {\n            result[i-1] = sum(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    // Initialize counters for even and odd palindromes\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Loop through each number in the range [1, n]\n    for (int i = 1; i <= n; ++i) {\n        // Convert the number to a string\n        string num_str = to_string(i);\n        \n        // Check if the string is a palindrome\n        string rev_str = num_str;\n        reverse(rev_str.begin(), rev_str.end());\n        \n        if (num_str == rev_str) {\n            // If it is a palindrome, check if it is even or odd\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    // Return the result as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    if (n.empty()) {\n        return 0;\n    }\n\n    int count = 0;\n    for (int num : n) {\n        int sum_of_digits = 0;\n        int abs_num = abs(num);\n        int sign = (num < 0) ? -1 : 1;\n        while (abs_num > 0) {\n            int digit = abs_num % 10;\n            sum_of_digits += sign * digit;\n            abs_num /= 10;\n        }\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        return true;\n    }\n\n    // Step 2: Identify the Sorted Position\n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Step 3: Check for Sorted Sequence\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        // Rotate the array by i positions\n        vector<int> rotated_arr(arr.begin() + i, arr.end());\n        rotated_arr.insert(rotated_arr.end(), arr.begin(), arr.begin() + i);\n\n        // Check if the rotated array matches the sorted array\n        if (rotated_arr == sorted_arr) {\n            return true;\n        }\n    }\n\n    // Step 4: Return the Result\n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountLst1 = 0;\n    int evenCountLst2 = 0;\n\n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    // Compare counts and return result\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Step 1: Input Parsing\n    vector<char> letters;\n    stringstream ss(test);\n    char letter;\n    while (ss >> letter) {\n        letters.push_back(letter);\n    }\n\n    // Step 2: Frequency Counting\n    map<char, int> frequency_map;\n    for (char l : letters) {\n        frequency_map[l]++;\n    }\n\n    // Step 3: Determine Maximum Frequency\n    int max_frequency = 0;\n    for (const auto& entry : frequency_map) {\n        if (entry.second > max_frequency) {\n            max_frequency = entry.second;\n        }\n    }\n\n    // Step 4: Filter Letters by Maximum Frequency\n    map<char, int> result_map;\n    for (const auto& entry : frequency_map) {\n        if (entry.second == max_frequency) {\n            result_map[entry.first] = entry.second;\n        }\n    }\n\n    // Step 5: Output the Result\n    return result_map;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Step 1: Character Deletion\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Step 2: Palindrome Check\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n\n    // Step 3: Result Packaging\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n\n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& str : lst) {\n        int odd_count = 0;\n        for (char c : str) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                odd_count++;\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(odd_count) + \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) + \" of the \" + to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <limits.h>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    // Step 1: Input Validation\n    if (nums.empty()) {\n        // Handle empty vector case\n        return 0; // or throw an error, depending on system requirements\n    }\n\n    // Step 2: Initialization\n    long long minSum = LONG_LONG_MAX;\n\n    // Step 3: Iterate Through Sub-Vectors\n    for (int start = 0; start < nums.size(); ++start) {\n        long long currentSum = 0;\n        for (int end = start; end < nums.size(); ++end) {\n            currentSum += nums[end];\n            // Step 4: Calculate Sub-Vector Sums\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n        }\n    }\n\n    // Step 5: Edge Case Handling\n    // (Implicitly handled by the loop structure)\n\n    // Step 6: Return the Result\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint count_water_units(const vector<int>& row) {\n    int count = 0;\n    for (int unit : row) {\n        if (unit == 1) count++;\n    }\n    return count;\n}\n\nint calculate_lowerings(int water_units, int capacity) {\n    return (water_units + capacity - 1) / capacity; // Integer division with ceiling\n}\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    for (const vector<int>& row : grid) {\n        int water_units = count_water_units(row);\n        int lowerings = calculate_lowerings(water_units, capacity);\n        total_lowerings += lowerings;\n    }\n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator function\nbool compare_by_ones_and_value(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b; // If number of ones is the same, compare by decimal value\n    }\n    return ones_a < ones_b; // Otherwise, compare by number of ones\n}\n\n// Main function to sort the array\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare_by_ones_and_value);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) {\n        return {};\n    }\n\n    vector<string> result;\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    istringstream iss(s);\n    string word;\n\n    while (iss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            if (vowels.find(c) == vowels.end()) {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define vowels and consonants\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    unordered_set<char> consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'};\n    \n    // Traverse the word from right to left\n    bool last_was_consonant = false;\n    for (int i = word.size() - 1; i >= 0; --i) {\n        char ch = word[i];\n        if (consonants.count(ch)) {\n            last_was_consonant = true;\n        } else if (vowels.count(ch)) {\n            if (last_was_consonant) {\n                return string(1, ch);\n            }\n        }\n    }\n    \n    // If no valid vowel found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Step 2: Count parentheses\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n    for (char c : lst[0]) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n    for (char c : lst[1]) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Step 3: Balance check\n    if (open1 + open2 != close1 + close2) return \"No\";\n\n    // Step 4: Concatenation and validation\n    string concat1 = lst[0] + lst[1];\n    string concat2 = lst[1] + lst[0];\n\n    auto isBalanced = [](const string& s) {\n        int balance = 0;\n        for (char c : s) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        return balance == 0;\n    };\n\n    if (isBalanced(concat1) || isBalanced(concat2)) return \"Yes\";\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Input validation\n    if (k < 0 || k > arr.size()) {\n        return {};\n    }\n\n    // Sort the vector in ascending order\n    sort(arr.begin(), arr.end());\n\n    // Extract the top k elements\n    vector<int> result(arr.end() - k, arr.end());\n\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (arr.empty() || k < 1 || k > arr.size()) {\n        // Handle error (e.g., return -1 or throw an exception)\n        return -1;\n    }\n\n    // Step 2: Extract the first k elements\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        // Step 3: Identify elements with at most two digits\n        if (arr[i] < 100) {\n            // Step 4: Sum the valid elements\n            sum += arr[i];\n        }\n    }\n\n    // Step 5: Return the result\n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add the final 1 to the sequence\n\n    // Filter and collect odd numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <sstream>\n#include <iostream>\nusing namespace std;\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    // Step 1: Input Parsing and Format Check\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    \n    string mm = date.substr(0, 2);\n    string dd = date.substr(3, 2);\n    string yyyy = date.substr(6, 4);\n    \n    // Convert strings to integers\n    int month, day, year;\n    try {\n        month = stoi(mm);\n        day = stoi(dd);\n        year = stoi(yyyy);\n    } catch (const invalid_argument&) {\n        return false;\n    }\n    \n    // Step 2: Month Validation\n    if (month < 1 || month > 12) {\n        return false;\n    }\n    \n    // Step 3: Day Validation\n    bool valid_day = false;\n    if (month == 2) {\n        // February\n        if (is_leap_year(year)) {\n            valid_day = (day >= 1 && day <= 29);\n        } else {\n            valid_day = (day >= 1 && day <= 28);\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // 30-day months\n        valid_day = (day >= 1 && day <= 30);\n    } else {\n        // 31-day months\n        valid_day = (day >= 1 && day <= 31);\n    }\n    \n    // Step 4: Combine Results\n    return valid_day;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Step 1: Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Step 2: Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split on commas\n        istringstream iss(txt);\n        string word;\n        while (getline(iss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Step 3: Count odd-ordered lowercase letters\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int order = c - 'a';\n            if (order % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    \n    // Return the count as a single-element vector\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Step 1: Check if the vector is sorted\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Step 2: Check for duplicate elements\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false;\n        }\n    }\n\n    // Step 3: If both checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Calculate intersection start and end\n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    // Check if intervals intersect\n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    // Calculate length of intersection\n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    // Check if length is prime\n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        int sign = (num > 0) ? 1 : (num < 0) ? -1 : 0;\n        sign_product *= sign;\n        magnitude_sum += abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n// Function to get valid neighbors of a cell\nvector<pair<int, int>> getNeighbors(const vector<vector<int>>& grid, pair<int, int> cell) {\n    vector<pair<int, int>> neighbors;\n    int N = grid.size();\n    int x = cell.first, y = cell.second;\n    if (x > 0) neighbors.push_back({x - 1, y});\n    if (x < N - 1) neighbors.push_back({x + 1, y});\n    if (y > 0) neighbors.push_back({x, y - 1});\n    if (y < N - 1) neighbors.push_back({x, y + 1});\n    return neighbors;\n}\n\n// Function to compare two paths lexicographically\nbool isLexicographicallySmaller(const vector<int>& pathA, const vector<int>& pathB) {\n    return pathA < pathB;\n}\n\n// Recursive function to generate paths\nvoid generatePaths(const vector<vector<int>>& grid, pair<int, int> currentCell, int k, vector<int>& currentPath, vector<int>& minPath) {\n    if (k == 0) {\n        if (minPath.empty() || isLexicographicallySmaller(currentPath, minPath)) {\n            minPath = currentPath;\n        }\n        return;\n    }\n\n    vector<pair<int, int>> neighbors = getNeighbors(grid, currentCell);\n    for (const auto& neighbor : neighbors) {\n        int x = neighbor.first, y = neighbor.second;\n        currentPath.push_back(grid[x][y]);\n        generatePaths(grid, neighbor, k - 1, currentPath, minPath);\n        currentPath.pop_back();\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath;\n    int N = grid.size();\n    \n    // Iterate over all starting cells\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath = {grid[i][j]};\n            generatePaths(grid, {i, j}, k - 1, currentPath, minPath);\n        }\n    }\n    \n    return minPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n < 0) {\n        return {};\n    }\n    \n    vector<int> sequence(n + 1);\n    \n    for (int i = 0; i <= n; ++i) {\n        if (i == 1) {\n            sequence[i] = 3; // Base case\n        } else if (i % 2 == 0) {\n            sequence[i] = 1 + i / 2; // Even case\n        } else {\n            // Odd case: tri(i) = tri(i - 1) + tri(i - 2) + tri(i + 1)\n            // Adjusting the recurrence relation to fit the requirement\n            if (i == 0) {\n                sequence[i] = 1; // Assuming tri(0) = 1 as per the example\n            } else if (i == 2) {\n                sequence[i] = 2; // Assuming tri(2) = 2 as per the example\n            } else {\n                sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1];\n            }\n        }\n    }\n    \n    return sequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert the integer to a string to easily iterate through digits\n    string numStr = to_string(n);\n    \n    int product = 1;\n    bool hasOddDigit = false;\n    \n    // Iterate through each character in the string\n    for (char digitChar : numStr) {\n        int digit = digitChar - '0'; // Convert char to int\n        \n        // Check if the digit is odd\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n    }\n    \n    // If no odd digits were found, return 0\n    if (!hasOddDigit) {\n        return 0;\n    }\n    \n    return product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    // Step 1: Input Validation\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            return false;\n        }\n    }\n\n    // Step 2: Identify Valid Subsequences and Check for Nesting\n    stack<char> s;\n    bool nesting_found = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']') {\n            if (!s.empty() && s.top() == '[') {\n                s.pop();\n                if (s.size() > 0) {\n                    nesting_found = true;\n                }\n            }\n        }\n    }\n\n    // Step 3: Return the Result\n    return nesting_found;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);  // Round to the nearest upper integer\n        sum += rounded_num * rounded_num;  // Square the rounded value and add to sum\n    }\n    return sum;  // Return the final sum of squared values\n}\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Step 1: Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Step 2: Extract the last character\n    char last_char = txt.back();\n\n    // Step 3: Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Step 4: Check if the last character is part of a word\n    if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Initialize the largest index to -1\n    int largest_index = -1;\n    \n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if the current element is not greater than or equal to the previous element\n        if (arr[i] < arr[i - 1]) {\n            // Update the largest index\n            largest_index = i;\n        }\n    }\n    \n    // Return the largest index found, or -1 if no such index exists\n    return largest_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Step 1: Identify and convert types\n    float val1, val2;\n    bool is_val1_string = false, is_val2_string = false;\n\n    if (a.type() == typeid(int)) {\n        val1 = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val1 = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        string str1 = boost::any_cast<string>(a);\n        replace(str1.begin(), str1.end(), ',', '.');\n        val1 = stof(str1);\n        is_val1_string = true;\n    }\n\n    if (b.type() == typeid(int)) {\n        val2 = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val2 = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        string str2 = boost::any_cast<string>(b);\n        replace(str2.begin(), str2.end(), ',', '.');\n        val2 = stof(str2);\n        is_val2_string = true;\n    }\n\n    // Step 2: Compare the values\n    if (val1 == val2) {\n        return \"None\";\n    } else if (val1 > val2) {\n        return is_val1_string ? boost::any(to_string(val1)) : a;\n    } else {\n        return is_val2_string ? boost::any(to_string(val2)) : b;\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Early exit for numbers less than 8\n    if (n < 8) {\n        return false;\n    }\n\n    // Iterate over possible combinations of 4 even numbers\n    for (int i = 2; i <= n - 6; i += 2) {\n        for (int j = i; j <= n - 4; j += 2) {\n            for (int k = j; k <= n - 2; k += 2) {\n                for (int l = k; l <= n; l += 2) {\n                    if (i + j + k + l == n) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to compute the factorial of a given integer k\nlong long factorial(int k) {\n    if (k <= 1) return 1;\n    long long result = 1;\n    for (int i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the Brazilian factorial of a given integer n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/140", "generation": "#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces == 1) {\n                result += '_';\n            } else if (consecutive_spaces > 1) {\n                result += '-';\n            }\n            consecutive_spaces = 0;\n            result += c;\n        }\n    }\n\n    if (consecutive_spaces == 1) {\n        result += '_';\n    } else if (consecutive_spaces > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype>\n#include <unordered_set>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    if (file_name.empty()) return \"No\";\n\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_index = string::npos;\n\n    for (size_t i = 0; i < file_name.size(); ++i) {\n        if (isdigit(file_name[i])) {\n            ++digit_count;\n            if (digit_count > 3) return \"No\";\n        } else if (file_name[i] == '.') {\n            ++dot_count;\n            if (dot_count > 1) return \"No\";\n            dot_index = i;\n        }\n    }\n\n    if (dot_count != 1) return \"No\";\n\n    string pre_dot = file_name.substr(0, dot_index);\n    string post_dot = file_name.substr(dot_index + 1);\n\n    if (pre_dot.empty() || !isalpha(pre_dot[0])) return \"No\";\n\n    unordered_set<string> allowed_extensions = {\"txt\", \"exe\", \"dll\"};\n    if (allowed_extensions.find(post_dot) == allowed_extensions.end()) return \"No\";\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n        sum += lst[i];\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split a string into words\nvector<string> split_sentence(const string& sentence) {\n    vector<string> words;\n    istringstream stream(sentence);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to process the sentence\nstring words_in_sentence(string sentence) {\n    vector<string> words = split_sentence(sentence);\n    vector<string> prime_length_words;\n    \n    for (const string& word : words) {\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n    \n    string result;\n    for (size_t i = 0; i < prime_length_words.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += prime_length_words[i];\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to compute the GCD of two numbers\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool simplify(string x, string n) {\n    // Step 1: Parse the input strings\n    int num1, den1, num2, den2;\n    sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n    sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n    // Step 2: Multiply the fractions\n    int result_num = num1 * num2;\n    int result_den = den1 * den2;\n\n    // Step 3: Simplify the resulting fraction\n    int common_divisor = gcd(result_num, result_den);\n    result_num /= common_divisor;\n    result_den /= common_divisor;\n\n    // Step 4: Check if the result is a whole number\n    return result_den == 1;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\n// Data structure to store the integer, sum of digits, and original index\nstruct NumInfo {\n    int num;\n    int sum_of_digits;\n    int original_index;\n};\n\n// Custom comparator for sorting\nbool compare_num_info(const NumInfo& a, const NumInfo& b) {\n    if (a.sum_of_digits != b.sum_of_digits) {\n        return a.sum_of_digits < b.sum_of_digits;\n    }\n    return a.original_index < b.original_index;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    if (nums.empty()) {\n        return {};\n    }\n\n    vector<NumInfo> num_info_list;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_info_list.push_back({nums[i], sum_of_digits(nums[i]), i});\n    }\n\n    sort(num_info_list.begin(), num_info_list.end(), compare_num_info);\n\n    vector<int> sorted_nums;\n    for (const auto& info : num_info_list) {\n        sorted_nums.push_back(info.num);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <cmath> // for abs()\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            int absNum = abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            \n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            \n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    // Step 2: Count valid triples\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Step 3: Return the count of valid triples\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nbool isValidPlanet(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) != planets.end();\n}\n\nint getPlanetIndex(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) - planets.begin();\n}\n\nvector<string> bf(string planet1, string planet2) {\n    if (!isValidPlanet(planet1) || !isValidPlanet(planet2)) {\n        return {};\n    }\n    \n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n    \n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Ascending order by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true; // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Other even numbers are not prime\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to return x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    // Initialize the sum of squares to 0\n    long long sum_of_squares = 0;\n    \n    // Iterate through each element in the vector\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                // Compute the square and add to the sum\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n    \n    // Return the final sum of squares\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // for std::abs\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    // Step 1: Input Validation\n    if (game.size() != guess.size()) {\n        // Handle error: vectors are not of the same length\n        return {}; // or throw an exception\n    }\n\n    // Step 2: Initialize result vector\n    std::vector<int> result(game.size());\n\n    // Step 3: Comparison Loop\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <climits>\n#include <cctype>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n        int strength = CAP - SM;\n        if (strength > max_strength || (strength == max_strength && ext < strongest_extension)) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvector<string> generate_rotations(const string& b) {\n    vector<string> rotations;\n    int n = b.length();\n    for (int i = 0; i < n; ++i) {\n        string rotation = b.substr(i) + b.substr(0, i);\n        rotations.push_back(rotation);\n    }\n    return rotations;\n}\n\n// Main function to check if any rotation of b is a substring of a\nbool cycpattern_check(const string& a, const string& b) {\n    if (a.empty() || b.empty()) return false;\n    \n    vector<string> rotations = generate_rotations(b);\n    \n    for (const string& rotation : rotations) {\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <cmath> // for abs()\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Handle negative numbers\n    num = abs(num);\n    \n    // Process each digit\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n    \n    // Return the result as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Step 1: Define the Roman numeral mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    // Step 2: Initialize the result string\n    string result = \"\";\n    \n    // Step 3: Iterate through the mapping and build the Roman numeral string\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    \n    // Step 4: Convert the result to lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // for std::max\n#include <cmath>     // for std::pow\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return false;\n    }\n\n    // Step 2: Identify the Hypotenuse\n    float h = std::max({a, b, c});\n\n    // Step 3: Apply the Pythagorean Theorem\n    float h_squared = std::pow(h, 2);\n    float sum_of_squares = std::pow(a, 2) + std::pow(b, 2) + std::pow(c, 2) - h_squared;\n\n    // Step 4: Return the Result\n    return h_squared == sum_of_squares;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_characters(const string& word) {\n    unordered_set<char> unique_chars(word.begin(), word.end());\n    return unique_chars.size();\n}\n\n// Comparison function to compare two strings based on unique characters and lexicographical order\nint compare_strings(const string& a, const string& b) {\n    int unique_a = count_unique_characters(a);\n    int unique_b = count_unique_characters(b);\n    \n    if (unique_a > unique_b) {\n        return 1;\n    } else if (unique_a < unique_b) {\n        return -1;\n    } else {\n        return a.compare(b);\n    }\n}\n\n// Main function to find the word with the maximum number of unique characters\nstring find_max(vector<string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    string best_word = words[0];\n    for (const string& word : words) {\n        if (compare_strings(word, best_word) > 0) {\n            best_word = word;\n        }\n    }\n\n    return best_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Step 1: Input Validation\n    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n        // Handle invalid input (e.g., return an error vector or throw an exception)\n        return {-1, -1}; // Example error handling\n    }\n\n    // Step 2: Calculate Total Carrots Eaten\n    int totalEaten = number + need;\n\n    // Step 3: Determine Carrots Left\n    int carrotsLeft = 0;\n    if (totalEaten <= remaining) {\n        carrotsLeft = remaining - totalEaten;\n    } else {\n        // Step 4: Handle Insufficient Carrots\n        totalEaten = number + remaining;\n        carrotsLeft = 0;\n    }\n\n    // Step 5: Return the Result\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stdexcept>\n#include <sstream>\n#include <cmath>\n#include <stack>\n#include <iostream>\n\nusing namespace std;\n\nint evaluateExpression(const string& expression);\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Input Validation\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Invalid input: operator and operand vector lengths do not match.\");\n    }\n    for (int num : operand) {\n        if (num < 0) {\n            throw invalid_argument(\"Invalid input: operand vector contains negative integers.\");\n        }\n    }\n\n    // Step 2: Expression Construction\n    string expression;\n    for (size_t i = 0; i < operato.size(); ++i) {\n        expression += to_string(operand[i]) + \" \" + operato[i] + \" \";\n    }\n    expression += to_string(operand.back());\n\n    // Step 3: Expression Evaluation\n    try {\n        int result = evaluateExpression(expression);\n        return result;\n    } catch (const exception& e) {\n        throw runtime_error(\"Error during expression evaluation: \" + string(e.what()));\n    }\n}\n\nint evaluateExpression(const string& expression) {\n    // Custom expression evaluator using a stack\n    stack<int> operands;\n    stack<string> operators;\n    stringstream ss(expression);\n    string token;\n\n    while (ss >> token) {\n        if (isdigit(token[0]) || (token[0] == '-' && token.size() > 1)) {\n            // Token is an operand\n            operands.push(stoi(token));\n        } else {\n            // Token is an operator\n            while (!operators.empty() && \n                   ((token == \"+\" || token == \"-\") && (operators.top() == \"*\" || operators.top() == \"/\" || operators.top() == \"**\")) ||\n                   ((token == \"*\" || token == \"/\") && (operators.top() == \"**\")) ||\n                   (token == \"**\" && operators.top() == \"**\")) {\n                // Pop higher precedence operators\n                string op = operators.top();\n                operators.pop();\n                int b = operands.top();\n                operands.pop();\n                int a = operands.top();\n                operands.pop();\n                if (op == \"+\") operands.push(a + b);\n                else if (op == \"-\") operands.push(a - b);\n                else if (op == \"*\") operands.push(a * b);\n                else if (op == \"/\") {\n                    if (b == 0) throw runtime_error(\"Division by zero.\");\n                    operands.push(a / b);\n                }\n                else if (op == \"**\") operands.push(pow(a, b));\n            }\n            operators.push(token);\n        }\n    }\n\n    // Evaluate remaining operators\n    while (!operators.empty()) {\n        string op = operators.top();\n        operators.pop();\n        int b = operands.top();\n        operands.pop();\n        int a = operands.top();\n        operands.pop();\n        if (op == \"+\") operands.push(a + b);\n        else if (op == \"-\") operands.push(a - b);\n        else if (op == \"*\") operands.push(a * b);\n        else if (op == \"/\") {\n            if (b == 0) throw runtime_error(\"Division by zero.\");\n            operands.push(a / b);\n        }\n        else if (op == \"**\") operands.push(pow(a, b));\n    }\n\n    return operands.top();\n}\n"}
{"task_id": "CPP/161", "generation": "#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    string result = \"\";\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.c_str(), text.length());\n    MD5_Final(digest, &ctx);\n\n    char md5string[33];\n    for (int i = 0; i < 16; ++i) {\n        sprintf(&md5string[i*2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5string);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Define the even digits\n    vector<int> even_digits = {0, 2, 4, 6, 8};\n    vector<int> result;\n    \n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Filter even digits within the range\n    for (int num : even_digits) {\n        if (num >= start && num <= end) {\n            result.push_back(num);\n        }\n    }\n    \n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.empty() || threshold <= 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    \n    // Step 1: Clean the input string (remove spaces)\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    // Step 2: Identify and extract balanced parentheses groups\n    stack<char> s;\n    string current_group;\n    for (char c : paren_string) {\n        current_group += c;\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (!s.empty() && s.top() == '(') {\n                s.pop();\n            }\n        }\n        if (s.empty() && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n    \n    // Step 3: Validate each group (already done implicitly by the stack approach)\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.empty()) {\n        // Handle empty input case\n        return 0.0; // or throw an exception\n    }\n\n    // Step 2: Calculate the Mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 3: Compute Absolute Differences\n    float sum_of_abs_diff = 0.0;\n    for (float num : numbers) {\n        sum_of_abs_diff += fabs(num - mean);\n    }\n\n    // Step 4: Calculate the Mean of Absolute Differences\n    float mad = sum_of_abs_diff / numbers.size();\n\n    // Step 5: Return the Result\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nvector<string> split_by_spaces(const string& paren_string) {\n    vector<string> groups;\n    istringstream stream(paren_string);\n    string group;\n    while (stream >> group) {\n        groups.push_back(group);\n    }\n    return groups;\n}\n\nint calculate_max_nesting_level(const string& paren_group) {\n    int max_level = 0;\n    int current_level = 0;\n    for (char ch : paren_group) {\n        if (ch == '(') {\n            current_level++;\n            if (current_level > max_level) {\n                max_level = current_level;\n            }\n        } else if (ch == ')') {\n            current_level--;\n        }\n    }\n    return max_level;\n}\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<string> groups = split_by_spaces(paren_string);\n    vector<int> results;\n    for (const string& group : groups) {\n        results.push_back(calculate_max_nesting_level(group));\n    }\n    return results;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Step 1: Input Validation\n    if (strings.empty()) return {};\n    if (substring.empty()) return strings;\n\n    // Step 2: Initialize result vector\n    vector<string> result;\n\n    // Step 3: Iterate through each string and filter\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n\n    // Step 4: Return the filtered result\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Input Validation\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Sum Calculation\n    int sum = 0;\n    for (int num : numbers) {\n        sum += num;\n    }\n\n    // Product Calculation\n    int product = 1;\n    for (int num : numbers) {\n        product *= num;\n    }\n\n    // Result Construction\n    vector<int> result = {sum, product};\n    return result;\n}\n"}
{"task_id": "CPP/9", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            string reversed_prefix = string(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    // If no palindromic suffix is found, reverse the entire string and append\n    return str + string(str.rbegin(), str.rend());\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\n#include <stdexcept>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Input validation\n    if (a.empty() || b.empty()) {\n        return \"\";\n    }\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must be of the same length.\");\n    }\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input string a contains invalid characters.\");\n        }\n    }\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input string b contains invalid characters.\");\n        }\n    }\n\n    // Binary XOR operation\n    string result;\n    result.reserve(a.length());\n    for (size_t i = 0; i < a.length(); ++i) {\n        result.push_back((a[i] - '0') ^ (b[i] - '0') + '0');\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    // Input Validation\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    // Initialization\n    string longest_string = \"\";\n    size_t max_length = 0;\n\n    // Iteration and Comparison\n    for (const string& str : strings) {\n        if (str.length() > max_length) {\n            longest_string = str;\n            max_length = str.length();\n        }\n        // No need to handle the case where str.length() == max_length\n        // because we want to keep the first longest string.\n    }\n\n    // Return the Result\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Handle edge cases where one of the inputs is zero\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    // Ensure a is greater than or equal to b for the Euclidean Algorithm\n    if (a < b) {\n        swap(a, b);\n    }\n\n    // Implement the Euclidean Algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    // Return the GCD\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {}; // Return an empty vector if the input string is empty\n    }\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n#include <sstream>\n#include <vector>\n\nstd::string string_sequence(int n) {\n    // Step 1: Generate the sequence of numbers\n    std::vector<int> numbers;\n    for (int i = 0; i <= n; ++i) {\n        numbers.push_back(i);\n    }\n\n    // Step 2: Convert numbers to strings and concatenate with spaces\n    std::ostringstream result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result << numbers[i];\n        if (i < numbers.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    // Step 3: Return the concatenated string\n    return result.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include <string>\n#include <set>\n#include <algorithm>\n\nint count_distinct_characters(std::string str) {\n    // Step 1: Convert the string to lowercase\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Step 2: Initialize a set to store unique characters\n    std::set<char> unique_chars;\n    \n    // Step 3: Populate the set with unique characters\n    for (char c : str) {\n        unique_chars.insert(c);\n    }\n    \n    // Step 4: Return the size of the set\n    return unique_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\n\nint get_beats(const string& note) {\n    if (note == \"o\") return 4;\n    if (note == \"o|\") return 2;\n    if (note == \".|\") return 1;\n    return 0; // Handle invalid tokens\n}\n\nvector<int> parse_music(string music_string) {\n    // Step 1: Input Validation\n    if (music_string.empty()) return {};\n\n    // Step 2: Tokenization\n    vector<string> tokens;\n    stringstream ss(music_string);\n    string token;\n    while (ss >> token) {\n        tokens.push_back(token);\n    }\n\n    // Step 3: Mapping Notes to Beats\n    vector<int> beats;\n    for (const string& note : tokens) {\n        int beat = get_beats(note);\n        if (beat > 0) {\n            beats.push_back(beat);\n        }\n    }\n\n    // Step 4: Return the vector of beats\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n\n    int count = 0;\n    int pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next position to check for overlaps\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Define the mapping\n    map<string, int> numeral_to_int = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 2: Parse the input string\n    vector<string> numeral_words;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        if (numeral_to_int.find(word) != numeral_to_int.end()) {\n            numeral_words.push_back(word);\n        } else {\n            // Handle invalid input (optional)\n            throw invalid_argument(\"Invalid numeral: \" + word);\n        }\n    }\n\n    // Step 3: Convert numerals to integers\n    vector<int> int_values;\n    for (const string& numeral : numeral_words) {\n        int_values.push_back(numeral_to_int[numeral]);\n    }\n\n    // Step 4: Sort the integer values\n    sort(int_values.begin(), int_values.end());\n\n    // Step 5: Convert integers back to numerals\n    vector<string> sorted_numerals;\n    for (int value : int_values) {\n        for (const auto& pair : numeral_to_int) {\n            if (pair.second == value) {\n                sorted_numerals.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Step 6: Construct the output string\n    string result;\n    for (size_t i = 0; i < sorted_numerals.size(); ++i) {\n        result += sorted_numerals[i];\n        if (i < sorted_numerals.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    // Step 7: Return the output\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cfloat> // For FLT_MAX\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.size() < 2) {\n        // Handle the error, e.g., return an empty vector\n        return {};\n    }\n\n    // Step 2: Sorting the Vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 3: Finding the Closest Pair\n    float min_diff = FLT_MAX;\n    vector<float> closest_pair;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i - 1], numbers[i]};\n        }\n    }\n\n    // Step 4: Returning the Result\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The input vector must contain at least two elements.\");\n    }\n\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    if (range == 0) {\n        // Handle the case where all elements are the same\n        return vector<float>(numbers.size(), 0.0);\n    }\n\n    vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\n    for (float num : numbers) {\n        rescaled_numbers.push_back((num - min_val) / range);\n    }\n\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    if (str.empty()) {\n        return 0;\n    }\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    // Input validation\n    if (n <= 1) {\n        return 1; // Edge case: n is 1 or less\n    }\n\n    // Finding the largest divisor\n    int max_divisor = 1;\n    for (int i = 2; i < n; ++i) {\n        if (n % i == 0) {\n            max_divisor = i;\n        }\n    }\n\n    return max_divisor;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Input validation\n    if (n <= 0) {\n        // Handle invalid input (e.g., return empty vector)\n        return factors;\n    }\n    \n    // Prime factorization algorithm\n    int d = 2;\n    while (n > 1) {\n        while (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        }\n        d++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    vector<int> result;\n    unordered_map<int, int> count_map;\n\n    // Count occurrences of each element\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Filter unique elements\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<string>\n#include<cctype>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    \n    for (char c : str) {\n        if (isupper(c)) {\n            result += tolower(c);\n        } else if (islower(c)) {\n            result += toupper(c);\n        } else {\n            result += c;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nbool starts_with(const string& str, const string& prefix) {\n    if (prefix.size() > str.size()) return false;\n    return str.compare(0, prefix.size(), prefix) == 0;\n}\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    if (prefix.empty()) return strings;\n    \n    vector<string> result;\n    for (const string& str : strings) {\n        if (starts_with(str, prefix)) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    if (l.empty()) {\n        return vector<float>();\n    }\n\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    long long limit = static_cast<long long>(std::sqrt(n));\n    for (long long i = 3; i <= limit; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Validate input\n    if (xs.size() % 2 != 0 || xs.empty()) {\n        throw invalid_argument(\"xs must have an even number of coefficients and must not be empty.\");\n    }\n\n    // Find the largest non-zero coefficient\n    double max_coeff = 0;\n    for (double coeff : xs) {\n        if (abs(coeff) > abs(max_coeff)) {\n            max_coeff = coeff;\n        }\n    }\n\n    // Newton-Raphson Method\n    double x0 = 0; // Initial guess\n    double epsilon = 1e-7; // Tolerance\n    double x_new, x_old = x0;\n\n    do {\n        x_new = x_old - poly(xs, x_old) / poly_derivative(xs, x_old);\n        if (abs(x_new - x_old) < epsilon) {\n            break;\n        }\n        x_old = x_new;\n    } while (true);\n\n    return x_new;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Input Validation\n    if (l.empty()) return {};\n\n    // Step 2: Identify and Extract Values\n    vector<int> extracted_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            extracted_values.push_back(l[i]);\n        }\n    }\n\n    // Step 3: Sort the Extracted Values\n    sort(extracted_values.begin(), extracted_values.end());\n\n    // Step 4: Reconstruct the Output Vector\n    vector<int> l_prime(l.size());\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l_prime[i] = extracted_values[sorted_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Step 5: Return the Output Vector\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\n\nstd::vector<int> unique(std::vector<int> l) {\n    // Step 1: Remove duplicates using a set\n    std::set<int> uniqueSet(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    std::vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 3: Sort the vector\n    std::sort(uniqueVector.begin(), uniqueVector.end());\n    \n    // Step 4: Return the sorted vector\n    return uniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    if (l.empty()) return l;\n\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    sort(even_elements.begin(), even_elements.end());\n\n    vector<float> result(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_elements[i / 2];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // reverse the cycling operation within each group of three.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int a = 1, b = 1;\n    int count = 0;\n    while (true) {\n        int next_fib = a + b;\n        a = b;\n        b = next_fib;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Step 1: Input Validation\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Step 2: Triple Combination Generation\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                // Step 3: Sum Calculation and Comparison\n                if (l[i] + l[j] + l[k] == 0) {\n                    // Step 4: Result Determination\n                    return true;\n                }\n            }\n        }\n    }\n\n    // Step 4: Result Determination\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\n\nint car_race_collision(int n) {\n    // Calculate the number of collisions\n    int collisions = n * n;\n    \n    // Return the result\n    return collisions;\n}\n\n// Example usage\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); i++) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <string>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Input validation\n    if (base >= 10) {\n        return \"\"; // or throw an error\n    }\n\n    // Edge case: if x is 0, return \"0\"\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Base conversion logic\n    string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result += to_string(remainder);\n        x /= base;\n    }\n\n    // Reverse the result string to get the correct order\n    reverse(result.begin(), result.end());\n\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float h) {\n    if (a <= 0 || h <= 0) {\n        std::cerr << \"Error: Base and height must be positive numbers.\" << std::endl;\n        return -1; // Return a special value to indicate error\n    }\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdexcept>\n\nint fib4(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be non-negative.\");\n    }\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib4_0 = 0, fib4_1 = 0, fib4_2 = 2, fib4_3 = 0;\n    int result = 0;\n    for (int i = 4; i <= n; i++) {\n        result = fib4_0 + fib4_1 + fib4_2 + fib4_3;\n        fib4_0 = fib4_1;\n        fib4_1 = fib4_2;\n        fib4_2 = fib4_3;\n        fib4_3 = result;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n#include <stdexcept>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Input Validation\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n\n    // Step 2: Sorting the Vector\n    sort(l.begin(), l.end());\n\n    // Step 3: Calculating the Median\n    int size = l.size();\n    if (size % 2 == 1) {\n        return l[size / 2];\n    } else {\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true;\n    }\n\n    string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n\n    return text == reversed_text;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    if (p == 1) return 0;\n\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    for (char c : text) {\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Input validation: Check if the vector is empty\n    if (l.empty()) {\n        return true; // Assuming an empty vector should return true\n    }\n\n    // Iteration and comparison\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Return false if any element is greater than or equal to the threshold\n        }\n    }\n\n    // Final decision: All elements are below the threshold\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    int result = x + y;\n    return result;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\n// Helper function to count character frequencies\nunordered_map<char, int> count_chars(const string& s) {\n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    return freq;\n}\n\n// Main function to check if two strings have the same characters\nbool same_chars(string s0, string s1) {\n    // Edge case: If both strings are empty, return true\n    if (s0.empty() && s1.empty()) return true;\n    \n    // Edge case: If only one string is empty, return false\n    if (s0.empty() || s1.empty()) return false;\n    \n    // Get frequency maps for both strings\n    auto freq0 = count_chars(s0);\n    auto freq1 = count_chars(s1);\n    \n    // Compare the frequency maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n#include <unordered_map>\n#include <stdexcept>\n\nusing namespace std;\n\nint fib(int n) {\n    if (n < 0) {\n        throw invalid_argument(\"Input must be a non-negative integer.\");\n    }\n\n    static unordered_map<int, int> memo;\n\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    if (memo.find(n) != memo.end()) {\n        return memo[n];\n    }\n\n    memo[n] = fib(n - 1) + fib(n - 2);\n    return memo[n];\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    // Step 1: Input Validation\n    for (char c : brackets) {\n        if (c != '<' && c != '>') {\n            return false; // Invalid input\n        }\n    }\n\n    // Step 2: Counting Brackets\n    int open_count = 0, close_count = 0;\n    for (char c : brackets) {\n        if (c == '<') open_count++;\n        if (c == '>') close_count++;\n    }\n\n    // Step 3: Matching Brackets\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else if (c == '>') {\n            if (s.empty()) {\n                return false; // Unmatched closing bracket\n            }\n            s.pop();\n        }\n    }\n\n    // Step 4: Output the Result\n    return s.empty() && open_count == close_count;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Input Validation\n    if (l1.empty() || l2.empty()) {\n        return {};\n    }\n\n    // Step 2: Intersection Calculation\n    set<int> set1(l1.begin(), l1.end());\n    set<int> commonSet;\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            commonSet.insert(num);\n        }\n    }\n\n    // Step 3: Conversion to Vector\n    vector<int> result(commonSet.begin(), commonSet.end());\n\n    // Step 4: Sorting (already sorted since using set)\n\n    // Step 5: Return Result\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int factor = 2;\n\n    while (n > 1) {\n        if (n % factor == 0) {\n            largest_factor = factor;\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    if (n < 1) {\n        return 0;\n    }\n    return n * (n + 1) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    // Step 1: Input Validation\n    if (brackets.empty()) return false;\n    for (char c : brackets) {\n        if (c != '(' && c != ')') return false;\n    }\n\n    // Step 2: Tracking Brackets\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        // Step 3: Early Exit if Unmatched Closing Bracket\n        if (balance < 0) return false;\n    }\n\n    // Step 4: Final Check\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Step 1: Input Validation\n    if (xs.empty()) {\n        return {};\n    }\n\n    // Step 2: Derivative Calculation\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n\n    // Step 3: Output Formatting\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize variables for the first three FibFib numbers\n    int a = 0, b = 0, c = 1;\n    int result = 0;\n\n    // Iterate from 3 to n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c;  // Compute the next FibFib number\n        a = b;  // Update a to the value of b\n        b = c;  // Update b to the value of c\n        c = result;  // Update c to the value of the newly computed FibFib number\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    c = tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nint vowels_count(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (is_vowel(s[i])) {\n            count++;\n        }\n    }\n    if (s.length() > 0 && s[s.length() - 1] == 'y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    \n    // Determine the number of digits\n    int num_digits = str_x.length();\n    \n    // Check the shift condition\n    if (shift >= num_digits) {\n        // Reverse the string\n        reverse(str_x.begin(), str_x.end());\n    } else {\n        // Perform circular shift\n        string shifted_part = str_x.substr(num_digits - shift);\n        string remaining_part = str_x.substr(0, num_digits - shift);\n        str_x = shifted_part + remaining_part;\n    }\n    \n    // Return the result\n    return str_x;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Step 1: Parse the input string\n    regex pattern(\"(\\\\d+) apples and (\\\\d+) oranges\");\n    smatch match;\n    if (regex_search(s, match, pattern)) {\n        int apples = stoi(match[1]);\n        int oranges = stoi(match[2]);\n        \n        // Step 2: Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        \n        // Step 3: Return the result\n        return mangoes;\n    } else {\n        // Handle invalid input format\n        cerr << \"Invalid input format\" << endl;\n        return -1; // or throw an exception\n    }\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits.h>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Step 2: Initialization\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n\n    // Step 3: Iterate Through the Vector\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even || (arr[i] == smallest_even && i < smallest_index)) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    if (smallest_index == -1) {\n        return {};\n    } else {\n        return {smallest_even, smallest_index};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 2: Frequency Counting\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Step 3: Filtering and Validation\n    std::vector<int> validIntegers;\n    for (const auto& pair : frequencyMap) {\n        if (pair.second >= pair.first) {\n            validIntegers.push_back(pair.first);\n        }\n    }\n\n    // Step 4: Finding the Maximum Valid Integer\n    if (validIntegers.empty()) {\n        return -1; // Step 5: Edge Case Handling\n    }\n\n    int maxValidInteger = *std::max_element(validIntegers.begin(), validIntegers.end());\n\n    // Step 6: Output the Result\n    return maxValidInteger;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Sort the input vector\n    sort(lst.begin(), lst.end());\n    \n    // Step 2: Initialize pointers\n    int min_ptr = 0;\n    int max_ptr = lst.size() - 1;\n    \n    // Step 3: Result vector to store the final order\n    vector<int> result;\n    \n    // Step 4: Alternately extract values\n    while (min_ptr <= max_ptr) {\n        if (min_ptr <= max_ptr) {\n            result.push_back(lst[min_ptr++]);\n        }\n        if (min_ptr <= max_ptr) {\n            result.push_back(lst[max_ptr--]);\n        }\n    }\n    \n    // Step 5: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = std::round(area * 100) / 100;\n\n    return area;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function to check if the vector is palindromic\nbool is_palindromic(vector<int> q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper function to calculate the sum of the vector elements\nint sum_of_elements(vector<int> q) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum;\n}\n\n// Helper function to check if the sum is within the limit\nbool is_sum_within_limit(int sum, int w) {\n    return sum <= w;\n}\n\n// Main function to determine if the object will fly\nbool will_it_fly(vector<int> q, int w) {\n    // Input validation (optional, depending on requirements)\n    if (q.empty() || w <= 0) {\n        return false;\n    }\n\n    // Check if the vector is palindromic\n    bool is_balanced = is_palindromic(q);\n\n    // Calculate the sum of the vector elements\n    int sum = sum_of_elements(q);\n\n    // Check if the sum is within the limit\n    bool is_light_enough = is_sum_within_limit(sum, w);\n\n    // Combine the results\n    return is_balanced && is_light_enough;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int mismatch_count = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            mismatch_count++;\n        }\n        left++;\n        right--;\n    }\n\n    return mismatch_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate the total number of characters in a vector of strings\nint calculate_total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\n// Main function to compare two vectors of strings\nvector<string> total_match(const vector<string>& lst1, const vector<string>& lst2) {\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else if (total_chars_lst2 < total_chars_lst1) {\n        return lst2;\n    } else {\n        return lst1; // If both have the same number of characters, return the first vector\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> generate_primes_less_than_100() {\n    std::vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    if (a < 6) return false;\n\n    std::vector<int> primes = generate_primes_less_than_100();\n    int n = primes.size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    // Iterative power calculation\n    int power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\n\nbool iscube(int a) {\n    double cube_root = cbrt(a);\n    int int_cube_root = static_cast<int>(cube_root);\n    return int_cube_root == cube_root;\n}\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nconst unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <string>\n#include <algorithm> // for std::reverse\n\nstd::string decimal_to_binary(int decimal) {\n    // Step 1: Convert decimal to binary\n    std::string binary_str;\n    if (decimal == 0) {\n        binary_str = \"0\";\n    } else {\n        while (decimal > 0) {\n            binary_str += (decimal % 2) ? '1' : '0';\n            decimal /= 2;\n        }\n        std::reverse(binary_str.begin(), binary_str.end());\n    }\n\n    // Step 2: Format the binary string\n    std::string formatted_str = \"db\" + binary_str + \"db\";\n\n    // Step 3: Return the result\n    return formatted_str;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Loop through the string from the beginning to the third-to-last character\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // Extract the three consecutive characters\n        char first = s[i];\n        char second = s[i + 1];\n        char third = s[i + 2];\n\n        // Check if all three characters are distinct\n        if (first == second || first == third || second == third) {\n            return false;\n        }\n    }\n\n    // If all sets of 3 consecutive characters are distinct, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring convert_gpa_to_letter_grade(float gpa) {\n    if (gpa == 4.0) return \"A+\";\n    if (gpa > 3.7) return \"A\";\n    if (gpa > 3.3) return \"A-\";\n    if (gpa > 3.0) return \"B+\";\n    if (gpa > 2.7) return \"B\";\n    if (gpa > 2.3) return \"B-\";\n    if (gpa > 2.0) return \"C+\";\n    if (gpa > 1.7) return \"C\";\n    if (gpa > 1.3) return \"C-\";\n    if (gpa > 1.0) return \"D+\";\n    if (gpa > 0.7) return \"D\";\n    if (gpa > 0.0) return \"D-\";\n    if (gpa == 0.0) return \"E\";\n    return \"Invalid\";\n}\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        string letter_grade = convert_gpa_to_letter_grade(gpa);\n        letter_grades.push_back(letter_grade);\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    return is_prime(str.length());\n}\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n\nint starts_one_ends(int n) {\n    // Step 1: Input validation\n    if (n <= 0) return 0;\n\n    // Step 2: Calculate the range of n-digit numbers\n    int smallest_n_digit = pow(10, n - 1);\n    int largest_n_digit = pow(10, n) - 1;\n\n    // Step 3: Count numbers starting with '1'\n    int count_starts_with_1 = pow(10, n - 1);\n\n    // Step 4: Count numbers ending with '1'\n    int count_ends_with_1 = pow(10, n - 1);\n\n    // Step 5: Count numbers starting and ending with '1'\n    int count_starts_and_ends_with_1 = (n > 1) ? pow(10, n - 2) : 1;\n\n    // Step 6: Combine the counts\n    int total_count = count_starts_with_1 + count_ends_with_1 - count_starts_and_ends_with_1;\n\n    // Step 7: Return the result\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Sum of Digits Calculation\n    int sum = 0;\n    int temp = N;\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n\n    // Step 2: Binary Conversion\n    string binary_string = \"\";\n    while (sum > 0) {\n        binary_string = to_string(sum % 2) + binary_string;\n        sum /= 2;\n    }\n\n    // Handle the case where the sum is 0\n    if (binary_string.empty()) {\n        binary_string = \"0\";\n    }\n\n    // Step 3: Output the Result\n    return binary_string;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        // Handle empty vector case (e.g., throw an exception or return an error code)\n        return -1; // Example error code\n    }\n\n    int sum = 0; // Step 5: Initialize sum variable\n\n    // Step 2: Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Step 3: Check if the element is even\n        if (lst[i] % 2 == 0) {\n            // Step 4: Check if the index is odd\n            if (i % 2 != 0) {\n                // Step 5: Add the element to the sum\n                sum += lst[i];\n            }\n        }\n    }\n\n    // Step 6: Return the sum\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    vector<string> words;\n    string word;\n    istringstream stream(s);\n\n    // Step 1: Extract words and spaces\n    while (stream >> word) {\n        words.push_back(word);\n    }\n\n    // Step 2: Sort characters in each word\n    for (string& w : words) {\n        sort(w.begin(), w.end());\n    }\n\n    // Step 3: Reconstruct the output string\n    ostringstream result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) result << \" \";\n        result << words[i];\n    }\n\n    return result.str();\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    if (lst.empty()) {\n        return {};\n    }\n\n    vector<vector<int>> coordinates;\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1];\n        }\n        return a[0] < b[0];\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first_element = array.front();\n    int last_element = array.back();\n    int sum = first_element + last_element;\n    bool is_sum_odd = (sum % 2 != 0);\n\n    vector<int> sorted_array = array; // Create a copy of the input vector\n    if (is_sum_odd) {\n        sort(sorted_array.begin(), sorted_array.end()); // Ascending order\n    } else {\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>()); // Descending order\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted_string = \"\";\n    \n    for (char c : s) {\n        if (islower(c)) {\n            encrypted_string += ((c - 'a' + 4) % 26) + 'a';\n        } else if (isupper(c)) {\n            encrypted_string += ((c - 'A' + 4) % 26) + 'A';\n        } else {\n            // Handle non-alphabetic characters (e.g., ignore or raise an error)\n            encrypted_string += c;\n        }\n    }\n    \n    return encrypted_string;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Representing None\n    }\n\n    int smallest = INT_MAX;\n    int second_smallest = INT_MAX;\n\n    for (int num : lst) {\n        if (num < smallest) {\n            second_smallest = smallest;\n            smallest = num;\n        } else if (num < second_smallest && num != smallest) {\n            second_smallest = num;\n        }\n    }\n\n    if (second_smallest == INT_MAX) {\n        return -1; // Representing None\n    }\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint is_bored(string S) {\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    char delimiter[] = \".?!\";\n    \n    // Step 1: Split the string into sentences\n    while (getline(ss, sentence, delimiter[0])) {\n        for (int i = 1; i < 3; ++i) {\n            stringstream temp(sentence);\n            while (getline(temp, sentence, delimiter[i])) {\n                sentences.push_back(sentence);\n            }\n        }\n    }\n    \n    // Step 2: Count sentences starting with \"I\"\n    int boredom_count = 0;\n    for (const string& s : sentences) {\n        if (!s.empty() && s[0] == 'I') {\n            ++boredom_count;\n        }\n    }\n    \n    // Step 3: Return the count\n    return boredom_count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all inputs are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Calculate sums\n    float sum1 = b + c;\n    float sum2 = a + c;\n    float sum3 = a + b;\n\n    // Check if any number is equal to the sum of the other two\n    if (a == sum1 || b == sum2 || c == sum3) {\n        return true;\n    }\n\n    // If none of the conditions are met, return false\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <string>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nstring encode(string message) {\n    // Step 1: Case Swapping\n    for (char &c : message) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    \n    // Step 2: Vowel Replacement\n    string vowels = \"AEIOUaeiou\";\n    for (char &c : message) {\n        if (vowels.find(c) != string::npos) {\n            // Replace vowel with the letter 2 places ahead\n            if (isupper(c)) {\n                c = (c + 2 > 'Z') ? (c + 2 - 26) : (c + 2);\n            } else {\n                c = (c + 2 > 'z') ? (c + 2 - 26) : (c + 2);\n            }\n        }\n    }\n    \n    // Step 3: Return the encoded message\n    return message;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime in the list\nint findLargestPrime(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    return largestPrime;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to solve the problem\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = findLargestPrime(lst);\n    if (largestPrime == -1) return 0; // No prime found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Step 1: Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Step 2: Initialize a flag to track the case\n    bool is_lower_case = false;\n    bool is_upper_case = false;\n    bool first_key = true;\n\n    // Step 3: Iterate through the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Step 4: Check if the key is a string\n        if (typeid(key) != typeid(string)) {\n            return false;\n        }\n\n        // Step 5: Determine the case of the first key\n        if (first_key) {\n            is_lower_case = all_of(key.begin(), key.end(), ::islower);\n            is_upper_case = all_of(key.begin(), key.end(), ::isupper);\n            first_key = false;\n        } else {\n            // Step 6: Ensure subsequent keys match the initial case\n            if ((is_lower_case && !all_of(key.begin(), key.end(), ::islower)) ||\n                (is_upper_case && !all_of(key.begin(), key.end(), ::isupper))) {\n                return false;\n            }\n        }\n    }\n\n    // Step 7: Return true if all keys are strings and match the initial case\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\n\nint multiply(int a, int b) {\n    // Step 1: Extract unit digits\n    int unit_digit_a = abs(a) % 10;\n    int unit_digit_b = abs(b) % 10;\n    \n    // Step 2: Compute the product of unit digits\n    int result = unit_digit_a * unit_digit_b;\n    \n    // Step 3: Return the result\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    // Return the count of uppercase vowels at even indices\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <stdexcept>\n\nint closest_integer(const std::string& value) {\n    try {\n        // Step 1.1: Convert the string to a double\n        double num = std::stod(value);\n        \n        // Step 2.1: Separate the integer and fractional parts\n        double intPart, fracPart;\n        fracPart = modf(num, &intPart);\n        \n        // Step 2.2: Handle the case where the fractional part is exactly 0.5\n        if (fracPart == 0.5) {\n            return static_cast<int>(intPart + copysign(1.0, num));\n        }\n        \n        // Step 2.3 & 2.4: Round up or down based on the fractional part\n        return static_cast<int>(num > 0 ? ceil(num) : floor(num));\n    } catch (const std::invalid_argument& e) {\n        // Handle invalid input\n        throw std::invalid_argument(\"Invalid numeric string\");\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    stones.push_back(n);\n    \n    int current = n;\n    for (int i = 1; i < n; ++i) {\n        if (current % 2 == 0) {\n            current += 2; // Next even number\n        } else {\n            current += 2; // Next odd number\n        }\n        stones.push_back(current);\n    }\n    \n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use stringstream to handle both spaces and commas\n    while (getline(ss, word, ',')) {\n        stringstream word_ss(word);\n        string temp;\n        while (word_ss >> temp) {\n            words.push_back(temp);\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Input Validation\n    if (x <= 0 || y <= 0) {\n        return -1;  // Invalid input\n    }\n\n    // Step 2: Range Adjustment\n    if (x > y) {\n        return -1;  // Invalid range\n    }\n\n    // Step 3: Finding the Biggest Even Number\n    int max_even = -1;\n    for (int i = x; i <= y; i++) {\n        if (i % 2 == 0) {  // Check if i is even\n            if (i > max_even) {\n                max_even = i;\n            }\n        }\n    }\n\n    // Step 4: Return the Result\n    return max_even;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Step 1: Input Validation\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Average Calculation\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    int count = m - n + 1;\n    double average = (double)sum / count;\n\n    // Step 3: Rounding the Average\n    int rounded_average = floor(average);\n\n    // Step 4: Binary Conversion\n    if (rounded_average == 0) {\n        return \"0\";\n    }\n\n    string binary_string = \"\";\n    while (rounded_average > 0) {\n        binary_string = to_string(rounded_average % 2) + binary_string;\n        rounded_average /= 2;\n    }\n\n    // Step 5: Return the Result\n    return binary_string;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number contains any even digit\nbool hasEvenDigit(int num) {\n    string numStr = to_string(num);\n    for (char digit : numStr) {\n        if (digit == '0' || digit == '2' || digit == '4' || digit == '6' || digit == '8') {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Main function to filter and sort the vector\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    // Filter out elements with even digits\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the filtered vector\n    sort(result.begin(), result.end());\n    \n    // Return the sorted vector\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter and validate input\n    vector<int> valid_numbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            valid_numbers.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the valid vector\n    sort(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(valid_numbers.begin(), valid_numbers.end());\n\n    // Step 4: Map digits to corresponding names\n    static const map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n    for (int num : valid_numbers) {\n        result.push_back(digit_to_name.at(num));\n    }\n\n    // Step 5: Handle edge cases (already handled by filtering)\n\n    // Step 6: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function to calculate factorial of i\nint factorial(int i) {\n    int result = 1;\n    for (int j = 1; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate sum of numbers from 1 to i\nint sum_of_numbers(int i) {\n    int sum = 0;\n    for (int j = 1; j <= i; ++j) {\n        sum += j;\n    }\n    return sum;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i-1] = factorial(i);\n        } else {\n            result[i-1] = sum_of_numbers(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    // Initialize counters for even and odd palindromes\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate through each number from 1 to n\n    for (int i = 1; i <= n; ++i) {\n        // Convert the number to a string\n        string num_str = to_string(i);\n\n        // Check if the number is a palindrome\n        if (num_str == string(num_str.rbegin(), num_str.rend())) {\n            // Check if the number is even or odd\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Return the result as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            digit_sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            digit_sum -= 2 * (abs(num) % 10);\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isSorted(const vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int N = arr.size();\n    for (int shift = 0; shift < N; ++shift) {\n        // Rotate the vector by 'shift' positions\n        vector<int> rotated(arr.begin() + shift, arr.end());\n        rotated.insert(rotated.end(), arr.begin(), arr.begin() + shift);\n\n        // Check if the rotated vector is sorted\n        if (isSorted(rotated)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if (even_count_lst2 >= odd_count_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Step 1: Input Parsing\n    vector<char> letters;\n    stringstream ss(test);\n    char letter;\n    while (ss >> letter) {\n        letters.push_back(letter);\n    }\n\n    // Step 2: Frequency Counting\n    map<char, int> frequencyMap;\n    for (char l : letters) {\n        frequencyMap[l]++;\n    }\n\n    // Step 3: Determine Maximum Frequency\n    int maxFrequency = 0;\n    for (const auto& entry : frequencyMap) {\n        if (entry.second > maxFrequency) {\n            maxFrequency = entry.second;\n        }\n    }\n\n    // Step 4: Filter Letters by Maximum Frequency\n    map<char, int> resultMap;\n    for (const auto& entry : frequencyMap) {\n        if (entry.second == maxFrequency) {\n            resultMap[entry.first] = entry.second;\n        }\n    }\n\n    // Step 5: Output the Result\n    return resultMap;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    string result;\n    \n    // Step 2: Character Deletion\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n    \n    // Step 3: Palindrome Check\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n    \n    // Step 4: Result Packaging\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    // Step 5: Return the Result\n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        int oddCount = 0;\n        \n        for (char c : str) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                oddCount++;\n            }\n        }\n        \n        string output = \"the number of odd elements \" + to_string(oddCount) + \"n the str\" + to_string(oddCount) + \"ng \" + to_string(oddCount) + \" of the \" + to_string(oddCount) + \"nput.\";\n        result.push_back(output);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <limits.h> // For LONG_LONG_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    // Step 1: Input Validation\n    if (nums.empty()) {\n        // Handle empty vector case\n        return 0; // or throw an error\n    }\n\n    // Step 2: Initialization\n    long long minSum = LONG_LONG_MAX;\n\n    // Step 3: Iterate Through the Vector\n    for (size_t i = 0; i < nums.size(); ++i) {\n        long long currentSum = 0;\n        for (size_t j = i; j < nums.size(); ++j) {\n            // Step 4: Calculate Sub-Vector Sums\n            currentSum += nums[j];\n\n            // Step 5: Update Minimum Sum\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n        }\n    }\n\n    // Step 6: Return the Result\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // for ceil function\n#include <iostream>\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_extractions = 0;\n    \n    // Iterate through each well (row in the grid)\n    for (const auto& well : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the well\n        for (int unit : well) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        \n        // Calculate the number of extractions needed for this well\n        int extractions_needed = ceil((double)water_units / capacity);\n        \n        // Add to the total extractions\n        total_extractions += extractions_needed;\n    }\n    \n    return total_extractions;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int num) {\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator function\nbool compare_by_ones_and_value(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\n// Main function to sort the array\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare_by_ones_and_value);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) return {};\n\n    vector<string> result;\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    istringstream iss(s);\n    string word;\n\n    while (iss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            if (isalpha(c) && vowels.find(c) == vowels.end()) {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define vowels and consonants\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    unordered_set<char> consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z',\n                                      'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'};\n    \n    // Traverse the word from right to left\n    for (int i = word.length() - 1; i >= 0; --i) {\n        if (vowels.find(word[i]) != vowels.end()) {\n            // Check if the vowel is between two consonants\n            if (i > 0 && i < word.length() - 1 && \n                consonants.find(word[i - 1]) != consonants.end() && \n                consonants.find(word[i + 1]) != consonants.end()) {\n                return string(1, word[i]);\n            }\n        }\n    }\n    \n    // Return empty string if no valid vowel is found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n    // Count parentheses in the first string\n    for (char c : lst[0]) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    // Count parentheses in the second string\n    for (char c : lst[1]) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check if the total number of open and close parentheses are equal\n    if (open1 + open2 != close1 + close2) {\n        return \"No\";\n    }\n\n    // Check if we can concatenate the strings in a balanced manner\n    int balance = 0;\n    for (char c : lst[0]) {\n        if (c == '(') balance++;\n        else balance--;\n        if (balance < 0) return \"No\"; // More close than open at any point\n    }\n\n    // Check the second string\n    for (char c : lst[1]) {\n        if (c == '(') balance++;\n        else balance--;\n        if (balance < 0) return \"No\"; // More close than open at any point\n    }\n\n    // If we reach here, the strings can be concatenated to form a balanced string\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> maximum(std::vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (k < 0 || k > arr.size()) {\n        return {}; // Return an empty vector if k is out of range\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(arr.begin(), arr.end());\n\n    // Step 3: Extracting the Top k Elements\n    std::vector<int> result(arr.end() - k, arr.end());\n\n    // Step 4: Returning the Result\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Loop through the vector with a step of 2\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        // Check if the element at the even position is odd\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (arr.empty() || k < 1 || k > arr.size()) {\n        return -1; // or throw an exception\n    }\n\n    int sum = 0;\n\n    // Step 2: Extracting the First `k` Elements\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n\n        // Step 3: Identifying Elements with At Most Two Digits\n        if (num >= 0 && num <= 99) { // Assuming non-negative integers\n            // Step 4: Summing the Valid Elements\n            sum += num;\n        }\n    }\n\n    // Step 5: Returning the Result\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add the final 1 to the sequence\n\n    // Filter odd numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <regex>\nusing namespace std;\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    // Step 1: Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Step 2: Check if the date string matches the format \"mm-dd-yyyy\"\n    regex date_format(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n    if (!regex_match(date, date_format)) return false;\n\n    // Step 3: Extract month, day, and year\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Step 4: Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Step 5: Validate day based on month\n    if (month == 2) {\n        // February\n        if (is_leap_year(year)) {\n            if (day < 1 || day > 29) return false;\n        } else {\n            if (day < 1 || day > 28) return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day < 1 || day > 30) return false;\n    } else {\n        // Months with 31 days\n        if (day < 1 || day > 31) return false;\n    }\n\n    // Step 6: If all validations pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Count odd-ordered lowercase letters\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    result.push_back(to_string(count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Step 1: Check for ascending order\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Step 2: Check for element frequency\n    unordered_map<int, int> frequency;\n    for (int num : lst) {\n        frequency[num]++;\n        if (frequency[num] > 2) {\n            return false;\n        }\n    }\n\n    // Step 3: If both checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to calculate the intersection of two intervals\nvector<int> calculateIntersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    if (start > end) {\n        return {}; // No intersection\n    }\n    return {start, end};\n}\n\n// Function to calculate the length of an interval\nint calculateLength(vector<int> interval) {\n    if (interval.empty()) return 0;\n    return interval[1] - interval[0] + 1;\n}\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine if the length of intersection is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    vector<int> intersect = calculateIntersection(interval1, interval2);\n    if (intersect.empty()) return \"NO\";\n    int length = calculateLength(intersect);\n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n\n    for (int num : arr) {\n        int sign = (num > 0) ? 1 : (num < 0) ? -1 : 0;\n        product_of_signs *= sign;\n        sum_of_magnitudes += abs(num);\n    }\n\n    int result = sum_of_magnitudes * product_of_signs;\n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to get valid neighboring cells\nvector<pair<int, int>> getNeighbors(vector<vector<int>> grid, pair<int, int> cell) {\n    vector<pair<int, int>> neighbors;\n    int N = grid.size();\n    int x = cell.first, y = cell.second;\n    if (x > 0) neighbors.push_back({x - 1, y});\n    if (x < N - 1) neighbors.push_back({x + 1, y});\n    if (y > 0) neighbors.push_back({x, y - 1});\n    if (y < N - 1) neighbors.push_back({x, y + 1});\n    return neighbors;\n}\n\n// Function to generate all possible paths of length k starting from startCell\nvoid generatePaths(vector<vector<int>> grid, pair<int, int> startCell, int k, vector<int> currentPath, vector<vector<int>>& allPaths) {\n    if (k == 0) {\n        allPaths.push_back(currentPath);\n        return;\n    }\n    int x = startCell.first, y = startCell.second;\n    currentPath.push_back(grid[x][y]);\n    for (auto neighbor : getNeighbors(grid, startCell)) {\n        generatePaths(grid, neighbor, k - 1, currentPath, allPaths);\n    }\n}\n\n// Function to compare two paths lexicographically\nbool isLexicographicallySmaller(vector<int> pathA, vector<int> pathB) {\n    for (int i = 0; i < pathA.size(); ++i) {\n        if (pathA[i] < pathB[i]) return true;\n        if (pathA[i] > pathB[i]) return false;\n    }\n    return false;\n}\n\n// Main function to find the minimum path of length k\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<vector<int>> allPaths;\n    int N = grid.size();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            generatePaths(grid, {i, j}, k, {}, allPaths);\n        }\n    }\n    vector<int> smallestPath = allPaths[0];\n    for (auto path : allPaths) {\n        if (isLexicographicallySmaller(path, smallestPath)) {\n            smallestPath = path;\n        }\n    }\n    return smallestPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    // Initialize the result vector\n    vector<int> result;\n    \n    // Base case\n    result.push_back(3);\n    \n    // Iterate from 2 to n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Even case\n            result.push_back(1 + i / 2);\n        } else {\n            // Odd case\n            int value = result[i - 2] + result[i - 3] + result[i - 1];\n            result.push_back(value);\n        }\n    }\n    \n    // Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n);\n    int product = 1;\n    bool hasOdd = false;\n\n    for (char digitChar : numStr) {\n        int digit = digitChar - '0';\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n    }\n\n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    // Step 1: Input Validation\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            return false;\n        }\n    }\n\n    // Step 2: Stack-Based Validation for Valid Subsequences\n    stack<int> s;\n    bool nestingFound = false;\n\n    for (int i = 0; i < str.length(); ++i) {\n        if (str[i] == '[') {\n            s.push(i);\n        } else if (str[i] == ']') {\n            if (!s.empty() && str[s.top()] == '[') {\n                // Step 3: Check for Nested Brackets\n                if (s.top() < i - 1) {\n                    nestingFound = true;\n                }\n                s.pop();\n            } else {\n                return false; // Invalid subsequence\n            }\n        }\n    }\n\n    // Step 4: Return Result\n    return nestingFound;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        int rounded_num = ceil(num);  // Round to ceiling\n        sum += rounded_num * rounded_num;  // Square and accumulate\n    }\n    \n    return sum;  // Return the result\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype> // for isalpha\n\nbool check_if_last_char_is_a_letter(const std::string& txt) {\n    // Step 1: Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Step 2: Extract the last character\n    char last_char = txt.back();\n\n    // Step 3: Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Step 4: Check if the last character is part of a word\n    // If the last character is followed by a space or is the last character in the string and is not preceded by a space\n    if (txt.size() == 1 || txt[txt.size() - 2] == ' ') {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.size() <= 1) {\n        return -1;\n    }\n\n    // Step 2: Initialize largest_index to -1\n    int largest_index = -1;\n\n    // Step 3: Iterate through the vector\n    for (int i = 1; i < arr.size(); ++i) {\n        // Step 4: Compare current element with previous element\n        if (arr[i] < arr[i - 1]) {\n            // Step 5: Update largest_index if condition is met\n            largest_index = i;\n        }\n    }\n\n    // Step 6: Return the result\n    return largest_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <limits.h> // For INT_MAX and INT_MIN\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    // Initialize variables\n    int largest_negative = INT_MIN; // Smallest possible value for int\n    int smallest_positive = INT_MAX; // Largest possible value for int\n    bool found_negative = false;\n    bool found_positive = false;\n\n    // Traverse the input vector\n    for (int num : lst) {\n        if (num < 0) {\n            // Update largest negative\n            if (num > largest_negative) {\n                largest_negative = num;\n                found_negative = true;\n            }\n        } else if (num > 0) {\n            // Update smallest positive\n            if (num < smallest_positive) {\n                smallest_positive = num;\n                found_positive = true;\n            }\n        }\n    }\n\n    // If no negative or positive integers were found, set to 0\n    if (!found_negative) largest_negative = 0;\n    if (!found_positive) smallest_positive = 0;\n\n    // Return the result as a vector\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Step 1: Type Identification and Conversion\n    float val_a, val_b;\n    bool is_a_string = false, is_b_string = false;\n    boost::any result;\n\n    if (a.type() == typeid(int)) {\n        val_a = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val_a = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        string str_a = boost::any_cast<string>(a);\n        std::replace(str_a.begin(), str_a.end(), ',', '.');\n        val_a = std::stof(str_a);\n        is_a_string = true;\n    }\n\n    if (b.type() == typeid(int)) {\n        val_b = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val_b = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        string str_b = boost::any_cast<string>(b);\n        std::replace(str_b.begin(), str_b.end(), ',', '.');\n        val_b = std::stof(str_b);\n        is_b_string = true;\n    }\n\n    // Step 2: Comparison Logic\n    if (std::fabs(val_a - val_b) < 1e-9) {\n        result = string(\"None\");\n    } else if (val_a > val_b) {\n        if (is_a_string) {\n            result = boost::any_cast<string>(a);\n        } else if (a.type() == typeid(int)) {\n            result = boost::any_cast<int>(a);\n        } else {\n            result = boost::any_cast<float>(a);\n        }\n    } else {\n        if (is_b_string) {\n            result = boost::any_cast<string>(b);\n        } else if (b.type() == typeid(int)) {\n            result = boost::any_cast<int>(b);\n        } else {\n            result = boost::any_cast<float>(b);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // If n is less than 8, it cannot be the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n\n    // Iterate over possible combinations of 4 even numbers\n    for (int i = 2; i <= n - 6; i += 2) {\n        for (int j = 2; j <= n - i - 4; j += 2) {\n            for (int k = 2; k <= n - i - j - 2; k += 2) {\n                int l = n - i - j - k;\n                if (l > 0 && l % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // If no combination is found, return false\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(int n) {\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long product_of_factorials(int n) {\n    long long product = 1;\n    for (int i = n; i >= 1; --i) {\n        product *= factorial(i);\n    }\n    return product;\n}\n\nlong long special_factorial(int n) {\n    return product_of_factorials(n);\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces == 1) {\n                result += '_';\n            } else if (consecutive_spaces == 2) {\n                result.back() = '-'; // Replace the last underscore with a hyphen\n            }\n        } else {\n            result += c;\n            consecutive_spaces = 0;\n        }\n    }\n\n    if (consecutive_spaces > 0) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    if (file_name.empty()) return \"No\";\n\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_index = string::npos;\n\n    for (size_t i = 0; i < file_name.size(); ++i) {\n        if (isdigit(file_name[i])) {\n            ++digit_count;\n            if (digit_count > 3) return \"No\";\n        }\n        if (file_name[i] == '.') {\n            ++dot_count;\n            if (dot_count > 1) return \"No\";\n            dot_index = i;\n        }\n    }\n\n    if (dot_count != 1) return \"No\";\n\n    string pre_dot = file_name.substr(0, dot_index);\n    string post_dot = file_name.substr(dot_index + 1);\n\n    if (pre_dot.empty() || !isalpha(pre_dot[0])) return \"No\";\n\n    if (post_dot != \"txt\" && post_dot != \"exe\" && post_dot != \"dll\") return \"No\";\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split a string into words\nvector<string> splitSentence(const string& sentence) {\n    vector<string> words;\n    istringstream stream(sentence);\n    string word;\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to process the sentence\nstring words_in_sentence(string sentence) {\n    vector<string> words = splitSentence(sentence);\n    vector<string> primeLengthWords;\n\n    for (const string& word : words) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n\n    // Join the filtered words into a single string\n    string result = accumulate(primeLengthWords.begin(), primeLengthWords.end(), string(),\n                               [](const string& a, const string& b) {\n                                   return a.empty() ? b : a + \" \" + b;\n                               });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to compute the GCD of two numbers\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool simplify(string x, string n) {\n    // Step 1: Parse the input strings\n    int num1, den1, num2, den2;\n    sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n    sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n    // Step 2: Multiply the fractions\n    int new_num = num1 * num2;\n    int new_den = den1 * den2;\n\n    // Step 3: Simplify the resulting fraction\n    int common_divisor = gcd(new_num, new_den);\n    new_num /= common_divisor;\n    new_den /= common_divisor;\n\n    // Step 4: Check if the result is a whole number\n    return new_den == 1;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint calculate_digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\n// Main function to order the vector by digit sum\nvector<int> order_by_points(vector<int> nums) {\n    if (nums.empty()) return {};\n\n    // Create a vector of pairs (original index, digit sum)\n    vector<pair<int, int>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({i, calculate_digit_sum(nums[i])});\n    }\n\n    // Sort based on digit sum, and by original index if sums are equal\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.second == b.second) return a.first < b.first;\n        return a.second < b.second;\n    });\n\n    // Create the result vector based on the sorted indices\n    vector<int> result(nums.size());\n    for (size_t i = 0; i < indexed_nums.size(); ++i) {\n        result[i] = nums[indexed_nums[i].first];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = abs(num) % 10;\n            \n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    // Step 2: Count valid triples\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Step 3: Return the result\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Step 1: Define the list of valid planets\n    const vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Step 2: Validate input planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Step 3: Determine the order of planets\n    int index1 = it1 - planets.begin();\n    int index2 = it2 - planets.begin();\n    \n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Step 4: Collect planets between the two given planets\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Custom comparator for sorting\nbool customComparator(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // Alphabetical order if lengths are equal\n    }\n    return a.length() < b.length(); // Ascending order by length\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), customComparator);\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::floor and std::ceil\n\nlong long double_the_difference(std::vector<float> lst) {\n    // Initialize the sum of squares to 0\n    long long sum_of_squares = 0;\n\n    // Iterate through each element in the vector\n    for (float num : lst) {\n        // Check if the number is non-negative and an integer\n        if (num >= 0 && std::floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                // Compute the square and add to the sum\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    // Return the final sum of squares\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    // Step 1: Input Validation\n    if (game.size() != guess.size()) {\n        // Handle error: vectors are not of the same length\n        return {}; // or throw an exception\n    }\n\n    // Step 2: Initialize result vector\n    std::vector<int> result;\n    result.reserve(game.size()); // Reserve space to avoid reallocations\n\n    // Step 3: Comparison Loop\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result.push_back(0); // Correct guess\n        } else {\n            result.push_back(std::abs(game[i] - guess[i])); // Incorrect guess, store absolute difference\n        }\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n    \n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n        \n        // Count CAP and SM\n        for (char c : ext) {\n            if (isupper(c)) CAP++;\n            else if (islower(c)) SM++;\n        }\n        \n        int strength = CAP - SM;\n        \n        // Update strongest extension if current one is stronger or appears earlier\n        if (strength > max_strength || (strength == max_strength && ext < strongest_extension)) {\n            strongest_extension = ext;\n            max_strength = strength;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvector<string> generateRotations(const string& b) {\n    vector<string> rotations;\n    int len = b.length();\n    for (int i = 0; i < len; ++i) {\n        string rotation = b.substr(i) + b.substr(0, i);\n        rotations.push_back(rotation);\n    }\n    return rotations;\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(const string& a, const string& b) {\n    vector<string> rotations = generateRotations(b);\n    for (const string& rotation : rotations) {\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Step 1: Handle negative numbers\n    num = abs(num);\n    \n    // Step 2: Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Step 3: Extract and classify digits\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n    \n    // Step 4: Return the result\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Step 1: Define the Roman numeral mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    // Step 2: Initialize the result string\n    string result = \"\";\n    \n    // Step 3: Iterate through the mapping and build the Roman numeral string\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    \n    // Step 4: Convert the result to lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n    \n    // Step 5: Return the final result\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // for std::max\n#include <cmath>     // for std::pow\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (a <= 0 || b <= 0 || c <= 0) return false;\n    if (a + b <= c || a + c <= b || b + c <= a) return false;\n\n    // Step 2: Identify the Hypotenuse\n    float hypotenuse = std::max({a, b, c});\n\n    // Step 3: Apply the Pythagorean Theorem\n    float hypotenuse_squared = std::pow(hypotenuse, 2);\n    float sum_of_squares = std::pow(a, 2) + std::pow(b, 2) + std::pow(c, 2) - hypotenuse_squared;\n\n    // Step 4: Return the Result\n    return std::abs(hypotenuse_squared - sum_of_squares) < 1e-6; // Allow for floating-point precision\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\n// Helper function to count unique characters in a string\nint count_unique_characters(const string& str) {\n    unordered_set<char> unique_chars(str.begin(), str.end());\n    return unique_chars.size();\n}\n\n// Helper function to compare two strings based on unique characters and lexicographical order\nbool compare_strings(const string& str1, const string& str2) {\n    int unique_count1 = count_unique_characters(str1);\n    int unique_count2 = count_unique_characters(str2);\n    \n    if (unique_count1 > unique_count2) {\n        return true;\n    } else if (unique_count1 == unique_count2) {\n        return str1 < str2;\n    } else {\n        return false;\n    }\n}\n\n// Main function to find the word with the maximum number of unique characters\nstring find_max(vector<string> words) {\n    string best_word = \"\";\n    \n    for (const string& word : words) {\n        if (compare_strings(word, best_word)) {\n            best_word = word;\n        }\n    }\n    \n    return best_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Step 1: Input Validation\n    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n        // Handle invalid input (e.g., return an error vector or throw an exception)\n        return {-1, -1}; // Example error handling\n    }\n\n    // Step 2: Calculate Total Carrots Eaten\n    int total_carrots_eaten = number + need;\n\n    // Step 3: Determine Carrots Left\n    int carrots_left = 0;\n    if (total_carrots_eaten <= remaining) {\n        carrots_left = remaining - total_carrots_eaten;\n    }\n\n    // Step 4: Handle Insufficient Carrots\n    // If total_carrots_eaten > remaining, carrots_left is already 0\n\n    // Step 5: Return the Result\n    return {total_carrots_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <stdexcept>\n\nint evaluateExpression(const std::string& expression);\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    // Step 1: Input Validation\n    if (operators.size() != operands.size() - 1) {\n        throw std::invalid_argument(\"Invalid input: operator and operand vector lengths do not match.\");\n    }\n    for (int operand : operands) {\n        if (operand < 0) {\n            throw std::invalid_argument(\"Invalid input: operands must be non-negative integers.\");\n        }\n    }\n    for (const std::string& op : operators) {\n        if (op != \"+\" && op != \"-\" && op != \"*\" && op != \"//\" && op != \"**\") {\n            throw std::invalid_argument(\"Invalid input: operators must be one of '+', '-', '*', '//', '**'.\");\n        }\n    }\n\n    // Step 2: Expression Construction\n    std::string expression;\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += std::to_string(operands[i]) + \" \" + operators[i] + \" \";\n    }\n    expression += std::to_string(operands.back());\n\n    // Step 3: Expression Evaluation\n    return evaluateExpression(expression);\n}\n\nint evaluateExpression(const std::string& expression) {\n    std::stack<int> operands;\n    std::stack<std::string> operators;\n    std::string token;\n    for (char ch : expression) {\n        if (ch == ' ') {\n            if (!token.empty()) {\n                if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"//\" || token == \"**\") {\n                    operators.push(token);\n                } else {\n                    operands.push(std::stoi(token));\n                }\n                token.clear();\n            }\n        } else {\n            token += ch;\n        }\n    }\n    if (!token.empty()) {\n        operands.push(std::stoi(token));\n    }\n\n    while (!operators.empty()) {\n        std::string op = operators.top();\n        operators.pop();\n\n        int b = operands.top();\n        operands.pop();\n        int a = operands.top();\n        operands.pop();\n\n        if (op == \"**\") {\n            operands.push(std::pow(a, b));\n        } else if (op == \"*\") {\n            operands.push(a * b);\n        } else if (op == \"//\") {\n            operands.push(a / b);\n        } else if (op == \"+\") {\n            operands.push(a + b);\n        } else if (op == \"-\") {\n            operands.push(a - b);\n        }\n    }\n\n    return operands.top();\n}\n"}
{"task_id": "CPP/161", "generation": "#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring solve(string s) {\n    string modified;\n    bool hasLetters = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            if (islower(c)) {\n                modified += toupper(c);\n            } else {\n                modified += tolower(c);\n            }\n        } else {\n            modified += c;\n        }\n    }\n\n    if (!hasLetters) {\n        reverse(modified.begin(), modified.end());\n    }\n\n    return modified;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Step 1: Input Validation\n    if (text.empty()) {\n        return \"None\"; // Return \"None\" as a string representation of None\n    }\n\n    // Step 2: MD5 Hashing\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    // Step 3: Hexadecimal Conversion\n    string md5_string;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        char buf[3];\n        sprintf(buf, \"%02x\", result[i]);\n        md5_string += buf;\n    }\n\n    // Step 4: Return the Result\n    return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    \n    // Step 1: Input Validation\n    if (a <= 0 || b <= 0) {\n        return even_digits; // Return empty vector if inputs are invalid\n    }\n    \n    // Step 2: Range Determination\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    // Step 3: Digit Extraction and Even Digit Filtering\n    for (int num = min_val; num <= max_val; ++num) {\n        int temp = num;\n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit % 2 == 0 && digit < 10) {\n                even_digits.push_back(digit);\n            }\n            temp /= 10;\n        }\n    }\n    \n    // Step 4: Sorting\n    sort(even_digits.begin(), even_digits.end());\n    \n    // Step 5: Output\n    return even_digits;\n}\n"}
