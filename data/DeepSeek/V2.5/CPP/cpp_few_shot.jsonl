{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue; // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integerPart = static_cast<int>(number);\n    // Calculate the decimal part\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers){\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the sum of absolute deviations\n    float absDevSum = 0.0;\n    for (float num : numbers) {\n        absDevSum += abs(num - mean);\n    }\n\n    // Calculate and return the Mean Absolute Deviation\n    return absDevSum / numbers.size();\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n    \n    while (ss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers){\n    int sum = 0;\n    int product = 1;\n\n    for(int num : numbers){\n        sum += num;\n        product *= num;\n    }\n\n    if(numbers.empty()){\n        sum = 0;\n        product = 1;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    if (str.empty()) return \"\";\n\n    // Find the longest palindromic suffix\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the end of the string\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, append the reverse of the entire string\n    string reversed = str;\n    reverse(reversed.begin(), reversed.end());\n    return str + reversed.substr(1);\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int len = a.length();\n    \n    for (int i = 0; i < len; i++) {\n        // Perform XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestString = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n){\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use an unordered_set to store distinct characters\n    unordered_set<char> distinctChars(str.begin(), str.end());\n    \n    // Return the size of the set, which is the number of distinct characters\n    return distinctChars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string note;\n    for (size_t i = 0; i < music_string.size(); ++i) {\n        if (music_string[i] == ' ') {\n            continue;\n        }\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(2);\n                ++i;\n            } else {\n                beats.push_back(4);\n            }\n        } else if (music_string[i] == '.') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(1);\n                ++i;\n            }\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = str.find(substring);\n    \n    while (pos != string::npos) {\n        count++;\n        pos = str.find(substring, pos + 1);\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to convert words to their corresponding numbers\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to store the numbers corresponding to the words\n    vector<int> nums;\n\n    // Stringstream to split the input string by spaces\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        nums.push_back(wordToNumber[word]);\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Map to convert numbers back to their corresponding words\n    map<int, string> numberToWord = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Stringstream to build the output string\n    stringstream sortedNumbers;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i != 0) sortedNumbers << \" \";\n        sortedNumbers << numberToWord[nums[i]];\n    }\n\n    return sortedNumbers.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    vector<float> closestPair = {numbers[0], numbers[1]};\n    float minDistance = abs(numbers[0] - numbers[1]);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float distance = abs(numbers[i] - numbers[j]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestPair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    if (closestPair[0] > closestPair[1]) {\n        swap(closestPair[0], closestPair[1]);\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float minVal = numbers[0];\n    float maxVal = numbers[0];\n\n    // Find the minimum and maximum values in the vector\n    for (float num : numbers) {\n        if (num < minVal) {\n            minVal = num;\n        }\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n\n    // Calculate the range\n    float range = maxVal - minVal;\n\n    // Apply the linear transform\n    vector<float> rescaledNumbers;\n    for (float num : numbers) {\n        float rescaledNum = (num - minVal) / range;\n        rescaledNumbers.push_back(rescaledNum);\n    }\n\n    return rescaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n#include<typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n#include<cmath>\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case for n <= 1\n    for (int i = sqrt(n); i >= 2; --i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1; // If no other divisor found, n is prime\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    \n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str){\n    for(int i = 0; i < str.length(); i++){\n        if(islower(str[i])){\n            str[i] = toupper(str[i]);\n        } else if(isupper(str[i])){\n            str[i] = tolower(str[i]);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings){\n    string result = \"\";\n    for(const string& str : strings){\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_numbers;\n    for(float num : l){\n        if(num > 0){\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x){\n    /* \n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    */\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    double x0 = 0.0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (abs(fx) < tolerance) {\n            return x0; // Converged to a root\n        }\n\n        x0 = x0 - fx / dfx; // Newton-Raphson update\n    }\n\n    return x0; // Return the last computed value if max iterations reached\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> l_prime = l; // Initialize l' with the same values as l\n    vector<int> to_sort; // Vector to store elements at indices divisible by three\n\n    // Collect elements at indices divisible by three\n    for (int i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace the elements in l' with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); i += 3) {\n        l_prime[i] = to_sort[index++];\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Sort the vector to bring duplicates together\n    sort(l.begin(), l.end());\n    \n    // Use a vector to store unique elements\n    vector<int> uniqueElements;\n    \n    // Iterate through the sorted vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // If the current element is different from the previous one, add it to the uniqueElements vector\n        if (i == 0 || l[i] != l[i - 1]) {\n            uniqueElements.push_back(l[i]);\n        }\n    }\n    \n    return uniqueElements;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    float maxVal = l[0];\n    for (float num : l) {\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n    return maxVal;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint countSevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += countSevens(i);\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> l_prime = l; // Initialize l' with the same values as l\n    vector<float> even_values; // To store the values at even indices\n\n    // Extract values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    sort(even_values.begin(), even_values.end());\n\n    // Replace the even indices in l' with the sorted values\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l_prime[i] = even_values[j];\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    // returns decoded string by reversing the cycling of groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // reverse cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<int> fibs = {1, 1};\n    int count = 0;\n    while (true) {\n        int next_fib = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n        fibs.push_back(next_fib);\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    int n = l.size();\n    if (n < 3) return false;\n\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    // Therefore, the total number of collisions is the product of the number of cars in each direction.\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // The area of a triangle with base 'a' and height 'h' is given by:\n    // Area = 0.5 * base * height\n    return 0.5 * a * h;\n}\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    std::vector<int> fib4_sequence(n + 1);\n    fib4_sequence[0] = 0;\n    fib4_sequence[1] = 0;\n    fib4_sequence[2] = 2;\n    fib4_sequence[3] = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        fib4_sequence[i] = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4];\n    }\n\n    return fib4_sequence[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Find the size of the vector\n    int n = l.size();\n    \n    // If the size is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size is even, return the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    text.erase(remove_if(text.begin(), text.end(), [&](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    return text;\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create frequency maps for both strings\n    unordered_map<char, int> freq0, freq1;\n    \n    // Populate the frequency map for s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    \n    // Populate the frequency map for s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n    \n    // Compare the frequency maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n){\n    if (n <= 0) return 0; // Handle edge case for non-positive integers\n    if (n == 1) return 1; // Base case for Fibonacci sequence\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() < 2) return true; // A single element or no elements are trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n\n        // If neither increasing nor decreasing, it's not monotonic\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert the first list to a set for O(1) average time complexity lookups\n    unordered_set<int> set1(l1.begin(), l1.end());\n    \n    // Use a set to store common elements to ensure uniqueness\n    unordered_set<int> commonSet;\n    \n    // Iterate through the second list and check for common elements\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            commonSet.insert(num);\n        }\n    }\n    \n    // Convert the set of common elements to a vector and sort it\n    vector<int> result(commonSet.begin(), commonSet.end());\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    // Check for the number itself if it is prime\n    if (is_prime(n)) return n;\n\n    // Check for smallest factors first\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n                largest_factor = i;\n            }\n            if (is_prime(n / i)) {\n                largest_factor = n / i;\n                break; // Since n/i is larger than i, it is the largest factor found so far\n            }\n        }\n    }\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            s.push(bracket);\n        } else if (bracket == ')') {\n            if (s.empty() || s.top() != '(') {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> sequence(n + 1);\n    sequence[0] = 0;\n    sequence[1] = 0;\n    sequence[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i - 3];\n    }\n\n    return sequence[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    // Check if 'y' is at the end of the word\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to easily manipulate its digits\n    string digits = to_string(x);\n    int num_digits = digits.size();\n\n    // If shift is greater than the number of digits, return the digits reversed\n    if (shift > num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    // Calculate the effective shift (modulo the number of digits)\n    shift = shift % num_digits;\n\n    // Perform the circular shift\n    string result = digits.substr(num_digits - shift) + digits.substr(0, num_digits - shift);\n\n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Read the number of apples\n    ss >> temp;\n    apples = stoi(temp);\n    \n    // Skip the word \"apples\"\n    ss >> temp;\n    \n    // Skip the word \"and\"\n    ss >> temp;\n    \n    // Read the number of oranges\n    ss >> temp;\n    oranges = stoi(temp);\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int smallestEven = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestEven == -1) return {};\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst){\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer in the vector\n    for(int num : lst){\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Iterate through the frequency map to find the greatest integer that meets the criteria\n    for(const auto& pair : frequencyMap){\n        int num = pair.first;\n        int freq = pair.second;\n        \n        if(num <= freq && num > result){\n            result = num;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    sort(lst.begin(), lst.end());\n    \n    int i = 0;\n    int j = lst.size() - 1;\n    \n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides can form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    auto count_chars = [](const vector<string>& lst) {\n        int count = 0;\n        for (const string& s : lst) {\n            count += s.size();\n        }\n        return count;\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < primes.size(); ++i) {\n        for (int j = i; j < primes.size(); ++j) {\n            for (int k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return x == 1; // The only simple power of 1 is 1 itself.\n    }\n\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power == x;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a; // Take the absolute value of a\n    }\n    int cube_root = round(cbrt(a)); // Calculate the cube root and round it to the nearest integer\n    return cube_root * cube_root * cube_root == a; // Check if the cube of the rounded cube root equals the original number\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isPrime(char hexDigit) {\n    // Convert hex digit to decimal\n    int digit;\n    if (hexDigit >= '0' && hexDigit <= '9') {\n        digit = hexDigit - '0';\n    } else {\n        digit = hexDigit - 'A' + 10;\n    }\n    \n    // Check if the digit is a prime number\n    if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n        return true;\n    }\n    return false;\n}\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        if (isPrime(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\";\n    if (decimal == 0) {\n        binary += \"0\";\n    } else {\n        while (decimal > 0) {\n            binary = (decimal % 2 == 0 ? \"0\" : \"1\") + binary;\n            decimal /= 2;\n        }\n    }\n    binary += \"db\";\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive letters\n    for (int i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all 3 consecutive letters are distinct, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there are exactly two numbers: 1 and 0.\n    if (n == 1) {\n        return 2;\n    }\n    \n    // For n > 1, the count of n-digit numbers that start or end with 1 is:\n    // - Numbers that start with 1: 10^(n-1)\n    // - Numbers that end with 1: 10^(n-1)\n    // - Numbers that both start and end with 1: 10^(n-2)\n    // Using the principle of inclusion-exclusion, we get:\n    // 10^(n-1) + 10^(n-1) - 10^(n-2)\n    return (2 * pow(10, n-1)) - pow(10, n-2);\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    string binarySum;\n    while (sum > 0) {\n        binarySum = (sum % 2 == 0 ? \"0\" : \"1\") + binarySum;\n        sum /= 2;\n    }\n    \n    return binarySum.empty() ? \"0\" : binarySum;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    string word;\n    bool in_word = false;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (in_word) {\n                sort(word.begin(), word.end());\n                result += word;\n                word.clear();\n                in_word = false;\n            }\n            result += c;\n        } else {\n            word += c;\n            in_word = true;\n        }\n    }\n\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If the element matches x, add the coordinate to the list\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort coordinates by rows in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // For each row, sort coordinates by columns in descending order\n    int currentRow = -1;\n    for (int i = 0; i < coordinates.size(); ++i) {\n        if (coordinates[i][0] != currentRow) {\n            currentRow = coordinates[i][0];\n            int start = i;\n            while (i + 1 < coordinates.size() && coordinates[i + 1][0] == currentRow) {\n                ++i;\n            }\n            sort(coordinates.begin() + start, coordinates.begin() + i + 1, [](const vector<int>& a, const vector<int>& b) {\n                return a[1] > b[1];\n            });\n        }\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) return array;\n\n    int first_value = array.front();\n    int last_value = array.back();\n    int sum = first_value + last_value;\n\n    vector<int> sorted_array = array;\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = 'a' + (c - 'a' + 4) % 26;\n            encrypted += newChar;\n        } else {\n            // If the character is not a lowercase letter, leave it unchanged\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no such element\n    }\n\n    sort(lst.begin(), lst.end());\n\n    int smallest = lst[0];\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != smallest) {\n            return lst[i];\n        }\n    }\n\n    return -1; // Return -1 to indicate no such element\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    size_t pos = 0;\n    string delimiter = \".!?\";\n\n    while ((pos = S.find_first_of(delimiter, pos)) != string::npos) {\n        S[pos] = ' ';\n        pos++;\n    }\n\n    stringstream ss(S);\n    string word;\n    bool sentenceStart = true;\n\n    while (ss >> word) {\n        if (sentenceStart && word == \"I\") {\n            boredomCount++;\n        }\n        sentenceStart = (word.find_first_of(delimiter) != string::npos);\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n\n            // Replace vowels with the letter 2 places ahead\n            if (c == 'A' || c == 'a') c = 'C';\n            else if (c == 'E' || c == 'e') c = 'G';\n            else if (c == 'I' || c == 'i') c = 'K';\n            else if (c == 'O' || c == 'o') c = 'Q';\n            else if (c == 'U' || c == 'u') c = 'Y';\n        }\n        encodedMessage += c;\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0; // No prime found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) {\n            return false;\n        }\n\n        bool is_lower = true;\n        bool is_upper = true;\n\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n        }\n\n        if (!is_lower && !is_upper) {\n            return false;\n        }\n\n        all_lower &= is_lower;\n        all_upper &= is_upper;\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    string vowels = \"AEIOU\";\n    \n    for (int i = 0; i < s.length(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    }\n    // If the number is not halfway between two integers, round to the nearest integer\n    else {\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_level = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_level);\n        if (current_level % 2 == 0) {\n            current_level += 2; // Next even number\n        } else {\n            current_level += 2; // Next odd number\n        }\n    }\n    \n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use a delimiter to split the string by both commas and spaces\n    while (getline(ss, word, ',')) {\n        // Remove leading and trailing spaces from the word\n        word.erase(word.begin(), find_if(word.begin(), word.end(), [](int ch) {\n            return !isspace(ch);\n        }));\n        word.erase(find_if(word.rbegin(), word.rend(), [](int ch) {\n            return !isspace(ch);\n        }).base(), word.end());\n        \n        // If the word is not empty, add it to the vector\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n    }\n    \n    // If there are no commas, split by spaces\n    if (words.empty()) {\n        ss.clear();\n        ss.str(s);\n        while (ss >> word) {\n            words.push_back(word);\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Adjust x to be the first even number in the range [x, y]\n    if (x % 2 != 0) {\n        x += 1;\n    }\n\n    // Check if there is any even number in the range [x, y]\n    if (x > y) {\n        return -1;\n    }\n\n    // Return the biggest even number in the range [x, y]\n    return y % 2 == 0 ? y : y - 1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Round the average to the nearest integer (smaller one)\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binary_representation;\n    if (rounded_average == 0) {\n        binary_representation = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary_representation = to_string(rounded_average % 2) + binary_representation;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary_representation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr){\n    // Map to store the corresponding names for digits 1 to 9\n    map<int, string> digitNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the array to include only numbers between 1 and 9\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit by its corresponding name\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(digitNames[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum for odd i\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int shifts = 0;\n\n    // Find the number of shifts needed to make the array sorted\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            shifts++;\n        }\n    }\n\n    // If more than one shift is needed, it's not possible to sort the array\n    return shifts <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // If the number of odd elements in lst1 is less than or equal to the number of even elements in lst2,\n    // then it is possible to exchange elements to make lst1 all even.\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> result;\n    int maxCount = 0;\n\n    // Split the string into individual letters\n    stringstream ss(test);\n    string letter;\n    while (ss >> letter) {\n        for (char c : letter) {\n            letterCount[c]++;\n            if (letterCount[c] > maxCount) {\n                maxCount = letterCount[c];\n            }\n        }\n    }\n\n    // Find all letters with the maximum count\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are in c\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    bool isPalindrome = true;\n    int n = result.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (result[i] != result[n - i - 1]) {\n            isPalindrome = false;\n            break;\n        }\n    }\n\n    // Return the result string and the palindrome check result\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + to_string(odd_count) + \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) + \" of the \" + to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle the edge case where the vector is empty\n\n    long long minSum = nums[0];\n    long long currentSum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = min(nums[i], currentSum + nums[i]);\n        minSum = min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n        for (const auto& unit : well) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        total_lowers += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n    }\n\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of ones in their binary representation\n    // For similar number of ones, sort based on decimal value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b;\n        }\n        return onesA < onesB;\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    int consonantCount = 0;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (consonantCount == n) {\n                result.push_back(word);\n            }\n            word.clear();\n            consonantCount = 0;\n        } else {\n            word += c;\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n    }\n\n    // Check the last word in the string\n    if (consonantCount == n) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string result = \"\";\n\n    for (int i = word.size() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            bool left_consonant = false, right_consonant = false;\n            for (int j = i - 1; j >= 0; --j) {\n                if (consonants.find(word[j]) != string::npos) {\n                    left_consonant = true;\n                    break;\n                }\n            }\n            for (int j = i + 1; j < word.size(); ++j) {\n                if (consonants.find(word[j]) != string::npos) {\n                    right_consonant = true;\n                    break;\n                }\n            }\n            if (left_consonant && right_consonant) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int balance1 = 0, balance2 = 0;\n    \n    // Calculate the balance for the first string\n    for (char c : lst[0]) {\n        if (c == '(') balance1++;\n        else balance1--;\n    }\n    \n    // Calculate the balance for the second string\n    for (char c : lst[1]) {\n        if (c == '(') balance2++;\n        else balance2--;\n    }\n    \n    // Check if the total balance can be zero\n    if (balance1 + balance2 == 0 && balance1 >= 0 && balance2 >= 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (num >= 10 && num <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final 1 to the list of odd numbers\n    odd_numbers.push_back(1);\n    \n    // Sort the vector in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n\n    // Check if the date string is in the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date string into month, day, and year\n    stringstream ss(date);\n    string item;\n    vector<string> tokens;\n    while (getline(ss, item, '-')) {\n        tokens.push_back(item);\n    }\n\n    if (tokens.size() != 3) return false;\n\n    int month, day, year;\n    try {\n        month = stoi(tokens[0]);\n        day = stoi(tokens[1]);\n        year = stoi(tokens[2]);\n    } catch (invalid_argument&) {\n        return false;\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on month\n    if (month == 2) {\n        int maxDay = isLeapYear(year) ? 29 : 28;\n        if (day < 1 || day > maxDay) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) return false;\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    size_t pos = 0;\n    string delimiter = \" \";\n    \n    // Check if there are whitespaces\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // Check if there are commas\n    delimiter = \",\";\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // If no whitespaces or commas, count odd-ordered lower-case letters\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in ascending order\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // Check if any number appears more than twice\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int productOfSigns = 1;\n    int sumOfMagnitudes = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            productOfSigns *= 1;\n        } else if (num < 0) {\n            productOfSigns *= -1;\n        } else {\n            productOfSigns *= 0;\n        }\n        sumOfMagnitudes += abs(num);\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<int> result;\n\n    // Helper function to perform DFS and find the minimum path\n    function<void(int, int, vector<int>&)> dfs = [&](int x, int y, vector<int>& path) {\n        if (path.size() == k) {\n            if (result.empty() || path < result) {\n                result = path;\n            }\n            return;\n        }\n\n        for (auto& dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                path.push_back(grid[nx][ny]);\n                dfs(nx, ny, path);\n                path.pop_back();\n            }\n        }\n    };\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> path = {grid[i][j]};\n            dfs(i, j, path);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacciSequence(n + 1);\n    \n    // Base cases\n    tribonacciSequence[0] = 1;\n    tribonacciSequence[1] = 3;\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            tribonacciSequence[i] = 1 + i / 2;\n        } else {\n            tribonacciSequence[i] = tribonacciSequence[i - 1] + tribonacciSequence[i - 2] + tribonacciSequence[i + 1];\n        }\n    }\n    \n    return tribonacciSequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    \n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0;\n    int nestedCount = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n                nestedCount++;\n            }\n        }\n    }\n\n    return nestedCount > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) return false;\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) return false;\n\n    // Check if the last character is not part of a word\n    if (txt.length() == 1) return true; // Single character string\n\n    // Get the second last character\n    char secondLastChar = txt[txt.length() - 2];\n\n    // If the second last character is a space, the last character is not part of a word\n    return isspace(secondLastChar);\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    if (!has_negative) {\n        largest_negative = 0;\n    }\n    if (!has_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/algorithm/string.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        if (val.type() == typeid(int)) {\n            return static_cast<double>(boost::any_cast<int>(val));\n        } else if (val.type() == typeid(float)) {\n            return static_cast<double>(boost::any_cast<float>(val));\n        } else if (val.type() == typeid(double)) {\n            return boost::any_cast<double>(val);\n        } else if (val.type() == typeid(string)) {\n            string str = boost::any_cast<string>(val);\n            boost::replace_all(str, \",\", \".\");\n            return stod(str);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and greater than or equal to 8\n    if (n % 2 == 0 && n >= 8) {\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text){\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            if (spaceCount == 1) {\n                result += '_';\n            } else if (spaceCount > 2) {\n                // Do nothing, we will replace multiple spaces with '-' later\n            }\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            }\n            spaceCount = 0;\n            result += c;\n        }\n    }\n\n    // Handle the case where the string ends with multiple spaces\n    if (spaceCount > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    bool valid_extension = false;\n    string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    string before_dot = \"\";\n    string after_dot = \"\";\n\n    // Iterate through the file name to count dots and digits\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        } else if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there is exactly one dot\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the file name into before and after the dot\n    size_t dot_pos = file_name.find('.');\n    before_dot = file_name.substr(0, dot_pos);\n    after_dot = file_name.substr(dot_pos + 1);\n\n    // Check if the substring before the dot is not empty and starts with a letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of the valid extensions\n    for (string ext : valid_extensions) {\n        if (after_dot == ext) {\n            valid_extension = true;\n            break;\n        }\n    }\n\n    if (!valid_extension) {\n        return \"No\";\n    }\n\n    // Check if there are not more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the entry if index is a multiple of 3\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the entry if index is a multiple of 4 and not a multiple of 3\n        }\n        sum += lst[i]; // Add the modified entry to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeLengthWords;\n    \n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    string result;\n    for (const string& w : primeLengthWords) {\n        if (!result.empty()) result += \" \";\n        result += w;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to parse the fraction string and return the numerator and denominator\npair<int, int> parseFraction(const string& fraction) {\n    size_t pos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, pos));\n    int denominator = stoi(fraction.substr(pos + 1));\n    return {numerator, denominator};\n}\n\n// Helper function to check if the product of two fractions is a whole number\nbool isWholeNumber(int num1, int den1, int num2, int den2) {\n    // Calculate the product of the two fractions\n    int numerator = num1 * num2;\n    int denominator = den1 * den2;\n    \n    // Check if the product is a whole number\n    return numerator % denominator == 0;\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    pair<int, int> fractionX = parseFraction(x);\n    pair<int, int> fractionN = parseFraction(n);\n    \n    // Check if the product of the two fractions is a whole number\n    return isWholeNumber(fractionX.first, fractionX.second, fractionN.first, fractionN.second);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs where each pair contains the number and its sum of digits\n    vector<pair<int, int>> num_sum_pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_sum_pairs.push_back({nums[i], sum_of_digits(nums[i])});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.second == b.second) {\n            return false; // Keep the original order if sums are equal\n        }\n        return a.second < b.second;\n    });\n\n    // Extract the sorted numbers from the sorted pairs\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.first);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string numStr = to_string(abs(num));\n    char firstDigit = numStr.front();\n    char lastDigit = numStr.back();\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) return {};\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) swap(index1, index2);\n    \n    // Collect the planets between index1 and index2 (exclusive)\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and non-negative\n        if (floor(num) == num && num >= 0) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result(game.size());\n    for (int i = 0; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If the second string is longer than the first, it cannot be a substring or rotation\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    // Concatenate the second string with itself to handle rotations\n    string rotatedB = b + b;\n\n    // Check if the first string contains any rotation of the second string\n    return rotatedB.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> result = {0, 0}; // Initialize result vector with {even_count, odd_count}\n    num = abs(num); // Handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            result[0]++; // Increment even count\n        } else {\n            result[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    // Iterate through the symbols and append the corresponding Roman numeral to the result\n    for (const auto& symbol : romanSymbols) {\n        while (number >= symbol.first) {\n            result += symbol.second;\n            number -= symbol.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure the sides are sorted in ascending order\n    float sides[3] = {a, b, c};\n    for (int i = 0; i < 2; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (sides[i] > sides[j]) {\n                float temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n    \n    // Check the Pythagorean theorem\n    return (pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words){\n    auto count_unique_chars = [](const string& word) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        return unique_chars.size();\n    };\n\n    string max_word = \"\";\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_chars(word);\n        if (unique_count > max_unique_count || (unique_count == max_unique_count && word < max_word)) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int carrotsNeeded = need - number;\n\n    if (carrotsNeeded > 0) {\n        if (remaining >= carrotsNeeded) {\n            totalEaten += carrotsNeeded;\n            remaining -= carrotsNeeded;\n        } else {\n            totalEaten += remaining;\n            remaining = 0;\n        }\n    }\n\n    return {totalEaten, remaining};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands to build the expression\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    for (char &c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\n#include<sstream>\n#include<iomanip>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    ostringstream oss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        oss << hex << setw(2) << setfill('0') << (int)result[i];\n    }\n\n    return oss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    for (int i = start; i <= end; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    int balance = 0;\n    string current_group = \"\";\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue; // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group = \"\";\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integerPart = static_cast<int>(number);\n    // Calculate the decimal part\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers){\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the Mean Absolute Deviation\n    float mad = 0.0;\n    for (float num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n    \n    while (ss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    if (numbers.empty()) {\n        sum = 0;\n        product = 1;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> result;\n    if (numbers.empty()) return result;\n\n    int current_max = numbers[0];\n    result.push_back(current_max);\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    if (str.empty()) return \"\";\n\n    // Find the longest palindromic suffix\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the end of the string\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, append the reverse of the entire string\n    string reversed = str;\n    reverse(reversed.begin(), reversed.end());\n    return str + reversed;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int len = a.length();\n    \n    for (int i = 0; i < len; i++) {\n        // Perform XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestString = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str){ \n    unordered_set<char> distinctChars;\n    for (char &c : str) {\n        distinctChars.insert(tolower(c));\n    }\n    return distinctChars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string note;\n    for (size_t i = 0; i < music_string.size(); ++i) {\n        if (music_string[i] == ' ') {\n            continue;\n        }\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(2);\n                ++i; // Skip the '|'\n            } else {\n                beats.push_back(4);\n            }\n        } else if (music_string[i] == '.') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(1);\n                ++i; // Skip the '|'\n            }\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to convert words to their corresponding numbers\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to store the numbers corresponding to the words\n    vector<int> nums;\n\n    // Stringstream to split the input string by spaces\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        nums.push_back(wordToNumber[word]);\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Vector to store the sorted words\n    vector<string> sortedWords;\n    for (int num : nums) {\n        for (const auto& pair : wordToNumber) {\n            if (pair.second == num) {\n                sortedWords.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += sortedWords[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The input vector must contain at least two elements.\");\n    }\n\n    vector<float> closestPair = {numbers[0], numbers[1]};\n    float minDistance = abs(numbers[0] - numbers[1]);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float distance = abs(numbers[i] - numbers[j]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestPair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    if (closestPair[0] > closestPair[1]) {\n        swap(closestPair[0], closestPair[1]);\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    float minVal = numbers[0];\n    float maxVal = numbers[0];\n\n    // Find the minimum and maximum values in the vector\n    for (float num : numbers) {\n        if (num < minVal) {\n            minVal = num;\n        }\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n\n    // Calculate the range\n    float range = maxVal - minVal;\n\n    // Apply the linear transform\n    vector<float> rescaledNumbers;\n    for (float num : numbers) {\n        float rescaledNum = (num - minVal) / range;\n        rescaledNumbers.push_back(rescaledNum);\n    }\n\n    return rescaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n#include<typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n#include<cmath>\n\nint largest_divisor(int n) {\n    if (n <= 1) return -1; // No valid divisor for n <= 1\n    for (int i = sqrt(n); i >= 2; --i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1; // If no other divisor found, n is prime, so the largest divisor is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    \n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Add elements that occur only once to the result vector\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char& c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings){\n    string result = \"\";\n    for(const string& str : strings){\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_numbers;\n    for(float num : l){\n        if(num > 0){\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x){\n    /* \n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    */\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    double x0 = 0.0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (fabs(fx) < tolerance) {\n            return x0; // Converged to a root\n        }\n\n        x0 = x0 - fx / dfx; // Newton-Raphson update\n    }\n\n    return x0; // Return the last computed value if max iterations reached\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> l_prime = l; // Initialize l' with the same values as l\n    vector<int> to_sort; // Vector to store elements at indices divisible by three\n\n    // Collect elements at indices divisible by three\n    for (int i = 0; i < l.size(); i++) {\n        if ((i + 1) % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace the elements in l' with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if ((i + 1) % 3 == 0) {\n            l_prime[i] = to_sort[index++];\n        }\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use a vector to store unique elements\n    vector<int> uniqueElements;\n    \n    // Iterate through the sorted vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // If the current element is different from the previous one, add it to the uniqueElements vector\n        if (i == 0 || l[i] != l[i - 1]) {\n            uniqueElements.push_back(l[i]);\n        }\n    }\n    \n    return uniqueElements;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    float maxVal = l[0];\n    for (float num : l) {\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n    return maxVal;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint countSevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += countSevens(i);\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l){\n    // Extract even indexed elements and sort them\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    sort(even_elements.begin(), even_elements.end());\n\n    // Reconstruct the list with sorted even indexed elements\n    vector<float> sorted_list;\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            sorted_list.push_back(even_elements[even_index++]);\n        } else {\n            sorted_list.push_back(l[i]);\n        }\n    }\n\n    return sorted_list;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    // returns decoded string by reversing the cycling of groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<int> fibs = {1, 1};\n    int count = 0;\n    while (true) {\n        int next_fib = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n        fibs.push_back(next_fib);\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    int n = l.size();\n    if (n < 3) return false;\n\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    // Therefore, the total number of collisions is the product of the number of cars in each direction.\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // The area of a triangle with base 'a' and height 'h' is given by:\n    // Area = 0.5 * base * height\n    return 0.5 * a * h;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<vector>\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    std::vector<int> fib4_sequence(n + 1);\n    fib4_sequence[0] = 0;\n    fib4_sequence[1] = 0;\n    fib4_sequence[2] = 2;\n    fib4_sequence[3] = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        fib4_sequence[i] = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4];\n    }\n\n    return fib4_sequence[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Find the size of the vector\n    int n = l.size();\n    \n    // If the size of the vector is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size of the vector is even, return the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text){\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    long long result = 1;\n    long long base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    text.erase(remove_if(text.begin(), text.end(), [&](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    return text;\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create frequency maps for both strings\n    unordered_map<char, int> freq0, freq1;\n    \n    // Populate the frequency map for s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    \n    // Populate the frequency map for s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n    \n    // Compare the frequency maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n){\n    if (n <= 0) return 0; // Handle edge case for non-positive integers\n    if (n == 1) return 1; // Base case for the first Fibonacci number\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        // If balance goes negative, it means we have more closing brackets than opening ones\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() < 2) return true; // A single element or no elements are trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n\n        // If neither increasing nor decreasing, it's not monotonic\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert the first list to a set for O(1) lookups\n    unordered_set<int> set1(l1.begin(), l1.end());\n    vector<int> result;\n\n    // Iterate through the second list and check for common elements\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            result.push_back(num);\n            // Remove the element from the set to ensure uniqueness\n            set1.erase(num);\n        }\n    }\n\n    // Sort the result vector\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    // Check for the smallest factors first\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n                largest_factor = i;\n            }\n            if (is_prime(n / i)) {\n                largest_factor = n / i;\n            }\n        }\n    }\n    // If no prime factor found, n itself is a prime factor\n    if (largest_factor == 1) {\n        largest_factor = n;\n    }\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> fibfib_sequence(n + 1, 0);\n    fibfib_sequence[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfib_sequence[i] = fibfib_sequence[i - 1] + fibfib_sequence[i - 2] + fibfib_sequence[i - 3];\n    }\n\n    return fibfib_sequence[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (s.back() == 'y') { // Check if 'y' is at the end of the word\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to easily manipulate its digits\n    string digits = to_string(x);\n    int num_digits = digits.size();\n\n    // If shift is greater than the number of digits, return the digits reversed\n    if (shift > num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    // Calculate the effective shift (modulo the number of digits)\n    shift = shift % num_digits;\n\n    // Perform the circular shift\n    string result = digits.substr(num_digits - shift) + digits.substr(0, num_digits - shift);\n\n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    vector<string> tokens;\n    \n    // Tokenize the input string\n    while (ss >> temp) {\n        tokens.push_back(temp);\n    }\n    \n    // Extract the number of apples and oranges from the tokens\n    for (int i = 0; i < tokens.size(); i++) {\n        if (tokens[i] == \"apples\") {\n            apples = stoi(tokens[i - 1]);\n        } else if (tokens[i] == \"oranges\") {\n            oranges = stoi(tokens[i - 1]);\n        }\n    }\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int smallestEven = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestEven == -1) return {};\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst){\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer in the vector\n    for(int num : lst){\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Iterate through the frequency map to find the greatest integer that meets the criteria\n    for(const auto& pair : frequencyMap){\n        int num = pair.first;\n        int freq = pair.second;\n        \n        if(num <= freq && num > result){\n            result = num;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    sort(lst.begin(), lst.end());\n    \n    int i = 0;\n    int j = lst.size() - 1;\n    \n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides can form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    auto count_chars = [](const vector<string>& lst) {\n        int count = 0;\n        for (const string& s : lst) {\n            count += s.size();\n        }\n        return count;\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate all prime numbers less than 100\nvector<int> generatePrimes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = generatePrimes();\n    int count = 0;\n\n    for (int prime : primes) {\n        while (a % prime == 0) {\n            a /= prime;\n            count++;\n        }\n    }\n\n    return count == 3 && a == 1;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return x == 1; // The only simple power of 1 is 1 itself.\n    }\n\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power == x;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a; // Take the absolute value of a\n    }\n    int cube_root = round(cbrt(a)); // Calculate the cube root and round it to the nearest integer\n    return cube_root * cube_root * cube_root == a; // Check if the cube of the rounded cube root equals the original number\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        switch (c) {\n            case '2': case '3': case '5': case '7':\n            case 'B': case 'D':\n                if (isPrime(c >= 'A' ? c - 'A' + 10 : c - '0')) {\n                    count++;\n                }\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\";  // Start with the prefix \"db\"\n    if (decimal == 0) {\n        binary += \"0\";  // Special case for 0\n    } else {\n        while (decimal > 0) {\n            binary += to_string(decimal % 2);  // Append the least significant bit\n            decimal /= 2;  // Shift right\n        }\n        reverse(binary.begin() + 2, binary.end());  // Reverse the binary string to get the correct order\n    }\n    binary += \"db\";  // Append the suffix \"db\"\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive letters\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all 3 consecutive letters are distinct, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there are exactly two numbers: 1 and 0.\n    if (n == 1) {\n        return 2;\n    }\n\n    // For n > 1, the count of n-digit numbers that start or end with 1 is:\n    // - Numbers that start with 1: 10^(n-1)\n    // - Numbers that end with 1: 10^(n-1)\n    // - Subtract the overlap: 10^(n-2) (since numbers that start and end with 1 are counted twice)\n    return (2 * pow(10, n-1)) - pow(10, n-2);\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\n#include<bitset>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return bitset<32>(sum).to_string().substr(32 - log2(sum) - 1);\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                sort(word.begin(), word.end());\n                result += word;\n                word = \"\";\n            }\n            result += c;\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If the element matches x, add the coordinate to the list\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort coordinates by rows in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // For each row, sort coordinates by columns in descending order\n    int currentRow = -1;\n    for (int i = 0; i < coordinates.size(); ++i) {\n        if (coordinates[i][0] != currentRow) {\n            currentRow = coordinates[i][0];\n            int start = i;\n            while (i + 1 < coordinates.size() && coordinates[i + 1][0] == currentRow) {\n                ++i;\n            }\n            sort(coordinates.begin() + start, coordinates.begin() + i + 1, [](const vector<int>& a, const vector<int>& b) {\n                return a[1] > b[1];\n            });\n        }\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) return array;\n\n    int first_value = array.front();\n    int last_value = array.back();\n    int sum = first_value + last_value;\n\n    vector<int> sorted_array = array;\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = c + 4;\n            // Wrap around if necessary\n            if (newChar > 'z') {\n                newChar -= 26;\n            }\n            encrypted += newChar;\n        } else {\n            // If the character is not a lowercase letter, leave it unchanged\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no such element\n    }\n\n    sort(lst.begin(), lst.end());\n\n    int smallest = lst[0];\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != smallest) {\n            return lst[i];\n        }\n    }\n\n    return -1; // Return -1 to indicate no such element\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    size_t pos = 0;\n    string delimiter = \".!?\";\n\n    while ((pos = S.find_first_of(delimiter, pos)) != string::npos) {\n        S[pos] = '\\0'; // Null-terminate the sentence for easier processing\n        pos++;\n    }\n\n    string sentence;\n    for (size_t i = 0; i < S.size(); i++) {\n        if (S[i] == '\\0') {\n            if (!sentence.empty() && sentence[0] == 'I') {\n                boredomCount++;\n            }\n            sentence.clear();\n        } else {\n            sentence += S[i];\n        }\n    }\n\n    // Check the last sentence if the string does not end with a delimiter\n    if (!sentence.empty() && sentence[0] == 'I') {\n        boredomCount++;\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n\n            // Replace vowels with the letter 2 places ahead\n            if (c == 'a' || c == 'A') c = 'c';\n            else if (c == 'e' || c == 'E') c = 'g';\n            else if (c == 'i' || c == 'I') c = 'k';\n            else if (c == 'o' || c == 'O') c = 'q';\n            else if (c == 'u' || c == 'U') c = 'w';\n            else if (c == 'y' || c == 'Y') c = 'a'; // Wrap around for 'y'\n        }\n        encodedMessage += c;\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0; // No prime found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) {\n            return false;\n        }\n\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (islower(c)) {\n                allUpper = false;\n            }\n            if (isupper(c)) {\n                allLower = false;\n            }\n        }\n\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    string vowels = \"AEIOU\";\n    \n    for (int i = 0; i < s.size(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    }\n    // Otherwise, use standard rounding\n    else {\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_level = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_level);\n        if (current_level % 2 == 0) {\n            current_level += 2; // Next even number\n        } else {\n            current_level += 2; // Next odd number\n        }\n    }\n    \n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use a delimiter to handle both commas and spaces\n    while (getline(ss, word, ',')) {\n        // Remove leading and trailing spaces from the word\n        word.erase(word.begin(), find_if(word.begin(), word.end(), [](int ch) {\n            return !isspace(ch);\n        }));\n        word.erase(find_if(word.rbegin(), word.rend(), [](int ch) {\n            return !isspace(ch);\n        }).base(), word.end());\n        \n        // If the word is not empty, add it to the vector\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Adjust x to be the first even number in the range [x, y]\n    if (x % 2 != 0) {\n        x += 1; // Make x even\n    }\n\n    // Check if there is any even number in the range [x, y]\n    if (x > y) {\n        return -1;\n    }\n\n    // Return the biggest even number in the range [x, y]\n    return y % 2 == 0 ? y : y - 1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Round the average to the nearest integer (smaller one)\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binary_representation;\n    if (rounded_average == 0) {\n        binary_representation = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary_representation = to_string(rounded_average % 2) + binary_representation;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary_representation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr){\n    // Map to store the corresponding names for digits 1 to 9\n    map<int, string> digitToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter and sort the valid numbers (between 1 and 9 inclusive)\n    vector<int> validNumbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            validNumbers.push_back(num);\n        }\n    }\n    sort(validNumbers.begin(), validNumbers.end());\n\n    // Reverse the sorted vector\n    reverse(validNumbers.begin(), validNumbers.end());\n\n    // Replace each digit by its corresponding name\n    vector<string> result;\n    for (int num : validNumbers) {\n        result.push_back(digitToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum for odd i\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int shifts = 0;\n\n    // Find the number of shifts needed to make the array sorted\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            shifts++;\n        }\n    }\n\n    // If there is more than one break point, it's not possible to sort the array\n    return shifts <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // If the number of odd elements in lst1 is less than or equal to the number of even elements in lst2,\n    // then it is possible to exchange elements to make lst1 all even.\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> result;\n    int maxCount = 0;\n\n    // Split the string by spaces and count each letter\n    stringstream ss(test);\n    string letter;\n    while (ss >> letter) {\n        for (char c : letter) {\n            letterCount[c]++;\n            if (letterCount[c] > maxCount) {\n                maxCount = letterCount[c];\n            }\n        }\n    }\n\n    // Find all letters with the maximum count\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = maxCount;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are in c\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    bool isPalindrome = true;\n    int n = result.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (result[i] != result[n - i - 1]) {\n            isPalindrome = false;\n            break;\n        }\n    }\n\n    // Return the result string and the palindrome check result\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    string templateStr = \"the number of odd elements in the string of the input.\";\n    map<int, string> numToWord = {{1, \"1\"}, {2, \"2\"}, {3, \"3\"}, {4, \"4\"}, {5, \"5\"}, {6, \"6\"}, {7, \"7\"}, {8, \"8\"}, {9, \"9\"}};\n\n    for (int i = 0; i < lst.size(); ++i) {\n        int oddCount = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                oddCount++;\n            }\n        }\n        string output = templateStr;\n        output.replace(output.find(\"in the string\"), 13, numToWord[i + 1]);\n        output.replace(output.find(\"of the input.\"), 13, numToWord[oddCount] + \" of the \" + numToWord[i + 1] + \"put.\");\n        result.push_back(output);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle the edge case where the vector is empty\n\n    long long minSum = nums[0]; // Initialize minSum with the first element\n    long long currentSum = nums[0]; // Initialize currentSum with the first element\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update currentSum to be the minimum of the current element or the currentSum plus the current element\n        currentSum = min(nums[i], currentSum + nums[i]);\n        // Update minSum to be the minimum of minSum and currentSum\n        minSum = min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (const auto& unit : row) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        if (water_units > 0) {\n            total_lowers += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        }\n    }\n\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of ones in their binary representation\n    // If the number of ones is the same, sort based on the decimal value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b;\n        }\n        return countA < countB;\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u';\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    int consonantCount = 0;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (consonantCount == n) {\n                result.push_back(word);\n            }\n            word.clear();\n            consonantCount = 0;\n        } else {\n            word += c;\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n    }\n\n    // Check the last word in the string\n    if (consonantCount == n) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"AEIOUaeiou\";\n    string consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n\n    for (int i = word.size() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            bool left_consonant = consonants.find(word[i - 1]) != string::npos;\n            bool right_consonant = consonants.find(word[i + 1]) != string::npos;\n            if (left_consonant && right_consonant) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int balance1 = 0, balance2 = 0;\n    \n    // Calculate the balance for the first string\n    for (char c : lst[0]) {\n        if (c == '(') balance1++;\n        else balance1--;\n    }\n    \n    // Calculate the balance for the second string\n    for (char c : lst[1]) {\n        if (c == '(') balance2++;\n        else balance2--;\n    }\n    \n    // Check if the total balance can be zero\n    if (balance1 + balance2 == 0 && balance1 >= 0 && balance2 >= 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (num < 100 && num > -100) { // Check if the number has at most two digits\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Start the sequence with the given number\n    while (n != 1) {\n        if (n % 2 == 1) {\n            // If the number is odd, add it to the list\n            odd_numbers.push_back(n);\n        }\n        // Generate the next number in the sequence\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final 1 to the list\n    odd_numbers.push_back(1);\n    \n    // Sort the list in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date string into month, day, and year\n    stringstream ss(date);\n    string item;\n    vector<string> tokens;\n    while (getline(ss, item, '-')) {\n        tokens.push_back(item);\n    }\n\n    if (tokens.size() != 3) return false;\n\n    int month, day, year;\n    try {\n        month = stoi(tokens[0]);\n        day = stoi(tokens[1]);\n        year = stoi(tokens[2]);\n    } catch (invalid_argument&) {\n        return false;\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on month\n    if (month == 2) {\n        int max_days = is_leap_year(year) ? 29 : 28;\n        if (day < 1 || day > max_days) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) return false;\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    size_t pos = 0;\n    string delimiter = \" \";\n    \n    // Check if there are whitespaces\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // Check if there are commas\n    delimiter = \",\";\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // If no whitespaces or commas, count odd order lower-case letters\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in ascending order\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // Check if any number appears more than twice\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else {\n            product_of_signs *= 0;\n        }\n        sum_of_magnitudes += abs(num);\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<limits.h>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> result;\n    vector<int> currentPath;\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    function<void(int, int, int)> dfs = [&](int x, int y, int steps) {\n        currentPath.push_back(grid[x][y]);\n        if (steps == k) {\n            if (result.empty() || currentPath < result) {\n                result = currentPath;\n            }\n        } else {\n            for (auto& dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                    dfs(nx, ny, steps + 1);\n                }\n            }\n        }\n        currentPath.pop_back();\n    };\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dfs(i, j, 1);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacciSequence;\n    if (n < 0) return tribonacciSequence; // Return empty vector for negative input\n\n    // Initialize the first element of the sequence\n    tribonacciSequence.push_back(1);\n\n    // Handle the case where n is 0\n    if (n == 0) return tribonacciSequence;\n\n    // Initialize the second element of the sequence\n    tribonacciSequence.push_back(3);\n\n    // Handle the case where n is 1\n    if (n == 1) return tribonacciSequence;\n\n    // Initialize the third element of the sequence\n    tribonacciSequence.push_back(2);\n\n    // Handle the case where n is 2\n    if (n == 2) return tribonacciSequence;\n\n    // Compute the rest of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int nextValue;\n        if (i % 2 == 0) {\n            nextValue = 1 + i / 2;\n        } else {\n            nextValue = tribonacciSequence[i - 1] + tribonacciSequence[i - 2] + tribonacciSequence[i + 1];\n        }\n        tribonacciSequence.push_back(nextValue);\n    }\n\n    return tribonacciSequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    \n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0;\n    int nestedCount = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n                nestedCount++;\n            }\n        }\n    }\n\n    return nestedCount > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) return false;\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) return false;\n\n    // Check if the last character is not part of a word\n    if (txt.length() > 1) {\n        char secondLastChar = txt[txt.length() - 2];\n        if (isalpha(secondLastChar)) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    if (!has_negative) {\n        largest_negative = 0;\n    }\n    if (!has_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/algorithm/string.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        if (val.type() == typeid(int)) {\n            return static_cast<double>(boost::any_cast<int>(val));\n        } else if (val.type() == typeid(float)) {\n            return static_cast<double>(boost::any_cast<float>(val));\n        } else if (val.type() == typeid(double)) {\n            return boost::any_cast<double>(val);\n        } else if (val.type() == typeid(string)) {\n            string str = boost::any_cast<string>(val);\n            boost::replace_all(str, \",\", \".\");\n            return stod(str);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the number is even and greater than or equal to 8\n    if (n % 2 == 0 && n >= 8) {\n        // Any even number greater than or equal to 8 can be written as the sum of exactly 4 positive even numbers\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text){\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            if (spaceCount == 1) {\n                result += '_';\n            } else if (spaceCount > 2) {\n                // Do nothing, we will replace multiple spaces with '-' later\n            }\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            }\n            spaceCount = 0;\n            result += c;\n        }\n    }\n\n    // Handle the case where the string ends with multiple spaces\n    if (spaceCount > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    string extension;\n    string name_before_dot;\n\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n            if (dot_count > 1) return \"No\";\n        } else if (isdigit(c)) {\n            digit_count++;\n            if (digit_count > 3) return \"No\";\n        }\n    }\n\n    if (dot_count != 1) return \"No\";\n\n    size_t dot_pos = file_name.find('.');\n    name_before_dot = file_name.substr(0, dot_pos);\n    extension = file_name.substr(dot_pos + 1);\n\n    if (name_before_dot.empty() || !isalpha(name_before_dot[0])) return \"No\";\n\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the entry if index is a multiple of 3\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the entry if index is a multiple of 4 and not a multiple of 3\n        }\n        sum += lst[i]; // Add the modified entry to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeLengthWords;\n    \n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    string result;\n    for (const string& w : primeLengthWords) {\n        if (!result.empty()) result += \" \";\n        result += w;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to convert a fraction string to a pair of integers\npair<int, int> parseFraction(const string& fraction) {\n    size_t pos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, pos));\n    int denominator = stoi(fraction.substr(pos + 1));\n    return {numerator, denominator};\n}\n\n// Helper function to check if a number is a whole number\nbool isWholeNumber(int numerator, int denominator) {\n    return numerator % denominator == 0;\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    pair<int, int> xFraction = parseFraction(x);\n    pair<int, int> nFraction = parseFraction(n);\n\n    // Extract the numerator and denominator\n    int xNumerator = xFraction.first;\n    int xDenominator = xFraction.second;\n    int nNumerator = nFraction.first;\n    int nDenominator = nFraction.second;\n\n    // Calculate the product of the fractions\n    int productNumerator = xNumerator * nNumerator;\n    int productDenominator = xDenominator * nDenominator;\n\n    // Check if the product is a whole number\n    return isWholeNumber(productNumerator, productDenominator);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs where each pair contains the number and its sum of digits\n    vector<pair<int, int>> num_sum_pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_sum_pairs.push_back({nums[i], sum_of_digits(nums[i])});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.second == b.second) {\n            return false; // Keep the original order if sums are equal\n        }\n        return a.second < b.second;\n    });\n\n    // Extract the sorted numbers from the sorted pairs\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.first);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string numStr = to_string(abs(num));\n    char firstDigit = numStr.front();\n    char lastDigit = numStr.back();\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) return {};\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) swap(index1, index2);\n    \n    // Collect the planets between index1 and index2 (exclusive)\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the vector first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and non-negative\n        if (floor(num) == num && num >= 0) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If the second string is longer than the first, it cannot be a substring or rotation\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    // Concatenate the second string with itself to handle rotations\n    string rotatedB = b + b;\n\n    // Check if the first string contains any rotation of the second string\n    return rotatedB.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> result = {0, 0}; // Initialize result vector with {even_count, odd_count}\n    num = abs(num); // Handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            result[0]++; // Increment even count\n        } else {\n            result[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    // Iterate through the symbols and append the corresponding Roman numeral to the result\n    for (const auto& symbol : romanSymbols) {\n        while (number >= symbol.first) {\n            result += symbol.second;\n            number -= symbol.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure the sides are sorted in ascending order\n    float sides[3] = {a, b, c};\n    for (int i = 0; i < 2; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (sides[i] > sides[j]) {\n                float temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n    \n    // Check the Pythagorean theorem\n    return (pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words){\n    auto count_unique_chars = [](const string& word) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        return unique_chars.size();\n    };\n\n    string max_word = \"\";\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_chars(word);\n        if (unique_count > max_unique_count || (unique_count == max_unique_count && word < max_word)) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int carrotsNeeded = need - number;\n\n    if (carrotsNeeded > 0) {\n        if (remaining >= carrotsNeeded) {\n            totalEaten += carrotsNeeded;\n            remaining -= carrotsNeeded;\n        } else {\n            totalEaten += remaining;\n            remaining = 0;\n        }\n    }\n\n    return {totalEaten, remaining};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands to build the expression\n    for (int i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        // Perform the operation based on the operator\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            result /= next_operand;\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    for (char &c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    string md5_string;\n    char buf[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(buf, \"%02x\", result[i]);\n        md5_string += buf;\n    }\n\n    return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    for (int i = start; i <= end; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue; // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integerPart = static_cast<int>(number);\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers){\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the Mean Absolute Deviation\n    float mad = 0.0;\n    for (float num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n    \n    while (ss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    if (numbers.empty()) {\n        sum = 0;\n        product = 1;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    if (str.empty()) return \"\";\n\n    // Find the longest palindromic suffix\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the end of the string\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, append the reverse of the entire string\n    string reversed = str;\n    reverse(reversed.begin(), reversed.end());\n    return str + reversed;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int len = a.length();\n    \n    for (int i = 0; i < len; i++) {\n        // Perform XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestString = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str){ \n    unordered_set<char> distinctChars;\n    for (char &c : str) {\n        distinctChars.insert(tolower(c));\n    }\n    return distinctChars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string note;\n    for (size_t i = 0; i < music_string.size(); ++i) {\n        if (music_string[i] == ' ') {\n            continue;\n        }\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(2);\n                ++i;\n            } else {\n                beats.push_back(4);\n            }\n        } else if (music_string[i] == '.') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(1);\n                ++i;\n            }\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos += 1; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to convert words to their corresponding numbers\n    map<string, int> wordToNum = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to store the numbers corresponding to the words\n    vector<int> nums;\n\n    // Stringstream to split the input string by spaces\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        nums.push_back(wordToNum[word]);\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Convert the sorted numbers back to words\n    vector<string> sortedWords;\n    for (int num : nums) {\n        for (const auto& pair : wordToNum) {\n            if (pair.second == num) {\n                sortedWords.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        if (i != 0) result += \" \";\n        result += sortedWords[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    vector<float> closestPair = {numbers[0], numbers[1]};\n    float minDistance = abs(numbers[0] - numbers[1]);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float distance = abs(numbers[i] - numbers[j]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestPair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    if (closestPair[0] > closestPair[1]) {\n        swap(closestPair[0], closestPair[1]);\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    float minVal = numbers[0];\n    float maxVal = numbers[0];\n\n    // Find the minimum and maximum values in the vector\n    for (float num : numbers) {\n        if (num < minVal) {\n            minVal = num;\n        }\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n\n    // Calculate the range\n    float range = maxVal - minVal;\n\n    // Apply the linear transform\n    vector<float> rescaledNumbers;\n    for (float num : numbers) {\n        float rescaledNum = (num - minVal) / range;\n        rescaledNumbers.push_back(rescaledNum);\n    }\n\n    return rescaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n#include<typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values){\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n <= 1) return -1; // No valid divisor for n <= 1\n    for (int i = n / 2; i > 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no other divisor is found, 1 is the largest divisor smaller than n\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    \n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Add elements that occur only once to the result vector\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings){\n    string result;\n    for(const string& str : strings){\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_numbers;\n    for(float num : l){\n        if(num > 0){\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    // Initial guess: midpoint of the interval defined by the roots of the derivative\n    double x0 = 0.0;\n    double epsilon = 1e-7;\n    double delta = 1e-7;\n    int max_iterations = 1000;\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (abs(fx) < epsilon) {\n            return x0;\n        }\n\n        if (abs(dfx) < delta) {\n            break; // Avoid division by a very small number\n        }\n\n        x0 = x0 - fx / dfx;\n    }\n\n    return x0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> l_prime = l; // Initialize l' with the same values as l\n    vector<int> to_sort; // Vector to store elements at indices divisible by three\n\n    // Collect elements at indices divisible by three\n    for (int i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace the elements at indices divisible by three in l' with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); i += 3) {\n        l_prime[i] = to_sort[index++];\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use a vector to store unique elements\n    vector<int> uniqueElements;\n    \n    // Iterate through the sorted vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // If the current element is different from the previous one, add it to the uniqueElements vector\n        if (i == 0 || l[i] != l[i - 1]) {\n            uniqueElements.push_back(l[i]);\n        }\n    }\n    \n    return uniqueElements;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    float maxVal = l[0];\n    for (float num : l) {\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n    return maxVal;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint countSevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += countSevens(i);\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even indexed elements and sort them\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    sort(even_elements.begin(), even_elements.end());\n\n    // Reconstruct the list with sorted even indexed elements\n    vector<float> sorted_list = l;\n    size_t even_index = 0;\n    for (size_t i = 0; i < sorted_list.size(); i += 2) {\n        sorted_list[i] = even_elements[even_index++];\n    }\n\n    return sorted_list;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    // returns decoded string by reversing the cycling of groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<int> fibs = {1, 1};\n    int count = 0;\n    while (true) {\n        int next_fib = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n        fibs.push_back(next_fib);\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    int n = l.size();\n    if (n < 3) return false;\n\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    // Therefore, the total number of collisions is the product of the number of cars in each direction.\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // The area of a triangle with base 'a' and height 'h' is given by:\n    // Area = 0.5 * base * height\n    return 0.5 * a * h;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    vector<int> fib4_sequence = {0, 0, 2, 0};\n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib4_sequence[i-1] + fib4_sequence[i-2] + fib4_sequence[i-3] + fib4_sequence[i-4];\n        fib4_sequence.push_back(next_value);\n    }\n    return fib4_sequence[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Find the size of the vector\n    int n = l.size();\n    \n    // If the size is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size is even, return the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    long long result = 1;\n    long long base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    text.erase(remove_if(text.begin(), text.end(), [&](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    return text;\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create frequency maps for both strings\n    unordered_map<char, int> freq0, freq1;\n    \n    // Populate the frequency map for s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    \n    // Populate the frequency map for s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n    \n    // Compare the frequency maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n){\n    if (n <= 0) return 0; // Handle edge case for non-positive integers\n    if (n == 1) return 1; // Base case for the first Fibonacci number\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() < 2) return true; // A single element or an empty list is trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n\n        // If neither increasing nor decreasing, it's not monotonic\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert the first list to a set for O(1) average time complexity lookups\n    unordered_set<int> set1(l1.begin(), l1.end());\n    \n    // Use a set to store common elements to ensure uniqueness\n    unordered_set<int> commonSet;\n    \n    // Iterate through the second list and check for common elements\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            commonSet.insert(num);\n        }\n    }\n    \n    // Convert the set of common elements to a vector and sort it\n    vector<int> result(commonSet.begin(), commonSet.end());\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    // Check for the smallest factors first\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n                largest_factor = i;\n            }\n            if (is_prime(n / i)) {\n                largest_factor = n / i;\n            }\n        }\n    }\n    // If no prime factors found, n itself is a prime factor\n    if (largest_factor == 1) {\n        largest_factor = n;\n    }\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\n#include<stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            s.push(bracket);\n        } else if (bracket == ')') {\n            if (s.empty() || s.top() != '(') {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs){\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> sequence(n + 1, 0);\n    sequence[0] = 0;\n    sequence[1] = 0;\n    sequence[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i - 3];\n    }\n\n    return sequence[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    // Check if 'y' is at the end of the word\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to easily manipulate its digits\n    string digits = to_string(x);\n    int num_digits = digits.size();\n\n    // If shift is greater than the number of digits, return the digits reversed\n    if (shift > num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    // Calculate the effective shift (modulo the number of digits)\n    shift = shift % num_digits;\n\n    // Perform the circular shift\n    string shifted_digits = digits.substr(num_digits - shift) + digits.substr(0, num_digits - shift);\n\n    return shifted_digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Read the number of apples\n    ss >> apples;\n    ss >> temp; // Skip the word \"apples\"\n    ss >> temp; // Skip the word \"and\"\n    \n    // Read the number of oranges\n    ss >> oranges;\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int smallestEven = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestEven == -1) return {};\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst){\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer in the vector\n    for(int num : lst){\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Iterate through the frequency map to find the greatest integer that meets the criteria\n    for(const auto& pair : frequencyMap){\n        int num = pair.first;\n        int freq = pair.second;\n        \n        if(num <= freq && num > result){\n            result = num;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    sort(lst.begin(), lst.end());\n    \n    int i = 0;\n    int j = lst.size() - 1;\n    \n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides can form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    auto count_chars = [](const vector<string>& lst) {\n        int count = 0;\n        for (const string& s : lst) {\n            count += s.size();\n        }\n        return count;\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < primes.size(); ++i) {\n        for (int j = i; j < primes.size(); ++j) {\n            for (int k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power == x;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a; // Handle negative numbers by taking the absolute value\n    }\n    int cube_root = round(cbrt(a)); // Calculate the cube root and round to the nearest integer\n    return cube_root * cube_root * cube_root == a; // Check if the cube of the rounded cube root equals the original number\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        switch (c) {\n            case '2': case '3': case '5': case '7':\n            case 'B': case 'D':\n                if (isPrime(c >= 'A' ? c - 'A' + 10 : c - '0')) {\n                    count++;\n                }\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\";\n    if (decimal == 0) {\n        binary += \"0\";\n    } else {\n        while (decimal > 0) {\n            binary = (decimal % 2 == 0 ? \"0\" : \"1\") + binary;\n            decimal /= 2;\n        }\n    }\n    binary += \"db\";\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive letters\n    for (int i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all 3 consecutive letters are distinct, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there are exactly 2 numbers: 1 and 0.\n    // Since we are only considering positive integers, the answer is 1.\n    if (n == 1) {\n        return 1;\n    }\n\n    // For n-digit numbers, the first digit can be any digit from 1 to 9 (9 choices).\n    // The last digit can be any digit from 0 to 9 (10 choices).\n    // However, we need to exclude the cases where both the first and last digits are not 1.\n\n    // Total n-digit numbers: 9 * 10^(n-2) * 10\n    // Numbers where first digit is 1: 1 * 10^(n-1)\n    // Numbers where last digit is 1: 9 * 10^(n-2) * 1\n    // Numbers where both first and last digit are 1: 1 * 10^(n-2) * 1\n\n    // Using the principle of inclusion-exclusion:\n    // Total numbers starting or ending with 1 = (Numbers starting with 1) + (Numbers ending with 1) - (Numbers starting and ending with 1)\n\n    int total_numbers = 9 * pow(10, n-1);\n    int starts_with_one = pow(10, n-1);\n    int ends_with_one = 9 * pow(10, n-2);\n    int starts_and_ends_with_one = pow(10, n-2);\n\n    return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    string binarySum;\n    while (sum > 0) {\n        binarySum = (sum % 2 == 0 ? \"0\" : \"1\") + binarySum;\n        sum /= 2;\n    }\n    \n    return binarySum.empty() ? \"0\" : binarySum;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    string word;\n    bool in_word = false;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (in_word) {\n                sort(word.begin(), word.end());\n                result += word;\n                word.clear();\n                in_word = false;\n            }\n            result += c;\n        } else {\n            word += c;\n            in_word = true;\n        }\n    }\n\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If the element matches x, add the coordinate to the list\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort coordinates by rows in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // Sort coordinates of the same row by columns in descending order\n    for (int i = 0; i < coordinates.size(); ++i) {\n        for (int j = i + 1; j < coordinates.size(); ++j) {\n            if (coordinates[i][0] == coordinates[j][0] && coordinates[i][1] < coordinates[j][1]) {\n                swap(coordinates[i], coordinates[j]);\n            }\n        }\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) return array;\n\n    int first_value = array.front();\n    int last_value = array.back();\n    int sum = first_value + last_value;\n\n    vector<int> sorted_array = array;\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = ((c - 'a' + 4) % 26) + 'a';\n            encrypted += newChar;\n        } else if (c >= 'A' && c <= 'Z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = ((c - 'A' + 4) % 26) + 'A';\n            encrypted += newChar;\n        } else {\n            // If the character is not a letter, just append it as is\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no such element\n    }\n\n    // Sort the vector\n    sort(lst.begin(), lst.end());\n\n    // Find the first distinct smallest element\n    int smallest = lst[0];\n    int index = 1;\n    while (index < lst.size() && lst[index] == smallest) {\n        index++;\n    }\n\n    // If we have reached the end, there is no second smallest element\n    if (index == lst.size()) {\n        return -1; // Return -1 to indicate no such element\n    }\n\n    // Return the second smallest element\n    return lst[index];\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    size_t pos = 0;\n    string delimiter = \".!?\";\n\n    while ((pos = S.find_first_of(delimiter, pos)) != string::npos) {\n        S[pos] = '\\0'; // Null-terminate the sentence\n        pos++; // Move past the delimiter\n    }\n\n    string sentence;\n    for (size_t i = 0; i < S.size(); i++) {\n        if (S[i] == '\\0') {\n            if (!sentence.empty() && sentence[0] == 'I') {\n                boredomCount++;\n            }\n            sentence.clear();\n        } else {\n            sentence += S[i];\n        }\n    }\n\n    // Check the last sentence if it ends without a delimiter\n    if (!sentence.empty() && sentence[0] == 'I') {\n        boredomCount++;\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n\n            // Replace vowels with the letter 2 places ahead\n            if (c == 'a' || c == 'A') {\n                c = (c == 'a') ? 'c' : 'C';\n            } else if (c == 'e' || c == 'E') {\n                c = (c == 'e') ? 'g' : 'G';\n            } else if (c == 'i' || c == 'I') {\n                c = (c == 'i') ? 'k' : 'K';\n            } else if (c == 'o' || c == 'O') {\n                c = (c == 'o') ? 'q' : 'Q';\n            } else if (c == 'u' || c == 'U') {\n                c = (c == 'u') ? 'w' : 'W';\n            }\n        }\n        encodedMessage += c;\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0; // No prime found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) {\n            return false;\n        }\n\n        bool is_lower = true;\n        bool is_upper = true;\n\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n        }\n\n        if (!is_lower && !is_upper) {\n            return false;\n        }\n\n        all_lower &= is_lower;\n        all_upper &= is_upper;\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\n\nint multiply(int a, int b) {\n    // Extract the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    string vowels = \"AEIOU\";\n    \n    for (int i = 0; i < s.size(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    }\n    // Otherwise, use standard rounding\n    else {\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_level = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_level);\n        if (current_level % 2 == 0) {\n            current_level += 2; // Next even number\n        } else {\n            current_level += 2; // Next odd number\n        }\n    }\n    \n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use a delimiter to split the string\n    while (getline(ss, word, ',')) {\n        // Remove leading and trailing spaces from the word\n        word.erase(word.begin(), find_if(word.begin(), word.end(), [](int ch) {\n            return !isspace(ch);\n        }));\n        word.erase(find_if(word.rbegin(), word.rend(), [](int ch) {\n            return !isspace(ch);\n        }).base(), word.end());\n        \n        // Split the word further by spaces if needed\n        stringstream word_ss(word);\n        string subword;\n        while (word_ss >> subword) {\n            words.push_back(subword);\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Adjust x to be the smallest even number greater than or equal to x\n    if (x % 2 != 0) {\n        x += 1;\n    }\n\n    // Adjust y to be the largest even number less than or equal to y\n    if (y % 2 != 0) {\n        y -= 1;\n    }\n\n    // If x is still greater than y after adjustments, return -1\n    if (x > y) {\n        return -1;\n    }\n\n    // Return the largest even number in the range [x, y]\n    return y;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Round the average to the nearest integer (smaller one)\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binary_representation;\n    if (rounded_average == 0) {\n        binary_representation = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary_representation = to_string(rounded_average % 2) + binary_representation;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary_representation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr){\n    // Map to store the corresponding names for digits 1 to 9\n    map<int, string> digitToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the array to include only numbers between 1 and 9\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit by its corresponding name\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(digitToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum for odd i\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int shifts = 0;\n\n    // Find the number of shifts needed to make the array sorted\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            shifts++;\n        }\n    }\n\n    // If more than one shift is needed, it's not possible to sort the array\n    return shifts <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // If the number of odd elements in lst1 is less than or equal to the number of even elements in lst2,\n    // then it is possible to exchange elements to make lst1 all even.\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> result;\n    int maxCount = 0;\n\n    // Convert the string to a stream to easily iterate over words\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each letter\n    while (ss >> word) {\n        for (char c : word) {\n            letterCount[c]++;\n            maxCount = max(maxCount, letterCount[c]);\n        }\n    }\n\n    // Find letters with the maximum count\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are in c\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    bool isPalindrome = true;\n    int n = result.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (result[i] != result[n - i - 1]) {\n            isPalindrome = false;\n            break;\n        }\n    }\n\n    // Return the result string and the palindrome check result\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + to_string(odd_count) + \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) + \" of the \" + to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle the edge case where the vector is empty\n\n    long long minSum = nums[0]; // Initialize minSum with the first element\n    long long currentSum = nums[0]; // Initialize currentSum with the first element\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update currentSum to be the minimum of the current element or the currentSum plus the current element\n        currentSum = min(nums[i], currentSum + nums[i]);\n        // Update minSum to be the minimum of minSum and currentSum\n        minSum = min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n        for (const auto& unit : well) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        total_lowers += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n    }\n\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of ones in their binary representation\n    // For similar number of ones, sort based on decimal value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b;\n        }\n        return onesA < onesB;\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u';\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    int consonantCount = 0;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (consonantCount == n) {\n                result.push_back(word);\n            }\n            word.clear();\n            consonantCount = 0;\n        } else {\n            word += c;\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n    }\n\n    // Check the last word in the string\n    if (consonantCount == n) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"AEIOUaeiou\";\n    string consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n\n    for (int i = word.size() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            bool left_consonant = false, right_consonant = false;\n            for (int j = i - 1; j >= 0; --j) {\n                if (consonants.find(word[j]) != string::npos) {\n                    left_consonant = true;\n                    break;\n                }\n            }\n            for (int j = i + 1; j < word.size(); ++j) {\n                if (consonants.find(word[j]) != string::npos) {\n                    right_consonant = true;\n                    break;\n                }\n            }\n            if (left_consonant && right_consonant) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int balance1 = 0, balance2 = 0;\n    \n    // Calculate the balance for the first string\n    for (char c : lst[0]) {\n        if (c == '(') balance1++;\n        else balance1--;\n    }\n    \n    // Calculate the balance for the second string\n    for (char c : lst[1]) {\n        if (c == '(') balance2++;\n        else balance2--;\n    }\n    \n    // Check if the total balance can be zero\n    if (balance1 + balance2 == 0 && balance1 >= 0 && balance2 >= 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (num >= 10 && num <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Start the sequence with the given number\n    while (n != 1) {\n        if (n % 2 == 1) {\n            // If the number is odd, add it to the list\n            odd_numbers.push_back(n);\n        }\n        // Generate the next number in the sequence\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final 1 to the list\n    odd_numbers.push_back(1);\n    \n    // Sort the list in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Check if the date string is in the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date string into month, day, and year\n    stringstream ss(date);\n    string item;\n    vector<string> tokens;\n    while (getline(ss, item, '-')) {\n        tokens.push_back(item);\n    }\n\n    // Check if the split resulted in exactly three parts\n    if (tokens.size() != 3) return false;\n\n    // Convert the parts to integers\n    int month, day, year;\n    try {\n        month = stoi(tokens[0]);\n        day = stoi(tokens[1]);\n        year = stoi(tokens[2]);\n    } catch (invalid_argument&) {\n        return false;\n    }\n\n    // Check if the month is valid\n    if (month < 1 || month > 12) return false;\n\n    // Check if the day is valid based on the month\n    if (month == 2) {\n        // February can have 29 days in a leap year\n        bool isLeapYear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n        if (day < 1 || (day > 29 || (day == 29 && !isLeapYear))) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // April, June, September, November have 30 days\n        if (day < 1 || day > 30) return false;\n    } else {\n        // All other months have 31 days\n        if (day < 1 || day > 31) return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    size_t pos = 0;\n    string delimiter = \" \";\n    \n    // Check for whitespace first\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // Check for commas if no whitespace\n    delimiter = \",\";\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // If no whitespace or commas, count odd-ordered lower-case letters\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in ascending order\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // Check if any number appears more than twice\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int productOfSigns = 1;\n    int sumOfMagnitudes = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            productOfSigns *= 1;\n        } else if (num < 0) {\n            productOfSigns *= -1;\n        } else {\n            productOfSigns *= 0;\n        }\n        sumOfMagnitudes += abs(num);\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<int> result;\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\n\n    // Initialize the priority queue with all starting points\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({grid[i][j], i, j, 0});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        int value = current[0];\n        int x = current[1];\n        int y = current[2];\n        int steps = current[3];\n\n        if (steps == k - 1) {\n            result.push_back(value);\n            break;\n        }\n\n        for (auto& dir : directions) {\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                pq.push({grid[newX][newY], newX, newY, steps + 1});\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacciSequence;\n    if (n < 0) return tribonacciSequence; // Return empty vector for negative input\n\n    // Initialize the first element of the sequence\n    tribonacciSequence.push_back(1);\n\n    // Handle the case where n is 0\n    if (n == 0) return tribonacciSequence;\n\n    // Initialize the second element of the sequence\n    tribonacciSequence.push_back(3);\n\n    // Handle the case where n is 1\n    if (n == 1) return tribonacciSequence;\n\n    // Initialize the third element of the sequence\n    tribonacciSequence.push_back(2);\n\n    // Handle the case where n is 2\n    if (n == 2) return tribonacciSequence;\n\n    // Compute the remaining elements of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int nextValue;\n        if (i % 2 == 0) {\n            nextValue = 1 + i / 2;\n        } else {\n            nextValue = tribonacciSequence[i - 1] + tribonacciSequence[i - 2] + tribonacciSequence[i + 1];\n        }\n        tribonacciSequence.push_back(nextValue);\n    }\n\n    return tribonacciSequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0;\n    int nestedCount = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n                nestedCount++;\n            }\n        }\n    }\n\n    return nestedCount > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) {\n        return false;\n    }\n\n    // Check if the last character is not part of a word\n    if (txt.length() > 1) {\n        char secondLastChar = txt[txt.length() - 2];\n        if (isalpha(secondLastChar)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    if (!has_negative) {\n        largest_negative = 0;\n    }\n    if (!has_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/algorithm/string.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        if (val.type() == typeid(int)) {\n            return static_cast<double>(boost::any_cast<int>(val));\n        } else if (val.type() == typeid(float)) {\n            return static_cast<double>(boost::any_cast<float>(val));\n        } else if (val.type() == typeid(double)) {\n            return boost::any_cast<double>(val);\n        } else if (val.type() == typeid(string)) {\n            string str = boost::any_cast<string>(val);\n            boost::replace_all(str, \",\", \".\");\n            return stod(str);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    // Convert both values to double\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    // Compare the values\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the number is even and greater than or equal to 8\n    if (n % 2 == 0 && n >= 8) {\n        // Since the smallest sum of 4 positive even numbers is 8 (2 + 2 + 2 + 2),\n        // any even number greater than or equal to 8 can be written as the sum of 4 positive even numbers.\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text){\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            if (spaceCount == 1) {\n                result += '_';\n            } else if (spaceCount > 2) {\n                // Do nothing, we will replace multiple spaces with '-' later\n            }\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            }\n            spaceCount = 0;\n            result += c;\n        }\n    }\n\n    // Handle the case where the string ends with spaces\n    if (spaceCount > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    string extension;\n    string name_before_dot;\n\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n            if (dot_count > 1) return \"No\";\n        } else if (isdigit(c)) {\n            digit_count++;\n            if (digit_count > 3) return \"No\";\n        }\n    }\n\n    if (dot_count != 1) return \"No\";\n\n    size_t dot_pos = file_name.find('.');\n    name_before_dot = file_name.substr(0, dot_pos);\n    extension = file_name.substr(dot_pos + 1);\n\n    if (name_before_dot.empty() || !isalpha(name_before_dot[0])) return \"No\";\n\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the entry if index is a multiple of 3\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the entry if index is a multiple of 4 and not a multiple of 3\n        }\n        sum += lst[i]; // Add the modified entry to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeLengthWords;\n    \n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    string result;\n    for (const string& w : primeLengthWords) {\n        if (!result.empty()) result += \" \";\n        result += w;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to convert a fraction string to a pair of integers\npair<int, int> parseFraction(const string& fraction) {\n    size_t pos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, pos));\n    int denominator = stoi(fraction.substr(pos + 1));\n    return {numerator, denominator};\n}\n\n// Helper function to check if a number is a whole number\nbool isWholeNumber(int numerator, int denominator) {\n    return numerator % denominator == 0;\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    pair<int, int> xFraction = parseFraction(x);\n    pair<int, int> nFraction = parseFraction(n);\n\n    // Extract the numerator and denominator\n    int xNumerator = xFraction.first;\n    int xDenominator = xFraction.second;\n    int nNumerator = nFraction.first;\n    int nDenominator = nFraction.second;\n\n    // Calculate the product of the fractions\n    int productNumerator = xNumerator * nNumerator;\n    int productDenominator = xDenominator * nDenominator;\n\n    // Check if the product is a whole number\n    return isWholeNumber(productNumerator, productDenominator);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs where each pair contains the sum of digits and the original number\n    vector<pair<int, int>> num_sum_pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_sum_pairs.push_back({sum_of_digits(nums[i]), nums[i]});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) {\n            // If sums are equal, maintain the original order\n            return false;\n        }\n        return a.first < b.first;\n    });\n\n    // Extract the sorted numbers from the sorted pairs\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.second);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string numStr = to_string(abs(num));\n    char firstDigit = numStr.front();\n    char lastDigit = numStr.back();\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) return {};\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) swap(index1, index2);\n    \n    // Collect the planets between index1 and index2 (exclusive)\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the vector first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and non-negative\n        if (floor(num) == num && num >= 0) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If the length of b is greater than a, it cannot be a substring or rotation\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    // Concatenate b with itself to handle rotations\n    string b_rotated = b + b;\n\n    // Check if any rotation of b is a substring of a\n    for (int i = 0; i < b.length(); ++i) {\n        if (a.find(b_rotated.substr(i, b.length())) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> result = {0, 0}; // Initialize result vector with {even_count, odd_count}\n    num = abs(num); // Handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            result[0]++; // Increment even count\n        } else {\n            result[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    // Iterate through the symbols and append the corresponding Roman numeral to the result\n    for (const auto& symbol : romanSymbols) {\n        while (number >= symbol.first) {\n            result += symbol.second;\n            number -= symbol.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure the sides are sorted in ascending order\n    float sides[3] = {a, b, c};\n    for (int i = 0; i < 2; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (sides[i] > sides[j]) {\n                float temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n    \n    // Check the Pythagorean theorem\n    return (pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words){\n    auto count_unique_chars = [](const string& word) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        return unique_chars.size();\n    };\n\n    string max_word = \"\";\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_chars(word);\n        if (unique_count > max_unique_count || (unique_count == max_unique_count && word < max_word)) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number + need;\n    int carrotsLeft = remaining - need;\n\n    if (carrotsLeft < 0) {\n        totalEaten += remaining;\n        carrotsLeft = 0;\n    } else {\n        totalEaten += need;\n    }\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands\n    for (size_t i = 0; i < operato.size(); ++i) {\n        // Get the current operator and operand\n        string op = operato[i];\n        int num = operand[i + 1];\n\n        // Perform the operation based on the operator\n        if (op == \"+\") {\n            result += num;\n        } else if (op == \"-\") {\n            result -= num;\n        } else if (op == \"*\") {\n            result *= num;\n        } else if (op == \"//\") {\n            result /= num;\n        } else if (op == \"**\") {\n            result = pow(result, num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    for (char &c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    \n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    string md5_string;\n    char buf[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(buf, \"%02x\", result[i]);\n        md5_string += buf;\n    }\n\n    return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    for (int i = start; i <= end; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    int balance = 0;\n    string current_group = \"\";\n\n    for (char c : paren_string) {\n        if (c == ' ') continue; // Ignore spaces\n        current_group += c;\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group = \"\";\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integerPart = static_cast<int>(number);\n    // Calculate the decimal part\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers){\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the sum of absolute deviations\n    float absDevSum = 0.0;\n    for (float num : numbers) {\n        absDevSum += abs(num - mean);\n    }\n\n    // Calculate and return the Mean Absolute Deviation\n    return absDevSum / numbers.size();\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n    \n    while (getline(ss, group, ' ')) {\n        int max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    if (numbers.empty()) {\n        sum = 0;\n        product = 1;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    if (str.empty()) return \"\";\n\n    // Find the longest palindromic suffix\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the end of the string\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, append the reverse of the entire string\n    string reversed = str;\n    reverse(reversed.begin(), reversed.end());\n    return str + reversed;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestString = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n){\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str){ \n    unordered_set<char> distinctChars;\n    for (char &c : str) {\n        distinctChars.insert(tolower(c));\n    }\n    return distinctChars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string note;\n    for (size_t i = 0; i < music_string.size(); ++i) {\n        if (music_string[i] == ' ') {\n            continue;\n        }\n        note += music_string[i];\n        if (i + 1 == music_string.size() || music_string[i + 1] == ' ') {\n            if (note == \"o\") {\n                beats.push_back(4);\n            } else if (note == \"o|\") {\n                beats.push_back(2);\n            } else if (note == \".|\") {\n                beats.push_back(1);\n            }\n            note.clear();\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to convert words to their corresponding numbers\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to store the numbers corresponding to the words\n    vector<int> nums;\n\n    // Stringstream to split the input string by spaces\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        if (wordToNumber.find(word) != wordToNumber.end()) {\n            nums.push_back(wordToNumber[word]);\n        }\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Map to convert numbers back to their corresponding words\n    map<int, string> numberToWord = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Stringstream to build the output string\n    stringstream sortedNumbers;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i != 0) {\n            sortedNumbers << \" \";\n        }\n        sortedNumbers << numberToWord[nums[i]];\n    }\n\n    return sortedNumbers.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    vector<float> closestPair = {numbers[0], numbers[1]};\n    float minDistance = abs(numbers[0] - numbers[1]);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float distance = abs(numbers[i] - numbers[j]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestPair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    if (closestPair[0] > closestPair[1]) {\n        swap(closestPair[0], closestPair[1]);\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    float minVal = numbers[0];\n    float maxVal = numbers[0];\n\n    // Find the minimum and maximum values in the vector\n    for (float num : numbers) {\n        if (num < minVal) {\n            minVal = num;\n        }\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n\n    // Calculate the range\n    float range = maxVal - minVal;\n\n    // Apply the linear transform\n    vector<float> rescaledNumbers;\n    for (float num : numbers) {\n        float rescaledNum = (num - minVal) / range;\n        rescaledNumbers.push_back(rescaledNum);\n    }\n\n    return rescaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n#include<typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n#include<cmath>\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case for n <= 1\n    for (int i = sqrt(n); i >= 2; --i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1; // If no other divisor is found, n is prime\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    \n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Count the occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Add numbers to the result if they occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char& c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings){\n    string result = \"\";\n    for(const string& str : strings){\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_numbers;\n    for(float num : l){\n        if(num > 0){\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(long long n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x){\n    /* \n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    */\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    double x0 = 0.0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (abs(fx) < tolerance) {\n            return x0; // Converged to a root\n        }\n\n        x0 = x0 - fx / dfx; // Newton-Raphson update\n    }\n\n    return x0; // Return the last computed value if max iterations reached\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> l_prime = l; // Initialize l' with the same values as l\n    vector<int> to_sort; // Vector to store elements at indices divisible by three\n\n    // Collect elements at indices divisible by three\n    for (int i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace the elements in l' with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); i += 3) {\n        l_prime[i] = to_sort[index++];\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use a vector to store unique elements\n    vector<int> uniqueElements;\n    \n    // Iterate through the sorted vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // If the current element is different from the previous one, add it to the uniqueElements vector\n        if (i == 0 || l[i] != l[i - 1]) {\n            uniqueElements.push_back(l[i]);\n        }\n    }\n    \n    return uniqueElements;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    float maxVal = l[0];\n    for (float num : l) {\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n    return maxVal;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint countSevens(int num) {\n    int count = 0;\n    string numStr = to_string(num);\n    for (char c : numStr) {\n        if (c == '7') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += countSevens(i);\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even-indexed elements and sort them\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    sort(even_elements.begin(), even_elements.end());\n\n    // Reconstruct the list with sorted even-indexed elements\n    vector<float> sorted_list;\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            sorted_list.push_back(even_elements[even_index++]);\n        } else {\n            sorted_list.push_back(l[i]);\n        }\n    }\n\n    return sorted_list;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<int> fibs = {1, 1};\n    int count = 0;\n    while (true) {\n        int next_fib = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n        fibs.push_back(next_fib);\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    int n = l.size();\n    if (n < 3) return false;\n\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    // Therefore, the total number of collisions is the product of the number of cars in each direction.\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // The area of a triangle with base 'a' and height 'h' is given by:\n    // Area = 0.5 * base * height\n    return 0.5 * a * h;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    vector<int> fib4_sequence(n + 1);\n    fib4_sequence[0] = 0;\n    fib4_sequence[1] = 0;\n    fib4_sequence[2] = 2;\n    fib4_sequence[3] = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        fib4_sequence[i] = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4];\n    }\n\n    return fib4_sequence[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Find the size of the vector\n    int n = l.size();\n    \n    // If the size is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size is even, return the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    text.erase(remove_if(text.begin(), text.end(), [&](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    return text;\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    \n    // Compare the sorted strings\n    return s0 == s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n){\n    if (n <= 0) return 0; // Handle edge case for non-positive integers\n    if (n == 1) return 1; // Base case for the first Fibonacci number\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() < 2) return true; // A single element or an empty list is trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n\n        // If neither increasing nor decreasing, it's not monotonic\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert the first list to a set for O(1) average time complexity lookups\n    unordered_set<int> set1(l1.begin(), l1.end());\n    \n    // Use a set to store common elements to ensure uniqueness\n    unordered_set<int> commonSet;\n    \n    // Iterate through the second list and check for common elements\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            commonSet.insert(num);\n        }\n    }\n    \n    // Convert the set of common elements to a sorted vector\n    vector<int> result(commonSet.begin(), commonSet.end());\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<cmath>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for and remove factors of 2\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 upwards\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 2, then it must be prime\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        // If balance goes negative, it means we have a closing bracket without a corresponding opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // If balance is zero, all opening brackets have corresponding closing brackets\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> fibfibSequence(n + 1);\n    fibfibSequence[0] = 0;\n    fibfibSequence[1] = 0;\n    fibfibSequence[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        fibfibSequence[i] = fibfibSequence[i - 1] + fibfibSequence[i - 2] + fibfibSequence[i - 3];\n    }\n\n    return fibfibSequence[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    // Check if 'y' is at the end of the word\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to easily manipulate its digits\n    string digits = to_string(x);\n    int num_digits = digits.size();\n\n    // If shift is greater than the number of digits, return the digits reversed\n    if (shift > num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    // Calculate the effective shift (modulo the number of digits)\n    shift = shift % num_digits;\n\n    // Perform the circular shift\n    string shifted_digits = digits.substr(num_digits - shift) + digits.substr(0, num_digits - shift);\n\n    return shifted_digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Read the number of apples\n    ss >> apples;\n    ss >> temp; // Skip the word \"apples\"\n    ss >> temp; // Skip the word \"and\"\n    \n    // Read the number of oranges\n    ss >> oranges;\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int smallestEven = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestEven == -1) return {};\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nint search(vector<int> lst){\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Iterate through the frequency map to find the greatest integer that meets the criteria\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        \n        if (num > 0 && freq >= num) {\n            if (result == -1 || num > result) {\n                result = num;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    sort(lst.begin(), lst.end());\n    \n    int i = 0;\n    int j = lst.size() - 1;\n    \n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides can form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    auto count_chars = [](const vector<string>& lst) {\n        int count = 0;\n        for (const string& s : lst) {\n            count += s.size();\n        }\n        return count;\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < primes.size(); ++i) {\n        for (int j = i; j < primes.size(); ++j) {\n            for (int k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return false; // n must be greater than 1 for the concept of simple power to be meaningful\n    }\n\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power == x;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a; // Take the absolute value of a\n    }\n    int cube_root = round(cbrt(a)); // Calculate the cube root and round it to the nearest integer\n    return cube_root * cube_root * cube_root == a; // Check if the cube of the rounded cube root equals the original number\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isPrime(char hexDigit) {\n    // Convert hexadecimal digit to decimal\n    int decimalValue;\n    if (hexDigit >= '0' && hexDigit <= '9') {\n        decimalValue = hexDigit - '0';\n    } else if (hexDigit >= 'A' && hexDigit <= 'F') {\n        decimalValue = hexDigit - 'A' + 10;\n    } else {\n        return false;\n    }\n\n    // Check if the decimal value is a prime number\n    if (decimalValue < 2) return false;\n    if (decimalValue == 2 || decimalValue == 3 || decimalValue == 5 || decimalValue == 7) return true;\n    if (decimalValue == 11 || decimalValue == 13) return true;\n    return false;\n}\n\nint hex_key(string num) {\n    int count = 0;\n    for (char digit : num) {\n        if (isPrime(digit)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\";\n    if (decimal == 0) {\n        binary += \"0\";\n    } else {\n        while (decimal > 0) {\n            binary = (decimal % 2 == 0 ? \"0\" : \"1\") + binary;\n            decimal /= 2;\n        }\n    }\n    binary += \"db\";\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive letters\n    for (int i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all 3 consecutive letters are distinct, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there are exactly 2 numbers: 1 and 0.\n    if (n == 1) {\n        return 2;\n    }\n    \n    // For n > 1, the count of n-digit numbers that start or end with 1 is:\n    // - Numbers starting with 1: 10^(n-1)\n    // - Numbers ending with 1: 10^(n-1)\n    // - Numbers starting and ending with 1: 10^(n-2)\n    // Using the principle of inclusion-exclusion, we get:\n    // 10^(n-1) + 10^(n-1) - 10^(n-2)\n    return (2 * pow(10, n-1)) - pow(10, n-2);\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    int temp = N;\n    \n    // Calculate the sum of digits\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n            sum /= 2;\n        }\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    bool in_word = false;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (in_word) {\n                sort(word.begin(), word.end());\n                result += word;\n                word = \"\";\n                in_word = false;\n            }\n            result += c;\n        } else {\n            word += c;\n            in_word = true;\n        }\n    }\n\n    if (in_word) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Collect all coordinates where the value is x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort coordinates by rows in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // For each row, sort columns in descending order\n    int currentRow = -1;\n    for (int i = 0; i < coordinates.size(); ++i) {\n        if (coordinates[i][0] != currentRow) {\n            currentRow = coordinates[i][0];\n            int start = i;\n            while (i + 1 < coordinates.size() && coordinates[i + 1][0] == currentRow) {\n                ++i;\n            }\n            sort(coordinates.begin() + start, coordinates.begin() + i + 1, [](const vector<int>& a, const vector<int>& b) {\n                return a[1] > b[1];\n            });\n        }\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) return array;\n\n    int first_value = array.front();\n    int last_value = array.back();\n    int sum = first_value + last_value;\n\n    vector<int> sorted_array = array;\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = ((c - 'a' + 4) % 26) + 'a';\n            encrypted += newChar;\n        } else if (c >= 'A' && c <= 'Z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = ((c - 'A' + 4) % 26) + 'A';\n            encrypted += newChar;\n        } else {\n            // If the character is not a letter, just append it as is\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no such element\n    }\n\n    sort(lst.begin(), lst.end());\n\n    int smallest = lst[0];\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != smallest) {\n            return lst[i];\n        }\n    }\n\n    return -1; // Return -1 to indicate no such element\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    size_t pos = 0;\n    string delimiter = \".!?\";\n\n    while ((pos = S.find_first_of(delimiter, pos)) != string::npos) {\n        S[pos] = '\\0'; // Null-terminate the current sentence\n        if (S.substr(0, pos).find(\"I \") == 0) {\n            boredomCount++;\n        }\n        S = S.substr(pos + 1); // Move to the next sentence\n        pos = 0;\n    }\n\n    // Check the last sentence if there's no trailing delimiter\n    if (!S.empty() && S.find(\"I \") == 0) {\n        boredomCount++;\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n\n            // Replace vowels with the letter 2 places ahead\n            if (c == 'a' || c == 'A') c = 'c';\n            else if (c == 'e' || c == 'E') c = 'g';\n            else if (c == 'i' || c == 'I') c = 'k';\n            else if (c == 'o' || c == 'O') c = 'q';\n            else if (c == 'u' || c == 'U') c = 'w';\n            else if (c == 'y' || c == 'Y') c = 'a'; // Wrap around for 'y'\n        }\n        encodedMessage += c;\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0; // No prime numbers found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) {\n            return false;\n        }\n\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (islower(c)) {\n                all_upper = false;\n            }\n            if (isupper(c)) {\n                all_lower = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s){\n    int count = 0;\n    string vowels = \"AEIOU\";\n    \n    for (int i = 0; i < s.size(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    }\n    // If the number is not halfway between two integers, round to the nearest integer\n    else {\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_level = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_level);\n        if (current_level % 2 == 0) {\n            current_level += 2; // Next even number\n        } else {\n            current_level += 2; // Next odd number\n        }\n    }\n    \n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use a delimiter to handle both commas and spaces\n    while (getline(ss, word, ',')) {\n        // Remove leading and trailing spaces from the word\n        word.erase(word.begin(), find_if(word.begin(), word.end(), [](int ch) {\n            return !isspace(ch);\n        }));\n        word.erase(find_if(word.rbegin(), word.rend(), [](int ch) {\n            return !isspace(ch);\n        }).base(), word.end());\n        \n        // If the word is not empty, add it to the vector\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Adjust x to be the smallest even number greater than or equal to x\n    if (x % 2 != 0) {\n        x += 1;\n    }\n\n    // Adjust y to be the largest even number less than or equal to y\n    if (y % 2 != 0) {\n        y -= 1;\n    }\n\n    // If x is still greater than y after adjustments, return -1\n    if (x > y) {\n        return -1;\n    }\n\n    // Return the largest even number in the range [x, y]\n    return y;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Round the average to the nearest integer (smaller one)\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binary_representation;\n    if (rounded_average == 0) {\n        binary_representation = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary_representation = to_string(rounded_average % 2) + binary_representation;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary_representation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr){\n    // Map to store the corresponding names for digits 1 to 9\n    map<int, string> digitNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the array to include only numbers between 1 and 9\n    vector<int> filteredArr;\n    for(int num : arr) {\n        if(num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit by its corresponding name\n    vector<string> result;\n    for(int num : filteredArr) {\n        result.push_back(digitNames[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum for odd i\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int shifts = 0;\n\n    // Find the number of shifts needed to make the array sorted\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            shifts++;\n        }\n    }\n\n    // If there is more than one break point, it's not possible to sort the array\n    return shifts <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // If the number of odd elements in lst1 is less than or equal to the number of even elements in lst2,\n    // then it is possible to exchange elements to make lst1 all even.\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> result;\n    int maxCount = 0;\n\n    // Split the string by spaces and count each letter's occurrences\n    stringstream ss(test);\n    string letter;\n    while (ss >> letter) {\n        for (char c : letter) {\n            letterCount[c]++;\n            if (letterCount[c] > maxCount) {\n                maxCount = letterCount[c];\n            }\n        }\n    }\n\n    // Find all letters with the maximum count\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = maxCount;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are in c\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    bool isPalindrome = true;\n    int n = result.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (result[i] != result[n - i - 1]) {\n            isPalindrome = false;\n            break;\n        }\n    }\n\n    // Return the result string and the palindrome check result\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst){\n    vector<string> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + to_string(odd_count) + \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) + \" of the \" + to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle the edge case where the vector is empty\n\n    long long minSum = nums[0]; // Initialize minSum with the first element\n    long long currentSum = nums[0]; // Initialize currentSum with the first element\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update currentSum to be the minimum of the current element or the currentSum plus the current element\n        currentSum = min(nums[i], currentSum + nums[i]);\n        // Update minSum to be the minimum of minSum and currentSum\n        minSum = min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (const auto& unit : row) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        if (water_units > 0) {\n            total_lowers += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        }\n    }\n\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of ones in their binary representation\n    // For similar number of ones, sort based on decimal value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA == onesB) {\n            return a < b;\n        }\n        return onesA < onesB;\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u';\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    int consonantCount = 0;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (consonantCount == n) {\n                result.push_back(word);\n            }\n            word.clear();\n            consonantCount = 0;\n        } else {\n            word += c;\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n    }\n\n    // Check the last word in the string\n    if (consonantCount == n) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"AEIOUaeiou\";\n    string result = \"\";\n    int n = word.size();\n\n    for (int i = n - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            bool left_consonant = find(vowels.begin(), vowels.end(), word[i - 1]) == vowels.end();\n            bool right_consonant = find(vowels.begin(), vowels.end(), word[i + 1]) == vowels.end();\n            if (left_consonant && right_consonant) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int balance1 = 0, balance2 = 0;\n\n    // Calculate the balance for the first string\n    for (char c : lst[0]) {\n        if (c == '(') balance1++;\n        else balance1--;\n    }\n\n    // Calculate the balance for the second string\n    for (char c : lst[1]) {\n        if (c == '(') balance2++;\n        else balance2--;\n    }\n\n    // Check if the total balance can be zero\n    if (balance1 + balance2 == 0 && balance1 >= 0 && balance2 >= 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (num >= 10 && num <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Start the sequence with the given number\n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rule\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final 1 to the sequence\n    odd_numbers.push_back(1);\n    \n    // Sort the vector in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date string into month, day, and year\n    stringstream ss(date);\n    string item;\n    vector<string> tokens;\n    while (getline(ss, item, '-')) {\n        tokens.push_back(item);\n    }\n\n    if (tokens.size() != 3) return false;\n\n    int month, day, year;\n    try {\n        month = stoi(tokens[0]);\n        day = stoi(tokens[1]);\n        year = stoi(tokens[2]);\n    } catch (invalid_argument&) {\n        return false;\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on month\n    if (month == 2) {\n        int maxDay = isLeapYear(year) ? 29 : 28;\n        if (day < 1 || day > maxDay) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) return false;\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    size_t pos = 0;\n    string delimiter = \" \";\n    \n    // Check for whitespace first\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // Check for commas if no whitespace\n    delimiter = \",\";\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // If no whitespace or commas, count odd-ordered lower-case letters\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in ascending order\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // Check if any number appears more than twice\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int productOfSigns = 1;\n    int sumOfMagnitudes = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            productOfSigns *= 1;\n        } else if (num < 0) {\n            productOfSigns *= -1;\n        } else {\n            productOfSigns *= 0;\n        }\n        sumOfMagnitudes += abs(num);\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<int> result;\n\n    // Helper function to perform DFS and find the minimum path\n    function<void(int, int, vector<int>&)> dfs = [&](int x, int y, vector<int>& path) {\n        if (path.size() == k) {\n            if (result.empty() || path < result) {\n                result = path;\n            }\n            return;\n        }\n\n        for (auto& dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                path.push_back(grid[nx][ny]);\n                dfs(nx, ny, path);\n                path.pop_back();\n            }\n        }\n    };\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> path = {grid[i][j]};\n            dfs(i, j, path);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacciSequence;\n    if (n < 0) return tribonacciSequence; // Return empty vector if n is negative\n\n    // Initialize the first element of the sequence\n    tribonacciSequence.push_back(1);\n\n    // Handle the case where n is 0\n    if (n == 0) return tribonacciSequence;\n\n    // Initialize the second element of the sequence\n    tribonacciSequence.push_back(3);\n\n    // Handle the case where n is 1\n    if (n == 1) return tribonacciSequence;\n\n    // Initialize the third element of the sequence\n    tribonacciSequence.push_back(2);\n\n    // Handle the case where n is 2\n    if (n == 2) return tribonacciSequence;\n\n    // Compute the remaining elements of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int nextValue;\n        if (i % 2 == 0) {\n            nextValue = 1 + i / 2;\n        } else {\n            nextValue = tribonacciSequence[i - 1] + tribonacciSequence[i - 2] + tribonacciSequence[i + 1];\n        }\n        tribonacciSequence.push_back(nextValue);\n    }\n\n    return tribonacciSequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    \n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0;\n    int nestedCount = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n                nestedCount++;\n            }\n        }\n    }\n\n    return nestedCount > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) return false;\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) return false;\n\n    // Check if the last character is not part of a word\n    if (txt.length() > 1) {\n        char secondLastChar = txt[txt.length() - 2];\n        if (isalpha(secondLastChar)) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    if (!has_negative) {\n        largest_negative = 0;\n    }\n    if (!has_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/algorithm/string.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        if (val.type() == typeid(int)) {\n            return static_cast<double>(boost::any_cast<int>(val));\n        } else if (val.type() == typeid(float)) {\n            return static_cast<double>(boost::any_cast<float>(val));\n        } else if (val.type() == typeid(double)) {\n            return boost::any_cast<double>(val);\n        } else if (val.type() == typeid(string)) {\n            string str = boost::any_cast<string>(val);\n            boost::replace_all(str, \",\", \".\");\n            return stod(str);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is divisible by 2 and greater than or equal to 8\n    // Since the smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    return n % 2 == 0 && n >= 8;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 0) {\n                if (spaceCount == 1) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                spaceCount = 0;\n            }\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (spaceCount == 1) {\n        result += '_';\n    } else if (spaceCount > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    bool valid_extension = false;\n    bool starts_with_letter = false;\n    string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n\n    for (int i = 0; i < file_name.size(); i++) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n            if (digit_count > 3) return \"No\";\n        }\n        if (file_name[i] == '.') {\n            dot_count++;\n            if (dot_count > 1) return \"No\";\n            if (i == 0 || i == file_name.size() - 1) return \"No\";\n            string extension = file_name.substr(i + 1);\n            for (string ext : valid_extensions) {\n                if (extension == ext) {\n                    valid_extension = true;\n                    break;\n                }\n            }\n            if (!valid_extension) return \"No\";\n            if (i > 0 && isalpha(file_name[0])) {\n                starts_with_letter = true;\n            }\n        }\n    }\n\n    if (dot_count != 1 || digit_count > 3 || !starts_with_letter || !valid_extension) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the entry if index is a multiple of 3\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the entry if index is a multiple of 4 and not a multiple of 3\n        }\n        sum += lst[i]; // Add the modified entry to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeLengthWords;\n    \n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    string result;\n    for (const string& w : primeLengthWords) {\n        if (!result.empty()) result += \" \";\n        result += w;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to parse the fraction string and return the numerator and denominator\npair<int, int> parseFraction(const string& fraction) {\n    size_t pos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, pos));\n    int denominator = stoi(fraction.substr(pos + 1));\n    return {numerator, denominator};\n}\n\n// Helper function to check if the product of two fractions is a whole number\nbool isWholeNumber(int num1, int den1, int num2, int den2) {\n    // Calculate the product of the two fractions\n    int numerator = num1 * num2;\n    int denominator = den1 * den2;\n    \n    // Check if the product is a whole number\n    return numerator % denominator == 0;\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    pair<int, int> fractionX = parseFraction(x);\n    pair<int, int> fractionN = parseFraction(n);\n    \n    // Check if the product of the two fractions is a whole number\n    return isWholeNumber(fractionX.first, fractionX.second, fractionN.first, fractionN.second);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs where each pair contains the number and its sum of digits\n    vector<pair<int, int>> num_sum_pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_sum_pairs.push_back({nums[i], sum_of_digits(nums[i])});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.second == b.second) {\n            return false; // Keep the original order if sums are equal\n        }\n        return a.second < b.second;\n    });\n\n    // Extract the sorted numbers from the sorted pairs\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.first);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string numStr = to_string(abs(num));\n    char firstDigit = numStr.front();\n    char lastDigit = numStr.back();\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) return {};\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) swap(index1, index2);\n    \n    // Collect the planets between index1 and index2 (exclusive)\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the vector first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and non-negative\n        if (floor(num) == num && num >= 0) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If the second string is longer than the first, it cannot be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    // Concatenate the second string with itself to handle rotations\n    string rotatedB = b + b;\n\n    // Check if the first string contains any rotation of the second string\n    return rotatedB.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> result = {0, 0}; // Initialize result vector with {even_count, odd_count}\n    num = abs(num); // Handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            result[0]++; // Increment even count\n        } else {\n            result[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    // Iterate through the symbols and append the corresponding Roman numeral to the result\n    for (const auto& symbol : romanSymbols) {\n        while (number >= symbol.first) {\n            result += symbol.second;\n            number -= symbol.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure the sides are sorted in ascending order\n    float sides[3] = {a, b, c};\n    for (int i = 0; i < 2; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (sides[i] > sides[j]) {\n                float temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n    \n    // Check if the sides satisfy the Pythagorean theorem\n    return (pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    auto count_unique_chars = [](const string& word) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        return unique_chars.size();\n    };\n\n    string max_word = \"\";\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_chars(word);\n        if (unique_count > max_unique_count || (unique_count == max_unique_count && word < max_word)) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number + need;\n    int carrotsLeft = remaining - need;\n\n    if (carrotsLeft < 0) {\n        totalEaten += remaining;\n        carrotsLeft = 0;\n    } else {\n        totalEaten += need;\n    }\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Ensure the vectors are of the correct size\n    if (operato.size() != operand.size() - 1) {\n        return -1; // Error condition\n    }\n\n    // Initialize the result with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands to build the expression\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            if (operand[i + 1] == 0) {\n                return -1; // Division by zero error\n            }\n            result /= operand[i + 1];\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        } else {\n            return -1; // Unknown operator error\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    for (char &c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    string md5_string;\n    char buf[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(buf, \"%02x\", result[i]);\n        md5_string += buf;\n    }\n\n    return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    for (int i = start; i <= end; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue; // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integerPart = static_cast<int>(number);\n    // Calculate the decimal part\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers){\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the sum of absolute deviations\n    float absDevSum = 0.0;\n    for (float num : numbers) {\n        absDevSum += abs(num - mean);\n    }\n\n    // Calculate and return the Mean Absolute Deviation\n    return absDevSum / numbers.size();\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (int i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n    \n    while (ss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    if (numbers.empty()) {\n        sum = 0;\n        product = 1;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers){\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int current_max = numbers[0];\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    if (str.empty()) return \"\";\n\n    // Find the longest palindromic suffix\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the end of the string\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, append the reverse of the entire string\n    string reversed = str;\n    reverse(reversed.begin(), reversed.end());\n    return str + reversed;\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int len = a.length();\n    \n    for (int i = 0; i < len; i++) {\n        // Perform XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestString = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n){\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use an unordered_set to store distinct characters\n    unordered_set<char> distinctChars(str.begin(), str.end());\n    \n    // Return the size of the set, which represents the number of distinct characters\n    return distinctChars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string note;\n    for (size_t i = 0; i < music_string.size(); ++i) {\n        if (music_string[i] == ' ') {\n            continue;\n        }\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(2);\n                ++i; // Skip the '|'\n            } else {\n                beats.push_back(4);\n            }\n        } else if (music_string[i] == '.') {\n            if (i + 1 < music_string.size() && music_string[i + 1] == '|') {\n                beats.push_back(1);\n                ++i; // Skip the '|'\n            }\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos += 1; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    // Map to convert words to their corresponding numbers\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to store the numbers corresponding to the words\n    vector<int> nums;\n\n    // Stringstream to split the input string by spaces\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        if (wordToNumber.find(word) != wordToNumber.end()) {\n            nums.push_back(wordToNumber[word]);\n        }\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Map to convert numbers back to their corresponding words\n    map<int, string> numberToWord = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Stringstream to build the output string\n    stringstream sortedNumbers;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i != 0) {\n            sortedNumbers << \" \";\n        }\n        sortedNumbers << numberToWord[nums[i]];\n    }\n\n    return sortedNumbers.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    vector<float> closestPair = {numbers[0], numbers[1]};\n    float minDistance = abs(numbers[0] - numbers[1]);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float distance = abs(numbers[i] - numbers[j]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestPair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    if (closestPair[0] > closestPair[1]) {\n        swap(closestPair[0], closestPair[1]);\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    float minVal = numbers[0];\n    float maxVal = numbers[0];\n\n    // Find the minimum and maximum values in the vector\n    for (float num : numbers) {\n        if (num < minVal) {\n            minVal = num;\n        }\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n\n    // Calculate the range\n    float range = maxVal - minVal;\n\n    // Apply the linear transform\n    vector<float> rescaledNumbers;\n    for (float num : numbers) {\n        float rescaledNum = (num - minVal) / range;\n        rescaledNumbers.push_back(rescaledNum);\n    }\n\n    return rescaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\n#include<typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str){\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n#include<cmath>\n\nint largest_divisor(int n) {\n    if (n <= 1) return 1; // Edge case for n <= 1\n    for (int i = sqrt(n); i >= 2; --i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1; // If no other divisor found, n is prime\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    \n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Add elements that occur only once to the result vector\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (int i = 0; i < str.length(); i++) {\n        if (islower(str[i])) {\n            str[i] = toupper(str[i]);\n        } else if (isupper(str[i])) {\n            str[i] = tolower(str[i]);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings){\n    string result;\n    for(const string& str : strings){\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_numbers;\n    for(float num : l){\n        if(num > 0){\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(long long n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    double tolerance = 1e-7;\n    double x0 = 0.0; // Initial guess, can be improved based on the problem constraints\n    double x1;\n\n    while (true) {\n        double fx = poly(xs, x0);\n        double fx_prime = poly_derivative(xs, x0);\n\n        if (fx_prime == 0) {\n            // Avoid division by zero\n            x0 += 1e-7;\n            continue;\n        }\n\n        x1 = x0 - fx / fx_prime;\n\n        if (abs(x1 - x0) < tolerance) {\n            break;\n        }\n\n        x0 = x1;\n    }\n\n    return x1;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> l_prime = l; // Initialize l' with the same values as l\n    vector<int> to_sort; // Vector to store elements at indices divisible by three\n\n    // Collect elements at indices divisible by three\n    for (int i = 0; i < l.size(); i++) {\n        if ((i + 1) % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace the elements in l' with the sorted elements\n    int index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if ((i + 1) % 3 == 0) {\n            l_prime[i] = to_sort[index++];\n        }\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    // Sort the vector to bring duplicates together\n    sort(l.begin(), l.end());\n    \n    // Use a vector to store unique elements\n    vector<int> uniqueElements;\n    \n    // Iterate through the sorted vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // If it's the first element or the current element is different from the previous one\n        if (i == 0 || l[i] != l[i - 1]) {\n            uniqueElements.push_back(l[i]);\n        }\n    }\n    \n    return uniqueElements;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    if (l.empty()) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    float maxVal = l[0];\n    for (float num : l) {\n        if (num > maxVal) {\n            maxVal = num;\n        }\n    }\n    return maxVal;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint countSevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += countSevens(i);\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even-indexed elements and sort them\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    sort(even_elements.begin(), even_elements.end());\n\n    // Reconstruct the list with sorted even-indexed elements\n    vector<float> result;\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(even_elements[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_cyclic(string s){ \n    // returns decoded string by reversing the cycling of groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<int> fibs = {1, 1};\n    int count = 0;\n    while (true) {\n        int next_fib = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n        fibs.push_back(next_fib);\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib;\n            }\n        }\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l){\n    int n = l.size();\n    if (n < 3) return false;\n\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    // Therefore, the total number of collisions is the product of the number of cars in each direction.\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l){\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // The area of a triangle with base 'a' and height 'h' is given by:\n    // Area = 0.5 * base * height\n    return 0.5 * a * h;\n}\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    std::vector<int> fib4_sequence(n + 1);\n    fib4_sequence[0] = 0;\n    fib4_sequence[1] = 0;\n    fib4_sequence[2] = 2;\n    fib4_sequence[3] = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        fib4_sequence[i] = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4];\n    }\n\n    return fib4_sequence[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l){\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Find the size of the vector\n    int n = l.size();\n    \n    // If the size of the vector is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size of the vector is even, return the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1;\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    text.erase(remove_if(text.begin(), text.end(), [&](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    return text;\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create frequency maps for both strings\n    unordered_map<char, int> freq0, freq1;\n    \n    // Populate the frequency map for s0\n    for (char c : s0) {\n        freq0[c]++;\n    }\n    \n    // Populate the frequency map for s1\n    for (char c : s1) {\n        freq1[c]++;\n    }\n    \n    // Compare the frequency maps\n    return freq0 == freq1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n){\n    if (n <= 0) return 0; // Handle edge case for non-positive integers\n    if (n == 1) return 1; // Base case for the first Fibonacci number\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l){\n    if (l.size() < 2) return true; // A single element or no elements are trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n\n        // If neither increasing nor decreasing, it's not monotonic\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Use a set to store unique common elements\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    // Convert the set back to a vector and return\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    // Check for the number itself if it is prime\n    if (is_prime(n)) return n;\n\n    // Check for factors from 2 up to sqrt(n)\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n                largest_factor = i;\n            }\n            if (is_prime(n / i)) {\n                largest_factor = n / i;\n            }\n        }\n    }\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> sequence(n + 1, 0);\n    sequence[0] = 0;\n    sequence[1] = 0;\n    sequence[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i - 3];\n    }\n\n    return sequence[n];\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    transform(s.begin(), s.end(), s.begin(), ::tolower); // Convert string to lowercase\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    // Check if 'y' is at the end of the word\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to easily manipulate its digits\n    string digits = to_string(x);\n    int num_digits = digits.size();\n\n    // If shift is greater than the number of digits, return the digits reversed\n    if (shift > num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    // Calculate the effective shift (modulo the number of digits)\n    shift = shift % num_digits;\n\n    // Perform the circular shift\n    string shifted_digits = digits.substr(num_digits - shift) + digits.substr(0, num_digits - shift);\n\n    return shifted_digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    \n    // Read the number of apples\n    ss >> apples;\n    ss >> temp; // Skip the word \"apples\"\n    ss >> temp; // Skip the word \"and\"\n    \n    // Read the number of oranges\n    ss >> oranges;\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int smallestEven = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestEven == -1) return {};\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst){\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer in the vector\n    for(int num : lst){\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Iterate through the frequency map to find the greatest integer that meets the criteria\n    for(const auto& pair : frequencyMap){\n        int num = pair.first;\n        int freq = pair.second;\n        \n        if(num <= freq && num > result){\n            result = num;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    sort(lst.begin(), lst.end());\n    \n    int i = 0;\n    int j = lst.size() - 1;\n    \n    while (i <= j) {\n        if (i <= j) {\n            result.push_back(lst[i]);\n            i++;\n        }\n        if (i <= j) {\n            result.push_back(lst[j]);\n            j--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides can form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return is_palindromic(q) && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    auto count_chars = [](const vector<string>& lst) {\n        int count = 0;\n        for (const string& s : lst) {\n            count += s.size();\n        }\n        return count;\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < primes.size(); ++i) {\n        for (int j = i; j < primes.size(); ++j) {\n            for (int k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return x == 1; // Special case: n is 1, only x == 1 is a simple power of 1\n    }\n\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power == x;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a; // Take the absolute value of a\n    }\n    int cube_root = round(cbrt(a)); // Calculate the cube root and round it to the nearest integer\n    return cube_root * cube_root * cube_root == a; // Check if the cube of the rounded cube root equals the original number\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        switch (c) {\n            case '2': case '3': case '5': case '7':\n            case 'B': case 'D':\n                if (isPrime(c >= 'A' ? c - 'A' + 10 : c - '0')) {\n                    count++;\n                }\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\";  // Start with the prefix \"db\"\n    if (decimal == 0) {\n        binary += \"0\";  // Special case for 0\n    } else {\n        while (decimal > 0) {\n            binary += to_string(decimal % 2);  // Append the least significant bit\n            decimal /= 2;  // Shift right\n        }\n        reverse(binary.begin() + 2, binary.end());  // Reverse the binary string to get the correct order\n    }\n    binary += \"db\";  // Append the suffix \"db\"\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive letters\n    for (int i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all 3 consecutive letters are distinct, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there are only two numbers: 0 and 1.\n    // Only 1 starts with 1 and ends with 1.\n    if (n == 1) {\n        return 1;\n    }\n\n    // For n > 1, we can calculate the number of n-digit numbers\n    // that start or end with 1.\n    // There are 9 possible digits for the first digit (1-9)\n    // and 10 possible digits for the rest of the digits (0-9).\n    // However, we need to exclude the case where the first digit is 1\n    // and the last digit is not 1, and vice versa.\n\n    // Total n-digit numbers: 9 * 10^(n-1)\n    // Numbers that start with 1: 1 * 10^(n-1)\n    // Numbers that end with 1: 9 * 10^(n-2)\n    // Numbers that start and end with 1: 1 * 10^(n-2)\n\n    // Using the principle of inclusion-exclusion:\n    // Total = (Numbers that start with 1) + (Numbers that end with 1) - (Numbers that start and end with 1)\n    // Total = 10^(n-1) + 9 * 10^(n-2) - 10^(n-2)\n    // Total = 10^(n-1) + 8 * 10^(n-2)\n\n    int total = (1 * pow(10, n-1)) + (8 * pow(10, n-2));\n    return total;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    int temp = N;\n    \n    // Calculate the sum of digits\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n            sum /= 2;\n        }\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    string word;\n    bool in_word = false;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (in_word) {\n                sort(word.begin(), word.end());\n                result += word;\n                word.clear();\n                in_word = false;\n            }\n            result += c;\n        } else {\n            word += c;\n            in_word = true;\n        }\n    }\n\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If the element matches x, add the coordinate to the list\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort coordinates by rows in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // Sort coordinates of the same row by columns in descending order\n    for (int i = 0; i < coordinates.size(); ++i) {\n        for (int j = i + 1; j < coordinates.size(); ++j) {\n            if (coordinates[i][0] == coordinates[j][0] && coordinates[i][1] < coordinates[j][1]) {\n                swap(coordinates[i], coordinates[j]);\n            }\n        }\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) return array;\n\n    int first_value = array.front();\n    int last_value = array.back();\n    int sum = first_value + last_value;\n\n    vector<int> sorted_array = array;\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character down by 2 * 2 = 4 places\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26;\n            }\n            encrypted += newChar;\n        } else {\n            // If the character is not a lowercase letter, leave it unchanged\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no such element\n    }\n\n    sort(lst.begin(), lst.end());\n\n    int smallest = lst[0];\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != smallest) {\n            return lst[i];\n        }\n    }\n\n    return -1; // Return -1 to indicate no such element\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    size_t pos = 0;\n    string delimiter = \".!?\";\n\n    while ((pos = S.find_first_of(delimiter, pos)) != string::npos) {\n        S[pos] = '\\0'; // Null-terminate the sentence\n        pos++; // Move past the delimiter\n    }\n\n    string sentence;\n    for (size_t i = 0; i < S.size(); i++) {\n        if (S[i] == '\\0') {\n            if (!sentence.empty() && sentence[0] == 'I') {\n                boredomCount++;\n            }\n            sentence.clear();\n        } else {\n            sentence += S[i];\n        }\n    }\n\n    // Check the last sentence if the string does not end with a delimiter\n    if (!sentence.empty() && sentence[0] == 'I') {\n        boredomCount++;\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int intA = static_cast<int>(a);\n    int intB = static_cast<int>(b);\n    int intC = static_cast<int>(c);\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (intA == intB + intC || intB == intA + intC || intC == intA + intB) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        // Swap case\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n\n        // Replace vowels with the letter 2 places ahead\n        if (c == 'a' || c == 'A') {\n            c = (c == 'a') ? 'c' : 'C';\n        } else if (c == 'e' || c == 'E') {\n            c = (c == 'e') ? 'g' : 'G';\n        } else if (c == 'i' || c == 'I') {\n            c = (c == 'i') ? 'k' : 'K';\n        } else if (c == 'o' || c == 'O') {\n            c = (c == 'o') ? 'q' : 'Q';\n        } else if (c == 'u' || c == 'U') {\n            c = (c == 'u') ? 'w' : 'W';\n        }\n\n        encodedMessage += c;\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) return 0; // No prime found\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) {\n            return false;\n        }\n\n        bool is_lower = true;\n        bool is_upper = true;\n\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n        }\n\n        if (!is_lower && !is_upper) {\n            return false;\n        }\n\n        all_lower &= is_lower;\n        all_upper &= is_upper;\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    string vowels = \"AEIOU\";\n    \n    for (int i = 0; i < s.size(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fmod(num, 1) == 0.5) {\n        // If the number is positive, round up\n        if (num > 0) {\n            return static_cast<int>(num + 0.5);\n        }\n        // If the number is negative, round down\n        else {\n            return static_cast<int>(num - 0.5);\n        }\n    }\n    // Otherwise, use standard rounding\n    else {\n        return static_cast<int>(round(num));\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_level = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_level);\n        if (current_level % 2 == 0) {\n            current_level += 2; // Next even number\n        } else {\n            current_level += 2; // Next odd number\n        }\n    }\n    \n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s){\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Use a delimiter to handle both commas and spaces\n    while (getline(ss, word, ',')) {\n        // Remove leading and trailing spaces from the word\n        word.erase(0, word.find_first_not_of(' '));\n        word.erase(word.find_last_not_of(' ') + 1);\n        \n        // If the word is not empty, add it to the vector\n        if (!word.empty()) {\n            words.push_back(word);\n        }\n        \n        // Check if there are more words separated by spaces\n        while (ss.peek() == ' ') {\n            ss.ignore();\n            if (getline(ss, word, ' ')) {\n                word.erase(0, word.find_first_not_of(' '));\n                word.erase(word.find_last_not_of(' ') + 1);\n                if (!word.empty()) {\n                    words.push_back(word);\n                }\n            }\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Adjust x to be the smallest even number greater than or equal to x\n    if (x % 2 != 0) {\n        x += 1;\n    }\n\n    // Adjust y to be the largest even number less than or equal to y\n    if (y % 2 != 0) {\n        y -= 1;\n    }\n\n    // If x is still greater than y after adjustments, return -1\n    if (x > y) {\n        return -1;\n    }\n\n    // Return the largest even number in the range [x, y]\n    return y;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average\n    int count = m - n + 1;\n    double average = static_cast<double>(sum) / count;\n\n    // Round the average to the nearest integer (smaller one)\n    int roundedAverage = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binaryRepresentation;\n    if (roundedAverage == 0) {\n        binaryRepresentation = \"0\";\n    } else {\n        while (roundedAverage > 0) {\n            binaryRepresentation = to_string(roundedAverage % 2) + binaryRepresentation;\n            roundedAverage /= 2;\n        }\n    }\n\n    return binaryRepresentation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the corresponding names for digits 1 to 9\n    map<int, string> digitNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter and sort the valid numbers (between 1 and 9 inclusive)\n    vector<int> validNumbers;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            validNumbers.push_back(num);\n        }\n    }\n    sort(validNumbers.begin(), validNumbers.end());\n\n    // Reverse the sorted vector\n    reverse(validNumbers.begin(), validNumbers.end());\n\n    // Replace each digit by its corresponding name\n    vector<string> result;\n    for (int num : validNumbers) {\n        result.push_back(digitNames[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum for odd i\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int shifts = 0;\n\n    // Find the number of shifts needed to make the array sorted\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            shifts++;\n        }\n    }\n\n    // If more than one shift is needed, it's not possible to sort the array\n    return shifts <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // If the number of odd elements in lst1 is less than or equal to the number of even elements in lst2,\n    // then it is possible to exchange elements to make lst1 all even.\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> result;\n    int maxCount = 0;\n\n    // Convert the string to a stream to easily iterate over words\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each letter\n    while (ss >> word) {\n        for (char c : word) {\n            letterCount[c]++;\n            maxCount = max(maxCount, letterCount[c]);\n        }\n    }\n\n    // Find all letters with the maximum count\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = maxCount;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are in c\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    bool isPalindrome = true;\n    int n = result.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (result[i] != result[n - i - 1]) {\n            isPalindrome = false;\n            break;\n        }\n    }\n\n    // Return the result string and the palindrome check result\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(odd_count) + \"n the string \" + to_string(i + 1) + \" of the input.\";\n        result.push_back(output);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle the edge case where the vector is empty\n\n    long long minSum = nums[0]; // Initialize minSum with the first element\n    long long currentSum = nums[0]; // Initialize currentSum with the first element\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update currentSum to be the minimum of the current element or the currentSum plus the current element\n        currentSum = min(nums[i], currentSum + nums[i]);\n        // Update minSum to be the minimum of minSum and currentSum\n        minSum = min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (const auto& unit : row) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        if (water_units > 0) {\n            total_lowers += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        }\n    }\n\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of a number\nint countOnes(int num) {\n    int count = 0;\n    while (num != 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of ones in their binary representation\n    // For similar number of ones, sort based on decimal value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b;\n        }\n        return countA < countB;\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u';\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    int consonantCount = 0;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (consonantCount == n) {\n                result.push_back(word);\n            }\n            word.clear();\n            consonantCount = 0;\n        } else {\n            word += c;\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n    }\n\n    // Check the last word in the string\n    if (consonantCount == n) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"AEIOUaeiou\";\n    string consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n\n    for (int i = word.size() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            bool left_consonant = false, right_consonant = false;\n\n            // Check if the left character is a consonant\n            for (int j = i - 1; j >= 0; --j) {\n                if (consonants.find(word[j]) != string::npos) {\n                    left_consonant = true;\n                    break;\n                }\n            }\n\n            // Check if the right character is a consonant\n            for (int j = i + 1; j < word.size(); ++j) {\n                if (consonants.find(word[j]) != string::npos) {\n                    right_consonant = true;\n                    break;\n                }\n            }\n\n            if (left_consonant && right_consonant) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int balance1 = 0, balance2 = 0;\n    \n    // Calculate the balance for the first string\n    for (char c : lst[0]) {\n        if (c == '(') balance1++;\n        else balance1--;\n    }\n    \n    // Calculate the balance for the second string\n    for (char c : lst[1]) {\n        if (c == '(') balance2++;\n        else balance2--;\n    }\n    \n    // Check if the total balance can be zero\n    if (balance1 + balance2 == 0 && balance1 >= 0 && balance2 >= 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (num >= 10 && num <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Start the sequence with the given number\n    while (n != 1) {\n        if (n % 2 == 1) {\n            // If the number is odd, add it to the list\n            odd_numbers.push_back(n);\n        }\n        // Generate the next number in the sequence\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final 1 to the list\n    odd_numbers.push_back(1);\n    \n    // Sort the list in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n\n    // Check if the date string is in the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date string into month, day, and year\n    stringstream ss(date);\n    string item;\n    vector<string> tokens;\n    while (getline(ss, item, '-')) {\n        tokens.push_back(item);\n    }\n\n    if (tokens.size() != 3) return false;\n\n    int month, day, year;\n    try {\n        month = stoi(tokens[0]);\n        day = stoi(tokens[1]);\n        year = stoi(tokens[2]);\n    } catch (invalid_argument&) {\n        return false;\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on month\n    if (month == 2) {\n        int maxDay = isLeapYear(year) ? 29 : 28;\n        if (day < 1 || day > maxDay) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) return false;\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    size_t pos = 0;\n    string delimiter = \" \";\n    \n    // Check for whitespace first\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // Check for commas if no whitespace found\n    delimiter = \",\";\n    if (txt.find(delimiter) != string::npos) {\n        while ((pos = txt.find(delimiter)) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + delimiter.length());\n        }\n        result.push_back(txt);\n        return result;\n    }\n    \n    // If no whitespace or commas, count odd-ordered lower-case letters\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 != 0) {\n                odd_count++;\n            }\n        }\n    }\n    result.push_back(to_string(odd_count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in ascending order\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // Check if any number appears more than twice\n    for (int i = 2; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n    \n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n    \n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int productOfSigns = 1;\n    int sumOfMagnitudes = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            productOfSigns *= 1;\n        } else if (num < 0) {\n            productOfSigns *= -1;\n        } else {\n            productOfSigns *= 0;\n        }\n        sumOfMagnitudes += abs(num);\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<int> result;\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\n\n    // Initialize the priority queue with all starting points\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({grid[i][j], i, j, 1});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        int value = current[0];\n        int x = current[1];\n        int y = current[2];\n        int length = current[3];\n\n        if (length == k) {\n            result.push_back(value);\n            if (result.size() == k) {\n                return result;\n            }\n        } else {\n            for (auto& dir : directions) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                    pq.push({grid[newX][newY], newX, newY, length + 1});\n                }\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacciSequence;\n    if (n < 0) return tribonacciSequence; // Handle invalid input\n\n    // Initialize the first element of the sequence\n    tribonacciSequence.push_back(1);\n\n    // Handle the case where n is 0\n    if (n == 0) return tribonacciSequence;\n\n    // Initialize the second element of the sequence\n    tribonacciSequence.push_back(3);\n\n    // Handle the case where n is 1\n    if (n == 1) return tribonacciSequence;\n\n    // Initialize the third element of the sequence\n    tribonacciSequence.push_back(2);\n\n    // Handle the case where n is 2\n    if (n == 2) return tribonacciSequence;\n\n    // Compute the rest of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int nextValue;\n        if (i % 2 == 0) {\n            nextValue = 1 + i / 2;\n        } else {\n            nextValue = tribonacciSequence[i - 1] + tribonacciSequence[i - 2] + tribonacciSequence[i + 1];\n        }\n        tribonacciSequence.push_back(nextValue);\n    }\n\n    return tribonacciSequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    \n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0;\n    int nestedCount = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n                nestedCount++;\n            }\n        }\n    }\n\n    return nestedCount > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) return false;\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) return false;\n\n    // Check if the last character is not part of a word\n    if (txt.size() == 1) return true; // Single character string\n\n    // Get the second last character\n    char secondLastChar = txt[txt.size() - 2];\n\n    // If the second last character is a space, then the last character is not part of a word\n    return isspace(secondLastChar);\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    if (!has_negative) {\n        largest_negative = 0;\n    }\n    if (!has_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\n#include<boost/lexical_cast.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert any type to double\n    auto to_double = [](const boost::any& val) -> double {\n        try {\n            if (val.type() == typeid(int)) {\n                return boost::any_cast<int>(val);\n            } else if (val.type() == typeid(float)) {\n                return boost::any_cast<float>(val);\n            } else if (val.type() == typeid(double)) {\n                return boost::any_cast<double>(val);\n            } else if (val.type() == typeid(string)) {\n                string str = boost::any_cast<string>(val);\n                replace(str.begin(), str.end(), ',', '.');\n                return boost::lexical_cast<double>(str);\n            }\n        } catch (const boost::bad_any_cast&) {\n            throw runtime_error(\"Unsupported type\");\n        }\n        throw runtime_error(\"Unsupported type\");\n    };\n\n    double a_val = to_double(a);\n    double b_val = to_double(b);\n\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the number is even and greater than or equal to 8\n    if (n % 2 == 0 && n >= 8) {\n        // Any even number greater than or equal to 8 can be written as the sum of exactly 4 positive even numbers\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n            if (space_count == 1) {\n                result += '_';\n            }\n        } else {\n            if (space_count > 1) {\n                result += '-';\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    if (space_count > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    bool valid_extension = false;\n    string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    string before_dot = \"\";\n    string after_dot = \"\";\n\n    // Iterate through the file name to count dots and digits\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        } else if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there is exactly one dot\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the file name into before and after the dot\n    size_t dot_pos = file_name.find('.');\n    before_dot = file_name.substr(0, dot_pos);\n    after_dot = file_name.substr(dot_pos + 1);\n\n    // Check if the substring before the dot is not empty and starts with a letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of the valid extensions\n    for (string ext : valid_extensions) {\n        if (after_dot == ext) {\n            valid_extension = true;\n            break;\n        }\n    }\n\n    if (!valid_extension) {\n        return \"No\";\n    }\n\n    // Check if there are not more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the entry if index is a multiple of 3\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the entry if index is a multiple of 4 and not a multiple of 3\n        }\n        sum += lst[i]; // Add the modified or unmodified entry to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeLengthWords;\n    \n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            primeLengthWords.push_back(word);\n        }\n    }\n    \n    string result;\n    for (const string& w : primeLengthWords) {\n        if (!result.empty()) result += \" \";\n        result += w;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to parse the fraction string and return the numerator and denominator\npair<int, int> parseFraction(const string& fraction) {\n    size_t pos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, pos));\n    int denominator = stoi(fraction.substr(pos + 1));\n    return {numerator, denominator};\n}\n\n// Helper function to check if the product of two fractions is a whole number\nbool isWholeNumber(int num1, int den1, int num2, int den2) {\n    int numerator = num1 * num2;\n    int denominator = den1 * den2;\n    return numerator % denominator == 0;\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    pair<int, int> fractionX = parseFraction(x);\n    pair<int, int> fractionN = parseFraction(n);\n\n    // Extract the numerator and denominator\n    int numX = fractionX.first;\n    int denX = fractionX.second;\n    int numN = fractionN.first;\n    int denN = fractionN.second;\n\n    // Check if the product of the two fractions is a whole number\n    return isWholeNumber(numX, denX, numN, denN);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs where each pair contains the sum of digits and the original number\n    vector<pair<int, int>> num_sum_pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        num_sum_pairs.push_back({sum_of_digits(nums[i]), nums[i]});\n    }\n\n    // Sort the vector of pairs based on the sum of digits\n    sort(num_sum_pairs.begin(), num_sum_pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) {\n            // If sums are equal, maintain the original order\n            return false;\n        }\n        return a.first < b.first;\n    });\n\n    // Extract the sorted numbers from the sorted pairs\n    vector<int> sorted_nums;\n    for (const auto& pair : num_sum_pairs) {\n        sorted_nums.push_back(pair.second);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string numStr = to_string(abs(num));\n    char firstDigit = numStr.front();\n    char lastDigit = numStr.back();\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) return {};\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) swap(index1, index2);\n    \n    // Collect the planets between index1 and index2 (exclusive)\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the vector first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\n#include<cmath>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and non-negative\n        if (floor(num) == num && num >= 0) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If the length of b is greater than a, it cannot be a substring or rotation\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    // Concatenate b with itself to handle rotations\n    string b_rotated = b + b;\n\n    // Check if any rotation of b is a substring of a\n    for (int i = 0; i < b.length(); ++i) {\n        if (a.find(b_rotated.substr(i, b.length())) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> result = {0, 0}; // Initialize result vector with {even_count, odd_count}\n    num = abs(num); // Handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            result[0]++; // Increment even count\n        } else {\n            result[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanSymbols = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    // Iterate through the symbols and append the corresponding Roman numeral to the result\n    for (const auto& symbol : romanSymbols) {\n        while (number >= symbol.first) {\n            result += symbol.second;\n            number -= symbol.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure the sides are sorted in ascending order\n    float sides[3] = {a, b, c};\n    for (int i = 0; i < 2; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (sides[i] > sides[j]) {\n                float temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n    \n    // Check if the sides satisfy the Pythagorean theorem\n    return (pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words){\n    auto count_unique_chars = [](const string& word) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        return unique_chars.size();\n    };\n\n    string max_word = \"\";\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_chars(word);\n        if (unique_count > max_unique_count || (unique_count == max_unique_count && word < max_word)) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int carrotsNeeded = need - number;\n\n    if (carrotsNeeded > 0) {\n        if (remaining >= carrotsNeeded) {\n            totalEaten += carrotsNeeded;\n            remaining -= carrotsNeeded;\n        } else {\n            totalEaten += remaining;\n            remaining = 0;\n        }\n    }\n\n    return {totalEaten, remaining};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands to build the expression\n    for (int i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        // Perform the operation based on the operator\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            result /= next_operand;\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    for (char &c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), result);\n\n    string md5_string;\n    char buf[3];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(buf, \"%02x\", result[i]);\n        md5_string += buf;\n    }\n\n    return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    for (int i = start; i <= end; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
