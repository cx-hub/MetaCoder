{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Iterate through each pair of numbers in the list\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                // Calculate the absolute difference between the two numbers\n                double difference = Math.abs(numbers.get(i) - numbers.get(j));\n                // Check if the difference is less than the threshold\n                if (difference < threshold) {\n                    return true; // Found a pair closer than the threshold\n                }\n            }\n        }\n        return false; // No pair found closer than the threshold\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        paren_string = paren_string.replaceAll(\" \", \"\");\n        \n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char ch : paren_string.toCharArray()) {\n            currentGroup.append(ch);\n            if (ch == '(') {\n                balance++;\n            } else if (ch == ')') {\n                balance--;\n            }\n            \n            // When balance is zero, we have a complete group\n            if (balance == 0) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Reset for the next group\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.separate_paren_groups(\"( ) (( )) (( )( ))\")); // [\"()\", \"(())\", \"(()())\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n     */\n    public double truncate_number(double number) {\n        // Get the integer part of the number\n        double integerPart = Math.floor(number);\n        \n        // Subtract the integer part from the original number to get the decimal part\n        double decimalPart = number - integerPart;\n        \n        return decimalPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5)); // Output: 0.5\n        System.out.println(solution.truncate_number(1.0)); // Output: 0.0\n        System.out.println(solution.truncate_number(2.75)); // Output: 0.75\n        System.out.println(solution.truncate_number(0.123)); // Output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Step 1: Calculate the mean of the dataset\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Compute the absolute differences between each element and the mean\n        double absoluteDeviationsSum = 0.0;\n        for (double number : numbers) {\n            absoluteDeviationsSum += Math.abs(number - mean);\n        }\n\n        // Step 3: Calculate the average of these absolute differences\n        double mad = absoluteDeviationsSum / numbers.size();\n\n        return mad;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(solution.mean_absolute_deviation(numbers)); // Output: 1.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // If the input list is empty, return an empty list\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n\n        // Iterate through the input list\n        for (int i = 0; i < numbers.size(); i++) {\n            // Add the current element to the result list\n            result.add(numbers.get(i));\n\n            // If it's not the last element, add the delimiter\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                result.add(str);\n            }\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum and product\n        int sum = 0;\n        int product = 1;\n\n        // Iterate through the list of numbers\n        for (int number : numbers) {\n            sum += number;       // Add the number to the sum\n            product *= number;   // Multiply the number to the product\n        }\n\n        // Return the result as a list\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_product(List.of())); // [0, 1]\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize the current maximum to the smallest possible integer value\n        int currentMax = Integer.MIN_VALUE;\n        \n        // Iterate through the list of numbers\n        for (int number : numbers) {\n            // Update the current maximum if the current number is greater\n            if (number > currentMax) {\n                currentMax = number;\n            }\n            // Add the current maximum to the result list\n            result.add(currentMax);\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> result = solution.rolling_max(numbers);\n        System.out.println(result); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "public class PalindromeMaker {\n\n    public String make_palindrome(String string) {\n        if (string == null || string.isEmpty()) {\n            return string;\n        }\n\n        // Find the longest palindromic suffix\n        int n = string.length();\n        int longestPalindromicSuffixLength = 1;\n        for (int i = 0; i < n; i++) {\n            if (isPalindrome(string.substring(i))) {\n                longestPalindromicSuffixLength = n - i;\n                break;\n            }\n        }\n\n        // The prefix that needs to be reversed and appended\n        String prefixToReverse = string.substring(0, n - longestPalindromicSuffixLength);\n\n        // Construct the palindrome\n        StringBuilder palindromeBuilder = new StringBuilder(string);\n        palindromeBuilder.append(new StringBuilder(prefixToReverse).reverse());\n\n        return palindromeBuilder.toString();\n    }\n\n    // Assuming isPalindrome is correctly implemented elsewhere\n    public boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        PalindromeMaker pm = new PalindromeMaker();\n        System.out.println(pm.make_palindrome(\"race\")); // Output: \"racecar\"\n        System.out.println(pm.make_palindrome(\"aab\")); // Output: \"aabaa\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n     */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of the same length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Input strings must be of the same length\");\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each character of the strings\n        for (int i = 0; i < a.length(); i++) {\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n\n            // Perform XOR operation\n            if (charA == charB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Output: \"100\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n\n        return Optional.of(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure that a is greater than or equal to b\n        if (b > a) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        // Apply the Euclidean algorithm\n        while (b != 0) {\n            int remainder = a % b;\n            a = b;\n            b = remainder;\n        }\n        \n        // The GCD is the non-zero number left in 'a'\n        return a;\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.all_prefixes(\"abc\")); // Output: [\"a\", \"ab\", \"abc\"]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String string_sequence(int n) {\n        // Create a StringBuilder to efficiently build the result string\n        StringBuilder sb = new StringBuilder();\n        \n        // Loop from 0 to n inclusive\n        for (int i = 0; i <= n; i++) {\n            // Append the current number to the StringBuilder\n            sb.append(i);\n            \n            // If the current number is not the last one, append a space\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to handle case insensitivity\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a Set to store distinct characters\n        Set<Character> distinctCharacters = new HashSet<>();\n        \n        // Iterate through the string and add each character to the Set\n        for (char c : lowerCaseString.toCharArray()) {\n            distinctCharacters.add(c);\n        }\n        \n        // The size of the Set is the count of distinct characters\n        return distinctCharacters.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        // Initialize the list to store the beats\n        List<Integer> beatsList = new ArrayList<>();\n        \n        // Create a map to store the mapping of notes to beats\n        Map<String, Integer> noteToBeats = new HashMap<>();\n        noteToBeats.put(\"o\", 4);\n        noteToBeats.put(\"o|\", 2);\n        noteToBeats.put(\".|\", 1);\n        \n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Iterate through each note and add the corresponding beats to the list\n        for (String note : notes) {\n            beatsList.add(noteToBeats.get(note));\n        }\n        \n        // Return the list of beats\n        return beatsList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\"));\n        // Output should be: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n     */\n    public int how_many_times(String string, String substring) {\n        int count = 0;\n        int subLength = substring.length();\n        int strLength = string.length();\n        \n        // Iterate through the string and check for the substring\n        for (int i = 0; i <= strLength - subLength; i++) {\n            // Check if the substring matches starting from position i\n            if (string.substring(i, i + subLength).equals(substring)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\")); // 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Step 1: Create a mapping from number words to their corresponding integer values\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Step 2: Split the input string into individual number words\n        String[] numberWords = numbers.split(\" \");\n\n        // Step 3: Sort the words based on their values using the mapping\n        Arrays.sort(numberWords, new Comparator<String>() {\n            @Override\n            public int compare(String word1, String word2) {\n                return numberMap.get(word1) - numberMap.get(word2);\n            }\n        });\n\n        // Step 4: Reconstruct the sorted string\n        return String.join(\" \", numberWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\")); // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements\n        Collections.sort(numbers);\n        \n        // Initialize variables to keep track of the minimum difference and the closest elements\n        double minDifference = Double.MAX_VALUE;\n        double num1 = 0.0;\n        double num2 = 0.0;\n        \n        // Iterate through the sorted list to find the closest elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double currentDifference = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (currentDifference < minDifference) {\n                minDifference = currentDifference;\n                num1 = numbers.get(i);\n                num2 = numbers.get(i + 1);\n            }\n        }\n        \n        // Return the closest elements in the required order\n        List<Double> result = new ArrayList<>();\n        result.add(Math.min(num1, num2));\n        result.add(Math.max(num1, num2));\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))); // [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n        \n        // Create a new list to store the rescaled values\n        List<Double> rescaledList = new ArrayList<>();\n        \n        // Apply the linear transformation to each number\n        for (Double number : numbers) {\n            double rescaledValue = (number - min) / (max - min);\n            rescaledList.add(rescaledValue);\n        }\n        \n        return rescaledList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        List<Double> rescaledNumbers = solution.rescale_to_unit(numbers);\n        System.out.println(rescaledNumbers); // Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1\n        for (int i = n - 1; i > 0; i--) {\n            // Check if i divides n evenly\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, return 1 (since 1 is a divisor of any number)\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_divisor(15)); // Output: 5\n        System.out.println(sol.largest_divisor(28)); // Output: 14\n        System.out.println(sol.largest_divisor(13)); // Output: 1 (since 13 is a prime number)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Start with the smallest prime number\n        int factor = 2;\n        \n        // Continue until n becomes 1\n        while (n > 1) {\n            // Check if the current factor divides n\n            while (n % factor == 0) {\n                // If it does, add it to the list and divide n by the factor\n                factors.add(factor);\n                n /= factor;\n            }\n            // Move to the next potential factor\n            factor++;\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.factorize(8));   // Output: [2, 2, 2]\n        System.out.println(sol.factorize(25));  // Output: [5, 5]\n        System.out.println(sol.factorize(70));  // Output: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer number : numbers) {\n            if (!seen.contains(number)) {\n                result.add(number);\n                seen.add(number);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> output = solution.remove_duplicates(input);\n        System.out.println(output); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else {\n                flippedString.append(c); // If it's not a letter, just append it as is\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.flip_case(\"Hello\")); // Output: \"hELLO\"\n        System.out.println(solution.flip_case(\"World\")); // Output: \"wORLD\"\n        System.out.println(solution.flip_case(\"Hello, World!\")); // Output: \"hELLO, wORLD!\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix(List.of(), \"a\")\n    []\n    >>> filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(n -> n > 0)  // Filter out non-positive numbers\n                .collect(Collectors.toList());  // Collect the results into a list\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    false\n    >>> is_prime(101)\n    true\n    >>> is_prime(11)\n    true\n    >>> is_prime(13441)\n    true\n    >>> is_prime(61)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(1)\n    false\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime\n        }\n        \n        // Check for factors from 3 to sqrt(n)\n        int sqrt = (int) Math.sqrt(n);\n        for (int i = 3; i <= sqrt; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    return xs[1] + 2 * xs[2] * x + 3 * xs[3] * x^2 + .... n * xs[n] * x^(n-1)\n     */\n    public double polyDerivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> find_zero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> find_zero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double find_zero(List<Double> xs) {\n        double tolerance = 1e-7; // Tolerance for convergence\n        double x0 = 0.0; // Initial guess\n        double x1 = x0;\n        \n        do {\n            x0 = x1;\n            double fx = poly(xs, x0);\n            double dfx = polyDerivative(xs, x0);\n            if (dfx == 0) {\n                throw new ArithmeticException(\"Derivative is zero, Newton-Raphson method fails.\");\n            }\n            x1 = x0 - fx / dfx;\n        } while (Math.abs(x1 - x0) > tolerance);\n        \n        return x1;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Create a list to store the values at indices divisible by three\n        List<Integer> valuesToSort = new ArrayList<>();\n        \n        // Iterate through the list and collect values at indices divisible by three\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                valuesToSort.add(l.get(i));\n            }\n        }\n        \n        // Sort the collected values\n        Collections.sort(valuesToSort);\n        \n        // Place the sorted values back into the original list at the correct positions\n        int index = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                l.set(i, valuesToSort.get(index));\n                index++;\n            }\n        }\n        \n        return l;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Step 1: Convert the list to a Set to remove duplicates\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        \n        // Step 2: Convert the Set back to a List\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        \n        // Step 3: Sort the list\n        Collections.sort(uniqueList);\n        \n        // Step 4: Return the sorted list\n        return uniqueList;\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int max_element(List<Integer> l) {\n        // Initialize the maximum element to the smallest possible integer value\n        int max = Integer.MIN_VALUE;\n        \n        // Iterate through each element in the list\n        for (int num : l) {\n            // Update the maximum value if the current element is greater\n            if (num > max) {\n                max = num;\n            }\n        }\n        \n        // Return the maximum element found\n        return max;\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numberStr = Integer.toString(i);\n                for (char c : numberStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fizz_buzz(50)); // Output: 0\n        System.out.println(sol.fizz_buzz(78)); // Output: 2\n        System.out.println(sol.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sort_even(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to store the sorted even indices values\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace the values at even indices with the sorted values\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n     */\n    public int prime_fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be a positive integer\");\n        }\n        \n        int count = 0;\n        int a = 0, b = 1;\n        \n        while (true) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                count++;\n                if (count == n) {\n                    return fib;\n                }\n            }\n        }\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        if (num % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.prime_fib(1)); // 2\n        System.out.println(sol.prime_fib(2)); // 3\n        System.out.println(sol.prime_fib(3)); // 5\n        System.out.println(sol.prime_fib(4)); // 13\n        System.out.println(sol.prime_fib(5)); // 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to use the two-pointer technique\n        Collections.sort(l);\n        \n        // Iterate through the list\n        for (int i = 0; i < l.size() - 2; i++) {\n            // Skip duplicates to ensure distinct elements\n            if (i > 0 && l.get(i).equals(l.get(i - 1))) {\n                continue;\n            }\n            \n            int left = i + 1;\n            int right = l.size() - 1;\n            int target = -l.get(i);\n            \n            // Use two-pointer technique to find the pair that sums to target\n            while (left < right) {\n                int sum = l.get(left) + l.get(right);\n                \n                if (sum == target) {\n                    return true;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "// File: Solution.java\npublic class Solution {\n    public int car_race_collision(int n) {\n        // The number of collisions is simply n * n\n        return n * n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.car_race_collision(3)); // Output: 9\n        System.out.println(solution.car_race_collision(4)); // Output: 16\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream()\n                .map(i -> i + 1)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairs_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) {\n            return \"0\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x = x / base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.change_base(8, 3));  // Output: \"22\"\n        System.out.println(solution.change_base(8, 2));  // Output: \"1000\"\n        System.out.println(solution.change_base(7, 2));  // Output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array to store the last four computed values\n        int[] fib4Values = new int[4];\n        fib4Values[0] = 0; // fib4(0)\n        fib4Values[1] = 0; // fib4(1)\n        fib4Values[2] = 2; // fib4(2)\n        fib4Values[3] = 0; // fib4(3)\n\n        // Compute the sequence iteratively\n        for (int i = 4; i <= n; i++) {\n            int nextValue = fib4Values[0] + fib4Values[1] + fib4Values[2] + fib4Values[3];\n            // Shift the values to the left\n            fib4Values[0] = fib4Values[1];\n            fib4Values[1] = fib4Values[2];\n            fib4Values[2] = fib4Values[3];\n            fib4Values[3] = nextValue;\n        }\n\n        // The result is the last computed value\n        return fib4Values[3];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    8.0\n     */\n    public double median(List<Integer> l) {\n        // Sort the list\n        Collections.sort(l);\n        \n        int size = l.size();\n        \n        // Check if the size of the list is odd or even\n        if (size % 2 == 1) {\n            // If odd, return the middle element\n            return l.get(size / 2);\n        } else {\n            // If even, return the average of the two middle elements\n            int mid1 = l.get(size / 2 - 1);\n            int mid2 = l.get(size / 2);\n            return (mid1 + mid2) / 2.0;\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n     */\n    public boolean is_palindrome(String text) {\n        // An empty string is considered a palindrome\n        if (text.isEmpty()) {\n            return true;\n        }\n        \n        // Use two pointers to compare characters from the start and end of the string\n        int left = 0;\n        int right = text.length() - 1;\n        \n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/49", "generation": "public int modp(int n, int p) {\n    if (n == 0) {\n        return 1;\n    }\n    \n    int result = 1;\n    int base = 2;\n    \n    while (n > 0) {\n        // If n is odd, multiply base with result and take modulus\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        // n must be even now\n        n = n >> 1; // n = n / 2\n        base = (base * base) % p; // Change base to base^2 % p\n    }\n    \n    return result;\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Calculate the new character by shifting back 5 positions\n            char decodedChar = (char) ('a' + ((ch - 5 - 'a' + 26) % 26));\n            sb.append(decodedChar);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for quick lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Use a StringBuilder to construct the result string\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string\n        for (char c : text.toCharArray()) {\n            // If the character is not a vowel, append it to the result\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Adds two integers.\n     *\n     * @param x the first integer\n     * @param y the second integer\n     * @return the sum of x and y\n     * @example\n     * <pre>\n     * add(2, 3)  // returns 5\n     * add(5, 7)  // returns 12\n     * </pre>\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if two words have the same kind of characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create frequency maps for both strings\n        Map<Character, Integer> freqMap0 = getFrequencyMap(s0);\n        Map<Character, Integer> freqMap1 = getFrequencyMap(s1);\n        \n        // Compare the frequency maps\n        return freqMap0.equals(freqMap1);\n    }\n    \n    // Helper method to create a frequency map for a given string\n    private Map<Character, Integer> getFrequencyMap(String s) {\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n        return freqMap;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        \n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib(10)); // Output: 55\n        System.out.println(solution.fib(1));  // Output: 1\n        System.out.println(solution.fib(8));  // Output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '<') {\n                stack.push(bracket);\n            } else if (bracket == '>') {\n                if (stack.isEmpty() || stack.pop() != '<') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // false\n        System.out.println(solution.correct_bracketing(\"<>\")); // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) {\n            return true; // An empty list or a single element list is trivially monotonic\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        \n        // Find the intersection of the two sets\n        set1.retainAll(set2);\n        \n        // Convert the set to a list and sort it\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        int largestPrime = 1;\n        \n        // Check for the smallest prime factor, which is 2\n        while (n % 2 == 0) {\n            largestPrime = 2;\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 to sqrt(n)\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestPrime = i;\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then n itself is a prime number\n        if (n > 2) {\n            largestPrime = n;\n        }\n        \n        return largestPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_prime_factor(13195)); // Output: 29\n        System.out.println(sol.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Output: 465\n        System.out.println(solution.sum_to_n(100)); // Output: 5050\n        System.out.println(solution.sum_to_n(5));   // Output: 15\n        System.out.println(solution.sum_to_n(10));  // Output: 55\n        System.out.println(solution.sum_to_n(1));   // Output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '(') {\n                stack.push(bracket);\n            } else if (bracket == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"(\")); // false\n        System.out.println(solution.correct_bracketing(\"()\")); // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Start from the second element (index 1) since the derivative of the constant term is 0\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.derivative(Arrays.asList(3, 1, 2, 4, 5))); // [1, 4, 12, 20]\n        System.out.println(solution.derivative(Arrays.asList(1, 2, 3))); // [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n     */\n    public int fibfib(int n) {\n        // Base cases\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        // Initialize the first three FibFib numbers\n        int a = 0, b = 0, c = 1;\n        int result = 0;\n\n        // Compute the n-th FibFib number iteratively\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n     */\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle case insensitivity\n        s = s.toLowerCase();\n        \n        // Initialize a counter for vowels\n        int count = 0;\n        \n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));\n        \n        // Iterate through the string\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            // Check if the character is a vowel\n            if (vowels.contains(c)) {\n                count++;\n            }\n        }\n        \n        // Check if 'y' is at the end of the word\n        if (s.length() > 0 && s.charAt(s.length() - 1) == 'y') {\n            count++;\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.vowels_count(\"abcde\")); // Output: 2\n        System.out.println(sol.vowels_count(\"ACEDY\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        int length = numStr.length();\n\n        // If shift is greater than or equal to the number of digits, return the reversed string\n        if (shift >= length) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n\n        // Perform the circular shift\n        String shiftedPart = numStr.substring(length - shift);\n        String remainingPart = numStr.substring(0, length - shift);\n        String result = shiftedPart + remainingPart;\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(solution.circular_shift(12345, 2)); // Output: \"45123\"\n        System.out.println(solution.circular_shift(12345, 5)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                sum += (int) ch;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.digitSum(\"\")); // 0\n        System.out.println(sol.digitSum(\"abAB\")); // 131\n        System.out.println(sol.digitSum(\"abcCd\")); // 67\n        System.out.println(sol.digitSum(\"helloE\")); // 69\n        System.out.println(sol.digitSum(\"woArBld\")); // 131\n        System.out.println(sol.digitSum(\"aAaaaXa\")); // 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Split the string by spaces to isolate the numbers and words\n        String[] parts = s.split(\" \");\n        \n        // The number of apples is the first number in the string\n        int apples = Integer.parseInt(parts[0]);\n        \n        // The number of oranges is the third number in the string\n        int oranges = Integer.parseInt(parts[2]);\n        \n        // Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        \n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(sol.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Output: 2\n        System.out.println(sol.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(sol.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        // Initialize variables to store the smallest even value and its index\n        int minEvenValue = Integer.MAX_VALUE;\n        int minEvenIndex = -1;\n        \n        // Iterate through the list to find the smallest even value\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            \n            // Check if the current value is even and smaller than the current smallest even value\n            if (currentValue % 2 == 0 && currentValue < minEvenValue) {\n                minEvenValue = currentValue;\n                minEvenIndex = i;\n            }\n        }\n        \n        // If a smallest even value was found, return it along with its index\n        if (minEvenIndex != -1) {\n            return Arrays.asList(minEvenValue, minEvenIndex);\n        } else {\n            // If no even value was found, return an empty list\n            return Collections.emptyList();\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList())); // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Count the frequency of each integer in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Find the greatest integer that meets the criteria\n        int maxValidInteger = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            if (num > 0 && freq >= num) {\n                if (num > maxValidInteger) {\n                    maxValidInteger = num;\n                }\n            }\n        }\n\n        return maxValidInteger;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Output: 2\n        System.out.println(sol.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Output: 3\n        System.out.println(sol.search(Arrays.asList(5, 5, 4, 4, 4))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list in ascending order\n        Collections.sort(lst);\n        \n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize two pointers: one for minimum and one for maximum\n        int minIndex = 0;\n        int maxIndex = lst.size() - 1;\n        \n        // Alternate between picking the minimum and maximum values\n        while (minIndex <= maxIndex) {\n            if (minIndex <= maxIndex) {\n                result.add(lst.get(minIndex));\n                minIndex++;\n            }\n            if (minIndex <= maxIndex) {\n                result.add(lst.get(maxIndex));\n                maxIndex--;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // [1, 4, 2, 3]\n        System.out.println(sol.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // [5, 5, 5, 5]\n        System.out.println(sol.strange_sort_list(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round the area to 2 decimal places\n        area = Math.round(area * 100.0) / 100.0;\n        \n        return area;\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        List<Integer> reversedQ = new ArrayList<>(q);\n        Collections.reverse(reversedQ);\n        if (!q.equals(reversedQ)) {\n            return false;\n        }\n\n        // Calculate the sum of the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to the maximum weight\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n        \n        // Compare elements from the start and end moving towards the center\n        for (int i = 0; i < n / 2; i++) {\n            if (arr.get(i) != arr.get(n - 1 - i)) {\n                changes++;\n            }\n        }\n        \n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper function to calculate the total number of characters in a list of strings.\n     */\n    private int totalChars(List<String> lst) {\n        int total = 0;\n        for (String str : lst) {\n            total += str.length();\n        }\n        return total;\n    }\n\n    /**\n     * Function to compare two lists of strings based on the total number of characters.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int total1 = totalChars(lst1);\n        int total2 = totalChars(lst2);\n\n        if (total1 <= total2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.total_match(Arrays.asList(), Arrays.asList())); // []\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that the prime number is less then 100.\n    Example:\n    is_multiply_prime(30) == true\n    30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        // Generate all prime numbers less than 100\n        List<Integer> primes = generatePrimes(100);\n        \n        // Check all combinations of three primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + 1; j < primes.size(); j++) {\n                for (int k = j + 1; k < primes.size(); k++) {\n                    if (primes.get(i) * primes.get(j) * primes.get(k) == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Helper method to generate prime numbers less than n using Sieve of Eratosthenes\n    private List<Integer> generatePrimes(int n) {\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_multiply_prime(30)); // true\n        System.out.println(sol.is_multiply_prime(29)); // false\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        // If x is 1, it is a power of any number (n^0 = 1)\n        if (x == 1) {\n            return true;\n        }\n        \n        // If n is 1, the only power of 1 is 1 itself, so x must be 1\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        // Iteratively divide x by n\n        while (x % n == 0) {\n            x /= n;\n        }\n        \n        // If x becomes 1, it means x was a power of n\n        return x == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_simple_power(1, 4)); // true\n        System.out.println(sol.is_simple_power(2, 2)); // true\n        System.out.println(sol.is_simple_power(8, 2)); // true\n        System.out.println(sol.is_simple_power(3, 2)); // false\n        System.out.println(sol.is_simple_power(3, 1)); // false\n        System.out.println(sol.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an integer a and returns true\n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> true\n    iscube(2) ==> false\n    iscube(-1) ==> true\n    iscube(64) ==> true\n    iscube(0) ==> true\n    iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        // Calculate the cube root of a\n        double cubeRoot = Math.cbrt(a);\n        \n        // Round the cube root to the nearest integer\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n        \n        // Check if cubing the rounded cube root gives back a\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a;\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // List of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize the count of prime digits\n        int count = 0;\n        \n        // Iterate through each character in the string\n        for (char c : num.toCharArray()) {\n            // If the character is in the set of prime hexadecimal digits, increment the count\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        // Return the final count\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.hex_key(\"AB\")); // Output: 1\n        System.out.println(sol.hex_key(\"1077E\")); // Output: 2\n        System.out.println(sol.hex_key(\"ABED1A33\")); // Output: 4\n        System.out.println(sol.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(sol.hex_key(\"2020\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Wrap the binary string with 'db' at the beginning and end\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Output: \"db100000db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => false\n    is_happy(aa) => false\n    is_happy(abcd) => true\n    is_happy(aabb) => false\n    is_happy(adb) => true\n    is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) {\n            return false;\n        }\n        \n        // Iterate through the string and check every set of 3 consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            // Check if all three characters are distinct\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        // If all sets of 3 consecutive characters are distinct, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\")); // false\n        System.out.println(solution.is_happy(\"aa\")); // false\n        System.out.println(solution.is_happy(\"abcd\")); // true\n        System.out.println(solution.is_happy(\"aabb\")); // false\n        System.out.println(solution.is_happy(\"adb\")); // true\n        System.out.println(solution.is_happy(\"xyy\")); // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> letterGrades = solution.numerical_letter_grade(grades);\n        System.out.println(letterGrades); // Output: [A+, B+, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    prime_length(\"Hello\") == true\n    prime_length(\"abcdcba\") == true\n    prime_length(\"kittens\") == true\n    prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        if (length < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_length(\"Hello\")); // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\")); // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Special case: there is only one 1-digit number that starts and ends with 1.\n        }\n        int countStartsWith1 = (int) Math.pow(10, n - 1);\n        int countEndsWith1 = (int) Math.pow(10, n - 1);\n        int countBoth = (int) Math.pow(10, n - 2);\n        return countStartsWith1 + countEndsWith1 - countBoth;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(int N) {\n        // Step 1: Calculate the sum of digits of N\n        int sumOfDigits = 0;\n        int temp = N;\n        \n        while (temp > 0) {\n            sumOfDigits += temp % 10; // Add the last digit to the sum\n            temp /= 10; // Remove the last digit\n        }\n        \n        // Step 2: Convert the sum of digits to binary\n        String binarySum = Integer.toBinaryString(sumOfDigits);\n        \n        // Step 3: Return the binary string\n        return binarySum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.solve(1000)); // Output: \"1\"\n        System.out.println(sol.solve(150));  // Output: \"110\"\n        System.out.println(sol.solve(147));  // Output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int total = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                total += lst.get(i);\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.add(Arrays.asList(4, 2, 6, 7))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string into words using space as the delimiter\n        String[] words = s.split(\" \");\n        \n        // Create a list to hold the sorted words\n        List<String> sortedWords = new ArrayList<>();\n        \n        // Iterate over each word\n        for (String word : words) {\n            // Convert the word to a character array\n            char[] chars = word.toCharArray();\n            \n            // Sort the character array based on ASCII values\n            Arrays.sort(chars);\n            \n            // Convert the sorted character array back to a string\n            String sortedWord = new String(chars);\n            \n            // Add the sorted word to the list\n            sortedWords.add(sortedWord);\n        }\n        \n        // Join the sorted words back into a single string with spaces\n        String result = String.join(\" \", sortedWords);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.anti_shuffle(\"Hi\")); // Output: \"Hi\"\n        System.out.println(sol.anti_shuffle(\"hello\")); // Output: \"ehllo\"\n        System.out.println(sol.anti_shuffle(\"Hello World!!!\")); // Output: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Traverse the nested list to find occurrences of x\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        \n        // Sort the coordinates\n        coordinates.sort((a, b) -> {\n            // First, compare by row (ascending)\n            int rowComparison = a.get(0).compareTo(b.get(0));\n            if (rowComparison != 0) {\n                return rowComparison;\n            }\n            // If rows are the same, compare by column (descending)\n            return b.get(1).compareTo(a.get(1));\n        });\n        \n        return coordinates;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        \n        List<List<Integer>> lst2 = Arrays.asList();\n        System.out.println(solution.get_row(lst2, 1)); // []\n        \n        List<List<Integer>> lst3 = Arrays.asList(\n            Arrays.asList(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the array is empty or has only one element\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Calculate the sum of the first and last elements\n        int firstElement = array.get(0);\n        int lastElement = array.get(array.size() - 1);\n        int sum = firstElement + lastElement;\n\n        // Create a copy of the array to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Sort the array based on the sum\n        if (sum % 2 == 0) {\n            // Sort in descending order if the sum is even\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            // Sort in ascending order if the sum is odd\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                // Shift lowercase letters by 4 places\n                char newChar = (char) (c + 4);\n                if (newChar > 'z') {\n                    newChar = (char) (newChar - 26);\n                }\n                encrypted.append(newChar);\n            } else if (Character.isUpperCase(c)) {\n                // Shift uppercase letters by 4 places\n                char newChar = (char) (c + 4);\n                if (newChar > 'Z') {\n                    newChar = (char) (newChar - 26);\n                }\n                encrypted.append(newChar);\n            } else {\n                // Non-alphabet characters remain unchanged\n                encrypted.append(c);\n            }\n        }\n        \n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(sol.encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(sol.encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(sol.encrypt(\"et\")); // Output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * Returns null if there is no such element.\n     * \n     * @param lst The list of integers.\n     * @return Optional containing the 2nd smallest element or empty if not found.\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        int smallest = Integer.MAX_VALUE;\n        int secondSmallest = Integer.MAX_VALUE;\n        boolean foundSecondSmallest = false;\n\n        for (int num : lst) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num > smallest && num < secondSmallest) {\n                secondSmallest = num;\n                foundSecondSmallest = true;\n            }\n        }\n\n        return foundSecondSmallest ? Optional.of(secondSmallest) : Optional.empty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList())); // Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1))); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n     */\n    public int is_bored(String S) {\n        // Split the string into sentences based on '.', '?', and '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim any leading or trailing whitespace\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (sentence.startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\")); // 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // 1\n        System.out.println(solution.is_bored(\"I am bored. I need something to do! I think I will go for a walk?\")); // 3\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all three parameters are instances of Integer\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            // Convert the parameters to integers\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n            \n            // Check if any one of the integers is equal to the sum of the other two\n            return (a == b + c) || (b == a + c) || (c == a + b);\n        }\n        \n        // Return false if any of the parameters is not an integer\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes the given message by swapping the case of all letters and replacing\n     * all vowels with the letter that appears 2 places ahead in the English alphabet.\n     *\n     * @param message The input message to be encoded.\n     * @return The encoded message.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead\n                if (isVowel(swappedCaseChar)) {\n                    swappedCaseChar = getNextChar(swappedCaseChar, 2);\n                }\n                \n                encodedMessage.append(swappedCaseChar);\n            } else {\n                // If it's not a letter, just append it as is\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n    \n    /**\n     * Checks if the given character is a vowel.\n     *\n     * @param c The character to check.\n     * @return True if the character is a vowel, false otherwise.\n     */\n    private boolean isVowel(char c) {\n        return \"aeiouAEIOU\".indexOf(c) != -1;\n    }\n    \n    /**\n     * Gets the character that is `offset` places ahead of the given character in the alphabet.\n     *\n     * @param c The character to start from.\n     * @param offset The number of places to move ahead.\n     * @return The character that is `offset` places ahead.\n     */\n    private char getNextChar(char c, int offset) {\n        int base = Character.isUpperCase(c) ? 'A' : 'a';\n        return (char) ((c - base + offset) % 26 + base);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encode(\"test\")); // Output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Output: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to check if a number is prime.\n     * @param num The number to check.\n     * @return True if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2) return true; // 2 is the only even prime number\n        if (num % 2 == 0) return false; // Other even numbers are not prime\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Helper method to sum the digits of a number.\n     * @param num The number whose digits are to be summed.\n     * @return The sum of the digits of the number.\n     */\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Method to find the largest prime value in the list and return the sum of its digits.\n     * @param lst The list of integers.\n     * @return The sum of the digits of the largest prime number in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        int largestPrime = -1;\n        \n        // Find the largest prime in the list\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n        \n        // If no prime was found, return 0 (though the problem guarantees there is at least one prime)\n        if (largestPrime == -1) {\n            return 0;\n        }\n        \n        // Return the sum of the digits of the largest prime\n        return sumOfDigits(largestPrime);\n    }\n}\n\npublic class Java94 {\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(sol.skjkasdkd(lst1)); // Output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(sol.skjkasdkd(lst2)); // Output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(sol.skjkasdkd(lst3)); // Output: 13\n        \n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(sol.skjkasdkd(lst4)); // Output: 11\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the map is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            // Check if the key is a string\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            String strKey = (String) key;\n\n            // Check if the key is in lower case\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n\n            // Check if the key is in upper case\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n\n            // If neither allLowerCase nor allUpperCase is true, return false\n            if (!allLowerCase && !allUpperCase) {\n                return false;\n            }\n        }\n\n        // If either allLowerCase or allUpperCase is true, return true\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"a\", \"apple\");\n        map1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(map1)); // True\n\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"a\", \"apple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(map2)); // False\n\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"a\", \"apple\");\n        map3.put(8, \"banana\");\n        map3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(map3)); // False\n\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n        System.out.println(solution.check_dict_case(map4)); // False\n\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(map5)); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        if (n <= 2) {\n            return primes; // No primes less than 2\n        }\n\n        // Step 1: Create a boolean array \"isPrime[0..n]\" and initialize all entries as true.\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n\n        // Step 2: Mark non-prime numbers\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                // Mark all multiples of i as non-prime\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        // Step 3: Collect all prime numbers\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.count_up_to(5));  // Output: [2, 3]\n        System.out.println(sol.count_up_to(11)); // Output: [2, 3, 5, 7]\n        System.out.println(sol.count_up_to(0));  // Output: []\n        System.out.println(sol.count_up_to(20)); // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(sol.count_up_to(1));  // Output: []\n        System.out.println(sol.count_up_to(18)); // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digit of the first integer\n        int unitDigitA = Math.abs(a) % 10;\n        \n        // Extract the unit digit of the second integer\n        int unitDigitB = Math.abs(b) % 10;\n        \n        // Multiply the unit digits\n        int result = unitDigitA * unitDigitB;\n        \n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        \n        // Iterate through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            if (uppercaseVowels.contains(ch)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_upper(\"aBCdEf\")); // Output: 1\n        System.out.println(sol.count_upper(\"abcdefg\")); // Output: 0\n        System.out.println(sol.count_upper(\"dBBE\")); // Output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n     */\n    public int closest_integer(String value) {\n        // Parse the string to a double\n        double number = Double.parseDouble(value);\n        \n        // Round the double to the nearest integer, rounding away from zero for halfway cases\n        long rounded = Math.round(number);\n        \n        // Convert the rounded long to an int and return\n        return (int) rounded;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));    // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int current = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            if (current % 2 == 0) {\n                current += 2; // Next even number\n            } else {\n                current += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.make_a_pile(3)); // Output: [3, 5, 7]\n        System.out.println(sol.make_a_pile(4)); // Output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     */\n    public List<String> words_string(String s) {\n        // Split the string using the regular expression that matches spaces or commas with optional spaces around them\n        String[] words = s.split(\"\\\\s+|,\\\\s*\");\n        // Convert the array to a list and return it\n        return Arrays.asList(words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n        System.out.println(solution.words_string(\"Hello   world,  this  is  a test\")); // [\"Hello\", \"world\", \"this\", \"is\", \"a\", \"test\"]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure the range is valid\n        if (x > y) {\n            return -1;\n        }\n        \n        // Iterate from y down to x to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n        \n        // If no even number is found, return -1\n        return -1;\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Step 1: Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n        \n        // Step 2: Calculate the sum of integers from n to m\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        // Step 3: Compute the average\n        int count = m - n + 1;\n        double average = (double) sum / count;\n        \n        // Step 4: Round the average to the nearest integer\n        int roundedAverage = (int) Math.round(average);\n        \n        // Step 5: Convert the rounded average to binary\n        String binaryRepresentation = Integer.toBinaryString(roundedAverage);\n        \n        return binaryRepresentation;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.rounded_avg(1, 5)); // Output: \"11\"\n        System.out.println(sol.rounded_avg(7, 5)); // Output: -1\n        System.out.println(sol.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(sol.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all\n     * elements that hasn't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     *\n     * For example:\n     * >>> unique_digits(Arrays.asList(15, 33, 1422, 1))\n     * [1, 15, 33]\n     * >>> unique_digits(Arrays.asList(152, 323, 1422, 10))\n     * []\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!containsEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n    \n    private boolean containsEvenDigit(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            num /= 10;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.unique_digits(Arrays.asList(15, 33, 1422, 1))); // [1, 15, 33]\n        System.out.println(sol.unique_digits(Arrays.asList(152, 323, 1422, 10))); // []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter and sort the array\n        List<Integer> filteredAndSorted = arr.stream()\n                                             .filter(num -> num >= 1 && num <= 9)\n                                             .sorted()\n                                             .collect(Collectors.toList());\n        \n        // Step 2: Reverse the sorted array\n        Collections.reverse(filteredAndSorted);\n        \n        // Step 3: Map each digit to its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredAndSorted) {\n            result.add(getNumberName(num));\n        }\n        \n        return result;\n    }\n    \n    private String getNumberName(int num) {\n        switch (num) {\n            case 1: return \"One\";\n            case 2: return \"Two\";\n            case 3: return \"Three\";\n            case 4: return \"Four\";\n            case 5: return \"Five\";\n            case 6: return \"Six\";\n            case 7: return \"Seven\";\n            case 8: return \"Eight\";\n            case 9: return \"Nine\";\n            default: throw new IllegalArgumentException(\"Number out of range: \" + num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Output: [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n        \n        List<Integer> arr2 = Arrays.asList();\n        System.out.println(solution.by_length(arr2)); // Output: []\n        \n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Output: [\"One\"]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Compute factorial of i\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Compute sum of numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n    \n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int len = str.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(sol.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     * >>> count_nums(Arrays.asList()) == 0\n     * >>> count_nums(Arrays.asList(-1, 11, -11)) == 1\n     * >>> count_nums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            int sumOfDigits = 0;\n            int temp = Math.abs(num); // Work with the absolute value of the number\n            \n            while (temp > 0) {\n                sumOfDigits += temp % 10; // Add the last digit to the sum\n                temp /= 10; // Remove the last digit\n            }\n            \n            // If the number was negative, subtract the sum twice (to account for the negative sign)\n            if (num < 0) {\n                sumOfDigits = -sumOfDigits;\n            }\n            \n            if (sumOfDigits > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(sol.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(sol.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        int minIndex = 0;\n\n        // Find the index of the minimum element\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i) < arr.get(minIndex)) {\n                minIndex = i;\n            }\n        }\n\n        // Check if the array can be sorted by right shifts\n        for (int i = 0; i < n; i++) {\n            int current = (minIndex + i) % n;\n            int next = (minIndex + i + 1) % n;\n            if (arr.get(current) > arr.get(next)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count the number of odd elements in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        // Count the number of even elements in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // Check if we have enough even elements in lst2 to replace all odd elements in lst1\n        if (evenCountInLst2 >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // \"YES\"\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Step 1: Split the input string into individual letters\n        String[] letters = test.split(\" \");\n        \n        // Step 2: Use a map to count the occurrences of each letter\n        Map<String, Integer> letterCountMap = new HashMap<>();\n        for (String letter : letters) {\n            letterCountMap.put(letter, letterCountMap.getOrDefault(letter, 0) + 1);\n        }\n        \n        // Step 3: Determine the maximum count\n        int maxCount = 0;\n        for (int count : letterCountMap.values()) {\n            if (count > maxCount) {\n                maxCount = count;\n            }\n        }\n        \n        // Step 4: Collect letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCountMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        // Step 5: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Step 1: Remove characters from s that are in c\n        StringBuilder result = new StringBuilder();\n        Set<Character> charsToRemove = new HashSet<>();\n        \n        // Add all characters in c to the set\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n        \n        // Build the result string by excluding characters in charsToRemove\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                result.append(ch);\n            }\n        }\n        \n        // Step 2: Check if the result string is a palindrome\n        String resultString = result.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n        \n        // Step 3: Return the result as a list\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n        \n        return resultList;\n    }\n    \n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        \n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n            int oddCount = 0;\n            \n            // Count the number of odd digits in the string\n            for (char ch : str.toCharArray()) {\n                if (Character.isDigit(ch) && (ch - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            \n            // Construct the output string\n            String output = String.format(\"the number of odd elements %dn the str%dng %d of the %dnput.\", oddCount, oddCount, oddCount, oddCount);\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.odd_count(Arrays.asList(\"1234567\")));\n        // Expected output: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        System.out.println(sol.odd_count(Arrays.asList(\"3\", \"11111111\")));\n        // Expected output: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        // Initialize the minimum sum ending here and the minimum sum so far\n        int minEndingHere = nums.get(0);\n        int minSoFar = nums.get(0);\n        \n        // Iterate through the list starting from the second element\n        for (int i = 1; i < nums.size(); i++) {\n            int current = nums.get(i);\n            // Update minEndingHere to be the minimum of the current element or the sum of minEndingHere and the current element\n            minEndingHere = Math.min(current, minEndingHere + current);\n            // Update minSoFar to be the minimum of minSoFar and minEndingHere\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n        \n        // Return the minimum sum found\n        return minSoFar;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Output: 1\n        System.out.println(sol.minSubArraySum(Arrays.asList(-1, -2, -3))); // Output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalBucketsLowered = 0;\n        \n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n            for (int cell : row) {\n                if (cell == 1) {\n                    waterUnits++;\n                }\n            }\n            // Calculate the number of times the bucket needs to be lowered\n            int bucketsForRow = (int) Math.ceil((double) waterUnits / capacity);\n            totalBucketsLowered += bucketsForRow;\n        }\n        \n        return totalBucketsLowered;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(sol.max_fill(grid1, capacity1)); // Output: 6\n        \n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(sol.max_fill(grid2, capacity2)); // Output: 5\n        \n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(sol.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation in ascending order.\n     * For similar number of ones, sorts based on decimal value.\n     * \n     * @param arr The list of integers to be sorted.\n     * @return The sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Use a custom comparator to sort the array\n        arr.sort((a, b) -> {\n            // Count the number of ones in the binary representation of a and b\n            int countA = Integer.bitCount(a);\n            int countB = Integer.bitCount(b);\n            \n            // If the number of ones is the same, sort by decimal value\n            if (countA == countB) {\n                return Integer.compare(a, b);\n            }\n            \n            // Otherwise, sort by the number of ones\n            return Integer.compare(countA, countB);\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList(1, 5, 2, 3, 4))); // [1, 2, 4, 3, 5]\n        System.out.println(solution.sort_array(Arrays.asList(-2, -3, -4, -5, -6))); // [-4, -2, -6, -5, -3]\n        System.out.println(solution.sort_array(Arrays.asList(1, 0, 2, 3, 4))); // [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // List to store the result\n        List<String> result = new ArrayList<>();\n        \n        // If the input string is empty, return the empty list\n        if (s.isEmpty()) {\n            return result;\n        }\n        \n        // Split the string into words\n        String[] words = s.split(\" \");\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Count the number of consonants in the word\n            int consonantCount = countConsonants(word);\n            \n            // If the consonant count matches n, add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n    \n    // Helper method to count consonants in a word\n    private int countConsonants(String word) {\n        int count = 0;\n        // Convert the word to lowercase to handle case insensitivity\n        word = word.toLowerCase();\n        \n        // Iterate through each character in the word\n        for (char c : word.toCharArray()) {\n            // Check if the character is a consonant\n            if (isConsonant(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    // Helper method to check if a character is a consonant\n    private boolean isConsonant(char c) {\n        // Define the set of vowels\n        String vowels = \"aeiou\";\n        \n        // Check if the character is a letter and not a vowel\n        return Character.isLetter(c) && vowels.indexOf(c) == -1;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        // Define the set of vowels (case sensitive)\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Traverse the word from right to left\n        for (int i = word.length() - 2; i > 0; i--) {\n            char currentChar = word.charAt(i);\n            // Check if the current character is a vowel\n            if (vowels.contains(currentChar)) {\n                // Check if the character before and after the current character are consonants\n                char prevChar = word.charAt(i - 1);\n                char nextChar = word.charAt(i + 1);\n                if (!vowels.contains(prevChar) && !vowels.contains(nextChar)) {\n                    return String.valueOf(currentChar);\n                }\n            }\n        }\n        \n        // If no valid vowel is found, return an empty string\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_closest_vowel(\"yogurt\")); // \"u\"\n        System.out.println(sol.get_closest_vowel(\"FULL\"));   // \"U\"\n        System.out.println(sol.get_closest_vowel(\"quick\"));  // \"\"\n        System.out.println(sol.get_closest_vowel(\"ab\"));     // \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int openCount = 0;\n        int closeCount = 0;\n\n        // Count the number of opening and closing parentheses in both strings\n        for (String str : lst) {\n            for (char ch : str.toCharArray()) {\n                if (ch == '(') {\n                    openCount++;\n                } else if (ch == ')') {\n                    closeCount++;\n                }\n            }\n        }\n\n        // Check if the counts of opening and closing parentheses are equal\n        if (openCount == closeCount) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.match_parens(Arrays.asList(\"()(\", \")\"))); // Output: \"Yes\"\n        System.out.println(sol.match_parens(Arrays.asList(\")\", \")\"))); // Output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in ascending order\n        Collections.sort(arr);\n        \n        // Step 2: Select the top k elements from the end of the sorted array\n        List<Integer> result = new ArrayList<>();\n        for (int i = arr.size() - k; i < arr.size(); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Step 3: The result is already in ascending order, so no need to sort again\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3)); // Output: [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2)); // Output: [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0) { // Check if the index is even\n                if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                    sum += lst.get(i);\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        \n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            int num = arr.get(i);\n            \n            // Check if the number has at most two digits\n            if (num >= 0 && num <= 99) {\n                sum += num;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(sol.add_elements(arr, k)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddNumbers = new ArrayList<>();\n        \n        // Start with the given number\n        int current = n;\n        \n        // Loop until we reach 1\n        while (current != 1) {\n            // Check if the current number is odd\n            if (current % 2 != 0) {\n                oddNumbers.add(current);\n            }\n            \n            // Generate the next number in the sequence\n            if (current % 2 == 0) {\n                current = current / 2;\n            } else {\n                current = 3 * current + 1;\n            }\n        }\n        \n        // Add 1 to the list as it is always the last number in the sequence\n        oddNumbers.add(1);\n        \n        // Sort the list in increasing order\n        Collections.sort(oddNumbers);\n        \n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.get_odd_collatz(5)); // Output: [1, 5]\n        System.out.println(sol.get_odd_collatz(1)); // Output: [1]\n        System.out.println(sol.get_odd_collatz(10)); // Output: [1, 5]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Validates a given date string and returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\n     *    And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\n     *    And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * @param date The date string to validate.\n     * @return true if the date is valid, false otherwise.\n     */\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Check if the date string matches the format mm-dd-yyyy\n        if (!date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) {\n            return false;\n        }\n\n        // Split the date string into month, day, and year\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is valid\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Check if the day is valid based on the month\n        if (month == 2) {\n            // February can have 29 days in a leap year, otherwise 28\n            if (day < 1 || day > 29) {\n                return false;\n            }\n            // Check for leap year\n            if (day == 29 && !isLeapYear(year)) {\n                return false;\n            }\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            // April, June, September, November have 30 days\n            if (day < 1 || day > 30) {\n                return false;\n            }\n        } else {\n            // All other months have 31 days\n            if (day < 1 || day > 31) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    /**\n     * Helper method to determine if a given year is a leap year.\n     * @param year The year to check.\n     * @return true if the year is a leap year, false otherwise.\n     */\n    private boolean isLeapYear(int year) {\n        if (year % 4 == 0) {\n            if (year % 100 == 0) {\n                return year % 400 == 0;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-00-2040\")); // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check if there is any whitespace in the text\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        \n        // Check if there is any comma in the text\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        }\n        \n        // If no whitespace or comma, count the number of lowercase letters with odd order in the alphabet\n        int oddCount = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int order = c - 'a';\n                if (order % 2 != 0) {\n                    oddCount++;\n                }\n            }\n        }\n        \n        return oddCount;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"abcdef\")); // 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // If the list has 0 or 1 element, it is trivially sorted\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        // Use a HashMap to count occurrences of each number\n        Map<Integer, Integer> countMap = new HashMap<>();\n\n        // Iterate through the list to check sorting and count occurrences\n        for (int i = 1; i < lst.size(); i++) {\n            int current = lst.get(i);\n            int previous = lst.get(i - 1);\n\n            // Check if the list is not sorted\n            if (current < previous) {\n                return false;\n            }\n\n            // Update the count of the current number\n            countMap.put(current, countMap.getOrDefault(current, 0) + 1);\n\n            // If any number appears more than twice, return false\n            if (countMap.get(current) > 2) {\n                return false;\n            }\n        }\n\n        // Check the first element separately to avoid out of bounds error\n        countMap.put(lst.get(0), countMap.getOrDefault(lst.get(0), 0) + 1);\n        if (countMap.get(lst.get(0)) > 2) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n        \n        int intersectionStart = Math.max(start1, start2);\n        int intersectionEnd = Math.min(end1, end2);\n        \n        if (intersectionStart <= intersectionEnd) {\n            int lengthOfIntersection = intersectionEnd - intersectionStart + 1;\n            if (isPrime(lengthOfIntersection)) {\n                return \"YES\";\n            }\n        }\n        \n        return \"NO\";\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        if (num % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int sumOfMagnitudes = 0;\n\n        for (int num : arr) {\n            if (num > 0) {\n                signProduct *= 1;\n            } else if (num < 0) {\n                signProduct *= -1;\n            } else {\n                signProduct *= 0;\n            }\n            sumOfMagnitudes += Math.abs(num);\n        }\n\n        int result = sumOfMagnitudes * signProduct;\n        return Optional.of(result);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1))); // Output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList())); // Output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        if (n == 0) return new ArrayList<>();\n        \n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        // Custom comparator to compare List<Integer> based on the sum of their elements\n        Comparator<List<Integer>> pathComparator = (path1, path2) -> {\n            int sum1 = path1.stream().mapToInt(Integer::intValue).sum();\n            int sum2 = path2.stream().mapToInt(Integer::intValue).sum();\n            return Integer.compare(sum1, sum2);\n        };\n        \n        // Initialize the priority queue with the custom comparator\n        PriorityQueue<Path> pq = new PriorityQueue<>((p1, p2) -> pathComparator.compare(p1.path, p2.path));\n        \n        // Initialize the priority queue with all starting points\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                List<Integer> initialPath = new ArrayList<>();\n                initialPath.add(grid.get(i).get(j));\n                pq.offer(new Path(i, j, initialPath));\n            }\n        }\n        \n        while (!pq.isEmpty()) {\n            Path current = pq.poll();\n            if (current.path.size() == k) {\n                return current.path;\n            }\n            for (int[] dir : directions) {\n                int newRow = current.row + dir[0];\n                int newCol = current.col + dir[1];\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                    List<Integer> newPath = new ArrayList<>(current.path);\n                    newPath.add(grid.get(newRow).get(newCol));\n                    pq.offer(new Path(newRow, newCol, newPath));\n                }\n            }\n        }\n        \n        return new ArrayList<>(); // This should never be reached due to problem constraints\n    }\n    \n    class Path {\n        int row, col;\n        List<Integer> path;\n        \n        Path(int row, int col, List<Integer> path) {\n            this.row = row;\n            this.col = col;\n            this.path = path;\n        }\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> tribonacciSequence = new ArrayList<>();\n        \n        // Base case\n        tribonacciSequence.add(3); // tri(1) = 3\n        \n        for (int i = 2; i <= n + 1; i++) {\n            if (i % 2 == 0) {\n                // If i is even\n                tribonacciSequence.add(1 + i / 2);\n            } else {\n                // If i is odd\n                int tri_i_minus_1 = tribonacciSequence.get(i - 2); // tri(i - 1)\n                int tri_i_minus_2 = tribonacciSequence.get(i - 3); // tri(i - 2)\n                int tri_i_plus_1 = 1 + (i + 1) / 2; // tri(i + 1)\n                tribonacciSequence.add(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1);\n            }\n        }\n        \n        return tribonacciSequence;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Output: [3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Initialize the product to 1\n        int product = 1;\n        \n        // Convert the number to a string to iterate through each digit\n        String numberStr = Integer.toString(n);\n        \n        // Flag to check if any odd digit is found\n        boolean hasOddDigit = false;\n        \n        // Iterate through each character in the string\n        for (char ch : numberStr.toCharArray()) {\n            // Convert the character to an integer\n            int digit = Character.getNumericValue(ch);\n            \n            // Check if the digit is odd\n            if (digit % 2 != 0) {\n                // Multiply the product by the odd digit\n                product *= digit;\n                // Set the flag to true as we found an odd digit\n                hasOddDigit = true;\n            }\n        }\n        \n        // If no odd digit was found, return 0\n        if (!hasOddDigit) {\n            return 0;\n        }\n        \n        // Return the product of the odd digits\n        return product;\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n            } else if (ch == ']') {\n                if (!stack.isEmpty() && stack.peek() == '[') {\n                    return true; // Found a nested pair\n                }\n                // Clear the stack if we encounter a ']' without a matching '['\n                stack.clear();\n            }\n        }\n        \n        return false; // No nested pairs found\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_nested(\"[[]]\")); // true\n        System.out.println(sol.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(sol.is_nested(\"[][]\")); // false\n        System.out.println(sol.is_nested(\"[]\")); // false\n        System.out.println(sol.is_nested(\"[[][]]\")); // true\n        System.out.println(sol.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            int roundedNum = (int) Math.ceil(num);\n            // Square the rounded number\n            int squaredNum = roundedNum * roundedNum;\n            // Add to the sum\n            sum += squaredNum;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(sol.sum_squares(lst1)); // Output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(sol.sum_squares(lst2)); // Output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(sol.sum_squares(lst3)); // Output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(sol.sum_squares(lst4)); // Output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(sol.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt.isEmpty()) {\n            return false;\n        }\n\n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is an alphabetical character\n        if (Character.isLetter(lastChar)) {\n            // Check if the last character is not part of a word\n            // This means the last character should be the last in the string and not followed by any other characters\n            if (txt.length() == 1 || txt.charAt(txt.length() - 2) == ' ') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < arr.size(); i++) {\n            // Check if the current element is not greater than or equal to the previous element\n            if (arr.get(i) < arr.get(i - 1)) {\n                // Return the index of the current element\n                return i;\n            }\n        }\n        // If no such element is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (!largestNegative.isPresent() || num > largestNegative.get()) {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-5, -3, -1, 0, 2, 4))); // (Optional.of(-1), Optional.of(2))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        // Normalize the inputs to Double for comparison\n        Double valA = normalizeToDouble(a);\n        Double valB = normalizeToDouble(b);\n\n        // Compare the normalized values\n        if (valA == null || valB == null) {\n            return Optional.empty();\n        }\n\n        if (valA.equals(valB)) {\n            return Optional.empty();\n        } else if (valA > valB) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private Double normalizeToDouble(Object obj) {\n        if (obj instanceof Number) {\n            return ((Number) obj).doubleValue();\n        } else if (obj instanceof String) {\n            String str = (String) obj;\n            // Replace commas with dots for consistent parsing\n            str = str.replace(',', '.');\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                // Handle invalid number format\n                return null;\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(sol.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(sol.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(sol.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "public boolean is_equal_to_sum_even(int n) {\n    // If n is less than 8, it cannot be the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n    \n    // If n is odd, it cannot be the sum of 4 even numbers\n    if (n % 2 != 0) {\n        return false;\n    }\n    \n    // Check if n can be expressed as the sum of 4 even numbers\n    for (int i = 2; i <= n / 4; i += 2) {\n        for (int j = 2; j <= n / 4; j += 2) {\n            for (int k = 2; k <= n / 4; k += 2) {\n                int l = n - i - j - k;\n                if (l > 0 && l % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the factorial of a given number.\n     * @param num The number to compute the factorial for.\n     * @return The factorial of the number.\n     */\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        long result = 1;\n        for (int i = 2; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    /**\n     * Computes the Brazilian factorial of a given number.\n     * @param n The number to compute the Brazilian factorial for.\n     * @return The Brazilian factorial of the number.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = n; i >= 1; i--) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.special_factorial(4)); // Output should be 288\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Step 1: Replace all single spaces with underscores\n        text = text.replace(\" \", \"_\");\n        \n        // Step 2: Replace sequences of more than two consecutive underscores with a single hyphen\n        text = text.replaceAll(\"_{2,}\", \"-\");\n        \n        return text;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\")); // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\")); // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\")); // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\")); // \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotIndex = file_name.indexOf('.');\n        if (dotIndex == -1 || dotIndex != file_name.lastIndexOf('.')) {\n            return \"No\";\n        }\n\n        // Split the file name into prefix and suffix\n        String prefix = file_name.substring(0, dotIndex);\n        String suffix = file_name.substring(dotIndex + 1);\n\n        // Check if the prefix is not empty and starts with a Latin alphabet letter\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check if the suffix is one of the allowed extensions\n        Set<String> allowedExtensions = new HashSet<>(Arrays.asList(\"txt\", \"exe\", \"dll\"));\n        if (!allowedExtensions.contains(suffix)) {\n            return \"No\";\n        }\n\n        // Count the digits in the prefix\n        int digitCount = 0;\n        for (char c : prefix.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n                if (digitCount > 3) {\n                    return \"No\";\n                }\n            }\n        }\n\n        // If all conditions are met, return \"Yes\"\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.file_name_check(\"example.txt\")); // => \"Yes\"\n        System.out.println(solution.file_name_check(\"1example.dll\")); // => \"No\"\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int value = lst.get(i);\n            \n            if (i % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                value = value * value;\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the value if index is a multiple of 4 but not a multiple of 3\n                value = value * value * value;\n            }\n            \n            // Add the transformed value to the sum\n            sum += value;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(sol.sum_squares(lst1)); // Output: 6\n        \n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(sol.sum_squares(lst2)); // Output: 0\n        \n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(sol.sum_squares(lst3)); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to collect the words with prime length\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Check if the length of the word is a prime number\n            if (isPrime(word.length())) {\n                // Append the word to the result\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        // Return the resulting string\n        return result.toString();\n    }\n    \n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(sol.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the input fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n        \n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n        \n        // Compute the product of the two fractions\n        int numeratorProduct = numeratorX * numeratorN;\n        int denominatorProduct = denominatorX * denominatorN;\n        \n        // Simplify the resulting fraction\n        int gcd = gcd(numeratorProduct, denominatorProduct);\n        numeratorProduct /= gcd;\n        denominatorProduct /= gcd;\n        \n        // Check if the simplified fraction is a whole number\n        return denominatorProduct == 1;\n    }\n    \n    // Helper method to compute the greatest common divisor (GCD) using Euclidean algorithm\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(sol.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(sol.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (original number, sum of digits)\n        List<Pair> pairs = new ArrayList<>();\n        \n        for (int num : nums) {\n            pairs.add(new Pair(num, sumOfDigits(num)));\n        }\n        \n        // Sort the list of pairs based on the sum of digits\n        Collections.sort(pairs, Comparator.comparingInt(Pair::getSumOfDigits));\n        \n        // Extract the sorted numbers from the pairs\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.getNum());\n        }\n        \n        return sortedNums;\n    }\n    \n    // Helper method to calculate the sum of digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n        \n        while (num > 0) {\n            int digit = num % 10;\n            sum += digit;\n            num /= 10;\n        }\n        \n        // If the number was negative, the first digit should be negative\n        if (isNegative) {\n            sum = -sum;\n        }\n        \n        return sum;\n    }\n    \n    // Helper class to store the original number and its sum of digits\n    private static class Pair {\n        private final int num;\n        private final int sumOfDigits;\n        \n        public Pair(int num, int sumOfDigits) {\n            this.num = num;\n            this.sumOfDigits = sumOfDigits;\n        }\n        \n        public int getNum() {\n            return num;\n        }\n        \n        public int getSumOfDigits() {\n            return sumOfDigits;\n        }\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an array of numbers as input and returns\n    the number of elements in the array that are greater than 10 and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n    specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        \n        for (int num : nums) {\n            if (num > 10) {\n                int absNum = Math.abs(num);\n                int lastDigit = absNum % 10;\n                \n                // Extract the first digit\n                while (absNum >= 10) {\n                    absNum /= 10;\n                }\n                int firstDigit = absNum;\n                \n                // Check if both first and last digits are odd\n                if (firstDigit % 2 == 1 && lastDigit % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Generate the array a\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Step 2: Count the valid triples\n        int count = 0;\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Step 3: Return the count of valid triples\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_max_triples(5)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    );\n\n    public List<String> bf(String planet1, String planet2) {\n        // Validate the input planets\n        if (!PLANETS.contains(planet1) || !PLANETS.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        // Get the indices of the planets\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for the range to be valid\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Extract the planets between index1 and index2 (exclusive)\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\")); // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\")); // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Step 2: Sort the filtered list\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                // First, compare by length\n                int lengthCompare = Integer.compare(s1.length(), s2.length());\n                if (lengthCompare != 0) {\n                    return lengthCompare;\n                }\n                // If lengths are the same, compare alphabetically\n                return s1.compareTo(s2);\n            }\n        });\n\n        // Step 3: Return the sorted list\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        List<String> result1 = solution.sorted_list_sum(test1);\n        System.out.println(result1); // Output: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        List<String> result2 = solution.sorted_list_sum(test2);\n        System.out.println(result2); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        // Edge case: numbers less than 2 are not prime\n        if (n < 2) {\n            return y;\n        }\n        \n        // Check for divisibility from 2 to sqrt(n)\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return y; // n is not prime\n            }\n        }\n        \n        // If no divisors found, n is prime\n        return x;\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n        \n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num;\n                }\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through both lists\n        for (int i = 0; i < game.size(); i++) {\n            int gameScore = game.get(i);\n            int guessScore = guess.get(i);\n            \n            // Compare the scores\n            if (gameScore == guessScore) {\n                result.add(0);\n            } else {\n                result.add(Math.abs(gameScore - guessScore));\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2))); // [0, 0, 0, 0, 3, 3]\n        System.out.println(solution.compare(Arrays.asList(0, 5, 0, 0, 0, 4), Arrays.asList(4, 1, 1, 0, 0, -2))); // [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            int capCount = 0;\n            int smCount = 0;\n\n            // Count the number of uppercase and lowercase letters\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    capCount++;\n                } else if (Character.isLowerCase(c)) {\n                    smCount++;\n                }\n            }\n\n            // Calculate the strength of the extension\n            int strength = capCount - smCount;\n\n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Output: \"Slices.SErviNGSliCes\"\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Output: \"my_class.AA\"\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate b with itself to generate all rotations\n        String concatenated = b + b;\n        \n        // Check if a is a substring of the concatenated string\n        return concatenated.contains(a);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(sol.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(sol.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(sol.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(sol.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(sol.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer, return a list that has the number of even and odd digits respectively.\n    \n     Example:\n        even_odd_count(-12) ==> [1, 1]\n        even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to its absolute value to handle negative numbers\n        num = Math.abs(num);\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Loop through each digit of the number\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                evenCount++; // Increment even count if the digit is even\n            } else {\n                oddCount++; // Increment odd count if the digit is odd\n            }\n            num /= 10; // Remove the last digit\n        }\n        \n        // Return the counts as a list\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.even_odd_count(-12)); // Output: [1, 1]\n        System.out.println(solution.even_odd_count(123)); // Output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n        StringBuilder roman = new StringBuilder();\n        \n        // Iterate through the values and symbols\n        for (int i = 0; i < values.length; i++) {\n            // While the current value can fit into the number\n            while (number >= values[i]) {\n                // Subtract the value from the number\n                number -= values[i];\n                // Append the corresponding symbol to the result\n                roman.append(symbols[i]);\n            }\n        }\n        \n        // Convert the result to lowercase\n        return roman.toString().toLowerCase();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(sol.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(sol.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Identify the longest side\n        int maxSide = Math.max(a, Math.max(b, c));\n        \n        // Check if the triangle is right-angled using the Pythagorean theorem\n        if (maxSide == a) {\n            return a * a == b * b + c * c;\n        } else if (maxSide == b) {\n            return b * b == a * a + c * c;\n        } else {\n            return c * c == a * a + b * b;\n        }\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            // Use a HashSet to count unique characters in the word\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            int uniqueCount = uniqueChars.size();\n\n            // Check if the current word has more unique characters\n            // or if it has the same number but is lexicographically smaller\n            if (uniqueCount > maxUniqueChars || (uniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))); // \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots eaten\n        int totalEaten = number + need;\n        \n        // Determine the number of carrots left\n        int carrotsLeft;\n        if (remaining <= need) {\n            carrotsLeft = 0; // All remaining carrots are eaten\n        } else {\n            carrotsLeft = remaining - need; // Some carrots are left\n        }\n        \n        // Return the result as a list\n        return Arrays.asList(totalEaten, carrotsLeft);\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a list to hold the expression in postfix notation\n        List<Object> postfix = new ArrayList<>();\n        Stack<String> opStack = new Stack<>();\n\n        // Convert the infix expression to postfix notation\n        for (int i = 0; i < operator.size(); i++) {\n            postfix.add(operand.get(i));\n            while (!opStack.isEmpty() && hasHigherPrecedence(opStack.peek(), operator.get(i))) {\n                postfix.add(opStack.pop());\n            }\n            opStack.push(operator.get(i));\n        }\n        postfix.add(operand.get(operand.size() - 1));\n        while (!opStack.isEmpty()) {\n            postfix.add(opStack.pop());\n        }\n\n        // Evaluate the postfix expression\n        Stack<Integer> evalStack = new Stack<>();\n        for (Object token : postfix) {\n            if (token instanceof Integer) {\n                evalStack.push((Integer) token);\n            } else {\n                int b = evalStack.pop();\n                int a = evalStack.pop();\n                String op = (String) token;\n                evalStack.push(applyOperation(a, b, op));\n            }\n        }\n\n        return evalStack.pop();\n    }\n\n    private boolean hasHigherPrecedence(String op1, String op2) {\n        if (op1.equals(\"**\")) return true;\n        if (op2.equals(\"**\")) return false;\n        if (op1.equals(\"*\") || op1.equals(\"/\")) return true;\n        if (op2.equals(\"*\") || op2.equals(\"/\")) return false;\n        return false; // For \"+\" and \"-\"\n    }\n\n    private int applyOperation(int a, int b, String op) {\n        switch (op) {\n            case \"+\":\n                return a + b;\n            case \"-\":\n                return a - b;\n            case \"*\":\n                return a * b;\n            case \"/\":\n                return a / b;\n            case \"**\":\n                return (int) Math.pow(a, b);\n            default:\n                throw new IllegalArgumentException(\"Invalid operator: \" + op);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        System.out.println(sol.do_algebra(operator, operand)); // Output: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean containsLetter = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                break;\n            }\n        }\n\n        // If the string contains no letters, reverse the string\n        if (!containsLetter) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // If the string contains letters, process each character\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Reverse the case of the letter\n                if (Character.isUpperCase(c)) {\n                    result.append(Character.toLowerCase(c));\n                } else {\n                    result.append(Character.toUpperCase(c));\n                }\n            } else {\n                // Keep non-letter characters as they are\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solve(\"1234\")); // Output: \"4321\"\n        System.out.println(sol.solve(\"ab\"));   // Output: \"AB\"\n        System.out.println(sol.solve(\"#a@C\")); // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Check if the input string is empty\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Create a MessageDigest instance for MD5\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        // Compute the MD5 hash of the input string\n        byte[] messageDigest = md.digest(text.getBytes());\n\n        // Convert the byte array to a BigInteger\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert the BigInteger to a hexadecimal string\n        String hashtext = no.toString(16);\n\n        // Pad the hexadecimal string with leading zeros if necessary\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        // Return the resulting string wrapped in an Optional\n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is less than or equal to b\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n        \n        // Set to store unique even digits\n        Set<Integer> evenDigits = new HashSet<>();\n        \n        // Iterate through the range [start, end]\n        for (int i = start; i <= end; i++) {\n            int num = i;\n            // Extract digits and check if they are even\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit % 2 == 0) {\n                    evenDigits.add(digit);\n                }\n                num /= 10;\n            }\n        }\n        \n        // Convert set to list and sort it\n        List<Integer> result = new ArrayList<>(evenDigits);\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(10, 14)); // []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Iterate through each pair of numbers in the list\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                // Calculate the absolute difference between the two numbers\n                double difference = Math.abs(numbers.get(i) - numbers.get(j));\n                // Check if the difference is less than the threshold\n                if (difference < threshold) {\n                    return true; // Found a pair of numbers closer than the threshold\n                }\n            }\n        }\n        return false; // No such pair found\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        paren_string = paren_string.replaceAll(\" \", \"\");\n        \n        List<String> result = new ArrayList<>();\n        Stack<Character> stack = new Stack<>();\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char ch : paren_string.toCharArray()) {\n            if (ch == '(') {\n                // Push the opening parenthesis onto the stack\n                stack.push(ch);\n            } else if (ch == ')') {\n                // Pop the corresponding opening parenthesis from the stack\n                stack.pop();\n            }\n            \n            // Append the current character to the current group\n            currentGroup.append(ch);\n            \n            // If the stack is empty, it means we have a balanced group\n            if (stack.isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Reset the StringBuilder for the next group\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.separate_paren_groups(\"( ) (( )) (( )( ))\")); // [\"()\", \"(())\", \"(()())\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n     */\n    public double truncate_number(double number) {\n        // Get the integer part of the number\n        int integerPart = (int) number;\n        \n        // Subtract the integer part from the original number to get the decimal part\n        double decimalPart = number - integerPart;\n        \n        return decimalPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5)); // Output: 0.5\n        System.out.println(solution.truncate_number(1.0)); // Output: 0.0\n        System.out.println(solution.truncate_number(0.75)); // Output: 0.75\n        System.out.println(solution.truncate_number(123.456)); // Output: 0.456\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Step 1: Calculate the mean of the dataset\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Compute the absolute differences between each element and the mean\n        double absoluteDeviationsSum = 0.0;\n        for (double number : numbers) {\n            absoluteDeviationsSum += Math.abs(number - mean);\n        }\n\n        // Step 3: Calculate the average of these absolute differences\n        double mad = absoluteDeviationsSum / numbers.size();\n\n        return mad;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(solution.mean_absolute_deviation(numbers)); // Output: 1.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // If the input list is empty, return an empty list\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n\n        // Iterate through the input list\n        for (int i = 0; i < numbers.size(); i++) {\n            // Add the current element to the result list\n            result.add(numbers.get(i));\n\n            // If it's not the last element, add the delimiter\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char ch : group.toCharArray()) {\n                if (ch == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (ch == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        \n        for (String str : strings) {\n            if (str.contains(substring)) {\n                result.add(str);\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum to 0 and product to 1\n        int sum = 0;\n        int product = 1;\n\n        // Iterate through the list to calculate sum and product\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        // If the list is empty, sum is already 0 and product is already 1\n        // Return the result as a list\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_product(List.of())); // [0, 1]\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize the current maximum to the smallest possible integer value\n        int currentMax = Integer.MIN_VALUE;\n        \n        // Iterate through the list of numbers\n        for (int number : numbers) {\n            // Update the current maximum if the current number is greater\n            if (number > currentMax) {\n                currentMax = number;\n            }\n            // Add the current maximum to the result list\n            result.add(currentMax);\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> result = solution.rolling_max(numbers);\n        System.out.println(result); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n     */\n    public String make_palindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        // Find the longest palindromic suffix\n        int n = string.length();\n        for (int i = 0; i < n; i++) {\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // Reverse the prefix and append it to the original string\n                String prefix = string.substring(0, i);\n                String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n                return string + reversedPrefix;\n            }\n        }\n\n        // If no palindromic suffix is found, reverse the entire string and append\n        String reversedString = new StringBuilder(string).reverse().toString();\n        return string + reversedString;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n     */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of the same length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Input strings must be of the same length\");\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each character of the strings\n        for (int i = 0; i < a.length(); i++) {\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n\n            // Perform XOR operation\n            if (charA == charB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Output: \"100\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = null;\n        int maxLength = 0;\n\n        for (String str : strings) {\n            if (str.length() > maxLength) {\n                maxLength = str.length();\n                longestString = str;\n            }\n        }\n\n        return Optional.ofNullable(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure that a is greater than or equal to b\n        if (b > a) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        // Apply the Euclidean algorithm\n        while (b != 0) {\n            int remainder = a % b;\n            a = b;\n            b = remainder;\n        }\n        \n        // The GCD is the non-zero value in 'a'\n        return a;\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.all_prefixes(\"abc\")); // Output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 0; i <= n; i++) {\n            sb.append(i).append(\" \");\n        }\n        \n        // Remove the trailing space\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - 1);\n        }\n        \n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to handle case insensitivity\n        string = string.toLowerCase();\n        \n        // Use a Set to store distinct characters\n        Set<Character> distinctCharacters = new HashSet<>();\n        \n        // Iterate through the string and add each character to the Set\n        for (char c : string.toCharArray()) {\n            distinctCharacters.add(c);\n        }\n        \n        // The size of the Set is the count of distinct characters\n        return distinctCharacters.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        // Initialize the list to store the beats\n        List<Integer> beatsList = new ArrayList<>();\n        \n        // Create a map to store the mapping of notes to beats\n        Map<String, Integer> noteToBeats = new HashMap<>();\n        noteToBeats.put(\"o\", 4);\n        noteToBeats.put(\"o|\", 2);\n        noteToBeats.put(\".|\", 1);\n        \n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Iterate through each note and add the corresponding beats to the list\n        for (String note : notes) {\n            beatsList.add(noteToBeats.get(note));\n        }\n        \n        // Return the list of beats\n        return beatsList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\"));\n        // Output should be: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n     */\n    public int how_many_times(String string, String substring) {\n        int count = 0;\n        int subLength = substring.length();\n        \n        // If the substring is empty, it should not match any non-empty string\n        if (subLength == 0) {\n            return 0;\n        }\n        \n        // Iterate through the string and check for the substring\n        for (int i = 0; i <= string.length() - subLength; i++) {\n            if (string.substring(i, i + subLength).equals(substring)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\")); // 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Step 1: Create a mapping from number words to their corresponding numerical values\n        Map<String, Integer> wordToNumber = new HashMap<>();\n        wordToNumber.put(\"zero\", 0);\n        wordToNumber.put(\"one\", 1);\n        wordToNumber.put(\"two\", 2);\n        wordToNumber.put(\"three\", 3);\n        wordToNumber.put(\"four\", 4);\n        wordToNumber.put(\"five\", 5);\n        wordToNumber.put(\"six\", 6);\n        wordToNumber.put(\"seven\", 7);\n        wordToNumber.put(\"eight\", 8);\n        wordToNumber.put(\"nine\", 9);\n\n        // Step 2: Split the input string into individual number words\n        String[] words = numbers.split(\" \");\n\n        // Step 3: Sort the words based on their corresponding numerical values\n        Arrays.sort(words, new Comparator<String>() {\n            @Override\n            public int compare(String word1, String word2) {\n                return wordToNumber.get(word1).compareTo(wordToNumber.get(word2));\n            }\n        });\n\n        // Step 4: Join the sorted words back into a single string\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\")); // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements\n        Collections.sort(numbers);\n        \n        // Initialize variables to keep track of the minimum difference and the closest elements\n        double minDifference = Double.MAX_VALUE;\n        double num1 = 0.0;\n        double num2 = 0.0;\n        \n        // Iterate through the sorted list to find the closest elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double currentDifference = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (currentDifference < minDifference) {\n                minDifference = currentDifference;\n                num1 = numbers.get(i);\n                num2 = numbers.get(i + 1);\n            }\n        }\n        \n        // Return the closest elements in a list\n        List<Double> result = new ArrayList<>();\n        result.add(Math.min(num1, num2));\n        result.add(Math.max(num1, num2));\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))); // [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Step 1: Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n        \n        // Step 2: Apply the linear transformation to each number\n        List<Double> rescaledList = new ArrayList<>();\n        for (Double number : numbers) {\n            double rescaledValue = (number - min) / (max - min);\n            rescaledList.add(rescaledValue);\n        }\n        \n        return rescaledList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        List<Double> rescaledNumbers = solution.rescale_to_unit(numbers);\n        System.out.println(rescaledNumbers); // Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1\n        for (int i = n - 1; i > 0; i--) {\n            // Check if i divides n evenly\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found (which should not happen for n > 1), return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_divisor(15)); // Output: 5\n        System.out.println(sol.largest_divisor(20)); // Output: 10\n        System.out.println(sol.largest_divisor(7));  // Output: 1\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until n is odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Divide by odd numbers starting from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));   // Output: [2, 2, 2]\n        System.out.println(solution.factorize(25));  // Output: [5, 5]\n        System.out.println(solution.factorize(70));  // Output: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Set to keep track of elements that have been seen\n        Set<Integer> seen = new HashSet<>();\n        // List to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the input list\n        for (Integer num : numbers) {\n            // If the element has not been seen before, add it to the result list and mark it as seen\n            if (!seen.contains(num)) {\n                result.add(num);\n                seen.add(num);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> output = solution.remove_duplicates(input);\n        System.out.println(output); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(c); // If it's not a letter, just append it as is\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.flip_case(\"Hello\")); // Output: \"hELLO\"\n        System.out.println(solution.flip_case(\"World\")); // Output: \"wORLD\"\n        System.out.println(solution.flip_case(\"Java\"));  // Output: \"jAVA\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        // Create a StringBuilder to efficiently concatenate strings\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through the list of strings and append each string to the StringBuilder\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix(List.of(), \"a\")\n    []\n    >>> filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(n -> n > 0)  // Filter out non-positive numbers\n                .collect(Collectors.toList());  // Collect the results into a list\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    false\n    >>> is_prime(101)\n    true\n    >>> is_prime(11)\n    true\n    >>> is_prime(13441)\n    true\n    >>> is_prime(61)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(1)\n    false\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime\n        }\n        \n        // Check for factors from 3 to sqrt(n)\n        int sqrt = (int) Math.sqrt(n);\n        for (int i = 3; i <= sqrt; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    return xs[1] + 2 * xs[2] * x + 3 * xs[3] * x^2 + .... n * xs[n] * x^(n-1)\n     */\n    public double polyDerivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> find_zero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> find_zero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double find_zero(List<Double> xs) {\n        double tolerance = 1e-7; // Tolerance for convergence\n        int maxIterations = 1000; // Maximum number of iterations to prevent infinite loops\n        double x0 = 0.0; // Initial guess\n        \n        for (int i = 0; i < maxIterations; i++) {\n            double fx = poly(xs, x0);\n            double dfx = polyDerivative(xs, x0);\n            \n            if (Math.abs(fx) < tolerance) {\n                return x0; // Converged to a root\n            }\n            \n            if (dfx == 0) {\n                throw new ArithmeticException(\"Derivative is zero. Newton-Raphson method failed.\");\n            }\n            \n            x0 = x0 - fx / dfx; // Newton-Raphson iteration\n        }\n        \n        throw new RuntimeException(\"Failed to converge to a root within the maximum number of iterations.\");\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Create a copy of the list to avoid modifying the original list\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Create a list to store the values at indices divisible by three\n        List<Integer> toSort = new ArrayList<>();\n        \n        // Iterate through the list and collect values at indices divisible by three\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                toSort.add(l.get(i));\n            }\n        }\n        \n        // Sort the collected values\n        Collections.sort(toSort);\n        \n        // Place the sorted values back into their respective positions\n        int index = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                result.set(i, toSort.get(index));\n                index++;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(sol.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Step 1: Convert the list to a Set to remove duplicates\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        \n        // Step 2: Convert the Set back to a List\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        \n        // Step 3: Sort the list\n        Collections.sort(uniqueList);\n        \n        // Step 4: Return the sorted list\n        return uniqueList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> inputList = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> result = solution.unique(inputList);\n        System.out.println(result); // Output: [0, 2, 3, 5, 9, 123]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int max_element(List<Integer> l) {\n        // Initialize the maximum element with the first element of the list\n        int max = l.get(0);\n        \n        // Iterate through the list starting from the second element\n        for (int i = 1; i < l.size(); i++) {\n            // Update the maximum element if the current element is greater\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        // Return the maximum element found\n        return max;\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numberStr = Integer.toString(i);\n                for (char c : numberStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fizz_buzz(50)); // Output: 0\n        System.out.println(sol.fizz_buzz(78)); // Output: 2\n        System.out.println(sol.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sort_even(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to store the sorted even indexed values\n        List<Integer> evenIndexedValues = new ArrayList<>();\n        \n        // Extract the values at even indices\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndexedValues.add(l.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndexedValues);\n        \n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace the even indexed values in the result list with the sorted values\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i += 2) {\n            result.set(i, evenIndexedValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n     */\n    public int prime_fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be a positive integer\");\n        }\n        \n        int count = 0;\n        int a = 1, b = 1; // Starting Fibonacci numbers\n        \n        while (true) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                count++;\n                if (count == n) {\n                    return fib;\n                }\n            }\n        }\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        if (num % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    true\n    >>> triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))\n    true\n    >>> triples_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to use the two-pointer technique\n        Collections.sort(l);\n        \n        // Iterate through the list\n        for (int i = 0; i < l.size() - 2; i++) {\n            // Use two pointers to find the other two elements\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true; // Found a triplet that sums to zero\n                } else if (sum < 0) {\n                    left++; // Move left pointer to increase the sum\n                } else {\n                    right--; // Move right pointer to decrease the sum\n                }\n            }\n        }\n        \n        return false; // No triplet found that sums to zero\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function outputs the number of collisions between two sets of cars.\n     */\n    public int car_race_collision(int n) {\n        return n * n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream()\n                .map(i -> i + 1)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairs_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) {\n            return \"0\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base;\n            result.append(remainder);\n            x = x / base;\n        }\n        \n        // The result is built in reverse order, so we need to reverse it\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // \"22\"\n        System.out.println(solution.change_base(8, 2)); // \"1000\"\n        System.out.println(solution.change_base(7, 2)); // \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n     */\n    public double triangle_area(double a, double h) {\n        // Calculate the area using the formula\n        double area = 0.5 * a * h;\n        return area;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array to store the last four computed values\n        int[] fib4Values = new int[4];\n        fib4Values[0] = 0; // fib4(0)\n        fib4Values[1] = 0; // fib4(1)\n        fib4Values[2] = 2; // fib4(2)\n        fib4Values[3] = 0; // fib4(3)\n\n        // Compute the sequence iteratively up to n\n        for (int i = 4; i <= n; i++) {\n            int nextValue = fib4Values[0] + fib4Values[1] + fib4Values[2] + fib4Values[3];\n            // Shift the values to the left\n            fib4Values[0] = fib4Values[1];\n            fib4Values[1] = fib4Values[2];\n            fib4Values[2] = fib4Values[3];\n            fib4Values[3] = nextValue;\n        }\n\n        // The result is the last computed value\n        return fib4Values[3];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    8.0\n     */\n    public double median(List<Integer> l) {\n        // Step 1: Sort the list\n        Collections.sort(l);\n\n        // Step 2: Determine the size of the list\n        int size = l.size();\n\n        // Step 3: Calculate the median\n        if (size % 2 == 1) {\n            // If the size is odd, return the middle element\n            return l.get(size / 2);\n        } else {\n            // If the size is even, return the average of the two middle elements\n            int mid1 = l.get(size / 2 - 1);\n            int mid2 = l.get(size / 2);\n            return (mid1 + mid2) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.median(Arrays.asList(3, 1, 2, 4, 5))); // 3\n        System.out.println(solution.median(Arrays.asList(-10, 4, 6, 1000, 10, 20))); // 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n     */\n    public boolean is_palindrome(String text) {\n        // An empty string is considered a palindrome\n        if (text.isEmpty()) {\n            return true;\n        }\n        \n        // Use two pointers to compare characters from the start and end of the string\n        int left = 0;\n        int right = text.length() - 1;\n        \n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n        // Base case: 2^0 % p = 1\n        if (n == 0) {\n            return 1;\n        }\n        \n        // Initialize result to 1\n        int result = 1;\n        int base = 2;\n        \n        // Iterate from 0 to n-1\n        for (int i = 0; i < n; i++) {\n            result = (result * base) % p;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.modp(3, 5));    // Output: 3\n        System.out.println(sol.modp(1101, 101)); // Output: 2\n        System.out.println(sol.modp(0, 101));  // Output: 1\n        System.out.println(sol.modp(3, 11));   // Output: 8\n        System.out.println(sol.modp(100, 101)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Calculate the new character by shifting back 5 positions\n            char decodedChar = (char) ('a' + ((ch - 5 - 'a' + 26) % 26));\n            sb.append(decodedChar);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test encoding\n        String original = \"hello\";\n        String encoded = sol.encodeShift(original);\n        System.out.println(\"Encoded: \" + encoded); // Output should be \"mjqqt\"\n        \n        // Test decoding\n        String decoded = sol.decode_shift(encoded);\n        System.out.println(\"Decoded: \" + decoded); // Output should be \"hello\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for quick lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Use a StringBuilder to construct the result string\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string\n        for (char c : text.toCharArray()) {\n            // If the character is not a vowel, append it to the result\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Adds two integers.\n     *\n     * @param x the first integer\n     * @param y the second integer\n     * @return the sum of x and y\n     * @example\n     * <pre>\n     * add(2, 3)  // returns 5\n     * add(5, 7)  // returns 12\n     * </pre>\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if two words have the same kind of characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create two HashMaps to store the frequency of characters in both strings\n        Map<Character, Integer> charCount0 = new HashMap<>();\n        Map<Character, Integer> charCount1 = new HashMap<>();\n\n        // Count the frequency of each character in the first string\n        for (char c : s0.toCharArray()) {\n            charCount0.put(c, charCount0.getOrDefault(c, 0) + 1);\n        }\n\n        // Count the frequency of each character in the second string\n        for (char c : s1.toCharArray()) {\n            charCount1.put(c, charCount1.getOrDefault(c, 0) + 1);\n        }\n\n        // Compare the two HashMaps\n        return charCount0.equals(charCount1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        \n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib(10)); // 55\n        System.out.println(solution.fib(1));  // 1\n        System.out.println(solution.fib(8));  // 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '<') {\n                stack.push(bracket);\n            } else if (bracket == '>') {\n                if (stack.isEmpty() || stack.pop() != '<') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"<\")); // false\n        System.out.println(solution.correct_bracketing(\"<>\")); // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) {\n            return true; // An empty list or a single element list is trivially monotonic\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        \n        // Find the intersection of the two sets\n        set1.retainAll(set2);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set1);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        int largestPrime = 1;\n        \n        // Check for the smallest prime factor, which is 2\n        while (n % 2 == 0) {\n            largestPrime = 2;\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 to sqrt(n)\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestPrime = i;\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then n itself is a prime number\n        if (n > 2) {\n            largestPrime = n;\n        }\n        \n        return largestPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_prime_factor(13195)); // Output: 29\n        System.out.println(sol.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Output: 465\n        System.out.println(solution.sum_to_n(100)); // Output: 5050\n        System.out.println(solution.sum_to_n(5));   // Output: 15\n        System.out.println(solution.sum_to_n(10));  // Output: 55\n        System.out.println(solution.sum_to_n(1));   // Output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                stack.push(ch);\n            } else if (ch == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\")); // false\n        System.out.println(solution.correct_bracketing(\"()\")); // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     * >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n     * [1, 4, 12, 20]\n     * >>> derivative(Arrays.asList(1, 2, 3))\n     * [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Start from the coefficient of x^1 (index 1)\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.derivative(Arrays.asList(3, 1, 2, 4, 5))); // [1, 4, 12, 20]\n        System.out.println(solution.derivative(Arrays.asList(1, 2, 3))); // [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n     */\n    public int fibfib(int n) {\n        // Base cases\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        // Initialize the first three FibFib numbers\n        int a = 0, b = 0, c = 1;\n        int result = 0;\n\n        // Compute the n-th FibFib number iteratively\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n     */\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle case insensitivity\n        s = s.toLowerCase();\n        \n        // Initialize the count of vowels\n        int count = 0;\n        \n        // Iterate through each character of the string\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            \n            // Check if the character is a vowel\n            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n                count++;\n            }\n            // Check if the character is 'y' and it is at the end of the string\n            else if (ch == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        \n        // Return the total count of vowels\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.vowels_count(\"abcde\")); // Output: 2\n        System.out.println(sol.vowels_count(\"ACEDY\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        int length = numStr.length();\n\n        // If shift is greater than or equal to the number of digits, return the reversed string\n        if (shift >= length) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n\n        // Perform the circular shift\n        String shiftedPart = numStr.substring(length - shift);\n        String remainingPart = numStr.substring(0, length - shift);\n        String result = shiftedPart + remainingPart;\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(solution.circular_shift(12345, 2)); // Output: \"45123\"\n        System.out.println(solution.circular_shift(12345, 5)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                sum += (int) ch;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.digitSum(\"\")); // 0\n        System.out.println(sol.digitSum(\"abAB\")); // 131\n        System.out.println(sol.digitSum(\"abcCd\")); // 67\n        System.out.println(sol.digitSum(\"helloE\")); // 69\n        System.out.println(sol.digitSum(\"woArBld\")); // 131\n        System.out.println(sol.digitSum(\"aAaaaXa\")); // 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Split the string by spaces to separate the words\n        String[] parts = s.split(\" \");\n        \n        // The number of apples is the first number in the string\n        int apples = Integer.parseInt(parts[0]);\n        \n        // The number of oranges is the third number in the string\n        int oranges = Integer.parseInt(parts[2]);\n        \n        // Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        \n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(sol.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Output: 2\n        System.out.println(sol.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(sol.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        // Initialize variables to store the smallest even value and its index\n        int minEvenValue = Integer.MAX_VALUE;\n        int minEvenIndex = -1;\n        \n        // Iterate through the list to find the smallest even value\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            \n            // Check if the current value is even\n            if (currentValue % 2 == 0) {\n                // If it's the first even value found or it's smaller than the current smallest even value\n                if (currentValue < minEvenValue) {\n                    minEvenValue = currentValue;\n                    minEvenIndex = i;\n                }\n            }\n        }\n        \n        // If no even value was found, return an empty list\n        if (minEvenIndex == -1) {\n            return new ArrayList<>();\n        }\n        \n        // Return the smallest even value and its index\n        List<Integer> result = new ArrayList<>();\n        result.add(minEvenValue);\n        result.add(minEvenIndex);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList())); // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Count the frequency of each integer in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Find the greatest integer that meets the criteria\n        int maxValidInteger = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            if (num > 0 && freq >= num) {\n                if (num > maxValidInteger) {\n                    maxValidInteger = num;\n                }\n            }\n        }\n\n        // Step 3: Return the result\n        return maxValidInteger;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Output: 2\n        System.out.println(sol.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Output: 3\n        System.out.println(sol.search(Arrays.asList(5, 5, 4, 4, 4))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list in ascending order\n        Collections.sort(lst);\n        \n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize two pointers: one for the start and one for the end\n        int start = 0;\n        int end = lst.size() - 1;\n        \n        // Alternate between picking elements from the start and the end\n        while (start <= end) {\n            if (start <= end) {\n                result.add(lst.get(start));\n                start++;\n            }\n            if (start <= end) {\n                result.add(lst.get(end));\n                end--;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // [1, 4, 2, 3]\n        System.out.println(sol.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // [5, 5, 5, 5]\n        System.out.println(sol.strange_sort_list(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round the area to 2 decimal places\n        area = Math.round(area * 100.0) / 100.0;\n        \n        return area;\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        List<Integer> reversedQ = new ArrayList<>(q);\n        Collections.reverse(reversedQ);\n        if (!q.equals(reversedQ)) {\n            return false;\n        }\n\n        // Calculate the sum of the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to the maximum weight\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n        \n        // Compare elements from the start and end moving towards the center\n        for (int i = 0; i < n / 2; i++) {\n            if (arr.get(i) != arr.get(n - 1 - i)) {\n                changes++;\n            }\n        }\n        \n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper function to calculate the total number of characters in a list of strings.\n     */\n    private int totalChars(List<String> lst) {\n        int total = 0;\n        for (String s : lst) {\n            total += s.length();\n        }\n        return total;\n    }\n\n    /**\n     * Function to compare two lists of strings based on the total number of characters.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int total1 = totalChars(lst1);\n        int total2 = totalChars(lst2);\n\n        if (total1 <= total2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.total_match(Arrays.asList(), Arrays.asList())); // []\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less then 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        // Generate all prime numbers less than 100\n        List<Integer> primes = generatePrimes(100);\n        \n        // Check all combinations of three primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + 1; j < primes.size(); j++) {\n                for (int k = j + 1; k < primes.size(); k++) {\n                    int product = primes.get(i) * primes.get(j) * primes.get(k);\n                    if (product == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Helper method to generate all prime numbers less than n using Sieve of Eratosthenes\n    private List<Integer> generatePrimes(int n) {\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_multiply_prime(30)); // true\n        System.out.println(sol.is_multiply_prime(27)); // false\n        System.out.println(sol.is_multiply_prime(385)); // true (5 * 7 * 11)\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        // If x is 1, it is always a power of any n (except n=0, but we assume n > 0)\n        if (x == 1) {\n            return n == 1;\n        }\n        \n        // If n is 1, the only power of 1 is 1 itself, so x must be 1\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        // Check if x is a power of n\n        while (x % n == 0) {\n            x /= n;\n        }\n        \n        // If x becomes 1, it means x was a power of n\n        return x == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_simple_power(1, 4)); // true\n        System.out.println(sol.is_simple_power(2, 2)); // true\n        System.out.println(sol.is_simple_power(8, 2)); // true\n        System.out.println(sol.is_simple_power(3, 2)); // false\n        System.out.println(sol.is_simple_power(3, 1)); // false\n        System.out.println(sol.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean iscube(int a) {\n        // Calculate the cube root of a\n        double cubeRoot = Math.cbrt(a);\n        \n        // Check if the cube root is an integer\n        int intCubeRoot = (int) cubeRoot;\n        \n        // Check if cubing the integer cube root gives back the original number\n        return intCubeRoot * intCubeRoot * intCubeRoot == a;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.iscube(1));   // true\n        System.out.println(sol.iscube(2));   // false\n        System.out.println(sol.iscube(-1));  // true\n        System.out.println(sol.iscube(64));  // true\n        System.out.println(sol.iscube(0));   // true\n        System.out.println(sol.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // Define the set of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize the count of prime digits\n        int count = 0;\n        \n        // Iterate through each character in the input string\n        for (char c : num.toCharArray()) {\n            // If the character is in the set of prime hexadecimal digits, increment the count\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        // Return the final count\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.hex_key(\"AB\")); // Output: 1\n        System.out.println(sol.hex_key(\"1077E\")); // Output: 2\n        System.out.println(sol.hex_key(\"ABED1A33\")); // Output: 4\n        System.out.println(sol.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(sol.hex_key(\"2020\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Wrap the binary string with 'db' at the beginning and end\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Output: \"db100000db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) {\n            return false;\n        }\n\n        // Iterate through the string and check every set of 3 consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // Check if all three characters are distinct\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n\n        // If all sets of 3 consecutive characters are distinct, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_happy(\"a\")); // false\n        System.out.println(solution.is_happy(\"aa\")); // false\n        System.out.println(solution.is_happy(\"abcd\")); // true\n        System.out.println(solution.is_happy(\"aabb\")); // false\n        System.out.println(solution.is_happy(\"adb\")); // true\n        System.out.println(solution.is_happy(\"xyy\")); // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> letterGrades = solution.numerical_letter_grade(grades);\n        System.out.println(letterGrades); // Output: [A+, B+, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    prime_length(\"Hello\") == true\n    prime_length(\"abcdcba\") == true\n    prime_length(\"kittens\") == true\n    prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // Special case: For a single-digit number, only 1 starts and ends with 1.\n            return 1;\n        }\n        // Calculate the total count using the formula derived above\n        return (int) (Math.pow(10, n-1) + Math.pow(10, n-1) - Math.pow(10, n-2));\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(int N) {\n        // Step 1: Calculate the sum of digits of N\n        int sumOfDigits = 0;\n        int temp = N;\n        \n        while (temp > 0) {\n            sumOfDigits += temp % 10; // Add the last digit to the sum\n            temp /= 10; // Remove the last digit\n        }\n        \n        // Step 2: Convert the sum of digits to binary\n        String binarySum = Integer.toBinaryString(sumOfDigits);\n        \n        // Step 3: Return the binary string\n        return binarySum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.solve(1000)); // Output: \"1\"\n        System.out.println(sol.solve(150));  // Output: \"110\"\n        System.out.println(sol.solve(147));  // Output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int total = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                total += lst.get(i);\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string into words\n        String[] words = s.split(\" \");\n        \n        // Process each word\n        for (int i = 0; i < words.length; i++) {\n            // Convert the word to a character array\n            char[] chars = words[i].toCharArray();\n            \n            // Sort the character array\n            Arrays.sort(chars);\n            \n            // Convert the sorted character array back to a string\n            words[i] = new String(chars);\n        }\n        \n        // Join the processed words back into a single string with spaces\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.anti_shuffle(\"Hi\")); // Output: \"Hi\"\n        System.out.println(sol.anti_shuffle(\"hello\")); // Output: \"ehllo\"\n        System.out.println(sol.anti_shuffle(\"Hello World!!!\")); // Output: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Traverse the nested list to find occurrences of x\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        \n        // Sort the coordinates\n        coordinates.sort((a, b) -> {\n            // First, compare by row (ascending)\n            int rowComparison = a.get(0).compareTo(b.get(0));\n            if (rowComparison != 0) {\n                return rowComparison;\n            }\n            // If rows are the same, compare by column (descending)\n            return b.get(1).compareTo(a.get(1));\n        });\n        \n        return coordinates;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        \n        List<List<Integer>> lst2 = Arrays.asList();\n        System.out.println(solution.get_row(lst2, 1)); // []\n        \n        List<List<Integer>> lst3 = Arrays.asList(\n            Arrays.asList(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the array is empty or has only one element\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Calculate the sum of the first and last elements\n        int firstElement = array.get(0);\n        int lastElement = array.get(array.size() - 1);\n        int sum = firstElement + lastElement;\n\n        // Create a copy of the array to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Sort the array based on the sum\n        if (sum % 2 == 0) {\n            // Sort in descending order if the sum is even\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            // Sort in ascending order if the sum is odd\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            // Shift the character by 4 places\n            char newChar = (char) (c + 4);\n            \n            // If the new character goes past 'z', wrap around\n            if (newChar > 'z') {\n                newChar = (char) (newChar - 26);\n            }\n            \n            // Append the new character to the result\n            encrypted.append(newChar);\n        }\n        \n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(sol.encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(sol.encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(sol.encrypt(\"et\")); // Output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * Returns null if there is no such element.\n     * \n     * @param lst The list of integers.\n     * @return Optional containing the 2nd smallest element or empty if not found.\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        int smallest = Integer.MAX_VALUE;\n        int secondSmallest = Integer.MAX_VALUE;\n\n        for (int num : lst) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num < secondSmallest && num != smallest) {\n                secondSmallest = num;\n            }\n        }\n\n        return secondSmallest == Integer.MAX_VALUE ? Optional.empty() : Optional.of(secondSmallest);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList())); // Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1))); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n     */\n    public int is_bored(String S) {\n        // Split the string into sentences using the delimiters '.', '?', and '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim any leading or trailing whitespace\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (sentence.startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\")); // Output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n        System.out.println(solution.is_bored(\"I am bored. I need something to do! I think I will go for a walk?\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all three objects are instances of Integer\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n            \n            // Check if one of the numbers is equal to the sum of the other two\n            if (a == b + c || b == a + c || c == a + b) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a message, and encodes in such a\n    way that it swaps case of all letters, replaces all vowels in\n    the message with the letter that appears 2 places ahead of that\n    vowel in the english alphabet.\n    Assume only letters.\n\n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead\n                if (\"aeiouAEIOU\".indexOf(swappedCaseChar) != -1) {\n                    char base = Character.isUpperCase(swappedCaseChar) ? 'A' : 'a';\n                    swappedCaseChar = (char) (base + (swappedCaseChar - base + 2) % 26);\n                }\n                \n                encodedMessage.append(swappedCaseChar);\n            } else {\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encode(\"test\")); // \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to check if a number is prime.\n     * @param num The number to check.\n     * @return True if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Helper method to sum the digits of a number.\n     * @param num The number whose digits are to be summed.\n     * @return The sum of the digits of the number.\n     */\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Method to find the largest prime value in the list and return the sum of its digits.\n     * @param lst The list of integers.\n     * @return The sum of the digits of the largest prime in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        int largestPrime = -1;\n        \n        // Find the largest prime in the list\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n        \n        // If no prime was found, return 0 (or handle it as needed)\n        if (largestPrime == -1) {\n            return 0;\n        }\n        \n        // Return the sum of the digits of the largest prime\n        return sumOfDigits(largestPrime);\n    }\n}\n\npublic class Java94 {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(solution.skjkasdkd(lst1)); // Output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(solution.skjkasdkd(lst2)); // Output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(solution.skjkasdkd(lst3)); // Output: 13\n        \n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(solution.skjkasdkd(lst4)); // Output: 11\n        \n        List<Integer> lst5 = Arrays.asList(0, 1, 2, 3, 4, 5);\n        System.out.println(solution.skjkasdkd(lst5)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False if the given map is empty.\n     * Examples:\n     * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n     * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n     * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n     * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n     * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the map is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        // Iterate through the keys in the map\n        for (Object key : dict.keySet()) {\n            // Check if the key is a string\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            // Cast the key to a string\n            String strKey = (String) key;\n\n            // Check if the key is in lower case or upper case\n            if (!strKey.equals(strKey.toLowerCase()) && !strKey.equals(strKey.toUpperCase())) {\n                return false;\n            }\n        }\n\n        // If all checks pass, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"a\", \"apple\");\n        map1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(map1)); // Should return True\n\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"a\", \"apple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(map2)); // Should return False\n\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"a\", \"apple\");\n        map3.put(8, \"banana\");\n        map3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(map3)); // Should return False\n\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n        System.out.println(solution.check_dict_case(map4)); // Should return False\n\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(map5)); // Should return True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        if (n <= 2) {\n            return primes; // No primes less than 2\n        }\n        \n        // Step 1: Initialize a boolean array where index represents the number\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        \n        // 0 and 1 are not prime numbers\n        isPrime[0] = false;\n        isPrime[1] = false;\n        \n        // Step 2: Mark non-prime numbers\n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Step 3: Collect prime numbers\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.count_up_to(5));  // Output: [2, 3]\n        System.out.println(sol.count_up_to(11)); // Output: [2, 3, 5, 7]\n        System.out.println(sol.count_up_to(0));  // Output: []\n        System.out.println(sol.count_up_to(20)); // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(sol.count_up_to(1));  // Output: []\n        System.out.println(sol.count_up_to(18)); // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digit of 'a'\n        int unitDigitA = Math.abs(a) % 10;\n        \n        // Extract the unit digit of 'b'\n        int unitDigitB = Math.abs(b) % 10;\n        \n        // Multiply the unit digits\n        int result = unitDigitA * unitDigitB;\n        \n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        \n        // Iterate through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            // Check if the character is an uppercase vowel\n            if (uppercaseVowels.contains(ch)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_upper(\"aBCdEf\")); // Output: 1\n        System.out.println(sol.count_upper(\"abcdefg\")); // Output: 0\n        System.out.println(sol.count_upper(\"dBBE\")); // Output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        // Parse the string to a double\n        double number = Double.parseDouble(value);\n        \n        // Check if the number is exactly halfway between two integers\n        if (number % 1 == 0.5) {\n            // If the number is positive, round up\n            if (number > 0) {\n                return (int) Math.ceil(number);\n            }\n            // If the number is negative, round down\n            else {\n                return (int) Math.floor(number);\n            }\n        } else {\n            // For other cases, use standard rounding\n            return (int) Math.round(number);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.closest_integer(\"10\"));    // Output: 10\n        System.out.println(sol.closest_integer(\"15.3\"));  // Output: 15\n        System.out.println(sol.closest_integer(\"14.5\"));  // Output: 15\n        System.out.println(sol.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int current = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            current += 2; // Increment by 2 for the next level\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.make_a_pile(3)); // Output: [3, 5, 7]\n        System.out.println(sol.make_a_pile(4)); // Output: [4, 6, 8, 10]\n        System.out.println(sol.make_a_pile(1)); // Output: [1]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     */\n    public List<String> words_string(String s) {\n        // Split the string using the regular expression [,\\\\s]+\n        String[] wordsArray = s.split(\"[,\\\\s]+\");\n        \n        // Convert the array to a list and return it\n        return Arrays.asList(wordsArray);\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure the range is valid\n        if (x > y) {\n            return -1;\n        }\n        \n        // Iterate from y down to x to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n        \n        // If no even number is found, return -1\n        return -1;\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Step 1: Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n        \n        // Step 2: Calculate the sum of integers from n to m\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        // Step 3: Compute the average\n        int count = m - n + 1;\n        double average = (double) sum / count;\n        \n        // Step 4: Round the average to the nearest integer\n        int roundedAverage = (int) Math.round(average);\n        \n        // Step 5: Convert the rounded average to binary\n        String binaryRepresentation = Integer.toBinaryString(roundedAverage);\n        \n        return binaryRepresentation;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.rounded_avg(1, 5)); // Output: \"11\"\n        System.out.println(sol.rounded_avg(7, 5)); // Output: -1\n        System.out.println(sol.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(sol.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x, return a sorted list of all\n     * elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     *\n     * For example:\n     * >>> unique_digits(Arrays.asList(15, 33, 1422, 1))\n     * [1, 15, 33]\n     * >>> unique_digits(Arrays.asList(152, 323, 1422, 10))\n     * []\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : x) {\n            if (!containsEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n    \n    private boolean containsEvenDigit(Integer num) {\n        String numStr = num.toString();\n        for (char ch : numStr.toCharArray()) {\n            if (isEvenDigit(ch)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private boolean isEvenDigit(char ch) {\n        return ch == '0' || ch == '2' || ch == '4' || ch == '6' || ch == '8';\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.unique_digits(Arrays.asList(15, 33, 1422, 1))); // [1, 15, 33]\n        System.out.println(sol.unique_digits(Arrays.asList(152, 323, 1422, 10))); // []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter and sort the array\n        List<Integer> filteredAndSorted = arr.stream()\n                                             .filter(num -> num >= 1 && num <= 9)\n                                             .sorted()\n                                             .collect(Collectors.toList());\n        \n        // Step 2: Reverse the sorted array\n        Collections.reverse(filteredAndSorted);\n        \n        // Step 3: Map each digit to its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredAndSorted) {\n            result.add(getNumberName(num));\n        }\n        \n        return result;\n    }\n    \n    private String getNumberName(int num) {\n        switch (num) {\n            case 1: return \"One\";\n            case 2: return \"Two\";\n            case 3: return \"Three\";\n            case 4: return \"Four\";\n            case 5: return \"Five\";\n            case 6: return \"Six\";\n            case 7: return \"Seven\";\n            case 8: return \"Eight\";\n            case 9: return \"Nine\";\n            default: throw new IllegalArgumentException(\"Number out of range: \" + num);\n        }\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Compute factorial of i\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Compute sum of numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.f(5)); // Output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n        \n        return Arrays.asList(evenCount, oddCount);\n    }\n    \n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int len = str.length();\n        \n        for (int i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - 1 - i)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(sol.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     * >>> count_nums(Arrays.asList()) == 0\n     * >>> count_nums(Arrays.asList(-1, 11, -11)) == 1\n     * >>> count_nums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            int sumOfDigits = 0;\n            int absNum = Math.abs(num);\n            \n            // Calculate the sum of digits for the absolute value\n            while (absNum > 0) {\n                sumOfDigits += absNum % 10;\n                absNum /= 10;\n            }\n            \n            // Adjust for the sign of the original number\n            if (num < 0) {\n                sumOfDigits = -sumOfDigits;\n            }\n            \n            // Check if the sum of digits is greater than 0\n            if (sumOfDigits > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(sol.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(sol.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        int breakPoint = -1;\n\n        // Find the break point\n        for (int i = 0; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                breakPoint = i + 1;\n                break;\n            }\n        }\n\n        // If no break point found, the array is already sorted\n        if (breakPoint == -1) {\n            return true;\n        }\n\n        // Check if the array can be sorted by right shifts\n        for (int i = breakPoint; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                return false;\n            }\n        }\n\n        // Check the last element with the first element\n        return arr.get(n - 1) <= arr.get(0);\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count the number of odd elements in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        // Count the number of even elements in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // Check if we have enough even elements in lst2 to replace all odd elements in lst1\n        if (evenCountInLst2 >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // \"YES\"\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Step 1: Split the input string into individual letters\n        String[] letters = test.split(\" \");\n        \n        // Step 2: Count the frequency of each letter using a HashMap\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String letter : letters) {\n            frequencyMap.put(letter, frequencyMap.getOrDefault(letter, 0) + 1);\n        }\n        \n        // Step 3: Determine the maximum frequency\n        int maxFrequency = 0;\n        for (int frequency : frequencyMap.values()) {\n            if (frequency > maxFrequency) {\n                maxFrequency = frequency;\n            }\n        }\n        \n        // Step 4: Collect letters with the maximum frequency\n        Map<String, Integer> resultMap = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() == maxFrequency) {\n                resultMap.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        // Step 5: Return the result map\n        return resultMap;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Task\n     * We are given two strings s and c, you have to delete all the characters in s that are equal to any character in c\n     * then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     * Example\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set of characters to be deleted for quick lookup\n        Set<Character> charsToDelete = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToDelete.add(ch);\n        }\n\n        // StringBuilder to construct the resulting string\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToDelete.contains(ch)) {\n                result.append(ch);\n            }\n        }\n\n        // Convert the result to a string\n        String resultString = result.toString();\n\n        // Check if the result string is a palindrome\n        boolean isPalindrome = true;\n        int len = resultString.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (resultString.charAt(i) != resultString.charAt(len - i - 1)) {\n                isPalindrome = false;\n                break;\n            }\n        }\n\n        // Return the result as a list containing the string and the boolean\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n        return resultList;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.reverse_delete(\"abcde\", \"ae\")); // [\"bcd\", false]\n        System.out.println(sol.reverse_delete(\"abcdef\", \"b\")); // [\"acdef\", false]\n        System.out.println(sol.reverse_delete(\"abcdedcba\", \"ab\")); // [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n            int oddCount = 0;\n            \n            // Count the number of odd digits in the current string\n            for (char ch : str.toCharArray()) {\n                if (Character.isDigit(ch) && (ch - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            \n            // Construct the output string\n            String output = String.format(\"the number of odd elements %dn the str%dng %d of the %dnput.\", oddCount, oddCount, oddCount, oddCount);\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.odd_count(Arrays.asList(\"1234567\")));\n        // Expected output: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        System.out.println(sol.odd_count(Arrays.asList(\"3\", \"11111111\")));\n        // Expected output: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list must not be null or empty\");\n        }\n\n        int currentMin = nums.get(0);\n        int minSum = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            minSum = Math.min(minSum, currentMin);\n        }\n\n        return minSum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Output: 1\n        System.out.println(sol.minSubArraySum(Arrays.asList(-1, -2, -3))); // Output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalBucketsLowered = 0;\n        \n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n            for (int cell : row) {\n                if (cell == 1) {\n                    waterUnits++;\n                }\n            }\n            // Calculate the number of times the bucket needs to be lowered\n            int timesLowered = (waterUnits + capacity - 1) / capacity; // This is equivalent to Math.ceil(waterUnits / (double)capacity)\n            totalBucketsLowered += timesLowered;\n        }\n        \n        return totalBucketsLowered;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(sol.max_fill(grid1, capacity1)); // Output: 6\n        \n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(sol.max_fill(grid2, capacity2)); // Output: 5\n        \n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(sol.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation in ascending order.\n     * For similar number of ones, sorts based on decimal value.\n     * \n     * @param arr The list of integers to be sorted.\n     * @return The sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort the array using a custom comparator\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                // Count the number of ones in the binary representation of a and b\n                int countA = Integer.bitCount(a);\n                int countB = Integer.bitCount(b);\n                \n                // If the number of ones is different, sort by the number of ones\n                if (countA != countB) {\n                    return Integer.compare(countA, countB);\n                }\n                \n                // If the number of ones is the same, sort by the decimal value\n                return Integer.compare(a, b);\n            }\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))); // true\n        System.out.println(solution.sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))); // true\n        System.out.println(solution.sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))); // true\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // List to store the result\n        List<String> result = new ArrayList<>();\n        \n        // If the input string is empty, return the empty list\n        if (s.isEmpty()) {\n            return result;\n        }\n        \n        // Split the string into words\n        String[] words = s.split(\" \");\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Count the number of consonants in the word\n            int consonantCount = countConsonants(word);\n            \n            // If the consonant count matches n, add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n    \n    // Helper method to count consonants in a word\n    private int countConsonants(String word) {\n        int count = 0;\n        // Convert the word to lowercase to handle case insensitivity\n        word = word.toLowerCase();\n        \n        // Iterate through each character in the word\n        for (char c : word.toCharArray()) {\n            // Check if the character is a consonant\n            if (isConsonant(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    // Helper method to check if a character is a consonant\n    private boolean isConsonant(char c) {\n        // Define the set of vowels\n        String vowels = \"aeiou\";\n        \n        // Check if the character is a letter and not a vowel\n        return Character.isLetter(c) && vowels.indexOf(c) == -1;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        // Define the set of vowels (case sensitive)\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Traverse the word from right to left\n        for (int i = word.length() - 2; i > 0; i--) {\n            char currentChar = word.charAt(i);\n            // Check if the current character is a vowel\n            if (vowels.contains(currentChar)) {\n                // Check if the previous and next characters are consonants\n                char prevChar = word.charAt(i - 1);\n                char nextChar = word.charAt(i + 1);\n                if (!vowels.contains(prevChar) && !vowels.contains(nextChar)) {\n                    return String.valueOf(currentChar);\n                }\n            }\n        }\n        \n        // If no such vowel is found, return an empty string\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_closest_vowel(\"yogurt\")); // \"u\"\n        System.out.println(sol.get_closest_vowel(\"FULL\"));   // \"U\"\n        System.out.println(sol.get_closest_vowel(\"quick\"));  // \"\"\n        System.out.println(sol.get_closest_vowel(\"ab\"));     // \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int openCount1 = 0, closeCount1 = 0;\n        int openCount2 = 0, closeCount2 = 0;\n\n        // Count parentheses in the first string\n        for (char c : lst.get(0).toCharArray()) {\n            if (c == '(') {\n                openCount1++;\n            } else if (c == ')') {\n                closeCount1++;\n            }\n        }\n\n        // Count parentheses in the second string\n        for (char c : lst.get(1).toCharArray()) {\n            if (c == '(') {\n                openCount2++;\n            } else if (c == ')') {\n                closeCount2++;\n            }\n        }\n\n        // Total counts\n        int totalOpen = openCount1 + openCount2;\n        int totalClose = closeCount1 + closeCount2;\n\n        // Check if the total number of opening and closing parentheses match\n        if (totalOpen == totalClose) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.match_parens(Arrays.asList(\"()(\", \")\"))); // Output: \"Yes\"\n        System.out.println(sol.match_parens(Arrays.asList(\")\", \")\"))); // Output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in ascending order\n        Collections.sort(arr);\n        \n        // Step 2: Select the top k elements from the sorted array\n        List<Integer> result = new ArrayList<>();\n        for (int i = arr.size() - k; i < arr.size(); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Step 3: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3)); // Output: [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2)); // Output: [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0) { // Check if the index is even\n                if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                    sum += lst.get(i);\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        \n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            int num = arr.get(i);\n            \n            // Check if the number has at most two digits\n            if (num >= 0 && num <= 99) {\n                sum += num;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        \n        int result = sol.add_elements(arr, k);\n        System.out.println(result); // Output should be 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddNumbers = new ArrayList<>();\n        \n        // Start with the given number n\n        while (n != 1) {\n            if (n % 2 != 0) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            // Compute the next number in the sequence\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n        }\n        \n        // Add 1 to the list as it is always the last number in the sequence\n        oddNumbers.add(1);\n        \n        // Sort the list in increasing order\n        Collections.sort(oddNumbers);\n        \n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_odd_collatz(5)); // Output: [1, 5]\n        System.out.println(sol.get_odd_collatz(1)); // Output: [1]\n        System.out.println(sol.get_odd_collatz(10)); // Output: [1, 5]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Validates a given date string and returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\n     *    And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\n     *    And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * @param date The date string to validate.\n     * @return true if the date is valid, false otherwise.\n     */\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Check if the date string is in the format \"mm-dd-yyyy\"\n        if (!date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) {\n            return false;\n        }\n\n        // Split the date string into month, day, and year\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Validate the month\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Validate the day based on the month\n        if (month == 2) {\n            // February can have 29 days in a leap year, otherwise 28\n            if (day < 1 || day > 29) {\n                return false;\n            }\n            // Check for leap year\n            if (day == 29 && !isLeapYear(year)) {\n                return false;\n            }\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            // April, June, September, November have 30 days\n            if (day < 1 || day > 30) {\n                return false;\n            }\n        } else {\n            // January, March, May, July, August, October, December have 31 days\n            if (day < 1 || day > 31) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    /**\n     * Helper method to check if a year is a leap year.\n     * @param year The year to check.\n     * @return true if the year is a leap year, false otherwise.\n     */\n    private boolean isLeapYear(int year) {\n        if (year % 4 == 0) {\n            if (year % 100 == 0) {\n                return year % 400 == 0;\n            }\n            return true;\n        }\n        return false;\n    }\n}\n\npublic class Java124 {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\"));\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        \n        // Check for commas\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        }\n        \n        // Count lowercase letters with odd positions in the alphabet\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c) && (c - 'a') % 2 != 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"abcdef\")); // 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If a number appears more than twice, return false. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted(Arrays.asList(5)) -> true\n    is_sorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n    is_sorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n    is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n    is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n    is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n    is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n    is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        int previous = lst.get(0);\n        frequencyMap.put(previous, 1);\n\n        for (int i = 1; i < lst.size(); i++) {\n            int current = lst.get(i);\n\n            // Check if the list is sorted\n            if (current < previous) {\n                return false;\n            }\n\n            // Update the frequency map\n            frequencyMap.put(current, frequencyMap.getOrDefault(current, 0) + 1);\n\n            // Check if any number appears more than twice\n            if (frequencyMap.get(current) > 2) {\n                return false;\n            }\n\n            previous = current;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        int intersectionStart = Math.max(start1, start2);\n        int intersectionEnd = Math.min(end1, end2);\n\n        if (intersectionStart <= intersectionEnd) {\n            int lengthOfIntersection = intersectionEnd - intersectionStart + 1;\n            if (isPrime(lengthOfIntersection)) {\n                return \"YES\";\n            }\n        }\n        return \"NO\";\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // \"NO\"\n        System.out.println(sol.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // \"NO\"\n        System.out.println(sol.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // \"YES\"\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int sumOfMagnitudes = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                signProduct = 0;\n                break;\n            } else if (num < 0) {\n                signProduct *= -1;\n            }\n            sumOfMagnitudes += Math.abs(num);\n        }\n\n        return Optional.of(sumOfMagnitudes * signProduct);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1))); // Output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList())); // Output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        List<Integer> minPath = null;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                List<Integer> path = bfs(grid, i, j, k);\n                if (minPath == null || comparePaths(path, minPath) < 0) {\n                    minPath = path;\n                }\n            }\n        }\n        \n        return minPath;\n    }\n    \n    private List<Integer> bfs(List<List<Integer>> grid, int startX, int startY, int k) {\n        int n = grid.size();\n        Queue<List<Integer>> queue = new LinkedList<>();\n        Queue<List<Integer>> paths = new LinkedList<>();\n        \n        queue.add(Arrays.asList(startX, startY));\n        paths.add(Arrays.asList(grid.get(startX).get(startY)));\n        \n        for (int step = 1; step < k; step++) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                List<Integer> current = queue.poll();\n                List<Integer> currentPath = paths.poll();\n                int x = current.get(0);\n                int y = current.get(1);\n                \n                int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n                for (int[] dir : directions) {\n                    int newX = x + dir[0];\n                    int newY = y + dir[1];\n                    \n                    if (newX >= 0 && newX < n && newY >= 0 && newY < n) {\n                        List<Integer> newPath = new ArrayList<>(currentPath);\n                        newPath.add(grid.get(newX).get(newY));\n                        queue.add(Arrays.asList(newX, newY));\n                        paths.add(newPath);\n                    }\n                }\n            }\n        }\n        \n        List<Integer> minPath = null;\n        while (!paths.isEmpty()) {\n            List<Integer> path = paths.poll();\n            if (minPath == null || comparePaths(path, minPath) < 0) {\n                minPath = path;\n            }\n        }\n        \n        return minPath;\n    }\n    \n    private int comparePaths(List<Integer> path1, List<Integer> path2) {\n        for (int i = 0; i < path1.size(); i++) {\n            if (path1.get(i) < path2.get(i)) {\n                return -1;\n            } else if (path1.get(i) > path2.get(i)) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Base case\n        result.add(3); // tri(1) = 3\n        \n        for (int i = 2; i <= n + 1; i++) {\n            if (i % 2 == 0) {\n                // Even case\n                result.add(1 + i / 2);\n            } else {\n                // Odd case\n                int tri_i_minus_1 = result.get(i - 2); // tri(i - 1)\n                int tri_i_minus_2 = result.get(i - 3); // tri(i - 2)\n                int tri_i_plus_1 = 1 + (i + 1) / 2; // tri(i + 1)\n                result.add(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.tri(3)); // Output: [3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Initialize the product to 1\n        int product = 1;\n        // Convert the number to a string to iterate through each digit\n        String numStr = Integer.toString(n);\n        // Flag to check if any odd digit is found\n        boolean hasOdd = false;\n        \n        // Iterate through each character in the string\n        for (char ch : numStr.toCharArray()) {\n            // Convert the character to an integer\n            int digit = Character.getNumericValue(ch);\n            // Check if the digit is odd\n            if (digit % 2 != 0) {\n                // Multiply the product by the odd digit\n                product *= digit;\n                // Set the flag to true as we found an odd digit\n                hasOdd = true;\n            }\n        }\n        \n        // If no odd digit was found, return 0\n        if (!hasOdd) {\n            return 0;\n        }\n        \n        // Return the product of the odd digits\n        return product;\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean nested = false;\n\n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n            } else if (ch == ']') {\n                if (!stack.isEmpty() && stack.peek() == '[') {\n                    stack.pop();\n                    nested = true; // We found a nested bracket\n                } else {\n                    stack.push(ch); // Push the closing bracket to handle invalid cases\n                }\n            }\n        }\n\n        // If there are unmatched brackets left in the stack, it means the string is not valid\n        // But we only care about whether we found a nested bracket\n        return nested;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_nested(\"[[]]\")); // true\n        System.out.println(sol.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(sol.is_nested(\"[][]\")); // false\n        System.out.println(sol.is_nested(\"[]\")); // false\n        System.out.println(sol.is_nested(\"[[][]]\")); // true\n        System.out.println(sol.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            int roundedNum = (int) Math.ceil(num);\n            // Square the rounded number\n            int squaredNum = roundedNum * roundedNum;\n            // Add to the sum\n            sum += squaredNum;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(sol.sum_squares(lst1)); // Output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(sol.sum_squares(lst2)); // Output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(sol.sum_squares(lst3)); // Output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(sol.sum_squares(lst4)); // Output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(sol.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt.isEmpty()) {\n            return false;\n        }\n\n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is an alphabetical character\n        if (Character.isLetter(lastChar)) {\n            // Check if the last character is not part of a word\n            // If the last character is followed by a space or is the last character in the string, return true\n            if (txt.length() == 1 || txt.charAt(txt.length() - 2) == ' ') {\n                return true;\n            }\n        }\n\n        // If the last character is not an alphabetical character or is part of a word, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < arr.size(); i++) {\n            // Check if the current element is not greater than or equal to the previous element\n            if (arr.get(i) < arr.get(i - 1)) {\n                // Return the index of the current element\n                return i;\n            }\n        }\n        // If no such element is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (!largestNegative.isPresent() || num > largestNegative.get()) {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // (Optional.empty(), Optional.empty())\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        Double valA = normalizeToDouble(a);\n        Double valB = normalizeToDouble(b);\n\n        if (valA == null || valB == null) {\n            return Optional.empty();\n        }\n\n        if (valA.equals(valB)) {\n            return Optional.empty();\n        }\n\n        if (valA > valB) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private Double normalizeToDouble(Object obj) {\n        if (obj instanceof Number) {\n            return ((Number) obj).doubleValue();\n        } else if (obj instanceof String) {\n            String str = (String) obj;\n            try {\n                // Replace comma with dot for parsing\n                str = str.replace(',', '.');\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == false\n    is_equal_to_sum_even(6) == false\n    is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // If n is less than 8, it cannot be the sum of 4 positive even numbers\n        if (n < 8) {\n            return false;\n        }\n        \n        // If n is not even, it cannot be the sum of 4 even numbers\n        if (n % 2 != 0) {\n            return false;\n        }\n        \n        // For n >= 8 and n is even, it can always be expressed as the sum of 4 even numbers\n        // because we can always divide n into 4 parts, each of which is an even number\n        return true;\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper function to compute the factorial of a given number.\n     * @param num The number to compute the factorial for.\n     * @return The factorial of the given number.\n     */\n    private long factorial(int num) {\n        long result = 1;\n        for (int i = 1; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    /**\n     * Computes the Brazilian factorial of a given number.\n     * @param n The number to compute the Brazilian factorial for.\n     * @return The Brazilian factorial of the given number.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = n; i >= 1; i--) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.special_factorial(4)); // Output should be 288\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Step 1: Replace all single spaces with underscores\n        text = text.replace(\" \", \"_\");\n        \n        // Step 2: Replace sequences of more than two consecutive underscores with a single hyphen\n        text = text.replaceAll(\"_{3,}\", \"-\");\n        \n        return text;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\")); // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\")); // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\")); // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\")); // \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotIndex = file_name.indexOf('.');\n        if (dotIndex == -1 || dotIndex != file_name.lastIndexOf('.')) {\n            return \"No\";\n        }\n\n        // Split the file name into prefix and suffix\n        String prefix = file_name.substring(0, dotIndex);\n        String suffix = file_name.substring(dotIndex + 1);\n\n        // Check if the prefix is not empty and starts with a Latin alphabet letter\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check if the suffix is one of the allowed extensions\n        Set<String> allowedExtensions = new HashSet<>(Arrays.asList(\"txt\", \"exe\", \"dll\"));\n        if (!allowedExtensions.contains(suffix)) {\n            return \"No\";\n        }\n\n        // Count the digits in the prefix\n        int digitCount = 0;\n        for (char c : prefix.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n                if (digitCount > 3) {\n                    return \"No\";\n                }\n            }\n        }\n\n        // If all conditions are met, return \"Yes\"\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.file_name_check(\"example.txt\")); // => \"Yes\"\n        System.out.println(solution.file_name_check(\"1example.dll\")); // => \"No\"\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int value = lst.get(i);\n            \n            if (i % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                value = value * value;\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the value if index is a multiple of 4 but not a multiple of 3\n                value = value * value * value;\n            }\n            \n            // Add the transformed value to the sum\n            sum += value;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(sol.sum_squares(lst1)); // Output: 6\n        \n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(sol.sum_squares(lst2)); // Output: 0\n        \n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(sol.sum_squares(lst3)); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // Use a StringBuilder to collect the words with prime length\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Check if the length of the word is a prime number\n            if (isPrime(word.length())) {\n                // Append the word to the result\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        // Return the resulting string\n        return result.toString();\n    }\n    \n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(sol.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the input fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n        \n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n        \n        // Compute the product of the two fractions\n        int numeratorProduct = numeratorX * numeratorN;\n        int denominatorProduct = denominatorX * denominatorN;\n        \n        // Simplify the resulting fraction\n        int gcd = gcd(numeratorProduct, denominatorProduct);\n        numeratorProduct /= gcd;\n        denominatorProduct /= gcd;\n        \n        // Check if the simplified fraction is a whole number\n        return denominatorProduct == 1;\n    }\n    \n    // Helper method to compute the greatest common divisor (GCD)\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (sum of digits, original number)\n        List<Pair> pairs = new ArrayList<>();\n        for (int num : nums) {\n            pairs.add(new Pair(sumOfDigits(num), num));\n        }\n\n        // Sort the list of pairs based on the sum of digits\n        Collections.sort(pairs, Comparator.comparingInt(Pair::getSumOfDigits));\n\n        // Extract the sorted numbers from the pairs\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.getNum());\n        }\n\n        return sortedNums;\n    }\n\n    // Helper method to calculate the sum of digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n\n        while (num > 0) {\n            int digit = num % 10;\n            sum += digit;\n            num /= 10;\n        }\n\n        // If the number was negative, the first digit should be negative\n        if (isNegative) {\n            sum = -sum;\n        }\n\n        return sum;\n    }\n\n    // Helper class to store the sum of digits and the original number\n    private static class Pair {\n        private final int sumOfDigits;\n        private final int num;\n\n        public Pair(int sumOfDigits, int num) {\n            this.sumOfDigits = sumOfDigits;\n            this.num = num;\n        }\n\n        public int getSumOfDigits() {\n            return sumOfDigits;\n        }\n\n        public int getNum() {\n            return num;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.order_by_points(Arrays.asList(1, 11, -1, -11, -12))); // [-1, -11, 1, -12, 11]\n        System.out.println(solution.order_by_points(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an array of numbers as input and returns\n    the number of elements in the array that are greater than 10 and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n    specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        \n        for (int num : nums) {\n            if (num > 10) {\n                int lastDigit = Math.abs(num) % 10;\n                int firstDigit = Math.abs(num);\n                \n                // Extract the first digit\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n                \n                // Check if both first and last digits are odd\n                if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Generate the array a\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Step 2: Count the valid triples\n        int count = 0;\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Step 3: Return the count of valid triples\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_max_triples(5)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    );\n\n    public List<String> bf(String planet1, String planet2) {\n        // Validate the input planets\n        if (!PLANETS.contains(planet1) || !PLANETS.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        // Find the indices of the planets\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for simplicity\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Extract the planets between index1 and index2 (exclusive)\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\")); // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\")); // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Step 2: Sort the filtered list\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                // First, compare by length\n                int lengthCompare = Integer.compare(s1.length(), s2.length());\n                if (lengthCompare != 0) {\n                    return lengthCompare;\n                }\n                // If lengths are the same, compare alphabetically\n                return s1.compareTo(s2);\n            }\n        });\n\n        // Step 3: Return the sorted list\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        List<String> result1 = solution.sorted_list_sum(test1);\n        System.out.println(result1); // Output: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        List<String> result2 = solution.sorted_list_sum(test2);\n        System.out.println(result2); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        // Edge case: numbers less than 2 are not prime\n        if (n < 2) {\n            return y;\n        }\n        \n        // Check for divisibility from 2 to sqrt(n)\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return y; // n is not prime\n            }\n        }\n        \n        // If no divisors found, n is prime\n        return x;\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n        \n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num;\n                }\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the lists\n        for (int i = 0; i < game.size(); i++) {\n            int gameScore = game.get(i);\n            int guessScore = guess.get(i);\n            \n            // Compare the scores\n            if (gameScore == guessScore) {\n                result.add(0);\n            } else {\n                result.add(Math.abs(gameScore - guessScore));\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2))); // [0, 0, 0, 0, 3, 3]\n        System.out.println(solution.compare(Arrays.asList(0, 5, 0, 0, 0, 4), Arrays.asList(4, 1, 1, 0, 0, -2))); // [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            int cap = 0;\n            int sm = 0;\n\n            // Calculate CAP and SM for the current extension\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n\n            // Calculate the strength of the current extension\n            int strength = cap - sm;\n\n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Output: \"Slices.SErviNGSliCes\"\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Output: \"my_class.AA\"\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the second word with itself\n        String concatenated = b + b;\n        \n        // Check if the first word is a substring of the concatenated string\n        return concatenated.contains(a);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(sol.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(sol.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(sol.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(sol.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(sol.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer, return a list that has the number of even and odd digits respectively.\n    \n     Example:\n        even_odd_count(-12) ==> [1, 1]\n        even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to its absolute value to handle negative numbers\n        num = Math.abs(num);\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Iterate through each digit of the number\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                evenCount++; // Increment even count if the digit is even\n            } else {\n                oddCount++; // Increment odd count if the digit is odd\n            }\n            num /= 10; // Remove the last digit\n        }\n        \n        // Return the counts as a list\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.even_odd_count(-12)); // Output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        \n        StringBuilder roman = new StringBuilder();\n        \n        // Iterate through the values and symbols\n        for (int i = 0; i < values.length; i++) {\n            // While the current value can be subtracted from the number\n            while (number >= values[i]) {\n                // Subtract the value from the number\n                number -= values[i];\n                // Append the corresponding symbol to the result\n                roman.append(symbols[i]);\n            }\n        }\n        \n        // Convert the result to lowercase and return\n        return roman.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(sol.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(sol.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Identify the longest side\n        int maxSide = Math.max(a, Math.max(b, c));\n        \n        // Determine the other two sides\n        int side1, side2;\n        if (maxSide == a) {\n            side1 = b;\n            side2 = c;\n        } else if (maxSide == b) {\n            side1 = a;\n            side2 = c;\n        } else {\n            side1 = a;\n            side2 = b;\n        }\n        \n        // Check the Pythagorean theorem\n        return (side1 * side1 + side2 * side2 == maxSide * maxSide);\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            // Use a HashSet to count unique characters in the word\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            int uniqueCount = uniqueChars.size();\n\n            // Check if the current word has more unique characters\n            // or if it has the same number but is lexicographically smaller\n            if (uniqueCount > maxUniqueChars || (uniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))); // \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots eaten\n        int totalEaten = number + need;\n        \n        // Calculate the number of carrots left\n        int carrotsLeft;\n        if (remaining >= need) {\n            carrotsLeft = remaining - need;\n        } else {\n            carrotsLeft = 0;\n        }\n        \n        // Return the result as a list\n        return Arrays.asList(totalEaten, carrotsLeft);\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a list to hold the final expression in postfix notation\n        List<String> postfix = new ArrayList<>();\n        // Stack to help with the conversion to postfix notation\n        Stack<String> stack = new Stack<>();\n\n        // Convert the infix expression to postfix notation\n        for (int i = 0; i < operator.size(); i++) {\n            postfix.add(String.valueOf(operand.get(i)));\n            while (!stack.isEmpty() && hasHigherPrecedence(stack.peek(), operator.get(i))) {\n                postfix.add(stack.pop());\n            }\n            stack.push(operator.get(i));\n        }\n        postfix.add(String.valueOf(operand.get(operand.size() - 1)));\n        while (!stack.isEmpty()) {\n            postfix.add(stack.pop());\n        }\n\n        // Evaluate the postfix expression\n        Stack<Integer> evalStack = new Stack<>();\n        for (String token : postfix) {\n            if (isOperator(token)) {\n                int b = evalStack.pop();\n                int a = evalStack.pop();\n                evalStack.push(applyOperation(a, b, token));\n            } else {\n                evalStack.push(Integer.parseInt(token));\n            }\n        }\n\n        return evalStack.pop();\n    }\n\n    private boolean isOperator(String token) {\n        return token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\") || token.equals(\"**\");\n    }\n\n    private boolean hasHigherPrecedence(String op1, String op2) {\n        if (op1.equals(\"**\")) return true;\n        if (op2.equals(\"**\")) return false;\n        if (op1.equals(\"*\") || op1.equals(\"/\")) return true;\n        if (op2.equals(\"*\") || op2.equals(\"/\")) return false;\n        return false;\n    }\n\n    private int applyOperation(int a, int b, String operator) {\n        switch (operator) {\n            case \"+\":\n                return a + b;\n            case \"-\":\n                return a - b;\n            case \"*\":\n                return a * b;\n            case \"/\":\n                return a / b;\n            case \"**\":\n                return (int) Math.pow(a, b);\n            default:\n                throw new IllegalArgumentException(\"Invalid operator: \" + operator);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        System.out.println(sol.do_algebra(operator, operand)); // Output: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean containsLetter = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                break;\n            }\n        }\n\n        // If the string contains no letters, reverse the string\n        if (!containsLetter) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // If the string contains letters, process each character\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Reverse the case of the letter\n                if (Character.isUpperCase(c)) {\n                    result.append(Character.toLowerCase(c));\n                } else {\n                    result.append(Character.toUpperCase(c));\n                }\n            } else {\n                // Keep non-letter characters as they are\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solve(\"1234\")); // Output: \"4321\"\n        System.out.println(sol.solve(\"ab\"));   // Output: \"AB\"\n        System.out.println(sol.solve(\"#a@C\")); // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Check if the input string is empty\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Create a MessageDigest instance for MD5\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        // Compute the MD5 hash of the input string\n        byte[] messageDigest = md.digest(text.getBytes());\n\n        // Convert the byte array to a BigInteger\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert the BigInteger to a hexadecimal string\n        String hashtext = no.toString(16);\n\n        // Pad the hexadecimal string with leading zeros if necessary\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        // Return the resulting string wrapped in an Optional\n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Determine the start and end of the range\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n        \n        // Set to store unique even digits\n        Set<Integer> evenDigits = new HashSet<>();\n        \n        // Iterate through the range and collect even digits\n        for (int i = start; i <= end; i++) {\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit % 2 == 0 && digit < 10) {\n                    evenDigits.add(digit);\n                }\n                num /= 10;\n            }\n        }\n        \n        // Convert the set to a sorted list\n        List<Integer> result = new ArrayList<>(evenDigits);\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(10, 14)); // []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Iterate through each pair of numbers in the list\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                // Calculate the absolute difference between the two numbers\n                double difference = Math.abs(numbers.get(i) - numbers.get(j));\n                // Check if the difference is less than the threshold\n                if (difference < threshold) {\n                    return true; // Found a pair of numbers closer than the threshold\n                }\n            }\n        }\n        return false; // No such pair found\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        paren_string = paren_string.replaceAll(\" \", \"\");\n        \n        List<String> result = new ArrayList<>();\n        Stack<Character> stack = new Stack<>();\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char ch : paren_string.toCharArray()) {\n            if (ch == '(') {\n                // Push the opening parenthesis onto the stack\n                stack.push(ch);\n            } else if (ch == ')') {\n                // Pop the corresponding opening parenthesis from the stack\n                stack.pop();\n            }\n            \n            // Append the current character to the current group\n            currentGroup.append(ch);\n            \n            // If the stack is empty, it means we have a balanced group\n            if (stack.isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Reset the StringBuilder for the next group\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.separate_paren_groups(\"( ) (( )) (( )( ))\")); // [\"()\", \"(())\", \"(()())\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n     */\n    public double truncate_number(double number) {\n        // Get the integer part of the number\n        int integerPart = (int) number;\n        \n        // Subtract the integer part from the original number to get the decimal part\n        double decimalPart = number - integerPart;\n        \n        return decimalPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5)); // Output: 0.5\n        System.out.println(solution.truncate_number(1.0)); // Output: 0.0\n        System.out.println(solution.truncate_number(0.75)); // Output: 0.75\n        System.out.println(solution.truncate_number(123.456)); // Output: 0.456\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        // Step 1: Calculate the mean of the dataset\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Compute the absolute differences and their sum\n        double absoluteDifferencesSum = 0.0;\n        for (double number : numbers) {\n            absoluteDifferencesSum += Math.abs(number - mean);\n        }\n\n        // Step 3: Calculate the Mean Absolute Deviation\n        double mad = absoluteDifferencesSum / numbers.size();\n\n        return mad;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(solution.mean_absolute_deviation(numbers)); // Output: 1.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the input list\n        for (int i = 0; i < numbers.size(); i++) {\n            // Add the current element to the result list\n            result.add(numbers.get(i));\n            \n            // If it's not the last element, add the delimiter\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                result.add(str);\n            }\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum to 0 and product to 1\n        int sum = 0;\n        int product = 1;\n\n        // Iterate through the list to calculate sum and product\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        // Return the result as a list\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_product(List.of())); // [0, 1]\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize the current maximum to the smallest possible integer value\n        int currentMax = Integer.MIN_VALUE;\n        \n        // Iterate through the list of numbers\n        for (int number : numbers) {\n            // Update the current maximum if the current number is greater\n            if (number > currentMax) {\n                currentMax = number;\n            }\n            // Add the current maximum to the result list\n            result.add(currentMax);\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> result = solution.rolling_max(numbers);\n        System.out.println(result); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n     */\n    public String make_palindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        // Find the longest palindromic suffix\n        int n = string.length();\n        for (int i = 0; i < n; i++) {\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // Reverse the prefix and append it to the original string\n                String prefix = string.substring(0, i);\n                String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n                return string + reversedPrefix;\n            }\n        }\n\n        // If no palindromic suffix is found, reverse the entire string and append\n        String reversedString = new StringBuilder(string).reverse().toString();\n        return string + reversedString;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n     */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of the same length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Input strings must be of the same length\");\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each character of the strings\n        for (int i = 0; i < a.length(); i++) {\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n\n            // Perform XOR operation\n            if (charA == charB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Output: \"100\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n\n        return Optional.of(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure that a is greater than or equal to b\n        if (b > a) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        // Implement the Euclidean algorithm\n        while (b != 0) {\n            int remainder = a % b;\n            a = b;\n            b = remainder;\n        }\n        \n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.all_prefixes(\"abc\")); // Output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String string_sequence(int n) {\n        // Create a StringBuilder to efficiently build the result string\n        StringBuilder sb = new StringBuilder();\n        \n        // Loop from 0 to n inclusive\n        for (int i = 0; i <= n; i++) {\n            // Append the current number to the StringBuilder\n            sb.append(i);\n            \n            // If the current number is not the last one, append a space\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to handle case insensitivity\n        string = string.toLowerCase();\n        \n        // Use a Set to store distinct characters\n        Set<Character> distinctCharacters = new HashSet<>();\n        \n        // Iterate through the string and add each character to the Set\n        for (char c : string.toCharArray()) {\n            distinctCharacters.add(c);\n        }\n        \n        // The size of the Set is the number of distinct characters\n        return distinctCharacters.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        // Initialize the list to store the beats\n        List<Integer> beatsList = new ArrayList<>();\n        \n        // Create a map to store the mapping of notes to beats\n        Map<String, Integer> noteToBeats = new HashMap<>();\n        noteToBeats.put(\"o\", 4);\n        noteToBeats.put(\"o|\", 2);\n        noteToBeats.put(\".|\", 1);\n        \n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Iterate through each note and add the corresponding beats to the list\n        for (String note : notes) {\n            beatsList.add(noteToBeats.get(note));\n        }\n        \n        // Return the list of beats\n        return beatsList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\"));\n        // Output should be: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n     */\n    public int how_many_times(String string, String substring) {\n        int count = 0;\n        int subLength = substring.length();\n        \n        // Iterate through the string, checking for the substring at each position\n        for (int i = 0; i <= string.length() - subLength; i++) {\n            // Check if the substring matches starting from position i\n            if (string.substring(i, i + subLength).equals(substring)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\")); // 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Step 1: Create a mapping from number words to their corresponding integer values\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Step 2: Split the input string into individual number words\n        String[] numberWords = numbers.split(\" \");\n\n        // Step 3: Sort the words based on their values using the mapping\n        Arrays.sort(numberWords, new Comparator<String>() {\n            @Override\n            public int compare(String word1, String word2) {\n                return numberMap.get(word1).compareTo(numberMap.get(word2));\n            }\n        });\n\n        // Step 4: Reconstruct the sorted string\n        return String.join(\" \", numberWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\")); // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements\n        Collections.sort(numbers);\n        \n        // Initialize variables to keep track of the minimum difference and the closest elements\n        double minDifference = Double.MAX_VALUE;\n        double num1 = 0.0;\n        double num2 = 0.0;\n        \n        // Iterate through the sorted list to find the closest elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double currentDifference = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (currentDifference < minDifference) {\n                minDifference = currentDifference;\n                num1 = numbers.get(i);\n                num2 = numbers.get(i + 1);\n            }\n        }\n        \n        // Return the closest elements in a list\n        List<Double> result = new ArrayList<>();\n        result.add(Math.min(num1, num2));\n        result.add(Math.max(num1, num2));\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))); // [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n        \n        // Create a new list to store the rescaled values\n        List<Double> rescaledList = new ArrayList<>();\n        \n        // Apply the linear transformation to each number\n        for (Double number : numbers) {\n            double rescaledValue = (number - min) / (max - min);\n            rescaledList.add(rescaledValue);\n        }\n        \n        return rescaledList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        List<Double> rescaledNumbers = solution.rescale_to_unit(numbers);\n        System.out.println(rescaledNumbers); // Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1\n        for (int i = n - 1; i > 0; i--) {\n            // Check if i divides n evenly\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, return 1 (since 1 is a divisor of any number)\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_divisor(15)); // Output: 5\n        System.out.println(sol.largest_divisor(28)); // Output: 14\n        System.out.println(sol.largest_divisor(13)); // Output: 1 (since 13 is a prime number)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 as much as possible\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Divide by odd numbers starting from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then it must be prime\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));   // Output: [2, 2, 2]\n        System.out.println(solution.factorize(25));  // Output: [5, 5]\n        System.out.println(solution.factorize(70));  // Output: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Set to track elements that have been seen more than once\n        Set<Integer> seen = new HashSet<>();\n        // Set to track elements that have been added to the result list\n        Set<Integer> added = new HashSet<>();\n        // Result list to store the final elements\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : numbers) {\n            if (seen.contains(num)) {\n                // If the element has been seen before, remove it from the added set\n                added.remove(num);\n            } else {\n                // If the element has not been seen before, add it to the seen set\n                seen.add(num);\n                // Add the element to the result list and the added set\n                result.add(num);\n                added.add(num);\n            }\n        }\n        \n        // Filter the result list to keep only elements that are in the added set\n        return result.stream()\n                     .filter(added::contains)\n                     .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(numbers)); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(c); // If it's not a letter, just append it as is\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.flip_case(\"Hello\")); // Output: \"hELLO\"\n        System.out.println(solution.flip_case(\"World\")); // Output: \"wORLD\"\n        System.out.println(solution.flip_case(\"Java\"));  // Output: \"jAVA\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        // Create a StringBuilder to efficiently concatenate strings\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through the list of strings and append each string to the StringBuilder\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     * \n     * @param strings The list of strings to filter.\n     * @param prefix  The prefix to filter by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_by_prefix(List.of(), \"a\")); // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")); // [\"abc\", \"array\"]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(n -> n > 0)  // Filter out non-positive numbers\n                .collect(Collectors.toList());  // Collect the results into a list\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    false\n    >>> is_prime(101)\n    true\n    >>> is_prime(11)\n    true\n    >>> is_prime(13441)\n    true\n    >>> is_prime(61)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(1)\n    false\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime\n        }\n        \n        // Check for factors from 3 to sqrt(n)\n        int sqrt = (int) Math.sqrt(n);\n        for (int i = 3; i <= sqrt; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    return xs[1] + 2 * xs[2] * x + 3 * xs[3] * x^2 + .... n * xs[n] * x^(n-1)\n     */\n    public double polyDerivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> find_zero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> find_zero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double find_zero(List<Double> xs) {\n        double tolerance = 1e-7; // Tolerance for convergence\n        double x0 = 0.0; // Initial guess\n        double x1 = x0;\n        \n        do {\n            x0 = x1;\n            double fx = poly(xs, x0);\n            double dfx = polyDerivative(xs, x0);\n            if (Math.abs(dfx) < tolerance) {\n                throw new ArithmeticException(\"Derivative is zero, Newton-Raphson method failed.\");\n            }\n            x1 = x0 - fx / dfx;\n        } while (Math.abs(x1 - x0) >= tolerance);\n        \n        return x1;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Create a list to store the elements at indices divisible by three\n        List<Integer> elementsToSort = new ArrayList<>();\n        \n        // Collect the elements at indices divisible by three\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                elementsToSort.add(l.get(i));\n            }\n        }\n        \n        // Sort the collected elements\n        Collections.sort(elementsToSort);\n        \n        // Replace the original elements at indices divisible by three with the sorted elements\n        int sortedIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                l.set(i, elementsToSort.get(sortedIndex));\n                sortedIndex++;\n            }\n        }\n        \n        return l;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Step 1: Convert the list to a Set to remove duplicates\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        \n        // Step 2: Convert the Set back to a List\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        \n        // Step 3: Sort the list\n        Collections.sort(uniqueList);\n        \n        // Step 4: Return the sorted list\n        return uniqueList;\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int max_element(List<Integer> l) {\n        // Initialize the maximum element to the smallest possible integer value\n        int max = Integer.MIN_VALUE;\n        \n        // Iterate through each element in the list\n        for (int num : l) {\n            // Update the maximum value if the current element is greater\n            if (num > max) {\n                max = num;\n            }\n        }\n        \n        // Return the maximum element found\n        return max;\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numberStr = Integer.toString(i);\n                for (char c : numberStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fizz_buzz(50)); // Output: 0\n        System.out.println(sol.fizz_buzz(78)); // Output: 2\n        System.out.println(sol.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sort_even(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extract values at even indices\n        List<Integer> evenIndexValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndexValues.add(l.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndexValues);\n        \n        // Create the result list\n        List<Integer> result = new ArrayList<>(l);\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i += 2) {\n            result.set(i, evenIndexValues.get(evenIndex));\n            evenIndex++;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n     */\n    public int prime_fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be a positive integer\");\n        }\n        \n        int count = 0;\n        int a = 0, b = 1;\n        \n        while (true) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                count++;\n                if (count == n) {\n                    return fib;\n                }\n            }\n        }\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        if (num % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     *\n     * >>> triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n     * false\n     * >>> triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n     * true\n     * >>> triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n     * false\n     * >>> triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))\n     * true\n     * >>> triples_sum_to_zero(Arrays.asList(1))\n     * false\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to use the two-pointer technique\n        Collections.sort(l);\n        \n        // Iterate through the list\n        for (int i = 0; i < l.size() - 2; i++) {\n            // Use two pointers to find the other two elements\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true; // Found a triplet that sums to zero\n                } else if (sum < 0) {\n                    left++; // Move left pointer to increase the sum\n                } else {\n                    right--; // Move right pointer to decrease the sum\n                }\n            }\n        }\n        \n        return false; // No triplet found that sums to zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function outputs the number of collisions between two sets of cars.\n     */\n    public int car_race_collision(int n) {\n        return n * n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream()\n                .map(i -> i + 1)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairs_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) {\n            return \"0\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base;\n            result.append(remainder);\n            x = x / base;\n        }\n        \n        // Since we collected the digits in reverse order, we need to reverse the result\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.change_base(8, 3));  // Output: \"22\"\n        System.out.println(sol.change_base(8, 2));  // Output: \"1000\"\n        System.out.println(sol.change_base(7, 2));  // Output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array to store the last four computed values\n        int[] fib4Values = new int[4];\n        fib4Values[0] = 0; // fib4(0)\n        fib4Values[1] = 0; // fib4(1)\n        fib4Values[2] = 2; // fib4(2)\n        fib4Values[3] = 0; // fib4(3)\n\n        // Compute the sequence iteratively up to n\n        for (int i = 4; i <= n; i++) {\n            int nextValue = fib4Values[0] + fib4Values[1] + fib4Values[2] + fib4Values[3];\n            // Shift the values to the left\n            fib4Values[0] = fib4Values[1];\n            fib4Values[1] = fib4Values[2];\n            fib4Values[2] = fib4Values[3];\n            fib4Values[3] = nextValue;\n        }\n\n        // The result is the last computed value\n        return fib4Values[3];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    8.0\n     */\n    public double median(List<Integer> l) {\n        // Sort the list\n        Collections.sort(l);\n        \n        // Get the size of the list\n        int size = l.size();\n        \n        // Check if the size is odd or even\n        if (size % 2 == 1) {\n            // If odd, return the middle element\n            return l.get(size / 2);\n        } else {\n            // If even, return the average of the two middle elements\n            int mid1 = l.get(size / 2 - 1);\n            int mid2 = l.get(size / 2);\n            return (mid1 + mid2) / 2.0;\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n     */\n    public boolean is_palindrome(String text) {\n        // An empty string is considered a palindrome\n        if (text.isEmpty()) {\n            return true;\n        }\n        \n        // Use two pointers to compare characters from the start and end of the string\n        int left = 0;\n        int right = text.length() - 1;\n        \n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n        // Base case: 2^0 % p = 1\n        if (n == 0) {\n            return 1;\n        }\n        \n        // Use binary exponentiation to compute 2^n % p\n        long result = 1;\n        long base = 2;\n        \n        while (n > 0) {\n            // If n is odd, multiply base to result\n            if (n % 2 == 1) {\n                result = (result * base) % p;\n            }\n            // Square the base and reduce n by half\n            base = (base * base) % p;\n            n /= 2;\n        }\n        \n        return (int) result;\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Calculate the new character by shifting back 5 positions\n            char decodedChar = (char) ('a' + ((ch - 5 - 'a' + 26) % 26));\n            sb.append(decodedChar);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for quick lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Use a StringBuilder to construct the result string\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string\n        for (char c : text.toCharArray()) {\n            // If the character is not a vowel, append it to the result\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Adds two integers.\n     *\n     * @param x the first integer\n     * @param y the second integer\n     * @return the sum of x and y\n     * @example\n     * <pre>\n     * add(2, 3)  // returns 5\n     * add(5, 7)  // returns 12\n     * </pre>\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if two words have the same kind of characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create frequency maps for both strings\n        Map<Character, Integer> freqMap0 = new HashMap<>();\n        Map<Character, Integer> freqMap1 = new HashMap<>();\n        \n        // Populate the frequency map for s0\n        for (char c : s0.toCharArray()) {\n            freqMap0.put(c, freqMap0.getOrDefault(c, 0) + 1);\n        }\n        \n        // Populate the frequency map for s1\n        for (char c : s1.toCharArray()) {\n            freqMap1.put(c, freqMap1.getOrDefault(c, 0) + 1);\n        }\n        \n        // Compare the frequency maps\n        return freqMap0.equals(freqMap1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        \n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '<') {\n                stack.push(bracket);\n            } else if (bracket == '>') {\n                if (stack.isEmpty() || stack.pop() != '<') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"<\")); // false\n        System.out.println(solution.correct_bracketing(\"<>\")); // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) {\n            return true; // An empty list or a single element list is trivially monotonic\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        \n        // Find the intersection of the two sets\n        set1.retainAll(set2);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set1);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        int largestPrime = 1;\n        \n        // Check for the smallest prime factor, which is 2\n        while (n % 2 == 0) {\n            largestPrime = 2;\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 to sqrt(n)\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestPrime = i;\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then n itself is a prime number\n        if (n > 2) {\n            largestPrime = n;\n        }\n        \n        return largestPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_prime_factor(13195)); // Output: 29\n        System.out.println(sol.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Output: 465\n        System.out.println(solution.sum_to_n(100)); // Output: 5050\n        System.out.println(solution.sum_to_n(5));   // Output: 15\n        System.out.println(solution.sum_to_n(10));  // Output: 55\n        System.out.println(solution.sum_to_n(1));   // Output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                stack.push(ch);\n            } else if (ch == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"(\")); // false\n        System.out.println(solution.correct_bracketing(\"()\")); // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Start from the first coefficient (index 1) since the derivative of the constant term (index 0) is 0\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.derivative(Arrays.asList(3, 1, 2, 4, 5))); // [1, 4, 12, 20]\n        System.out.println(solution.derivative(Arrays.asList(1, 2, 3))); // [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n     */\n    public int fibfib(int n) {\n        // Base cases\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        // Initialize the first three FibFib numbers\n        int a = 0, b = 0, c = 1;\n        int result = 0;\n\n        // Compute the n-th FibFib number iteratively\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n     */\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle case insensitivity\n        s = s.toLowerCase();\n        \n        // Initialize a counter for vowels\n        int count = 0;\n        \n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));\n        \n        // Iterate through the string and count the vowels\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (vowels.contains(c)) {\n                count++;\n            }\n        }\n        \n        // Check if 'y' is at the end of the word and count it as a vowel if it is\n        if (s.length() > 0 && s.charAt(s.length() - 1) == 'y') {\n            count++;\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        int length = numStr.length();\n        \n        // If shift is greater than or equal to the number of digits, reverse the string\n        if (shift >= length) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Perform the circular shift\n        String shiftedPart = numStr.substring(length - shift);\n        String remainingPart = numStr.substring(0, length - shift);\n        \n        // Concatenate the shifted part with the remaining part\n        return shiftedPart + remainingPart;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(sol.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(sol.circular_shift(12345, 2)); // Output: \"45123\"\n        System.out.println(sol.circular_shift(12345, 5)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                sum += (int) ch;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.digitSum(\"\")); // 0\n        System.out.println(sol.digitSum(\"abAB\")); // 131\n        System.out.println(sol.digitSum(\"abcCd\")); // 67\n        System.out.println(sol.digitSum(\"helloE\")); // 69\n        System.out.println(sol.digitSum(\"woArBld\")); // 131\n        System.out.println(sol.digitSum(\"aAaaaXa\")); // 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Split the string by spaces to isolate the numbers\n        String[] parts = s.split(\" \");\n        \n        // The number of apples is the first number in the string\n        int apples = Integer.parseInt(parts[0]);\n        \n        // The number of oranges is the third number in the string\n        int oranges = Integer.parseInt(parts[2]);\n        \n        // Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        \n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(sol.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Output: 2\n        System.out.println(sol.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(sol.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        // Initialize variables to store the smallest even value and its index\n        int minEvenValue = Integer.MAX_VALUE;\n        int minEvenIndex = -1;\n        \n        // Iterate through the list\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            \n            // Check if the current value is even\n            if (currentValue % 2 == 0) {\n                // If it's the first even value found or it's smaller than the current smallest even value\n                if (currentValue < minEvenValue) {\n                    minEvenValue = currentValue;\n                    minEvenIndex = i;\n                }\n            }\n        }\n        \n        // If no even value was found, return an empty list\n        if (minEvenIndex == -1) {\n            return new ArrayList<>();\n        }\n        \n        // Return the smallest even value and its index\n        List<Integer> result = new ArrayList<>();\n        result.add(minEvenValue);\n        result.add(minEvenIndex);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList())); // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Count the frequency of each integer in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Find the greatest integer that meets the criteria\n        int maxValidInteger = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            if (num > 0 && freq >= num) {\n                if (num > maxValidInteger) {\n                    maxValidInteger = num;\n                }\n            }\n        }\n\n        // Step 3: Return the result\n        return maxValidInteger;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list in ascending order\n        Collections.sort(lst);\n        \n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize two pointers\n        int minIndex = 0;\n        int maxIndex = lst.size() - 1;\n        \n        // Alternate between picking the minimum and maximum values\n        while (minIndex <= maxIndex) {\n            if (minIndex <= maxIndex) {\n                result.add(lst.get(minIndex));\n                minIndex++;\n            }\n            if (minIndex <= maxIndex) {\n                result.add(lst.get(maxIndex));\n                maxIndex--;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // [1, 4, 2, 3]\n        System.out.println(sol.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // [5, 5, 5, 5]\n        System.out.println(sol.strange_sort_list(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round the area to 2 decimal places\n        area = Math.round(area * 100.0) / 100.0;\n        \n        return area;\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        List<Integer> reversedQ = new ArrayList<>(q);\n        Collections.reverse(reversedQ);\n        if (!q.equals(reversedQ)) {\n            return false;\n        }\n\n        // Calculate the sum of the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to the maximum weight\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n        \n        // Compare elements from the start and end moving towards the center\n        for (int i = 0; i < n / 2; i++) {\n            if (arr.get(i) != arr.get(n - 1 - i)) {\n                changes++;\n            }\n        }\n        \n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper function to calculate the total number of characters in a list of strings.\n     */\n    private int totalChars(List<String> lst) {\n        int total = 0;\n        for (String s : lst) {\n            total += s.length();\n        }\n        return total;\n    }\n\n    /**\n     * Function to compare two lists of strings based on the total number of characters.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int total1 = totalChars(lst1);\n        int total2 = totalChars(lst2);\n\n        if (total1 <= total2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.total_match(Arrays.asList(), Arrays.asList())); // []\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less then 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        // Generate all prime numbers less than 100\n        List<Integer> primes = generatePrimes(100);\n        \n        // Check all combinations of three primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + 1; j < primes.size(); j++) {\n                for (int k = j + 1; k < primes.size(); k++) {\n                    int product = primes.get(i) * primes.get(j) * primes.get(k);\n                    if (product == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Helper method to generate all prime numbers less than n using Sieve of Eratosthenes\n    private List<Integer> generatePrimes(int n) {\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_multiply_prime(30)); // true\n        System.out.println(sol.is_multiply_prime(27)); // false\n        System.out.println(sol.is_multiply_prime(385)); // true (5 * 7 * 11)\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        // If x is 1, it is always a power of any n (except n = 0, but we assume n > 0)\n        if (x == 1) {\n            return n == 1;\n        }\n        \n        // If n is 1, the only power of 1 is 1 itself, so x must be 1\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        // Check if x is a power of n\n        while (x % n == 0) {\n            x /= n;\n        }\n        \n        // If x becomes 1, it means x was a power of n\n        return x == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an integer a and returns true\n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> true\n    iscube(2) ==> false\n    iscube(-1) ==> true\n    iscube(64) ==> true\n    iscube(0) ==> true\n    iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        // Compute the cube root of a\n        double cubeRoot = Math.cbrt(a);\n        \n        // Convert the cube root to an integer\n        int intCubeRoot = (int) cubeRoot;\n        \n        // Check if cubing this integer gives back the original number\n        return intCubeRoot * intCubeRoot * intCubeRoot == a;\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // Define the set of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize the count of prime digits\n        int primeCount = 0;\n        \n        // Iterate through each character in the input string\n        for (char c : num.toCharArray()) {\n            // Check if the character is a prime hexadecimal digit\n            if (primeHexDigits.contains(c)) {\n                primeCount++;\n            }\n        }\n        \n        // Return the count of prime digits\n        return primeCount;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.hex_key(\"AB\")); // Output: 1\n        System.out.println(sol.hex_key(\"1077E\")); // Output: 2\n        System.out.println(sol.hex_key(\"ABED1A33\")); // Output: 4\n        System.out.println(sol.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(sol.hex_key(\"2020\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Wrap the binary string with 'db' at the beginning and end\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Output: \"db100000db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) {\n            return false;\n        }\n\n        // Iterate through the string and check every set of 3 consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // Check if all three characters are distinct\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n\n        // If all sets of 3 consecutive characters are distinct, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_happy(\"a\")); // false\n        System.out.println(solution.is_happy(\"aa\")); // false\n        System.out.println(solution.is_happy(\"abcd\")); // true\n        System.out.println(solution.is_happy(\"aabb\")); // false\n        System.out.println(solution.is_happy(\"adb\")); // true\n        System.out.println(solution.is_happy(\"xyy\")); // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> letterGrades = solution.numerical_letter_grade(grades);\n        System.out.println(letterGrades); // Output: [A+, B+, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    prime_length(\"Hello\") == true\n    prime_length(\"abcdcba\") == true\n    prime_length(\"kittens\") == true\n    prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        if (length < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_length(\"Hello\")); // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\")); // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Only number is 1\n        }\n        int count = (int) (Math.pow(10, n-1) + 8 * Math.pow(10, n-2));\n        return count;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer N, return in binary the total sum of its digits.\n\n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n             Constraints: 0 <= N <= 10000.\n    Output:\n         a string of binary number\n     */\n    public String solve(int N) {\n        // Step 1: Calculate the sum of digits\n        int sum = 0;\n        int temp = N;\n        while (temp > 0) {\n            sum += temp % 10; // Add the last digit to the sum\n            temp /= 10;       // Remove the last digit\n        }\n\n        // Step 2: Convert the sum to binary\n        String binarySum = Integer.toBinaryString(sum);\n\n        // Step 3: Return the binary string\n        return binarySum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Output: \"1\"\n        System.out.println(solution.solve(150));  // Output: \"110\"\n        System.out.println(solution.solve(147));  // Output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string into words using space as the delimiter\n        String[] words = s.split(\" \");\n        \n        // Create a list to hold the sorted words\n        List<String> sortedWords = new ArrayList<>();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Convert the word to a character array\n            char[] chars = word.toCharArray();\n            \n            // Sort the character array based on ASCII values\n            Arrays.sort(chars);\n            \n            // Convert the sorted character array back to a string\n            String sortedWord = new String(chars);\n            \n            // Add the sorted word to the list\n            sortedWords.add(sortedWord);\n        }\n        \n        // Join the sorted words with spaces to form the final string\n        String result = String.join(\" \", sortedWords);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Output: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Output: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Output: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Traverse the nested list to find occurrences of x\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        \n        // Sort the coordinates\n        coordinates.sort((a, b) -> {\n            // First, compare by row (ascending)\n            int rowComparison = a.get(0).compareTo(b.get(0));\n            if (rowComparison != 0) {\n                return rowComparison;\n            }\n            // If rows are the same, compare by column (descending)\n            return b.get(1).compareTo(a.get(1));\n        });\n        \n        return coordinates;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        \n        List<List<Integer>> lst2 = Arrays.asList();\n        System.out.println(solution.get_row(lst2, 1)); // []\n        \n        List<List<Integer>> lst3 = Arrays.asList(\n            Arrays.asList(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the array is empty or has only one element\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Calculate the sum of the first and last elements\n        int firstElement = array.get(0);\n        int lastElement = array.get(array.size() - 1);\n        int sum = firstElement + lastElement;\n\n        // Create a copy of the array to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Sort the array based on the sum's parity (odd or even)\n        if (sum % 2 == 0) {\n            // Sort in descending order if the sum is even\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            // Sort in ascending order if the sum is odd\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            // Calculate the new character after shifting by 4 places\n            char newChar = (char) (c + 4);\n            \n            // If the new character goes beyond 'z', wrap around\n            if (newChar > 'z') {\n                newChar = (char) (newChar - 26);\n            }\n            \n            // Append the new character to the result\n            encrypted.append(newChar);\n        }\n        \n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(sol.encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(sol.encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(sol.encrypt(\"et\")); // Output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * Returns null if there is no such element.\n     * \n     * @param lst The list of integers.\n     * @return Optional containing the 2nd smallest element or empty if not found.\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        int smallest = Integer.MAX_VALUE;\n        int secondSmallest = Integer.MAX_VALUE;\n        boolean foundSecondSmallest = false;\n\n        for (int num : lst) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num > smallest && num < secondSmallest) {\n                secondSmallest = num;\n                foundSecondSmallest = true;\n            }\n        }\n\n        return foundSecondSmallest ? Optional.of(secondSmallest) : Optional.empty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList())); // Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1))); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a given string.\n     * A boredom is a sentence that starts with the word \"I\".\n     * Sentences are delimited by '.', '?' or '!'.\n     *\n     * @param S The input string.\n     * @return The number of boredoms.\n     */\n    public int is_bored(String S) {\n        // Split the string into sentences based on delimiters '.', '?', and '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim any leading or trailing whitespace\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (sentence.startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\")); // Output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n        System.out.println(solution.is_bored(\"I am bored. I need something to do! I think I will go for a walk?\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all three objects are instances of Integer\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n            \n            // Check if one of the numbers is equal to the sum of the other two\n            if (a == b + c || b == a + c || c == a + b) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes the given message by swapping the case of all letters and replacing\n     * all vowels with the letter that appears 2 places ahead in the English alphabet.\n     *\n     * @param message The input message to be encoded.\n     * @return The encoded message.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead\n                if (\"aeiouAEIOU\".indexOf(swappedCaseChar) != -1) {\n                    char newChar = (char) (swappedCaseChar + 2);\n                    if (swappedCaseChar == 'u' || swappedCaseChar == 'U') {\n                        newChar -= 26; // Wrap around for 'u' and 'U'\n                    }\n                    encodedMessage.append(newChar);\n                } else {\n                    encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                encodedMessage.append(c); // Non-letter characters remain unchanged\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encode(\"test\")); // Output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Output: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to check if a number is prime.\n     * @param num The number to check.\n     * @return True if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2) return true; // 2 is the only even prime number\n        if (num % 2 == 0) return false; // Other even numbers are not prime\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Helper method to sum the digits of a number.\n     * @param num The number whose digits are to be summed.\n     * @return The sum of the digits of the number.\n     */\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Method to find the largest prime value in the list and return the sum of its digits.\n     * @param lst The list of integers.\n     * @return The sum of the digits of the largest prime number in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        int largestPrime = -1;\n        \n        // Find the largest prime in the list\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n        \n        // If no prime was found, return 0 (or handle as needed)\n        if (largestPrime == -1) {\n            return 0;\n        }\n        \n        // Return the sum of the digits of the largest prime\n        return sumOfDigits(largestPrime);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(sol.skjkasdkd(lst1)); // Output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(sol.skjkasdkd(lst2)); // Output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(sol.skjkasdkd(lst3)); // Output: 13\n        \n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(sol"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a map, return True if all keys are strings and all keys are in lower case or  in upper case, else return False.\n    The function should return False is the given map is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the map is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        // Iterate through the keys in the map\n        for (Object key : dict.keySet()) {\n            // Check if the key is a string\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            // Cast the key to a string\n            String strKey = (String) key;\n\n            // Check if the key is in lower case or upper case\n            if (!strKey.equals(strKey.toLowerCase()) && !strKey.equals(strKey.toUpperCase())) {\n                return false;\n            }\n        }\n\n        // If all checks pass, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"a\", \"apple\");\n        map1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(map1)); // Should return True\n\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"a\", \"apple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(map2)); // Should return False\n\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"a\", \"apple\");\n        map3.put(8, \"banana\");\n        map3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(map3)); // Should return False\n\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n        System.out.println(solution.check_dict_case(map4)); // Should return False\n\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(map5)); // Should return True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        // Initialize the list to store prime numbers\n        List<Integer> primes = new ArrayList<>();\n        \n        // Edge case: if n is less than 2, return an empty list\n        if (n < 2) {\n            return primes;\n        }\n        \n        // Create a boolean array \"isPrime[0..n]\" and initialize all entries as true.\n        // A value in isPrime[i] will finally be false if i is Not a prime, else true.\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        \n        // 0 and 1 are not prime numbers\n        isPrime[0] = isPrime[1] = false;\n        \n        // Implementing the Sieve of Eratosthenes\n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                // Marking all multiples of i as false\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Collecting all prime numbers\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.count_up_to(5));  // Output: [2, 3]\n        System.out.println(sol.count_up_to(11)); // Output: [2, 3, 5, 7]\n        System.out.println(sol.count_up_to(0));  // Output: []\n        System.out.println(sol.count_up_to(20)); // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(sol.count_up_to(1));  // Output: []\n        System.out.println(sol.count_up_to(18)); // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digit of 'a'\n        int unitDigitA = Math.abs(a) % 10;\n        \n        // Extract the unit digit of 'b'\n        int unitDigitB = Math.abs(b) % 10;\n        \n        // Multiply the unit digits\n        int result = unitDigitA * unitDigitB;\n        \n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        \n        // Iterate through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            // Check if the character is an uppercase vowel\n            if (uppercaseVowels.contains(ch)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_upper(\"aBCdEf\")); // Output: 1\n        System.out.println(sol.count_upper(\"abcdefg\")); // Output: 0\n        System.out.println(sol.count_upper(\"dBBE\")); // Output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        // Parse the string to a double\n        double number = Double.parseDouble(value);\n        \n        // Check if the number is exactly halfway between two integers\n        if (number % 1 == 0.5) {\n            // If the number is positive, round up\n            if (number > 0) {\n                return (int) Math.ceil(number);\n            }\n            // If the number is negative, round down\n            else {\n                return (int) Math.floor(number);\n            }\n        } else {\n            // For other cases, use standard rounding\n            return (int) Math.round(number);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.closest_integer(\"10\"));    // 10\n        System.out.println(sol.closest_integer(\"15.3\"));  // 15\n        System.out.println(sol.closest_integer(\"14.5\"));  // 15\n        System.out.println(sol.closest_integer(\"-14.5\")); // -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int current = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            if (current % 2 == 0) {\n                current += 2; // Next even number\n            } else {\n                current += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.make_a_pile(3)); // Output: [3, 5, 7]\n        System.out.println(sol.make_a_pile(4)); // Output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     */\n    public List<String> words_string(String s) {\n        // Split the string using the regular expression [,\\\\s]+\n        String[] wordsArray = s.split(\"[,\\\\s]+\");\n        \n        // Convert the array to a List and return it\n        return Arrays.asList(wordsArray);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure the range is valid\n        if (x > y) {\n            return -1;\n        }\n        \n        // Iterate from y down to x to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n        \n        // If no even number is found, return -1\n        return -1;\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Step 1: Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n        \n        // Step 2: Calculate the sum of integers from n to m\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        // Step 3: Compute the average\n        int count = m - n + 1;\n        double average = (double) sum / count;\n        \n        // Step 4: Round the average to the nearest integer\n        int roundedAverage = (int) Math.round(average);\n        \n        // Step 5: Convert the rounded average to binary\n        String binaryRepresentation = Integer.toBinaryString(roundedAverage);\n        \n        return binaryRepresentation;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.rounded_avg(1, 5)); // \"11\"\n        System.out.println(sol.rounded_avg(7, 5)); // -1\n        System.out.println(sol.rounded_avg(10, 20)); // \"1111\"\n        System.out.println(sol.rounded_avg(20, 33)); // \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all\n     * elements that hasn't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     *\n     * For example:\n     * >>> unique_digits(Arrays.asList(15, 33, 1422, 1))\n     * [1, 15, 33]\n     * >>> unique_digits(Arrays.asList(152, 323, 1422, 10))\n     * []\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!containsEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n    \n    private boolean containsEvenDigit(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            num /= 10;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.unique_digits(Arrays.asList(15, 33, 1422, 1))); // [1, 15, 33]\n        System.out.println(sol.unique_digits(Arrays.asList(152, 323, 1422, 10))); // []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter and sort the array\n        List<Integer> filteredAndSorted = arr.stream()\n                                             .filter(num -> num >= 1 && num <= 9)\n                                             .sorted()\n                                             .collect(Collectors.toList());\n        \n        // Step 2: Reverse the sorted array\n        Collections.reverse(filteredAndSorted);\n        \n        // Step 3: Map each digit to its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredAndSorted) {\n            result.add(getNumberName(num));\n        }\n        \n        return result;\n    }\n    \n    private String getNumberName(int num) {\n        switch (num) {\n            case 1: return \"One\";\n            case 2: return \"Two\";\n            case 3: return \"Three\";\n            case 4: return \"Four\";\n            case 5: return \"Five\";\n            case 6: return \"Six\";\n            case 7: return \"Seven\";\n            case 8: return \"Eight\";\n            case 9: return \"Nine\";\n            default: throw new IllegalArgumentException(\"Number out of range: \" + num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(sol.by_length(arr1)); // Output: [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n        \n        List<Integer> arr2 = Arrays.asList();\n        System.out.println(sol.by_length(arr2)); // Output: []\n        \n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(sol.by_length(arr3)); // Output: [\"One\"]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Compute factorial of i\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Compute sum of numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n    \n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int len = str.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(sol.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     * >>> count_nums(Arrays.asList()) == 0\n     * >>> count_nums(Arrays.asList(-1, 11, -11)) == 1\n     * >>> count_nums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            int sumOfDigits = 0;\n            String numStr = Integer.toString(num);\n            \n            for (int i = 0; i < numStr.length(); i++) {\n                char ch = numStr.charAt(i);\n                if (ch == '-') {\n                    continue; // Skip the negative sign\n                }\n                int digit = Character.getNumericValue(ch);\n                if (i == 0 && num < 0) {\n                    digit = -digit; // First digit of a negative number is negative\n                }\n                sumOfDigits += digit;\n            }\n            \n            if (sumOfDigits > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_nums(Arrays.asList())); // 0\n        System.out.println(sol.count_nums(Arrays.asList(-1, 11, -11))); // 1\n        System.out.println(sol.count_nums(Arrays.asList(1, 1, 2))); // 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        int breakPoints = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (arr.get(i) > arr.get((i + 1) % n)) {\n                breakPoints++;\n            }\n        }\n\n        return breakPoints <= 1;\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count the number of odd elements in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        // Count the number of even elements in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // Check if we have enough even elements in lst2 to replace all odd elements in lst1\n        if (evenCountInLst2 >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // \"YES\"\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Step 1: Split the input string into individual letters\n        String[] letters = test.split(\" \");\n        \n        // Step 2: Use a map to count the frequency of each letter\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String letter : letters) {\n            frequencyMap.put(letter, frequencyMap.getOrDefault(letter, 0) + 1);\n        }\n        \n        // Step 3: Determine the maximum frequency\n        int maxFrequency = 0;\n        for (int frequency : frequencyMap.values()) {\n            if (frequency > maxFrequency) {\n                maxFrequency = frequency;\n            }\n        }\n        \n        // Step 4: Collect letters with the maximum frequency\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() == maxFrequency) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        // Step 5: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Step 1: Remove characters from s that are in c\n        StringBuilder result = new StringBuilder();\n        Set<Character> charsToRemove = new HashSet<>();\n        \n        // Add characters from c to the set\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n        \n        // Build the result string by excluding characters in charsToRemove\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                result.append(ch);\n            }\n        }\n        \n        // Step 2: Check if the result string is a palindrome\n        boolean isPalindrome = true;\n        int len = result.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (result.charAt(i) != result.charAt(len - i - 1)) {\n                isPalindrome = false;\n                break;\n            }\n        }\n        \n        // Step 3: Return the result string and the palindrome check result\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(result.toString());\n        resultList.add(isPalindrome);\n        \n        return resultList;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.reverse_delete(\"abcde\", \"ae\")); // [\"bcd\", false]\n        System.out.println(sol.reverse_delete(\"abcdef\", \"b\")); // [\"acdef\", false]\n        System.out.println(sol.reverse_delete(\"abcdedcba\", \"ab\")); // [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n            int oddCount = 0;\n            \n            // Count the number of odd digits in the current string\n            for (char ch : str.toCharArray()) {\n                if (Character.isDigit(ch) && (ch - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            \n            // Construct the output string\n            String output = String.format(\"the number of odd elements %dn the str%dng %d of the %dnput.\", oddCount, oddCount, oddCount, oddCount);\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.odd_count(Arrays.asList(\"1234567\")));\n        // Expected output: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        System.out.println(sol.odd_count(Arrays.asList(\"3\", \"11111111\")));\n        // Expected output: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        // Initialize the minimum sum ending here and the minimum sum so far\n        int minEndingHere = nums.get(0);\n        int minSoFar = nums.get(0);\n        \n        // Iterate through the list starting from the second element\n        for (int i = 1; i < nums.size(); i++) {\n            int current = nums.get(i);\n            // Update minEndingHere to be the minimum of the current element or the sum of minEndingHere and the current element\n            minEndingHere = Math.min(current, minEndingHere + current);\n            // Update minSoFar to be the minimum of minSoFar and minEndingHere\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n        \n        // Return the minimum sum of any non-empty sub-array\n        return minSoFar;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Output: 1\n        System.out.println(sol.minSubArraySum(Arrays.asList(-1, -2, -3))); // Output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalBucketsLowered = 0;\n        \n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n            for (int cell : row) {\n                if (cell == 1) {\n                    waterUnits++;\n                }\n            }\n            // Calculate the number of times the bucket needs to be lowered\n            int bucketsNeeded = (int) Math.ceil((double) waterUnits / capacity);\n            totalBucketsLowered += bucketsNeeded;\n        }\n        \n        return totalBucketsLowered;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(sol.max_fill(grid1, capacity1)); // Output: 6\n        \n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(sol.max_fill(grid2, capacity2)); // Output: 5\n        \n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(sol.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation in ascending order.\n     * For similar number of ones, sorts based on decimal value.\n     * \n     * @param arr The list of integers to be sorted.\n     * @return The sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Use a custom comparator to sort the array\n        arr.sort((a, b) -> {\n            // Count the number of ones in the binary representation of a and b\n            int countA = Integer.bitCount(a);\n            int countB = Integer.bitCount(b);\n            \n            // If the number of ones is the same, sort by decimal value\n            if (countA == countB) {\n                return Integer.compare(a, b);\n            }\n            \n            // Otherwise, sort by the number of ones\n            return Integer.compare(countA, countB);\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))); // true\n        System.out.println(solution.sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))); // true\n        System.out.println(solution.sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))); // true\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // List to store the result\n        List<String> result = new ArrayList<>();\n        \n        // If the input string is empty, return the empty list\n        if (s.isEmpty()) {\n            return result;\n        }\n        \n        // Split the string into words\n        String[] words = s.split(\" \");\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Count the number of consonants in the word\n            int consonantCount = countConsonants(word);\n            \n            // If the consonant count matches n, add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n    \n    // Helper method to count consonants in a word\n    private int countConsonants(String word) {\n        int count = 0;\n        // Convert the word to lowercase to handle case insensitivity\n        word = word.toLowerCase();\n        \n        // Iterate through each character in the word\n        for (char c : word.toCharArray()) {\n            // Check if the character is a consonant\n            if (isConsonant(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    // Helper method to check if a character is a consonant\n    private boolean isConsonant(char c) {\n        // Define the set of vowels\n        String vowels = \"aeiou\";\n        \n        // Check if the character is a letter and not a vowel\n        return Character.isLetter(c) && vowels.indexOf(c) == -1;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        // Define the set of vowels (case sensitive)\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Traverse the word from right to left\n        for (int i = word.length() - 1; i >= 0; i--) {\n            char currentChar = word.charAt(i);\n            \n            // Check if the current character is a consonant\n            if (!vowels.contains(currentChar) && Character.isLetter(currentChar)) {\n                // Check the next character (moving leftwards)\n                for (int j = i - 1; j >= 0; j--) {\n                    char nextChar = word.charAt(j);\n                    \n                    // If the next character is a vowel\n                    if (vowels.contains(nextChar)) {\n                        // Check the character before the vowel\n                        if (j - 1 >= 0 && !vowels.contains(word.charAt(j - 1)) && Character.isLetter(word.charAt(j - 1))) {\n                            return String.valueOf(nextChar);\n                        }\n                    }\n                }\n            }\n        }\n        \n        // If no such vowel is found, return an empty string\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_closest_vowel(\"yogurt\")); // \"u\"\n        System.out.println(sol.get_closest_vowel(\"FULL\"));   // \"U\"\n        System.out.println(sol.get_closest_vowel(\"quick\"));  // \"\"\n        System.out.println(sol.get_closest_vowel(\"ab\"));     // \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int openCount = 0;\n        int closeCount = 0;\n\n        // Count the number of opening and closing parentheses in both strings\n        for (String str : lst) {\n            for (char ch : str.toCharArray()) {\n                if (ch == '(') {\n                    openCount++;\n                } else if (ch == ')') {\n                    closeCount++;\n                }\n            }\n        }\n\n        // Check if the counts of opening and closing parentheses are equal\n        if (openCount == closeCount) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.match_parens(Arrays.asList(\"()(\", \")\"))); // Output: \"Yes\"\n        System.out.println(sol.match_parens(Arrays.asList(\")\", \")\"))); // Output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in ascending order\n        Collections.sort(arr);\n        \n        // Step 2: Select the top k elements from the end of the sorted array\n        List<Integer> result = new ArrayList<>();\n        for (int i = arr.size() - k; i < arr.size(); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Step 3: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3)); // Output: [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2)); // Output: [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0) { // Check if the index is even\n                if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                    sum += lst.get(i);\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        \n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            int num = arr.get(i);\n            \n            // Check if the number has at most two digits\n            if (num >= 0 && num <= 99) {\n                sum += num;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        \n        int result = sol.add_elements(arr, k);\n        System.out.println(result); // Output: 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddNumbers = new ArrayList<>();\n        \n        // Start with the given number\n        int current = n;\n        \n        // Loop until we reach 1\n        while (current != 1) {\n            // Check if the current number is odd\n            if (current % 2 != 0) {\n                oddNumbers.add(current);\n            }\n            \n            // Generate the next number in the sequence\n            if (current % 2 == 0) {\n                current = current / 2;\n            } else {\n                current = 3 * current + 1;\n            }\n        }\n        \n        // Add 1 to the list as it is always the last number in the sequence\n        oddNumbers.add(1);\n        \n        // Sort the list in increasing order\n        Collections.sort(oddNumbers);\n        \n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.get_odd_collatz(5)); // Output: [1, 5]\n        System.out.println(sol.get_odd_collatz(1)); // Output: [1]\n        System.out.println(sol.get_odd_collatz(10)); // Output: [1, 5]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Validates a given date string and returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\n     *    And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\n     *    And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * @param date The date string to validate.\n     * @return true if the date is valid, false otherwise.\n     */\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Check if the date string matches the format mm-dd-yyyy\n        if (!date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) {\n            return false;\n        }\n\n        // Split the date string into month, day, and year\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is valid\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Check if the day is valid based on the month\n        if (month == 2) {\n            // February can have 29 days in a leap year, otherwise 28\n            if (day < 1 || day > 29) {\n                return false;\n            }\n            // Check for leap year\n            if (day == 29 && !isLeapYear(year)) {\n                return false;\n            }\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            // April, June, September, November have 30 days\n            if (day < 1 || day > 30) {\n                return false;\n            }\n        } else {\n            // All other months have 31 days\n            if (day < 1 || day > 31) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    /**\n     * Helper method to determine if a given year is a leap year.\n     * @param year The year to check.\n     * @return true if the year is a leap year, false otherwise.\n     */\n    private boolean isLeapYear(int year) {\n        if (year % 4 == 0) {\n            if (year % 100 == 0) {\n                return year % 400 == 0;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-00-2040\")); // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        \n        // Check for commas\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        }\n        \n        // Count lowercase letters with odd alphabet indices\n        int oddCount = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 != 0) {\n                    oddCount++;\n                }\n            }\n        }\n        \n        return oddCount;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"abcdef\")); // 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // Edge case: If the list is empty or has only one element, it is trivially sorted.\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        // HashMap to count occurrences of each number\n        Map<Integer, Integer> countMap = new HashMap<>();\n\n        // Iterate through the list to check both conditions\n        for (int i = 0; i < lst.size() - 1; i++) {\n            int current = lst.get(i);\n            int next = lst.get(i + 1);\n\n            // Check if the list is sorted\n            if (current > next) {\n                return false;\n            }\n\n            // Update the count of the current number\n            countMap.put(current, countMap.getOrDefault(current, 0) + 1);\n\n            // If the count exceeds 2, return false\n            if (countMap.get(current) > 2) {\n                return false;\n            }\n        }\n\n        // Check the last element\n        int last = lst.get(lst.size() - 1);\n        countMap.put(last, countMap.getOrDefault(last, 0) + 1);\n        if (countMap.get(last) > 2) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_sorted(Arrays.asList(5))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        // Find the intersection\n        int intersectionStart = Math.max(start1, start2);\n        int intersectionEnd = Math.min(end1, end2);\n\n        // Check if the intervals intersect\n        if (intersectionStart <= intersectionEnd) {\n            int intersectionLength = intersectionEnd - intersectionStart + 1;\n            if (isPrime(intersectionLength)) {\n                return \"YES\";\n            }\n        }\n        return \"NO\";\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // \"NO\"\n        System.out.println(sol.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // \"NO\"\n        System.out.println(sol.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // \"YES\"\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        // Step 1: Check if the array is empty\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Step 2: Determine the product of signs\n        int signProduct = 1;\n        int sumOfMagnitudes = 0;\n\n        for (int num : arr) {\n            if (num > 0) {\n                signProduct *= 1;\n            } else if (num < 0) {\n                signProduct *= -1;\n            } else {\n                signProduct *= 0;\n            }\n            sumOfMagnitudes += Math.abs(num);\n        }\n\n        // Step 3: Multiply the sum of magnitudes by the product of signs\n        int result = sumOfMagnitudes * signProduct;\n\n        // Step 4: Return the result wrapped in an Optional\n        return Optional.of(result);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1))); // Output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList())); // Output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        if (n == 0) return new ArrayList<>();\n        \n        // Custom comparator for comparing List<Integer> lexicographically\n        Comparator<List<Integer>> listComparator = (list1, list2) -> {\n            int minLength = Math.min(list1.size(), list2.size());\n            for (int i = 0; i < minLength; i++) {\n                int cmp = Integer.compare(list1.get(i), list2.get(i));\n                if (cmp != 0) {\n                    return cmp;\n                }\n            }\n            return Integer.compare(list1.size(), list2.size());\n        };\n        \n        // Priority queue to store paths lexicographically\n        PriorityQueue<Path> pq = new PriorityQueue<>(Comparator.comparing(Path::getPath, listComparator));\n        \n        // Initialize the priority queue with all starting points\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                pq.offer(new Path(new ArrayList<>(Arrays.asList(grid.get(i).get(j))), i, j));\n            }\n        }\n        \n        // Directions for moving in the grid (up, down, left, right)\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!pq.isEmpty()) {\n            Path current = pq.poll();\n            List<Integer> currentPath = current.getPath();\n            int currentLength = currentPath.size();\n            \n            // If the current path length is k, return it as the result\n            if (currentLength == k) {\n                return currentPath;\n            }\n            \n            // Explore neighbors\n            for (int[] dir : directions) {\n                int newRow = current.getRow() + dir[0];\n                int newCol = current.getCol() + dir[1];\n                \n                // Check if the new position is within the grid\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                    List<Integer> newPath = new ArrayList<>(currentPath);\n                    newPath.add(grid.get(newRow).get(newCol));\n                    pq.offer(new Path(newPath, newRow, newCol));\n                }\n            }\n        }\n        \n        // If no path of length k is found, return an empty list (shouldn't happen as per problem statement)\n        return new ArrayList<>();\n    }\n    \n    // Helper class to store the path and its current position\n    private static class Path {\n        private List<Integer> path;\n        private int row;\n        private int col;\n        \n        public Path(List<Integer> path, int row, int col) {\n            this.path = path;\n            this.row = row;\n            this.col = col;\n        }\n        \n        public List<Integer> getPath() {\n            return path;\n        }\n        \n        public int getRow() {\n            return row;\n        }\n        \n        public int getCol() {\n            return col;\n        }\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Base case\n        result.add(3); // tri(1) = 3\n        \n        for (int i = 2; i <= n + 1; i++) {\n            if (i % 2 == 0) {\n                // Even case\n                result.add(1 + i / 2);\n            } else {\n                // Odd case\n                int prev1 = result.get(i - 2); // tri(i - 1)\n                int prev2 = result.get(i - 3); // tri(i - 2)\n                int next1 = 1 + (i + 1) / 2;  // tri(i + 1)\n                result.add(prev1 + prev2 + next1);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.tri(3)); // Output: [3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Initialize the product to 1\n        int product = 1;\n        \n        // Convert the number to a string to iterate through each digit\n        String numStr = Integer.toString(n);\n        \n        // Flag to check if any odd digit is found\n        boolean hasOddDigit = false;\n        \n        // Iterate through each character in the string\n        for (char ch : numStr.toCharArray()) {\n            // Convert the character to an integer\n            int digit = Character.getNumericValue(ch);\n            \n            // Check if the digit is odd\n            if (digit % 2 != 0) {\n                // Multiply the product by the odd digit\n                product *= digit;\n                // Set the flag to true as we found an odd digit\n                hasOddDigit = true;\n            }\n        }\n        \n        // If no odd digit was found, return 0\n        if (!hasOddDigit) {\n            return 0;\n        }\n        \n        // Return the product of the odd digits\n        return product;\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n            } else if (ch == ']') {\n                if (!stack.isEmpty() && stack.peek() == '[') {\n                    return true; // Found a nested pair\n                }\n                // Clear the stack to handle cases like \"[]]]]]]][[[[[]\"\n                stack.clear();\n            }\n        }\n        \n        return false; // No nested brackets found\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_nested(\"[[]]\")); // true\n        System.out.println(sol.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(sol.is_nested(\"[][]\")); // false\n        System.out.println(sol.is_nested(\"[]\")); // false\n        System.out.println(sol.is_nested(\"[[][]]\")); // true\n        System.out.println(sol.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        \n        for (Double num : lst) {\n            // Round up to the nearest integer\n            int roundedNum = (int) Math.ceil(num);\n            // Square the rounded number\n            int squaredNum = roundedNum * roundedNum;\n            // Add to the sum\n            sum += squaredNum;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(sol.sum_squares(lst1)); // Output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(sol.sum_squares(lst2)); // Output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(sol.sum_squares(lst3)); // Output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(sol.sum_squares(lst4)); // Output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(sol.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") -> false\n    check_if_last_char_is_a_letter(\"apple pi e\") -> true\n    check_if_last_char_is_a_letter(\"apple pi e \") -> false\n    check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt.isEmpty()) {\n            return false;\n        }\n\n        // Get the last character\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is an alphabetical character\n        if (Character.isLetter(lastChar)) {\n            // Check if the last character is not part of a word\n            if (txt.length() == 1 || !Character.isLetter(txt.charAt(txt.length() - 2))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < arr.size(); i++) {\n            // Check if the current element is not greater than or equal to the previous element\n            if (arr.get(i) < arr.get(i - 1)) {\n                // Return the index of the current element\n                return i;\n            }\n        }\n        // If no such element is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (!largestNegative.isPresent() || num > largestNegative.get()) {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // (Optional.empty(), Optional.empty())\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        // Convert both inputs to floats\n        Float floatA = convertToFloat(a);\n        Float floatB = convertToFloat(b);\n\n        // If either conversion failed, return Optional.empty()\n        if (floatA == null || floatB == null) {\n            return Optional.empty();\n        }\n\n        // Compare the floats\n        if (floatA > floatB) {\n            return Optional.of(a);\n        } else if (floatB > floatA) {\n            return Optional.of(b);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    private Float convertToFloat(Object obj) {\n        if (obj instanceof Number) {\n            return ((Number) obj).floatValue();\n        } else if (obj instanceof String) {\n            String str = (String) obj;\n            try {\n                // Replace commas with dots and parse as float\n                return Float.parseFloat(str.replace(',', '.'));\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "public boolean is_equal_to_sum_even(int n) {\n    // If n is less than 8, it cannot be the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n    \n    // If n is odd, it cannot be the sum of 4 even numbers\n    if (n % 2 != 0) {\n        return false;\n    }\n    \n    // Iterate through possible combinations of four positive even numbers\n    for (int i = 2; i <= n / 4; i += 2) {\n        for (int j = i; j <= (n - i) / 3; j += 2) {\n            for (int k = j; k <= (n - i - j) / 2; k += 2) {\n                int l = n - i - j - k;\n                // Ensure l is a positive even number\n                if (l > 0 && l % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    // If no combination is found, return false\n    return false;\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to compute the factorial of a given number.\n     * @param num The number to compute the factorial for.\n     * @return The factorial of the given number.\n     */\n    private long factorial(int num) {\n        long result = 1;\n        for (int i = 1; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    /**\n     * Computes the Brazilian factorial of a given number.\n     * @param n The number to compute the Brazilian factorial for.\n     * @return The Brazilian factorial of the given number.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = n; i >= 1; i--) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.special_factorial(4)); // Output should be 288\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Replace all single spaces with underscores\n        text = text.replace(\" \", \"_\");\n        \n        // Use a regular expression to find sequences of more than 2 consecutive underscores\n        // and replace them with a single hyphen\n        text = text.replaceAll(\"_{2,}\", \"-\");\n        \n        return text;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\")); // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\")); // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\")); // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\")); // \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotIndex = file_name.indexOf('.');\n        if (dotIndex == -1 || dotIndex != file_name.lastIndexOf('.')) {\n            return \"No\";\n        }\n\n        // Split the file name into prefix and suffix\n        String prefix = file_name.substring(0, dotIndex);\n        String suffix = file_name.substring(dotIndex + 1);\n\n        // Check if the prefix is not empty and starts with a Latin alphabet letter\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check if the suffix is one of the allowed extensions\n        List<String> allowedExtensions = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!allowedExtensions.contains(suffix)) {\n            return \"No\";\n        }\n\n        // Count the digits in the prefix\n        int digitCount = 0;\n        for (char c : prefix.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n                if (digitCount > 3) {\n                    return \"No\";\n                }\n            }\n        }\n\n        // If all conditions are met, return \"Yes\"\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.file_name_check(\"example.txt\")); // => \"Yes\"\n        System.out.println(solution.file_name_check(\"1example.dll\")); // => \"No\"\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int value = lst.get(i);\n            \n            if (i % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                value = value * value;\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the value if index is a multiple of 4 but not a multiple of 3\n                value = value * value * value;\n            }\n            \n            // Add the transformed value to the sum\n            sum += value;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(sol.sum_squares(lst1)); // Output: 6\n        \n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(sol.sum_squares(lst2)); // Output: 0\n        \n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(sol.sum_squares(lst3)); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to collect the words with prime length\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Check if the length of the word is a prime number\n            if (isPrime(word.length())) {\n                // Append the word to the result\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        // Return the resulting string\n        return result.toString();\n    }\n    \n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(sol.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the input fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n        \n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n        \n        // Compute the product of the two fractions\n        int numeratorProduct = numeratorX * numeratorN;\n        int denominatorProduct = denominatorX * denominatorN;\n        \n        // Simplify the resulting fraction\n        int gcd = gcd(numeratorProduct, denominatorProduct);\n        numeratorProduct /= gcd;\n        denominatorProduct /= gcd;\n        \n        // Check if the simplified fraction is a whole number\n        return denominatorProduct == 1;\n    }\n    \n    // Helper method to compute the greatest common divisor (GCD) using Euclidean algorithm\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (sum of digits, original number)\n        List<Pair> pairs = new ArrayList<>();\n        for (int num : nums) {\n            pairs.add(new Pair(sumOfDigits(num), num));\n        }\n\n        // Sort the list of pairs based on the sum of digits\n        Collections.sort(pairs, Comparator.comparingInt(Pair::getSumOfDigits));\n\n        // Extract the sorted numbers from the pairs\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.getNum());\n        }\n\n        return sortedNums;\n    }\n\n    // Helper method to calculate the sum of digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n\n        while (num > 0) {\n            int digit = num % 10;\n            sum += digit;\n            num /= 10;\n        }\n\n        // If the number was negative, the first digit should be negative\n        if (isNegative) {\n            sum = -sum;\n        }\n\n        return sum;\n    }\n\n    // Helper class to store the sum of digits and the original number\n    private static class Pair {\n        private final int sumOfDigits;\n        private final int num;\n\n        public Pair(int sumOfDigits, int num) {\n            this.sumOfDigits = sumOfDigits;\n            this.num = num;\n        }\n\n        public int getSumOfDigits() {\n            return sumOfDigits;\n        }\n\n        public int getNum() {\n            return num;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.order_by_points(Arrays.asList(1, 11, -1, -11, -12))); // [-1, -11, 1, -12, 11]\n        System.out.println(solution.order_by_points(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an array of numbers as input and returns\n    the number of elements in the array that are greater than 10 and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n    specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        \n        for (int num : nums) {\n            if (num > 10) {\n                int absNum = Math.abs(num);\n                int lastDigit = absNum % 10;\n                \n                // Find the first digit\n                while (absNum >= 10) {\n                    absNum /= 10;\n                }\n                int firstDigit = absNum;\n                \n                // Check if both first and last digits are odd\n                if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Generate the array a\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Step 2: Initialize the count of valid triples\n        int count = 0;\n\n        // Step 3: Iterate through all possible triples (i, j, k)\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    // Step 4: Check if the sum of the elements at these indices is a multiple of 3\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Step 5: Return the count of valid triples\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_max_triples(5)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    );\n\n    public List<String> bf(String planet1, String planet2) {\n        // Validate the input planets\n        if (!PLANETS.contains(planet1) || !PLANETS.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        // Find the indices of the planets\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for proper range extraction\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Extract the planets between index1 and index2 (exclusive)\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\")); // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\")); // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Step 2: Sort the filtered list\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                // First, compare by length\n                int lengthCompare = Integer.compare(s1.length(), s2.length());\n                if (lengthCompare != 0) {\n                    return lengthCompare;\n                }\n                // If lengths are the same, compare alphabetically\n                return s1.compareTo(s2);\n            }\n        });\n\n        // Step 3: Return the sorted list\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        List<String> result1 = solution.sorted_list_sum(test1);\n        System.out.println(result1); // Output: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        List<String> result2 = solution.sorted_list_sum(test2);\n        System.out.println(result2); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        // Handle the special case where n is less than 2\n        if (n < 2) {\n            return y;\n        }\n        \n        // Check for primality by testing divisibility from 2 to sqrt(n)\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return y; // n is not a prime number\n            }\n        }\n        \n        // If no divisors were found, n is a prime number\n        return x;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.x_or_y(7, 34, 12)); // Output: 34\n        System.out.println(sol.x_or_y(15, 8, 5)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n        \n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num;\n                }\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through both lists\n        for (int i = 0; i < game.size(); i++) {\n            int gameScore = game.get(i);\n            int guessScore = guess.get(i);\n            \n            // Compare the scores\n            if (gameScore == guessScore) {\n                result.add(0);\n            } else {\n                result.add(Math.abs(gameScore - guessScore));\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2))); // [0, 0, 0, 0, 3, 3]\n        System.out.println(solution.compare(Arrays.asList(0, 5, 0, 0, 0, 4), Arrays.asList(4, 1, 1, 0, 0, -2))); // [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            int cap = 0;\n            int sm = 0;\n\n            // Calculate CAP and SM for the current extension\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n\n            // Calculate the strength of the current extension\n            int strength = cap - sm;\n\n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Output: \"Slices.SErviNGSliCes\"\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Output: \"my_class.AA\"\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Step 1: Concatenate the second word with itself\n        String concatenated = b + b;\n        \n        // Step 2: Check if the first word is a substring of the concatenated string\n        return concatenated.contains(a);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(sol.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(sol.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(sol.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(sol.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(sol.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer, return a list that has the number of even and odd digits respectively.\n    \n     Example:\n        even_odd_count(-12) ==> [1, 1]\n        even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to its absolute value to handle negative numbers\n        num = Math.abs(num);\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Iterate through each digit of the number\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                evenCount++; // Increment even count if the digit is even\n            } else {\n                oddCount++; // Increment odd count if the digit is odd\n            }\n            num /= 10; // Remove the last digit\n        }\n        \n        // Return the counts as a list\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.even_odd_count(-12)); // Output: [1, 1]\n        System.out.println(sol.even_odd_count(123)); // Output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        \n        StringBuilder roman = new StringBuilder();\n        \n        // Iterate through the values and symbols\n        for (int i = 0; i < values.length; i++) {\n            // While the current value can be subtracted from the number\n            while (number >= values[i]) {\n                // Subtract the value from the number\n                number -= values[i];\n                // Append the corresponding symbol to the result\n                roman.append(symbols[i]);\n            }\n        }\n        \n        // Convert the result to lowercase (though symbols are already in lowercase)\n        return roman.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(sol.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(sol.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Identify the longest side\n        int maxSide = Math.max(a, Math.max(b, c));\n        \n        // Determine the other two sides\n        int side1, side2;\n        if (maxSide == a) {\n            side1 = b;\n            side2 = c;\n        } else if (maxSide == b) {\n            side1 = a;\n            side2 = c;\n        } else {\n            side1 = a;\n            side2 = b;\n        }\n        \n        // Check the Pythagorean theorem\n        return (side1 * side1 + side2 * side2 == maxSide * maxSide);\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * find_max([\"name\", \"of\", \"string\"]) == \"string\"\n     * find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n     * find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            // Use a HashSet to count unique characters in the word\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            int uniqueCount = uniqueChars.size();\n\n            // Check if the current word has more unique characters\n            // or if it has the same number but is lexicographically smaller\n            if (uniqueCount > maxUniqueChars || (uniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1)); // Output: \"string\"\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2)); // Output: \"enam\"\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3)); // Output: \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots eaten\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate the number of carrots left\n        int carrotsLeft = Math.max(0, remaining - need);\n        \n        // Return the result as a list\n        return Arrays.asList(totalEaten, carrotsLeft);\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Stack to hold operands\n        Stack<Integer> operands = new Stack<>();\n        // Stack to hold operators\n        Stack<String> operators = new Stack<>();\n        \n        // Initialize the stacks with the first operand\n        operands.push(operand.get(0));\n        \n        // Iterate through the operators and operands\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int nextOperand = operand.get(i + 1);\n            \n            // Handle exponentiation first\n            if (op.equals(\"**\")) {\n                int prevOperand = operands.pop();\n                operands.push((int) Math.pow(prevOperand, nextOperand));\n            } else {\n                // Push the current operator and next operand\n                operators.push(op);\n                operands.push(nextOperand);\n            }\n        }\n        \n        // Now handle multiplication and division\n        Stack<Integer> tempOperands = new Stack<>();\n        Stack<String> tempOperators = new Stack<>();\n        \n        while (!operators.isEmpty()) {\n            String op = operators.pop();\n            int rightOperand = operands.pop();\n            int leftOperand = operands.pop();\n            \n            if (op.equals(\"*\")) {\n                operands.push(leftOperand * rightOperand);\n            } else if (op.equals(\"/\")) {\n                operands.push(leftOperand / rightOperand);\n            } else {\n                tempOperands.push(leftOperand);\n                tempOperators.push(op);\n                operands.push(rightOperand);\n            }\n        }\n        \n        // Push the last operand if any\n        if (!operands.isEmpty()) {\n            tempOperands.push(operands.pop());\n        }\n        \n        // Reverse the temp stacks to maintain the correct order\n        operands = tempOperands;\n        operators = tempOperators;\n        \n        // Now handle addition and subtraction\n        while (!operators.isEmpty()) {\n            String op = operators.pop();\n            int rightOperand = operands.pop();\n            int leftOperand = operands.pop();\n            \n            if (op.equals(\"+\")) {\n                operands.push(leftOperand + rightOperand);\n            } else if (op.equals(\"-\")) {\n                operands.push(leftOperand - rightOperand);\n            }\n        }\n        \n        // The final result should be the only element left in the operands stack\n        return operands.pop();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        System.out.println(sol.do_algebra(operator, operand)); // Output: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean containsLetter = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                break;\n            }\n        }\n\n        // If the string contains no letters, reverse the string\n        if (!containsLetter) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // If the string contains letters, process each character\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Reverse the case of the letter\n                if (Character.isUpperCase(c)) {\n                    result.append(Character.toLowerCase(c));\n                } else {\n                    result.append(Character.toUpperCase(c));\n                }\n            } else {\n                // Keep non-letter characters as they are\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solve(\"1234\")); // Output: \"4321\"\n        System.out.println(sol.solve(\"ab\"));   // Output: \"AB\"\n        System.out.println(sol.solve(\"#a@C\")); // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Check if the input string is empty\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Create a MessageDigest instance for MD5\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        // Compute the MD5 hash of the input string\n        byte[] messageDigest = md.digest(text.getBytes());\n\n        // Convert the byte array to a BigInteger\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert the BigInteger to a hexadecimal string\n        String hashtext = no.toString(16);\n\n        // Pad the hexadecimal string with leading zeros if necessary\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        // Return the resulting string wrapped in an Optional\n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Determine the start and end of the range\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n        \n        // Set to store unique even digits\n        Set<Integer> evenDigits = new HashSet<>();\n        \n        // Iterate through the range and collect even digits\n        for (int i = start; i <= end; i++) {\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit % 2 == 0 && digit < 10) {\n                    evenDigits.add(digit);\n                }\n                num /= 10;\n            }\n        }\n        \n        // Convert the set to a sorted list\n        List<Integer> result = new ArrayList<>(evenDigits);\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(10, 14)); // []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Iterate through each pair of numbers in the list\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                // Calculate the absolute difference between the two numbers\n                double difference = Math.abs(numbers.get(i) - numbers.get(j));\n                // Check if the difference is less than the threshold\n                if (difference < threshold) {\n                    return true; // Found a pair of numbers closer than the threshold\n                }\n            }\n        }\n        return false; // No such pair found\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        paren_string = paren_string.replaceAll(\" \", \"\");\n        \n        List<String> result = new ArrayList<>();\n        Stack<Character> stack = new Stack<>();\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char ch : paren_string.toCharArray()) {\n            currentGroup.append(ch);\n            \n            if (ch == '(') {\n                stack.push(ch);\n            } else if (ch == ')') {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    // We've found a balanced group\n                    result.add(currentGroup.toString());\n                    currentGroup.setLength(0); // Reset for the next group\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.separate_paren_groups(\"( ) (( )) (( )( ))\")); // [\"()\", \"(())\", \"(()())\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n     */\n    public double truncate_number(double number) {\n        // Get the integer part of the number\n        int integerPart = (int) number;\n        \n        // Subtract the integer part from the original number to get the decimal part\n        double decimalPart = number - integerPart;\n        \n        return decimalPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5)); // Output: 0.5\n        System.out.println(solution.truncate_number(1.0)); // Output: 0.0\n        System.out.println(solution.truncate_number(0.75)); // Output: 0.75\n        System.out.println(solution.truncate_number(123.456)); // Output: 0.456\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"The input list must not be null or empty.\");\n        }\n\n        // Step 1: Calculate the mean of the dataset\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Compute the absolute differences between each element and the mean\n        double absoluteDeviationsSum = 0.0;\n        for (double number : numbers) {\n            absoluteDeviationsSum += Math.abs(number - mean);\n        }\n\n        // Step 3: Calculate the average of these absolute differences\n        double mad = absoluteDeviationsSum / numbers.size();\n\n        return mad;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(solution.mean_absolute_deviation(numbers)); // Output: 1.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // If the input list is empty, return an empty list\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n\n        // Iterate through the input list\n        for (int i = 0; i < numbers.size(); i++) {\n            // Add the current element to the result list\n            result.add(numbers.get(i));\n\n            // If it's not the last element, add the delimiter\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Split the input string by spaces to get individual groups\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            // Iterate through each character in the group\n            for (char ch : group.toCharArray()) {\n                if (ch == '(') {\n                    currentDepth++;\n                    // Update the maximum depth if the current depth is greater\n                    if (currentDepth > maxDepth) {\n                        maxDepth = currentDepth;\n                    }\n                } else if (ch == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            // Add the maximum depth of the current group to the result list\n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                result.add(str);\n            }\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum to 0 and product to 1\n        int sum = 0;\n        int product = 1;\n\n        // Iterate through the list to calculate sum and product\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        // Return the result as a list\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_product(List.of())); // [0, 1]\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int currentMax = Integer.MIN_VALUE;\n\n        for (int num : numbers) {\n            if (num > currentMax) {\n                currentMax = num;\n            }\n            result.add(currentMax);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> result = solution.rolling_max(numbers);\n        System.out.println(result); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n     */\n    public String make_palindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        // Find the longest palindromic suffix\n        int n = string.length();\n        for (int i = 0; i < n; i++) {\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // Reverse the prefix and append it to the original string\n                String prefix = string.substring(0, i);\n                String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n                return string + reversedPrefix;\n            }\n        }\n\n        // If no palindromic suffix is found, reverse the entire string and append\n        return string + new StringBuilder(string).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n     */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of the same length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Input strings must be of the same length\");\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each character of the strings\n        for (int i = 0; i < a.length(); i++) {\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n\n            // Perform XOR operation\n            if (charA == charB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Output: \"100\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n\n        return Optional.of(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure that a is greater than or equal to b\n        if (b > a) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        // Apply the Euclidean algorithm\n        while (b != 0) {\n            int remainder = a % b;\n            a = b;\n            b = remainder;\n        }\n        \n        // The GCD is the non-zero number left in 'a'\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.greatest_common_divisor(3, 5));  // Output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.all_prefixes(\"abc\")); // Output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String string_sequence(int n) {\n        // Step 1: Initialize a list to store numbers\n        List<String> numbers = new ArrayList<>();\n        \n        // Step 2: Populate the list with numbers from 0 to n\n        for (int i = 0; i <= n; i++) {\n            numbers.add(String.valueOf(i));\n        }\n        \n        // Step 3: Join the numbers with a space delimiter\n        return String.join(\" \", numbers);\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to handle case insensitivity\n        string = string.toLowerCase();\n        \n        // Use a Set to store distinct characters\n        Set<Character> distinctCharacters = new HashSet<>();\n        \n        // Iterate through the string and add each character to the Set\n        for (char c : string.toCharArray()) {\n            distinctCharacters.add(c);\n        }\n        \n        // The size of the Set is the number of distinct characters\n        return distinctCharacters.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        // Initialize the list to store the beats\n        List<Integer> beatsList = new ArrayList<>();\n        \n        // Create a map to store the mapping of notes to beats\n        Map<String, Integer> noteToBeats = new HashMap<>();\n        noteToBeats.put(\"o\", 4);\n        noteToBeats.put(\"o|\", 2);\n        noteToBeats.put(\".|\", 1);\n        \n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Iterate through each note and add the corresponding beats to the list\n        for (String note : notes) {\n            beatsList.add(noteToBeats.get(note));\n        }\n        \n        // Return the list of beats\n        return beatsList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\"));\n        // Output should be: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n     */\n    public int how_many_times(String string, String substring) {\n        int count = 0;\n        int subLength = substring.length();\n        int strLength = string.length();\n        \n        // Iterate through the string and check for the substring\n        for (int i = 0; i <= strLength - subLength; i++) {\n            // Check if the substring matches starting from position i\n            if (string.substring(i, i + subLength).equals(substring)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\")); // 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Step 1: Create a mapping from number words to their corresponding integer values\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Step 2: Split the input string by spaces to get an array of number words\n        String[] numberWords = numbers.split(\" \");\n\n        // Step 3: Sort the array of number words based on their corresponding integer values\n        Arrays.sort(numberWords, new Comparator<String>() {\n            @Override\n            public int compare(String word1, String word2) {\n                return numberMap.get(word1) - numberMap.get(word2);\n            }\n        });\n\n        // Step 4: Join the sorted array back into a single string with spaces\n        return String.join(\" \", numberWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\")); // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements\n        Collections.sort(numbers);\n        \n        // Initialize variables to keep track of the minimum difference and the closest elements\n        double minDifference = Double.MAX_VALUE;\n        double num1 = 0.0;\n        double num2 = 0.0;\n        \n        // Iterate through the sorted list to find the closest elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double currentDifference = numbers.get(i + 1) - numbers.get(i);\n            if (currentDifference < minDifference) {\n                minDifference = currentDifference;\n                num1 = numbers.get(i);\n                num2 = numbers.get(i + 1);\n            }\n        }\n        \n        // Return the closest elements in a list\n        List<Double> result = new ArrayList<>();\n        result.add(num1);\n        result.add(num2);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))); // [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Step 1: Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n        \n        // Step 2: Apply the linear transformation to each number\n        List<Double> rescaledList = new ArrayList<>();\n        for (Double number : numbers) {\n            double rescaledValue = (number - min) / (max - min);\n            rescaledList.add(rescaledValue);\n        }\n        \n        return rescaledList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        List<Double> rescaledNumbers = solution.rescale_to_unit(numbers);\n        System.out.println(rescaledNumbers); // Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1\n        for (int i = n - 1; i > 0; i--) {\n            // Check if i divides n evenly\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found (which shouldn't happen for n > 1), return 1\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_divisor(15)); // Output: 5\n        System.out.println(sol.largest_divisor(28)); // Output: 14\n        System.out.println(sol.largest_divisor(13)); // Output: 1 (since 13 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until n is odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Divide by odd numbers starting from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then n itself is a prime number\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));   // Output: [2, 2, 2]\n        System.out.println(solution.factorize(25));  // Output: [5, 5]\n        System.out.println(solution.factorize(70));  // Output: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : numbers) {\n            if (!seen.contains(num)) {\n                result.add(num);\n                seen.add(num);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> output = solution.remove_duplicates(input);\n        System.out.println(output); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else {\n                flippedString.append(c); // If it's not a letter, just append it as is\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.flip_case(\"Hello\")); // Output: \"hELLO\"\n        System.out.println(solution.flip_case(\"World\")); // Output: \"wORLD\"\n        System.out.println(solution.flip_case(\"Hello, World!\")); // Output: \"hELLO, wORLD!\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        // Create a StringBuilder to efficiently concatenate strings\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through the list of strings and append each string to the StringBuilder\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix(List.of(), \"a\")\n    []\n    >>> filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(n -> n > 0)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    false\n    >>> is_prime(101)\n    true\n    >>> is_prime(11)\n    true\n    >>> is_prime(13441)\n    true\n    >>> is_prime(61)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(1)\n    false\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime\n        }\n        \n        // Check for factors from 3 to sqrt(n)\n        int sqrt = (int) Math.sqrt(n);\n        for (int i = 3; i <= sqrt; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    return xs[1] + 2 * xs[2] * x + 3 * xs[3] * x^2 + .... n * xs[n] * x^(n-1)\n     */\n    public double polyDerivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> find_zero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> find_zero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double find_zero(List<Double> xs) {\n        double tolerance = 1e-7; // Tolerance for convergence\n        int maxIterations = 1000; // Maximum number of iterations to prevent infinite loops\n        double x0 = 0.0; // Initial guess\n        \n        for (int i = 0; i < maxIterations; i++) {\n            double fx = poly(xs, x0);\n            double dfx = polyDerivative(xs, x0);\n            \n            if (Math.abs(fx) < tolerance) {\n                return x0; // Converged to a root\n            }\n            \n            if (dfx == 0) {\n                throw new ArithmeticException(\"Derivative is zero. Newton-Raphson method failed.\");\n            }\n            \n            x0 = x0 - fx / dfx; // Update x0 using Newton-Raphson formula\n        }\n        \n        throw new RuntimeException(\"Failed to converge to a root within the maximum number of iterations.\");\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Create a list to store the values at indices divisible by three\n        List<Integer> valuesToSort = new ArrayList<>();\n        \n        // Iterate through the list and collect values at indices divisible by three\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                valuesToSort.add(l.get(i));\n            }\n        }\n        \n        // Sort the collected values\n        Collections.sort(valuesToSort);\n        \n        // Place the sorted values back into the original list at the correct positions\n        int index = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                l.set(i, valuesToSort.get(index));\n                index++;\n            }\n        }\n        \n        return l;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Step 1: Convert the list to a Set to remove duplicates\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        \n        // Step 2: Convert the Set back to a List\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        \n        // Step 3: Sort the list\n        Collections.sort(uniqueList);\n        \n        // Step 4: Return the sorted list\n        return uniqueList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> result = solution.unique(input);\n        System.out.println(result); // Output: [0, 2, 3, 5, 9, 123]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int max_element(List<Integer> l) {\n        // Check if the list is empty\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        // Initialize the max element with the first element of the list\n        int max = l.get(0);\n\n        // Iterate through the list to find the maximum element\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n\n        return max;\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numberStr = Integer.toString(i);\n                for (char c : numberStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fizz_buzz(50)); // Output: 0\n        System.out.println(sol.fizz_buzz(78)); // Output: 2\n        System.out.println(sol.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sort_even(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to store the sorted even indices values\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Create the result list\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace the even indices in the result list with the sorted values\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex));\n            evenIndex++;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n     */\n    public int prime_fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be a positive integer\");\n        }\n        \n        int count = 0;\n        int a = 0, b = 1;\n        \n        while (true) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                count++;\n                if (count == n) {\n                    return fib;\n                }\n            }\n        }\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        if (num % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to use the two-pointer technique\n        Collections.sort(l);\n        \n        // Iterate through the list\n        for (int i = 0; i < l.size() - 2; i++) {\n            // Skip duplicates to ensure distinct elements\n            if (i > 0 && l.get(i).equals(l.get(i - 1))) {\n                continue;\n            }\n            \n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true; // Found a triplet that sums to zero\n                } else if (sum < 0) {\n                    left++; // Move left pointer to increase the sum\n                } else {\n                    right--; // Move right pointer to decrease the sum\n                }\n            }\n        }\n        \n        return false; // No triplet found that sums to zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function outputs the number of collisions between two sets of cars.\n     */\n    public int car_race_collision(int n) {\n        return n * n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream()\n                .map(i -> i + 1)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairs_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) {\n            return \"0\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base;\n            result.append(remainder);\n            x = x / base;\n        }\n        \n        // The result is built in reverse order, so we need to reverse it\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // \"22\"\n        System.out.println(solution.change_base(8, 2)); // \"1000\"\n        System.out.println(solution.change_base(7, 2)); // \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n     */\n    public double triangle_area(double a, double h) {\n        // Calculate the area using the formula\n        double area = 0.5 * a * h;\n        return area;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test the function with the example provided\n        double result = solution.triangle_area(5, 3);\n        System.out.println(result); // Output should be 7.5\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array to store the last four computed values\n        int[] fibValues = new int[4];\n        fibValues[0] = 0; // fib4(0)\n        fibValues[1] = 0; // fib4(1)\n        fibValues[2] = 2; // fib4(2)\n        fibValues[3] = 0; // fib4(3)\n\n        // Compute the sequence iteratively up to n\n        for (int i = 4; i <= n; i++) {\n            int nextValue = fibValues[0] + fibValues[1] + fibValues[2] + fibValues[3];\n            // Shift the values to the left\n            fibValues[0] = fibValues[1];\n            fibValues[1] = fibValues[2];\n            fibValues[2] = fibValues[3];\n            fibValues[3] = nextValue;\n        }\n\n        // The result is the last computed value\n        return fibValues[3];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    8.0\n     */\n    public double median(List<Integer> l) {\n        // Sort the list\n        Collections.sort(l);\n        \n        int size = l.size();\n        \n        // Check if the size of the list is odd or even\n        if (size % 2 == 1) {\n            // If odd, return the middle element\n            return l.get(size / 2);\n        } else {\n            // If even, return the average of the two middle elements\n            int mid1 = l.get(size / 2 - 1);\n            int mid2 = l.get(size / 2);\n            return (mid1 + mid2) / 2.0;\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n     */\n    public boolean is_palindrome(String text) {\n        // An empty string is considered a palindrome\n        if (text.isEmpty()) {\n            return true;\n        }\n        \n        // Use two pointers to compare characters from the start and end of the string\n        int left = 0;\n        int right = text.length() - 1;\n        \n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/49", "generation": "public class Modp {\n    public int modp(int n, int p) {\n        if (n == 0) {\n            return 1;\n        }\n        \n        int result = 1;\n        int base = 2;\n        \n        while (n > 0) {\n            // If n is odd, multiply base with result and take modulo p\n            if (n % 2 == 1) {\n                result = (result * base) % p;\n            }\n            // n must be even now\n            n = n >> 1; // n = n / 2\n            base = (base * base) % p; // Change base to base^2 % p\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Calculate the new character by shifting back 5 positions\n            char decodedChar = (char) ('a' + ((ch - 5 - 'a' + 26) % 26));\n            sb.append(decodedChar);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for quick lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Use a StringBuilder to construct the result string\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string\n        for (char c : text.toCharArray()) {\n            // If the character is not a vowel, append it to the result\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Adds two integers.\n     *\n     * @param x the first integer\n     * @param y the second integer\n     * @return the sum of x and y\n     *\n     * Example usage:\n     * add(2, 3) returns 5\n     * add(5, 7) returns 12\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if two words have the same kind of characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create frequency maps for both strings\n        Map<Character, Integer> freqMap0 = getFrequencyMap(s0);\n        Map<Character, Integer> freqMap1 = getFrequencyMap(s1);\n        \n        // Compare the frequency maps\n        return freqMap0.equals(freqMap1);\n    }\n    \n    // Helper method to create a frequency map for a given string\n    private Map<Character, Integer> getFrequencyMap(String s) {\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n        return freqMap;\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        \n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '<') {\n                stack.push(bracket);\n            } else if (bracket == '>') {\n                if (stack.isEmpty() || stack.pop() != '<') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"<\")); // false\n        System.out.println(solution.correct_bracketing(\"<>\")); // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) {\n            return true; // An empty list or a single element list is trivially monotonic\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        \n        // Find the intersection of the two sets\n        set1.retainAll(set2);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set1);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        int largestPrime = -1;\n        \n        // Divide n by 2 until it is odd\n        while (n % 2 == 0) {\n            largestPrime = 2;\n            n /= 2;\n        }\n        \n        // Now n must be odd, so we can skip even numbers\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestPrime = i;\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then n itself is a prime number\n        if (n > 2) {\n            largestPrime = n;\n        }\n        \n        return largestPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_prime_factor(13195)); // Output: 29\n        System.out.println(sol.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Output: 465\n        System.out.println(solution.sum_to_n(100)); // Output: 5050\n        System.out.println(solution.sum_to_n(5));   // Output: 15\n        System.out.println(solution.sum_to_n(10));  // Output: 55\n        System.out.println(solution.sum_to_n(1));   // Output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '(') {\n                stack.push(bracket);\n            } else if (bracket == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"(\")); // false\n        System.out.println(solution.correct_bracketing(\"()\")); // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     * >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n     * [1, 4, 12, 20]\n     * >>> derivative(Arrays.asList(1, 2, 3))\n     * [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Start from the second element (index 1) since the derivative of the constant term is 0\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.derivative(Arrays.asList(3, 1, 2, 4, 5))); // [1, 4, 12, 20]\n        System.out.println(solution.derivative(Arrays.asList(1, 2, 3))); // [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the FibFib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n     */\n    public int fibfib(int n) {\n        // Base cases\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        // Array to store the FibFib numbers\n        int[] fibfibArray = new int[n + 1];\n        \n        // Initialize the base cases\n        fibfibArray[0] = 0;\n        fibfibArray[1] = 0;\n        fibfibArray[2] = 1;\n\n        // Compute the FibFib numbers iteratively\n        for (int i = 3; i <= n; i++) {\n            fibfibArray[i] = fibfibArray[i - 1] + fibfibArray[i - 2] + fibfibArray[i - 3];\n        }\n\n        // Return the n-th FibFib number\n        return fibfibArray[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n     */\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle case insensitivity\n        s = s.toLowerCase();\n        \n        // Initialize the count of vowels\n        int count = 0;\n        \n        // Iterate through each character of the string\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            \n            // Check if the character is a vowel\n            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n                count++;\n            }\n            // Check if the character is 'y' and it is at the end of the string\n            else if (ch == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        \n        // Return the total count of vowels\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.vowels_count(\"abcde\")); // Output: 2\n        System.out.println(sol.vowels_count(\"ACEDY\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        int length = numStr.length();\n\n        // If shift is greater than or equal to the number of digits, reverse the string\n        if (shift >= length) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n\n        // Perform the circular shift\n        String shiftedPart = numStr.substring(length - shift);\n        String remainingPart = numStr.substring(0, length - shift);\n        return shiftedPart + remainingPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(solution.circular_shift(12345, 2)); // Output: \"45123\"\n        System.out.println(solution.circular_shift(12345, 5)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                sum += (int) ch;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.digitSum(\"\")); // 0\n        System.out.println(sol.digitSum(\"abAB\")); // 131\n        System.out.println(sol.digitSum(\"abcCd\")); // 67\n        System.out.println(sol.digitSum(\"helloE\")); // 69\n        System.out.println(sol.digitSum(\"woArBld\")); // 131\n        System.out.println(sol.digitSum(\"aAaaaXa\")); // 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Split the string by spaces to separate the components\n        String[] parts = s.split(\" \");\n        \n        // Extract the number of apples and oranges\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[2]);\n        \n        // Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        \n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(sol.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Output: 2\n        System.out.println(sol.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(sol.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        // Initialize variables to store the smallest even value and its index\n        int minEvenValue = Integer.MAX_VALUE;\n        int minEvenIndex = -1;\n        \n        // Iterate through the list to find the smallest even value\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            \n            // Check if the current value is even and smaller than the current minEvenValue\n            if (currentValue % 2 == 0 && currentValue < minEvenValue) {\n                minEvenValue = currentValue;\n                minEvenIndex = i;\n            }\n        }\n        \n        // If no even value was found, return an empty list\n        if (minEvenIndex == -1) {\n            return new ArrayList<>();\n        }\n        \n        // Return the smallest even value and its index\n        List<Integer> result = new ArrayList<>();\n        result.add(minEvenValue);\n        result.add(minEvenIndex);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList())); // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Count the frequency of each integer in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Find the greatest integer that meets the criteria\n        int maxValidInteger = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            if (num > 0 && freq >= num) {\n                if (num > maxValidInteger) {\n                    maxValidInteger = num;\n                }\n            }\n        }\n\n        // Step 3: Return the result\n        return maxValidInteger;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list in ascending order\n        Collections.sort(lst);\n        \n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize two pointers\n        int minIndex = 0;\n        int maxIndex = lst.size() - 1;\n        \n        // Alternate between picking the minimum and maximum values\n        while (minIndex <= maxIndex) {\n            if (minIndex <= maxIndex) {\n                result.add(lst.get(minIndex));\n                minIndex++;\n            }\n            if (minIndex <= maxIndex) {\n                result.add(lst.get(maxIndex));\n                maxIndex--;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // [1, 4, 2, 3]\n        System.out.println(sol.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // [5, 5, 5, 5]\n        System.out.println(sol.strange_sort_list(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round the area to 2 decimal places\n        area = Math.round(area * 100.0) / 100.0;\n        \n        return area;\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        List<Integer> reversedQ = new ArrayList<>(q);\n        Collections.reverse(reversedQ);\n        if (!q.equals(reversedQ)) {\n            return false;\n        }\n\n        // Calculate the sum of the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to the maximum weight\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n        \n        // Compare elements from the start and end moving towards the center\n        for (int i = 0; i < n / 2; i++) {\n            if (arr.get(i) != arr.get(n - 1 - i)) {\n                changes++;\n            }\n        }\n        \n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in the all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     *\n     * Examples\n     * total_match(Arrays.asList(), Arrays.asList()) -> []\n     * total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\")) -> [\"hI\", \"Hi\"]\n     * total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\")) -> [\"hi\", \"admin\"]\n     * total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\")) -> [\"hI\", \"hi\", \"hi\"]\n     * total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\")) -> [\"4\"]\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int totalChars1 = 0;\n        int totalChars2 = 0;\n\n        // Calculate total number of characters in lst1\n        for (String str : lst1) {\n            totalChars1 += str.length();\n        }\n\n        // Calculate total number of characters in lst2\n        for (String str : lst2) {\n            totalChars2 += str.length();\n        }\n\n        // Compare the totals and return the appropriate list\n        if (totalChars1 <= totalChars2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less then 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        // Generate all prime numbers less than 100\n        List<Integer> primes = generatePrimes(100);\n        \n        // Check all combinations of three primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + 1; j < primes.size(); j++) {\n                for (int k = j + 1; k < primes.size(); k++) {\n                    if (primes.get(i) * primes.get(j) * primes.get(k) == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Helper method to generate prime numbers less than n using Sieve of Eratosthenes\n    private List<Integer> generatePrimes(int n) {\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_multiply_prime(30)); // true\n        System.out.println(sol.is_multiply_prime(29)); // false\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        // If x is 1, it is a power of any n except when n is 0\n        if (x == 1) {\n            return n == 1;\n        }\n        \n        // If n is 1, the only power of 1 is 1 itself\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        // Check if x is a power of n\n        while (x % n == 0) {\n            x /= n;\n        }\n        \n        // If x becomes 1, it means x was a power of n\n        return x == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_simple_power(1, 4)); // true\n        System.out.println(sol.is_simple_power(2, 2)); // true\n        System.out.println(sol.is_simple_power(8, 2)); // true\n        System.out.println(sol.is_simple_power(3, 2)); // false\n        System.out.println(sol.is_simple_power(3, 1)); // false\n        System.out.println(sol.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an integer a and returns true\n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> true\n    iscube(2) ==> false\n    iscube(-1) ==> true\n    iscube(64) ==> true\n    iscube(0) ==> true\n    iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        // Handle the special case where a is 0\n        if (a == 0) {\n            return true;\n        }\n\n        // Compute the cube root of a\n        double cubeRoot = Math.cbrt(a);\n\n        // Round the cube root to the nearest integer\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n\n        // Check if cubing the rounded cube root gives back a\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // Define the set of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize the count of prime digits\n        int count = 0;\n        \n        // Iterate through each character in the input string\n        for (char c : num.toCharArray()) {\n            // If the character is in the set of prime hexadecimal digits, increment the count\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        // Return the final count\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.hex_key(\"AB\")); // Output: 1\n        System.out.println(sol.hex_key(\"1077E\")); // Output: 2\n        System.out.println(sol.hex_key(\"ABED1A33\")); // Output: 4\n        System.out.println(sol.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(sol.hex_key(\"2020\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Prepend and append 'db' to the binary string\n        String result = \"db\" + binaryString + \"db\";\n        \n        // Return the resulting string\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Output: \"db100000db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => false\n    is_happy(aa) => false\n    is_happy(abcd) => true\n    is_happy(aabb) => false\n    is_happy(adb) => true\n    is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) {\n            return false;\n        }\n        \n        // Iterate through the string and check every set of 3 consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            // Check if all three characters are distinct\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        // If all sets of 3 consecutive characters are distinct, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\")); // false\n        System.out.println(solution.is_happy(\"aa\")); // false\n        System.out.println(solution.is_happy(\"abcd\")); // true\n        System.out.println(solution.is_happy(\"aabb\")); // false\n        System.out.println(solution.is_happy(\"adb\")); // true\n        System.out.println(solution.is_happy(\"xyy\")); // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> letterGrades = solution.numerical_letter_grade(grades);\n        System.out.println(letterGrades); // Output: [A+, B+, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    prime_length(\"Hello\") == true\n    prime_length(\"abcdcba\") == true\n    prime_length(\"kittens\") == true\n    prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        if (length < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_length(\"Hello\")); // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\")); // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Special case: only the number 1 itself\n        }\n        int countStartsWith1 = (int) Math.pow(10, n - 1);\n        int countEndsWith1 = (int) Math.pow(10, n - 1);\n        int countBoth = (int) Math.pow(10, n - 2);\n        \n        return countStartsWith1 + countEndsWith1 - countBoth;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(int N) {\n        // Step 1: Calculate the sum of digits of N\n        int sumOfDigits = 0;\n        int temp = N;\n        while (temp > 0) {\n            sumOfDigits += temp % 10; // Add the last digit to the sum\n            temp /= 10; // Remove the last digit\n        }\n\n        // Step 2: Convert the sum of digits to binary\n        String binarySum = Integer.toBinaryString(sumOfDigits);\n\n        // Step 3: Return the binary string\n        return binarySum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solve(1000)); // Output: \"1\"\n        System.out.println(sol.solve(150));  // Output: \"110\"\n        System.out.println(sol.solve(147));  // Output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int total = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                total += lst.get(i);\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.add(Arrays.asList(4, 2, 6, 7))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string into words\n        String[] words = s.split(\" \");\n        \n        // Process each word\n        for (int i = 0; i < words.length; i++) {\n            // Convert the word to a character array\n            char[] chars = words[i].toCharArray();\n            \n            // Sort the character array\n            Arrays.sort(chars);\n            \n            // Convert the sorted character array back to a string\n            words[i] = new String(chars);\n        }\n        \n        // Join the words back into a single string with spaces\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.anti_shuffle(\"Hi\")); // \"Hi\"\n        System.out.println(sol.anti_shuffle(\"hello\")); // \"ehllo\"\n        System.out.println(sol.anti_shuffle(\"Hello World!!!\")); // \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Traverse the nested list to find occurrences of x\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        \n        // Sort the coordinates\n        coordinates.sort((a, b) -> {\n            // First sort by row in ascending order\n            int rowComparison = a.get(0).compareTo(b.get(0));\n            if (rowComparison != 0) {\n                return rowComparison;\n            }\n            // If rows are the same, sort by column in descending order\n            return b.get(1).compareTo(a.get(1));\n        });\n        \n        return coordinates;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        \n        List<List<Integer>> lst2 = Arrays.asList();\n        System.out.println(solution.get_row(lst2, 1)); // []\n        \n        List<List<Integer>> lst3 = Arrays.asList(\n            Arrays.asList(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the array is empty or has only one element\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Calculate the sum of the first and last index values\n        int firstValue = array.get(0);\n        int lastValue = array.get(array.size() - 1);\n        int sum = firstValue + lastValue;\n\n        // Create a copy of the array to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Sort the array based on the sum\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                // Shift lowercase letters\n                char newChar = (char) ((c - 'a' + 4) % 26 + 'a');\n                encrypted.append(newChar);\n            } else if (Character.isUpperCase(c)) {\n                // Shift uppercase letters\n                char newChar = (char) ((c - 'A' + 4) % 26 + 'A');\n                encrypted.append(newChar);\n            } else {\n                // Non-alphabetic characters remain unchanged\n                encrypted.append(c);\n            }\n        }\n        \n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(sol.encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(sol.encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(sol.encrypt(\"et\")); // Output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * Returns null if there is no such element.\n     * <p>\n     * next_smallest(Arrays.asList(1, 2, 3, 4, 5)) == Optional[2]\n     * next_smallest(Arrays.asList(5, 1, 4, 3, 2)) == Optional[2]\n     * next_smallest(Arrays.asList()) == Optional.empty\n     * next_smallest(Arrays.asList(1, 1)) == Optional.empty\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        int smallest = Integer.MAX_VALUE;\n        int secondSmallest = Integer.MAX_VALUE;\n        boolean foundSecondSmallest = false;\n\n        for (int num : lst) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num > smallest && num < secondSmallest) {\n                secondSmallest = num;\n                foundSecondSmallest = true;\n            }\n        }\n\n        return foundSecondSmallest ? Optional.of(secondSmallest) : Optional.empty();\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n     */\n    public int is_bored(String S) {\n        // Split the string into sentences based on '.', '?', and '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim any leading or trailing whitespace\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (sentence.startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\")); // 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // 1\n        System.out.println(solution.is_bored(\"I am happy! I am excited? I am bored.\")); // 3\n        System.out.println(solution.is_bored(\"This is a test. I am testing. Is this working?\")); // 1\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are integers\n        if (!(x instanceof Integer) || !(y instanceof Integer) || !(z instanceof Integer)) {\n            return false;\n        }\n\n        // Convert the inputs to integers\n        int a = (Integer) x;\n        int b = (Integer) y;\n        int c = (Integer) z;\n\n        // Check if any of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes the given message by swapping the case of all letters and replacing\n     * all vowels with the letter that appears 2 places ahead in the English alphabet.\n     *\n     * @param message The input message to be encoded.\n     * @return The encoded message.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            // Swap the case of the character\n            if (Character.isUpperCase(c)) {\n                c = Character.toLowerCase(c);\n            } else if (Character.isLowerCase(c)) {\n                c = Character.toUpperCase(c);\n            }\n            \n            // Replace vowels with the letter 2 places ahead\n            switch (c) {\n                case 'a':\n                case 'A':\n                    c = 'c';\n                    break;\n                case 'e':\n                case 'E':\n                    c = 'g';\n                    break;\n                case 'i':\n                case 'I':\n                    c = 'k';\n                    break;\n                case 'o':\n                case 'O':\n                    c = 'q';\n                    break;\n                case 'u':\n                case 'U':\n                    c = 'w';\n                    break;\n                default:\n                    // Do nothing for non-vowel characters\n                    break;\n            }\n            \n            encodedMessage.append(c);\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encode(\"test\")); // Output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Output: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to check if a number is prime.\n     * @param num The number to check.\n     * @return True if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2) return true; // 2 is the only even prime number\n        if (num % 2 == 0) return false; // Other even numbers are not prime\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Helper method to sum the digits of a number.\n     * @param num The number whose digits are to be summed.\n     * @return The sum of the digits of the number.\n     */\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Main method to find the largest prime in the list and return the sum of its digits.\n     * @param lst The list of integers.\n     * @return The sum of the digits of the largest prime in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        int largestPrime = -1;\n        \n        // Find the largest prime in the list\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n        \n        // If no prime was found, return 0 (though the problem guarantees there is at least one prime)\n        if (largestPrime == -1) {\n            return 0;\n        }\n        \n        // Return the sum of the digits of the largest prime\n        return sumOfDigits(largestPrime);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(sol.skjkasdkd(lst1)); // Output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(sol.skjkasdkd(lst2)); // Output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // If the map is empty, return False\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            // Check if the key is a string\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            String strKey = (String) key;\n\n            // Check if the key is in lower case\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n\n            // Check if the key is in upper case\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n\n            // If neither allLowerCase nor allUpperCase is true, return False\n            if (!allLowerCase && !allUpperCase) {\n                return false;\n            }\n        }\n\n        // If either allLowerCase or allUpperCase is true, return True\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"a\", \"apple\");\n        map1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(map1)); // True\n\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"a\", \"apple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(map2)); // False\n\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"a\", \"apple\");\n        map3.put(8, \"banana\");\n        map3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(map3)); // False\n\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n        System.out.println(solution.check_dict_case(map4)); // False\n\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(map5)); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        if (n <= 2) {\n            return primes; // No primes less than 2\n        }\n        \n        // Initialize a boolean array where index represents the number\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true); // Assume all numbers are prime initially\n        \n        // 0 and 1 are not prime numbers\n        isPrime[0] = false;\n        isPrime[1] = false;\n        \n        // Implementing the Sieve of Eratosthenes\n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false; // Mark multiples of i as non-prime\n                }\n            }\n        }\n        \n        // Collect all prime numbers\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.count_up_to(5));  // Output: [2, 3]\n        System.out.println(sol.count_up_to(11)); // Output: [2, 3, 5, 7]\n        System.out.println(sol.count_up_to(0));  // Output: []\n        System.out.println(sol.count_up_to(20)); // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(sol.count_up_to(1));  // Output: []\n        System.out.println(sol.count_up_to(18)); // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digit of 'a'\n        int unitDigitA = Math.abs(a) % 10;\n        \n        // Extract the unit digit of 'b'\n        int unitDigitB = Math.abs(b) % 10;\n        \n        // Multiply the unit digits\n        int result = unitDigitA * unitDigitB;\n        \n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        \n        // Iterate through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            // Check if the character is an uppercase vowel\n            if (uppercaseVowels.contains(ch)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_upper(\"aBCdEf\")); // Output: 1\n        System.out.println(sol.count_upper(\"abcdefg\")); // Output: 0\n        System.out.println(sol.count_upper(\"dBBE\")); // Output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        // Parse the string to a double\n        double number = Double.parseDouble(value);\n        \n        // Round the double to the nearest integer\n        long rounded = Math.round(number);\n        \n        // Convert the rounded value to an integer and return\n        return (int) rounded;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));    // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        int current = n;\n        \n        for (int i = 0; i < n; i++) {\n            pile.add(current);\n            if (current % 2 == 0) {\n                current += 2; // Next even number\n            } else {\n                current += 2; // Next odd number\n            }\n        }\n        \n        return pile;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.make_a_pile(3)); // Output: [3, 5, 7]\n        System.out.println(sol.make_a_pile(4)); // Output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     */\n    public List<String> words_string(String s) {\n        // Split the string using the regular expression that matches spaces or commas with optional spaces around them\n        String[] words = s.split(\"\\\\s+|,\\\\s*\");\n        // Convert the array to a list and return it\n        return Arrays.asList(words);\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n        System.out.println(solution.words_string(\"Hello   world,  this is a test\")); // [\"Hello\", \"world\", \"this\", \"is\", \"a\", \"test\"]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure the range is valid\n        if (x > y) {\n            return -1;\n        }\n        \n        // Iterate from y down to x to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n        \n        // If no even number is found, return -1\n        return -1;\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Step 1: Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n        \n        // Step 2: Calculate the sum of integers from n to m\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        // Step 3: Compute the average\n        int count = m - n + 1;\n        double average = (double) sum / count;\n        \n        // Step 4: Round the average to the nearest integer\n        int roundedAverage = (int) Math.round(average);\n        \n        // Step 5: Convert the rounded integer to binary\n        String binaryRepresentation = Integer.toBinaryString(roundedAverage);\n        \n        return binaryRepresentation;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.rounded_avg(1, 5)); // Output: \"11\"\n        System.out.println(sol.rounded_avg(7, 5)); // Output: -1\n        System.out.println(sol.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(sol.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all\n     * elements that hasn't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     *\n     * For example:\n     * >>> unique_digits(Arrays.asList(15, 33, 1422, 1))\n     * [1, 15, 33]\n     * >>> unique_digits(Arrays.asList(152, 323, 1422, 10))\n     * []\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : x) {\n            if (!containsEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n    \n    private boolean containsEvenDigit(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            num /= 10;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.unique_digits(Arrays.asList(15, 33, 1422, 1))); // [1, 15, 33]\n        System.out.println(sol.unique_digits(Arrays.asList(152, 323, 1422, 10))); // []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter and sort the array\n        List<Integer> filteredAndSorted = arr.stream()\n                .filter(num -> num >= 1 && num <= 9)\n                .sorted()\n                .collect(Collectors.toList());\n\n        // Step 2: Reverse the sorted array\n        Collections.reverse(filteredAndSorted);\n\n        // Step 3: Map each digit to its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredAndSorted) {\n            result.add(getNumberName(num));\n        }\n\n        return result;\n    }\n\n    private String getNumberName(int num) {\n        switch (num) {\n            case 1: return \"One\";\n            case 2: return \"Two\";\n            case 3: return \"Three\";\n            case 4: return \"Four\";\n            case 5: return \"Five\";\n            case 6: return \"Six\";\n            case 7: return \"Seven\";\n            case 8: return \"Eight\";\n            case 9: return \"Nine\";\n            default: throw new IllegalArgumentException(\"Unexpected number: \" + num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n        List<Integer> arr2 = Arrays.asList();\n        System.out.println(solution.by_length(arr2)); // []\n\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // [\"One\"]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Compute factorial of i\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Compute sum of numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n    \n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int len = str.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(sol.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            int sumOfDigits = 0;\n            int absNum = Math.abs(num); // Take the absolute value to handle negative numbers\n            \n            // Calculate the sum of digits\n            while (absNum > 0) {\n                sumOfDigits += absNum % 10;\n                absNum /= 10;\n            }\n            \n            // Check if the sum of digits is greater than 0\n            if (sumOfDigits > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(sol.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(sol.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        int breakPoint = 0;\n\n        // Find the break point where the sequence breaks\n        for (int i = 0; i < n; i++) {\n            if (arr.get(i) > arr.get((i + 1) % n)) {\n                breakPoint++;\n            }\n        }\n\n        // There should be exactly one break point for the array to be sortable by right shifts\n        return breakPoint <= 1;\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count odd numbers in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        // Count even numbers in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // Check if we have enough even numbers in lst2 to replace all odd numbers in lst1\n        if (evenCountInLst2 >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // \"YES\"\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Step 1: Split the input string by spaces to get individual letters\n        String[] letters = test.split(\" \");\n        \n        // Step 2: Use a Map to count the frequency of each letter\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String letter : letters) {\n            frequencyMap.put(letter, frequencyMap.getOrDefault(letter, 0) + 1);\n        }\n        \n        // Step 3: Determine the maximum frequency\n        int maxFrequency = 0;\n        for (int count : frequencyMap.values()) {\n            if (count > maxFrequency) {\n                maxFrequency = count;\n            }\n        }\n        \n        // Step 4: Collect all letters that have the maximum frequency\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() == maxFrequency) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        // Step 5: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Step 1: Remove characters from s that are in c\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {\n                result.append(ch);\n            }\n        }\n        \n        // Step 2: Check if the resulting string is a palindrome\n        String resultString = result.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n        \n        // Step 3: Return the result as a list\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n        \n        return resultList;\n    }\n    \n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        \n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n            int oddCount = 0;\n            \n            // Count the number of odd digits in the current string\n            for (char ch : str.toCharArray()) {\n                if (isOddDigit(ch)) {\n                    oddCount++;\n                }\n            }\n            \n            // Construct the output string with the odd count\n            String output = String.format(\"the number of odd elements %dn the str%dng %d of the %dnput.\", oddCount, oddCount, oddCount, oddCount);\n            result.add(output);\n        }\n        \n        return result;\n    }\n    \n    private boolean isOddDigit(char ch) {\n        // Check if the character is an odd digit\n        return ch == '1' || ch == '3' || ch == '5' || ch == '7' || ch == '9';\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.odd_count(Arrays.asList(\"1234567\")));\n        // Expected output: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        System.out.println(sol.odd_count(Arrays.asList(\"3\", \"11111111\")));\n        // Expected output: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        // Initialize the minimum sum ending here and the minimum sum so far\n        int minEndingHere = nums.get(0);\n        int minSoFar = nums.get(0);\n        \n        // Iterate through the list starting from the second element\n        for (int i = 1; i < nums.size(); i++) {\n            int current = nums.get(i);\n            // Update minEndingHere to be the minimum of the current element or the sum of minEndingHere and the current element\n            minEndingHere = Math.min(current, minEndingHere + current);\n            // Update minSoFar to be the minimum of minSoFar and minEndingHere\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n        \n        // Return the minimum sum found\n        return minSoFar;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3))); // Output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalBucketsLowered = 0;\n        \n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n            for (int unit : row) {\n                if (unit == 1) {\n                    waterUnits++;\n                }\n            }\n            // Calculate the number of times the bucket needs to be lowered\n            int timesLowered = (waterUnits + capacity - 1) / capacity; // This is equivalent to Math.ceil(waterUnits / (double)capacity)\n            totalBucketsLowered += timesLowered;\n        }\n        \n        return totalBucketsLowered;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(sol.max_fill(grid1, capacity1)); // Output: 6\n        \n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(sol.max_fill(grid2, capacity2)); // Output: 5\n        \n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(sol.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation in ascending order.\n     * For similar number of ones, sorts based on decimal value.\n     * \n     * @param arr The list of integers to be sorted.\n     * @return The sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Use a custom comparator to sort the list\n        arr.sort(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                // Count the number of ones in the binary representation of a and b\n                int onesA = Integer.bitCount(a);\n                int onesB = Integer.bitCount(b);\n                \n                // If the number of ones is different, sort by the number of ones\n                if (onesA != onesB) {\n                    return Integer.compare(onesA, onesB);\n                }\n                \n                // If the number of ones is the same, sort by the decimal value\n                return Integer.compare(a, b);\n            }\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))); // true\n        System.out.println(solution.sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))); // true\n        System.out.println(solution.sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))); // true\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // List to store the result\n        List<String> result = new ArrayList<>();\n        \n        // If the input string is empty, return the empty list\n        if (s.isEmpty()) {\n            return result;\n        }\n        \n        // Split the string into words\n        String[] words = s.split(\" \");\n        \n        // Set of vowels for quick lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Iterate through each word\n        for (String word : words) {\n            int consonantCount = 0;\n            \n            // Count the number of consonants in the word\n            for (char c : word.toCharArray()) {\n                if (Character.isLetter(c) && !vowels.contains(c)) {\n                    consonantCount++;\n                }\n            }\n            \n            // If the word has exactly n consonants, add it to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        // Define the set of vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Traverse the word from right to left\n        for (int i = word.length() - 2; i > 0; i--) {\n            char currentChar = word.charAt(i);\n            char prevChar = word.charAt(i - 1);\n            char nextChar = word.charAt(i + 1);\n            \n            // Check if the current character is a vowel and is surrounded by consonants\n            if (vowels.contains(currentChar) && !vowels.contains(prevChar) && !vowels.contains(nextChar)) {\n                return String.valueOf(currentChar);\n            }\n        }\n        \n        // If no such vowel is found, return an empty string\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_closest_vowel(\"yogurt\")); // \"u\"\n        System.out.println(sol.get_closest_vowel(\"FULL\"));   // \"U\"\n        System.out.println(sol.get_closest_vowel(\"quick\"));  // \"\"\n        System.out.println(sol.get_closest_vowel(\"ab\"));     // \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int openCount = 0;\n        int closeCount = 0;\n\n        // Count the number of opening and closing parentheses in both strings\n        for (String str : lst) {\n            for (char ch : str.toCharArray()) {\n                if (ch == '(') {\n                    openCount++;\n                } else if (ch == ')') {\n                    closeCount++;\n                }\n            }\n        }\n\n        // Check if the counts of opening and closing parentheses are equal\n        if (openCount == closeCount) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.match_parens(Arrays.asList(\"()(\", \")\"))); // Output: \"Yes\"\n        System.out.println(sol.match_parens(Arrays.asList(\")\", \")\"))); // Output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in ascending order\n        Collections.sort(arr);\n        \n        // Step 2: Select the top k elements from the end of the sorted array\n        List<Integer> result = new ArrayList<>();\n        for (int i = arr.size() - k; i < arr.size(); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Step 3: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3)); // Output: [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2)); // Output: [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0) { // Check if the index is even\n                if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                    sum += lst.get(i);\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        \n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            int num = arr.get(i);\n            \n            // Check if the number has at most two digits\n            if (num >= 0 && num <= 99) {\n                sum += num;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        \n        int result = sol.add_elements(arr, k);\n        System.out.println(result); // Output: 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddNumbers = new ArrayList<>();\n        \n        // Start the sequence with the given number n\n        while (n != 1) {\n            if (n % 2 != 0) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            // Generate the next number in the sequence\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n        }\n        \n        // Add the final 1 to the list\n        oddNumbers.add(1);\n        \n        // The list is already sorted in increasing order\n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_odd_collatz(5)); // Output: [5, 1]\n        System.out.println(sol.get_odd_collatz(1)); // Output: [1]\n        System.out.println(sol.get_odd_collatz(10)); // Output: [5, 1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Validates a given date string and returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\n     *    And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\n     *    And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * @param date The date string to validate.\n     * @return true if the date is valid, false otherwise.\n     */\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Check if the date string matches the format mm-dd-yyyy\n        if (!date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) {\n            return false;\n        }\n\n        // Split the date string into month, day, and year\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is valid\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Check if the day is valid based on the month\n        if (month == 2) {\n            // February can have 29 days in a leap year, otherwise 28\n            if (day < 1 || day > 29) {\n                return false;\n            }\n            // Check for leap year\n            if (day == 29 && !isLeapYear(year)) {\n                return false;\n            }\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            // April, June, September, November have 30 days\n            if (day < 1 || day > 30) {\n                return false;\n            }\n        } else {\n            // All other months have 31 days\n            if (day < 1 || day > 31) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    /**\n     * Helper method to determine if a given year is a leap year.\n     * @param year The year to check.\n     * @return true if the year is a leap year, false otherwise.\n     */\n    private boolean isLeapYear(int year) {\n        if (year % 4 == 0) {\n            if (year % 100 == 0) {\n                return year % 400 == 0;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-00-2040\")); // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        \n        // Check for commas\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        }\n        \n        // Count lowercase letters with odd alphabet indices\n        int oddCount = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 != 0) {\n                    oddCount++;\n                }\n            }\n        }\n        \n        return oddCount;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"abcdef\")); // 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // Edge case: if the list is empty or has only one element, it is trivially sorted\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        // HashMap to keep track of the frequency of each number\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n        // Iterate through the list to check both conditions\n        for (int i = 0; i < lst.size() - 1; i++) {\n            int current = lst.get(i);\n            int next = lst.get(i + 1);\n\n            // Check if the list is sorted in ascending order\n            if (current > next) {\n                return false;\n            }\n\n            // Update the frequency map\n            frequencyMap.put(current, frequencyMap.getOrDefault(current, 0) + 1);\n            if (frequencyMap.get(current) > 2) {\n                return false;\n            }\n        }\n\n        // Don't forget to check the last element\n        int lastElement = lst.get(lst.size() - 1);\n        frequencyMap.put(lastElement, frequencyMap.getOrDefault(lastElement, 0) + 1);\n        if (frequencyMap.get(lastElement) > 2) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_sorted(Arrays.asList(5))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(sol.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n        \n        int intersectionStart = Math.max(start1, start2);\n        int intersectionEnd = Math.min(end1, end2);\n        \n        if (intersectionStart <= intersectionEnd) {\n            int lengthOfIntersection = intersectionEnd - intersectionStart + 1;\n            if (isPrime(lengthOfIntersection)) {\n                return \"YES\";\n            }\n        }\n        \n        return \"NO\";\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        // Step 1: Check if the array is empty\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Step 2: Determine the product of signs\n        int signProduct = 1;\n        int sumOfMagnitudes = 0;\n\n        for (int num : arr) {\n            if (num > 0) {\n                signProduct *= 1;\n            } else if (num < 0) {\n                signProduct *= -1;\n            } else {\n                signProduct *= 0;\n            }\n            sumOfMagnitudes += Math.abs(num);\n        }\n\n        // Step 3: Multiply the sum of magnitudes by the product of signs\n        int result = sumOfMagnitudes * signProduct;\n\n        // Step 4: Return the result wrapped in an Optional\n        return Optional.of(result);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1))); // Output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList())); // Output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        if (n == 0) return new ArrayList<>();\n        \n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        PriorityQueue<Path> pq = new PriorityQueue<>(Comparator.comparing(Path::getPathLength));\n        \n        // Initialize the priority queue with all starting points\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                List<Integer> initialPath = new ArrayList<>();\n                initialPath.add(grid.get(i).get(j));\n                pq.offer(new Path(i, j, initialPath));\n            }\n        }\n        \n        while (!pq.isEmpty()) {\n            Path current = pq.poll();\n            int x = current.x;\n            int y = current.y;\n            List<Integer> currentPath = current.path;\n            \n            // If the path length is k, return it as the result\n            if (currentPath.size() == k) {\n                return currentPath;\n            }\n            \n            // Explore neighbors\n            for (int[] dir : directions) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                \n                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {\n                    List<Integer> newPath = new ArrayList<>(currentPath);\n                    newPath.add(grid.get(newX).get(newY));\n                    pq.offer(new Path(newX, newY, newPath));\n                }\n            }\n        }\n        \n        // If no path of length k is found, return an empty list (shouldn't happen as per problem statement)\n        return new ArrayList<>();\n    }\n    \n    class Path {\n        int x, y;\n        List<Integer> path;\n        \n        Path(int x, int y, List<Integer> path) {\n            this.x = x;\n            this.y = y;\n            this.path = path;\n        }\n        \n        List<Integer> getPath() {\n            return path;\n        }\n        \n        int getPathLength() {\n            return path.size();\n        }\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        // List to store the Tribonacci sequence\n        List<Integer> tribonacciSequence = new ArrayList<>();\n        \n        // Base case\n        tribonacciSequence.add(3); // tri(1) = 3\n        \n        // Iterate from 2 to n\n        for (int i = 2; i <= n + 1; i++) {\n            if (i % 2 == 0) {\n                // If i is even\n                tribonacciSequence.add(1 + i / 2);\n            } else {\n                // If i is odd\n                int tri_i_minus_1 = tribonacciSequence.get(i - 2); // tri(i - 1)\n                int tri_i_minus_2 = tribonacciSequence.get(i - 3); // tri(i - 2)\n                int tri_i_plus_1 = 1 + (i + 1) / 2; // tri(i + 1)\n                tribonacciSequence.add(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1);\n            }\n        }\n        \n        return tribonacciSequence;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.tri(3)); // Output: [3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Initialize the product to 1\n        int product = 1;\n        // Convert the number to a string to iterate over each digit\n        String numStr = Integer.toString(n);\n        // Flag to check if any odd digit is found\n        boolean hasOdd = false;\n        \n        // Iterate over each character in the string\n        for (char ch : numStr.toCharArray()) {\n            // Convert the character to an integer\n            int digit = Character.getNumericValue(ch);\n            // Check if the digit is odd\n            if (digit % 2 != 0) {\n                // Multiply the product by the odd digit\n                product *= digit;\n                // Set the flag to true as we found an odd digit\n                hasOdd = true;\n            }\n        }\n        \n        // If no odd digit was found, return 0\n        if (!hasOdd) {\n            return 0;\n        }\n        \n        // Return the product of the odd digits\n        return product;\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n            } else if (ch == ']') {\n                if (!stack.isEmpty() && stack.peek() == '[') {\n                    // Found a pair of brackets\n                    stack.pop();\n                    if (stack.size() > 0) {\n                        // If there are still brackets in the stack, it means there was nesting\n                        return true;\n                    }\n                } else {\n                    // If we encounter a closing bracket without a matching opening bracket, push it to the stack\n                    stack.push(ch);\n                }\n            }\n        }\n        \n        // If we finish the loop without finding any nesting, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            int roundedNum = (int) Math.ceil(num);\n            // Square the rounded number\n            int squaredNum = roundedNum * roundedNum;\n            // Add to the sum\n            sum += squaredNum;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(sol.sum_squares(lst1)); // Output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(sol.sum_squares(lst2)); // Output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(sol.sum_squares(lst3)); // Output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(sol.sum_squares(lst4)); // Output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(sol.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt.isEmpty()) {\n            return false;\n        }\n\n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is an alphabetical character\n        if (Character.isLetter(lastChar)) {\n            // Check if the last character is not part of a word\n            if (txt.length() == 1 || !Character.isLetter(txt.charAt(txt.length() - 2))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < arr.size(); i++) {\n            // Check if the current element is not greater than or equal to the previous element\n            if (arr.get(i) < arr.get(i - 1)) {\n                // Return the index of the current element\n                return i;\n            }\n        }\n        // If no such element is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (!largestNegative.isPresent() || num > largestNegative.get()) {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-5, -3, -1, 0, 2, 4))); // (Optional.of(-1), Optional.of(2))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        // Normalize the inputs to floats for comparison\n        float floatA = normalizeToFloat(a);\n        float floatB = normalizeToFloat(b);\n\n        // Compare the normalized values\n        if (floatA > floatB) {\n            return Optional.of(a);\n        } else if (floatB > floatA) {\n            return Optional.of(b);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    private float normalizeToFloat(Object obj) {\n        if (obj instanceof String) {\n            // Replace commas with dots and parse as float\n            String str = ((String) obj).replace(',', '.');\n            return Float.parseFloat(str);\n        } else if (obj instanceof Integer) {\n            return ((Integer) obj).floatValue();\n        } else if (obj instanceof Float) {\n            return (Float) obj;\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass());\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == false\n    is_equal_to_sum_even(6) == false\n    is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // If n is less than 8, it cannot be the sum of 4 positive even numbers\n        if (n < 8) {\n            return false;\n        }\n        \n        // If n is odd, it cannot be the sum of 4 even numbers\n        if (n % 2 != 0) {\n            return false;\n        }\n        \n        // For n >= 8 and n is even, it can always be expressed as the sum of 4 even numbers\n        // because we can always divide n into 4 parts, each of which is an even number\n        return true;\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     *\n     * The function will receive an integer as input and should return the special\n     * factorial of this integer.\n     */\n    \n    // Helper function to compute the factorial of a number\n    private long factorial(int num) {\n        long result = 1;\n        for (int i = 1; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    public long special_factorial(int n) {\n        // Compute the product of factorials from n down to 1\n        long result = 1;\n        for (int i = n; i >= 1; i--) {\n            result *= factorial(i);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.special_factorial(4)); // Output should be 288\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Replace all single spaces with underscores\n        text = text.replace(\" \", \"_\");\n        \n        // Use a regular expression to find sequences of more than two consecutive underscores\n        // and replace them with a single hyphen\n        text = text.replaceAll(\"_{2,}\", \"-\");\n        \n        return text;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\")); // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\")); // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\")); // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\")); // \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check for the number of digits\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n                if (digitCount > 3) {\n                    return \"No\";\n                }\n            }\n        }\n\n        // Check for exactly one dot\n        int dotIndex = file_name.indexOf('.');\n        if (dotIndex == -1 || dotIndex != file_name.lastIndexOf('.')) {\n            return \"No\";\n        }\n\n        // Check the prefix\n        String prefix = file_name.substring(0, dotIndex);\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check the suffix\n        String suffix = file_name.substring(dotIndex + 1);\n        if (!Arrays.asList(\"txt\", \"exe\", \"dll\").contains(suffix)) {\n            return \"No\";\n        }\n\n        // If all conditions are met\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.file_name_check(\"example.txt\")); // => \"Yes\"\n        System.out.println(solution.file_name_check(\"1example.dll\")); // => \"No\"\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int value = lst.get(i);\n            \n            if (i % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                value = value * value;\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the value if index is a multiple of 4 but not a multiple of 3\n                value = value * value * value;\n            }\n            \n            // Add the transformed value to the sum\n            sum += value;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.sum_squares(Arrays.asList(1, 2, 3))); // Output: 6\n        System.out.println(sol.sum_squares(Arrays.asList())); // Output: 0\n        System.out.println(sol.sum_squares(Arrays.asList(-1, -5, 2, -1, -5))); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // Use a StringBuilder to collect the words with prime lengths\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Check if the length of the word is a prime number\n            if (isPrime(word.length())) {\n                // Append the word to the result\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        // Return the resulting string\n        return result.toString();\n    }\n    \n    // Helper method to check if a number is prime\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime\n        }\n        // Check for factors from 3 to sqrt(n)\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(sol.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the input fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n        \n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n        \n        // Compute the product of the two fractions\n        int numeratorProduct = numeratorX * numeratorN;\n        int denominatorProduct = denominatorX * denominatorN;\n        \n        // Simplify the resulting fraction\n        int gcd = gcd(numeratorProduct, denominatorProduct);\n        numeratorProduct /= gcd;\n        denominatorProduct /= gcd;\n        \n        // Check if the simplified fraction is a whole number\n        return denominatorProduct == 1;\n    }\n    \n    // Helper method to compute the greatest common divisor (GCD)\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (sum of digits, original number)\n        List<Pair> pairs = new ArrayList<>();\n        for (int num : nums) {\n            pairs.add(new Pair(sumOfDigits(num), num));\n        }\n\n        // Sort the list of pairs based on the sum of digits\n        Collections.sort(pairs, Comparator.comparingInt(Pair::getSumOfDigits));\n\n        // Extract the sorted numbers from the pairs\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.getNum());\n        }\n\n        return sortedNums;\n    }\n\n    // Helper method to calculate the sum of digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        return isNegative ? -sum : sum;\n    }\n\n    // Helper class to store the sum of digits and the original number\n    private static class Pair {\n        private final int sumOfDigits;\n        private final int num;\n\n        public Pair(int sumOfDigits, int num) {\n            this.sumOfDigits = sumOfDigits;\n            this.num = num;\n        }\n\n        public int getSumOfDigits() {\n            return sumOfDigits;\n        }\n\n        public int getNum() {\n            return num;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.order_by_points(Arrays.asList(1, 11, -1, -11, -12))); // [-1, -11, 1, -12, 11]\n        System.out.println(solution.order_by_points(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an array of numbers as input and returns\n    the number of elements in the array that are greater than 10 and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n    specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        \n        for (int num : nums) {\n            if (num > 10) {\n                int absNum = Math.abs(num);\n                int lastDigit = absNum % 10;\n                \n                // Extract the first digit\n                while (absNum >= 10) {\n                    absNum /= 10;\n                }\n                int firstDigit = absNum;\n                \n                // Check if both first and last digits are odd\n                if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Generate the array a\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Step 2: Count the valid triples\n        int count = 0;\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Step 3: Return the count of valid triples\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_max_triples(5)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    );\n\n    public List<String> bf(String planet1, String planet2) {\n        // Validate the input planets\n        if (!PLANETS.contains(planet1) || !PLANETS.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        // Find the indices of the planets\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for simplicity\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Extract the planets between index1 and index2 (exclusive)\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\")); // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\")); // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Step 2: Sort the filtered list by length and then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                // First, compare by length\n                int lengthCompare = Integer.compare(s1.length(), s2.length());\n                if (lengthCompare != 0) {\n                    return lengthCompare;\n                }\n                // If lengths are the same, compare alphabetically\n                return s1.compareTo(s2);\n            }\n        });\n\n        // Step 3: Return the sorted list\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        List<String> result1 = solution.sorted_list_sum(test1);\n        System.out.println(result1); // Output: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        List<String> result2 = solution.sorted_list_sum(test2);\n        System.out.println(result2); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        // Handle the case where n is less than or equal to 1\n        if (n <= 1) {\n            return y;\n        }\n        \n        // Check for primality by testing divisibility from 2 to sqrt(n)\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return y; // n is not a prime number\n            }\n        }\n        \n        // If no divisors were found, n is a prime number\n        return x;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.x_or_y(7, 34, 12)); // Output: 34\n        System.out.println(sol.x_or_y(15, 8, 5)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n        \n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num;\n                }\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the lists\n        for (int i = 0; i < game.size(); i++) {\n            int gameScore = game.get(i);\n            int guessScore = guess.get(i);\n            \n            // Compare the scores\n            if (gameScore == guessScore) {\n                result.add(0);\n            } else {\n                result.add(Math.abs(gameScore - guessScore));\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2))); // [0, 0, 0, 0, 3, 3]\n        System.out.println(solution.compare(Arrays.asList(0, 5, 0, 0, 0, 4), Arrays.asList(4, 1, 1, 0, 0, -2))); // [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            int capCount = 0;\n            int smCount = 0;\n\n            // Count the number of uppercase and lowercase letters\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    capCount++;\n                } else if (Character.isLowerCase(c)) {\n                    smCount++;\n                }\n            }\n\n            // Calculate the strength of the extension\n            int strength = capCount - smCount;\n\n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Output: \"Slices.SErviNGSliCes\"\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Output: \"my_class.AA\"\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => false\n    cycpattern_check(\"hello\",\"ell\") => true\n    cycpattern_check(\"whassup\",\"psus\") => false\n    cycpattern_check(\"abab\",\"baa\") => true\n    cycpattern_check(\"efef\",\"eeff\") => false\n    cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Step 1: Concatenate the second word with itself\n        String concatenated = b + b;\n        \n        // Step 2: Check if the first word is a substring of the concatenated string\n        return concatenated.contains(a);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer, return a list that has the number of even and odd digits respectively.\n    \n    Example:\n        even_odd_count(-12) ==> [1, 1]\n        even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to its absolute value to handle negative numbers\n        num = Math.abs(num);\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Loop through each digit of the number\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                evenCount++; // Increment even count if the digit is even\n            } else {\n                oddCount++; // Increment odd count if the digit is odd\n            }\n            num /= 10; // Remove the last digit\n        }\n        \n        // Return the counts as a list\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.even_odd_count(-12)); // Output: [1, 1]\n        System.out.println(sol.even_odd_count(123)); // Output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through the values and symbols\n        for (int i = 0; i < values.length; i++) {\n            // While the current value can be subtracted from the number\n            while (number >= values[i]) {\n                // Subtract the value from the number\n                number -= values[i];\n                // Append the corresponding symbol to the result\n                result.append(symbols[i]);\n            }\n        }\n        \n        // Return the result as a string\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(sol.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(sol.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Identify the longest side\n        int maxSide = Math.max(a, Math.max(b, c));\n        \n        // Check which side is the longest and apply the Pythagorean theorem\n        if (maxSide == a) {\n            return a * a == b * b + c * c;\n        } else if (maxSide == b) {\n            return b * b == a * a + c * c;\n        } else {\n            return c * c == a * a + b * b;\n        }\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            // Use a HashSet to count unique characters in the word\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Check if the current word has more unique characters than the previous max\n            if (uniqueChars.size() > maxUniqueChars || \n                (uniqueChars.size() == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueChars.size();\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))); // \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots eaten\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate the number of carrots left\n        int carrotsLeft = Math.max(0, remaining - need);\n        \n        // Return the result as a list\n        return Arrays.asList(totalEaten, carrotsLeft);\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Step 1: Evaluate all exponentiation operations\n        for (int i = 0; i < operator.size(); i++) {\n            if (operator.get(i).equals(\"**\")) {\n                int result = (int) Math.pow(operand.get(i), operand.get(i + 1));\n                operand.set(i, result);\n                operand.remove(i + 1);\n                operator.remove(i);\n                i--; // Adjust index after removal\n            }\n        }\n\n        // Step 2: Evaluate all multiplication and division operations\n        for (int i = 0; i < operator.size(); i++) {\n            if (operator.get(i).equals(\"*\")) {\n                int result = operand.get(i) * operand.get(i + 1);\n                operand.set(i, result);\n                operand.remove(i + 1);\n                operator.remove(i);\n                i--; // Adjust index after removal\n            } else if (operator.get(i).equals(\"/\")) {\n                int result = operand.get(i) / operand.get(i + 1);\n                operand.set(i, result);\n                operand.remove(i + 1);\n                operator.remove(i);\n                i--; // Adjust index after removal\n            }\n        }\n\n        // Step 3: Evaluate all addition and subtraction operations\n        for (int i = 0; i < operator.size(); i++) {\n            if (operator.get(i).equals(\"+\")) {\n                int result = operand.get(i) + operand.get(i + 1);\n                operand.set(i, result);\n                operand.remove(i + 1);\n                operator.remove(i);\n                i--; // Adjust index after removal\n            } else if (operator.get(i).equals(\"-\")) {\n                int result = operand.get(i) - operand.get(i + 1);\n                operand.set(i, result);\n                operand.remove(i + 1);\n                operator.remove(i);\n                i--; // Adjust index after removal\n            }\n        }\n\n        // The final result should be the only element left in the operand list\n        return operand.get(0);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        System.out.println(sol.do_algebra(operator, operand)); // Output: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean containsLetter = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                break;\n            }\n        }\n\n        // If the string contains no letters, reverse the string\n        if (!containsLetter) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // If the string contains letters, process each character\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Reverse the case of the letter\n                if (Character.isUpperCase(c)) {\n                    result.append(Character.toLowerCase(c));\n                } else {\n                    result.append(Character.toUpperCase(c));\n                }\n            } else {\n                // Keep non-letter characters as they are\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solve(\"1234\")); // Output: \"4321\"\n        System.out.println(sol.solve(\"ab\"));   // Output: \"AB\"\n        System.out.println(sol.solve(\"#a@C\")); // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     * \n     * >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Check if the input string is empty\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Create a MessageDigest instance for MD5\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        // Compute the MD5 hash of the input string\n        byte[] messageDigest = md.digest(text.getBytes());\n\n        // Convert the byte array to a BigInteger\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert the BigInteger to a hexadecimal string\n        String hashText = no.toString(16);\n\n        // Pad the hexadecimal string with leading zeros if necessary to ensure length of 32\n        while (hashText.length() < 32) {\n            hashText = \"0\" + hashText;\n        }\n\n        // Return the hexadecimal string wrapped in an Optional\n        return Optional.of(hashText);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Determine the start and end of the range\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n        \n        // Set to store unique even digits\n        Set<Integer> evenDigits = new HashSet<>();\n        \n        // Iterate through the range and collect even digits\n        for (int i = start; i <= end; i++) {\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit % 2 == 0 && digit < 10) {\n                    evenDigits.add(digit);\n                }\n                num /= 10;\n            }\n        }\n        \n        // Convert the set to a sorted list\n        List<Integer> result = new ArrayList<>(evenDigits);\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(10, 14)); // []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Iterate through each pair of numbers in the list\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                // Calculate the absolute difference between the two numbers\n                double difference = Math.abs(numbers.get(i) - numbers.get(j));\n                // Check if the difference is less than the threshold\n                if (difference < threshold) {\n                    return true;\n                }\n            }\n        }\n        // If no such pair is found, return false\n        return false;\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        paren_string = paren_string.replaceAll(\" \", \"\");\n        \n        List<String> result = new ArrayList<>();\n        Stack<Character> stack = new Stack<>();\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char ch : paren_string.toCharArray()) {\n            if (ch == '(') {\n                // Push the opening parenthesis onto the stack\n                stack.push(ch);\n            } else if (ch == ')') {\n                // Pop the corresponding opening parenthesis from the stack\n                stack.pop();\n            }\n            \n            // Append the current character to the current group\n            currentGroup.append(ch);\n            \n            // If the stack is empty, it means we have a balanced group\n            if (stack.isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Reset the StringBuilder for the next group\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.separate_paren_groups(\"( ) (( )) (( )( ))\")); // [\"()\", \"(())\", \"(()())\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n     */\n    public double truncate_number(double number) {\n        // Get the integer part of the number\n        int integerPart = (int) number;\n        \n        // Subtract the integer part from the original number to get the decimal part\n        double decimalPart = number - integerPart;\n        \n        return decimalPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5)); // Output: 0.5\n        System.out.println(solution.truncate_number(1.0)); // Output: 0.0\n        System.out.println(solution.truncate_number(7.89)); // Output: 0.89\n        System.out.println(solution.truncate_number(0.123)); // Output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        // Step 1: Calculate the mean of the dataset\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Compute the absolute differences and their sum\n        double absoluteDifferencesSum = 0.0;\n        for (double number : numbers) {\n            absoluteDifferencesSum += Math.abs(number - mean);\n        }\n\n        // Step 3: Calculate the average of the absolute differences\n        double mad = absoluteDifferencesSum / numbers.size();\n\n        return mad;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(solution.mean_absolute_deviation(numbers)); // Output should be 1.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // If the input list is empty, return an empty list\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n\n        // Iterate through the input list\n        for (int i = 0; i < numbers.size(); i++) {\n            // Add the current element to the result list\n            result.add(numbers.get(i));\n\n            // If it's not the last element, add the delimiter\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                result.add(str);\n            }\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum to 0 and product to 1\n        int sum = 0;\n        int product = 1;\n\n        // Iterate through the list to calculate sum and product\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        // If the list is empty, product should remain 1\n        if (numbers.isEmpty()) {\n            product = 1;\n        }\n\n        // Return the result as a list\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_product(List.of())); // [0, 1]\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        // Check if the input list is null or empty\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize the current maximum to the first element\n        int currentMax = numbers.get(0);\n        \n        // Iterate through the list\n        for (int i = 0; i < numbers.size(); i++) {\n            // Update the current maximum if the current element is greater\n            if (numbers.get(i) > currentMax) {\n                currentMax = numbers.get(i);\n            }\n            // Add the current maximum to the result list\n            result.add(currentMax);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> result = solution.rolling_max(numbers);\n        System.out.println(result); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n     */\n    public String make_palindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        // Find the longest palindromic suffix\n        int n = string.length();\n        for (int i = 0; i < n; i++) {\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // Reverse the prefix and append it to the original string\n                String prefix = string.substring(0, i);\n                String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n                return string + reversedPrefix;\n            }\n        }\n\n        // If no palindromic suffix is found, reverse the entire string and append\n        String reversedString = new StringBuilder(string).reverse().toString();\n        return string + reversedString;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\"));    // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n     */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of the same length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Input strings must be of the same length\");\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each character of the strings\n        for (int i = 0; i < a.length(); i++) {\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n\n            // Perform XOR operation\n            if (charA == charB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Output: \"100\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = null;\n        int maxLength = 0;\n\n        for (String str : strings) {\n            if (str.length() > maxLength) {\n                maxLength = str.length();\n                longestString = str;\n            }\n        }\n\n        return Optional.ofNullable(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure that a is greater than or equal to b\n        if (b > a) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        // Apply the Euclidean algorithm\n        while (b != 0) {\n            int remainder = a % b;\n            a = b;\n            b = remainder;\n        }\n        \n        // When b becomes 0, a is the GCD\n        return a;\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.all_prefixes(\"abc\")); // Output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 0; i <= n; i++) {\n            sb.append(i).append(\" \");\n        }\n        \n        // Remove the trailing space\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - 1);\n        }\n        \n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to handle case insensitivity\n        string = string.toLowerCase();\n        \n        // Use a Set to store distinct characters\n        Set<Character> distinctCharacters = new HashSet<>();\n        \n        // Iterate through the string and add each character to the Set\n        for (char c : string.toCharArray()) {\n            distinctCharacters.add(c);\n        }\n        \n        // The size of the Set is the count of distinct characters\n        return distinctCharacters.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Initialize a list to store the number of beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Iterate through the split notes\n        for (String note : notes) {\n            // Determine the number of beats for each note\n            switch (note) {\n                case \"o\":\n                    beats.add(4); // Whole note lasts four beats\n                    break;\n                case \"o|\":\n                    beats.add(2); // Half note lasts two beats\n                    break;\n                case \".|\":\n                    beats.add(1); // Quarter note lasts one beat\n                    break;\n                default:\n                    // If the note is not recognized, you can handle it as needed\n                    // For now, we'll just ignore it\n                    break;\n            }\n        }\n        \n        // Return the list of beats\n        return beats;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String input = \"o o| .| o| o| .| .| .| .| o o\";\n        List<Integer> result = solution.parse_music(input);\n        System.out.println(result); // Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n     */\n    public int how_many_times(String string, String substring) {\n        int count = 0;\n        int subLength = substring.length();\n        \n        // If the substring is empty, it should not match any non-empty string\n        if (subLength == 0) {\n            return 0;\n        }\n        \n        // Iterate through the string and check for the substring\n        for (int i = 0; i <= string.length() - subLength; i++) {\n            if (string.substring(i, i + subLength).equals(substring)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\")); // 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Step 1: Create a mapping from number words to their corresponding numerical values\n        Map<String, Integer> wordToNumber = new HashMap<>();\n        wordToNumber.put(\"zero\", 0);\n        wordToNumber.put(\"one\", 1);\n        wordToNumber.put(\"two\", 2);\n        wordToNumber.put(\"three\", 3);\n        wordToNumber.put(\"four\", 4);\n        wordToNumber.put(\"five\", 5);\n        wordToNumber.put(\"six\", 6);\n        wordToNumber.put(\"seven\", 7);\n        wordToNumber.put(\"eight\", 8);\n        wordToNumber.put(\"nine\", 9);\n\n        // Step 2: Split the input string into individual number words\n        String[] words = numbers.split(\" \");\n\n        // Step 3: Sort the words based on their corresponding numerical values\n        Arrays.sort(words, new Comparator<String>() {\n            @Override\n            public int compare(String word1, String word2) {\n                return wordToNumber.get(word1).compareTo(wordToNumber.get(word2));\n            }\n        });\n\n        // Step 4: Join the sorted words back into a single string with spaces\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\")); // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements\n        Collections.sort(numbers);\n        \n        // Initialize variables to keep track of the minimum difference and the closest elements\n        double minDifference = Double.MAX_VALUE;\n        double num1 = 0.0;\n        double num2 = 0.0;\n        \n        // Iterate through the sorted list to find the closest elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double currentDifference = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (currentDifference < minDifference) {\n                minDifference = currentDifference;\n                num1 = numbers.get(i);\n                num2 = numbers.get(i + 1);\n            }\n        }\n        \n        // Return the closest elements in a list\n        List<Double> result = new ArrayList<>();\n        result.add(Math.min(num1, num2));\n        result.add(Math.max(num1, num2));\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))); // [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Step 1: Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n        \n        // Step 2: Apply the linear transformation to each number\n        List<Double> rescaledList = new ArrayList<>();\n        for (Double number : numbers) {\n            double rescaledValue = (number - min) / (max - min);\n            rescaledList.add(rescaledValue);\n        }\n        \n        return rescaledList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        List<Double> rescaledNumbers = solution.rescale_to_unit(numbers);\n        System.out.println(rescaledNumbers); // Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1\n        for (int i = n - 1; i > 0; i--) {\n            // Check if i divides n evenly\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, return 1 (since 1 is a divisor of any number)\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_divisor(15)); // Output: 5\n        System.out.println(sol.largest_divisor(20)); // Output: 10\n        System.out.println(sol.largest_divisor(7));  // Output: 1\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 as much as possible\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Divide by odd numbers starting from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then it must be prime\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));  // Output: [2, 2, 2]\n        System.out.println(solution.factorize(25)); // Output: [5, 5]\n        System.out.println(solution.factorize(70)); // Output: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Set to keep track of elements that have been seen more than once\n        Set<Integer> seen = new HashSet<>();\n        // Set to keep track of elements that have been added to the result list\n        Set<Integer> added = new HashSet<>();\n        // Result list to store the final elements\n        List<Integer> result = new ArrayList<>();\n\n        for (Integer number : numbers) {\n            if (seen.contains(number)) {\n                // If the number has been seen before, remove it from the result list\n                if (added.contains(number)) {\n                    result.remove(number);\n                    added.remove(number);\n                }\n            } else {\n                // If the number has not been seen before, add it to the result list\n                seen.add(number);\n                result.add(number);\n                added.add(number);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> result = solution.remove_duplicates(numbers);\n        System.out.println(result); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else {\n                flippedString.append(c); // If it's not a letter, just append it as is\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.flip_case(\"Hello\")); // Output: \"hELLO\"\n        System.out.println(solution.flip_case(\"World\")); // Output: \"wORLD\"\n        System.out.println(solution.flip_case(\"Java\"));  // Output: \"jAVA\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder result = new StringBuilder();\n        for (String str : strings) {\n            result.append(str);\n        }\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     * \n     * @param strings The list of strings to filter.\n     * @param prefix  The prefix to filter by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        if (strings == null || prefix == null) {\n            throw new IllegalArgumentException(\"Input list and prefix must not be null.\");\n        }\n        \n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.filter_by_prefix(List.of(), \"a\")); // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")); // [\"abc\", \"array\"]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(n -> n > 0)  // Filter out non-positive numbers\n                .collect(Collectors.toList());  // Collect the results into a list\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    false\n    >>> is_prime(101)\n    true\n    >>> is_prime(11)\n    true\n    >>> is_prime(13441)\n    true\n    >>> is_prime(61)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(1)\n    false\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime\n        }\n        \n        // Check for factors from 3 to sqrt(n)\n        int sqrt = (int) Math.sqrt(n);\n        for (int i = 3; i <= sqrt; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    Evaluates the derivative of the polynomial with coefficients xs at point x.\n    return xs[1] + 2 * xs[2] * x + 3 * xs[3] * x^2 + .... n * xs[n] * x^(n-1)\n     */\n    public double polyDerivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> find_zero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> find_zero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double find_zero(List<Double> xs) {\n        double tolerance = 1e-7; // Tolerance for convergence\n        int maxIterations = 1000; // Maximum number of iterations to prevent infinite loops\n        double x0 = 0.0; // Initial guess\n        \n        for (int i = 0; i < maxIterations; i++) {\n            double fx = poly(xs, x0);\n            double dfx = polyDerivative(xs, x0);\n            \n            if (Math.abs(fx) < tolerance) {\n                return x0; // Converged to a root\n            }\n            \n            if (dfx == 0) {\n                throw new ArithmeticException(\"Derivative is zero. Newton-Raphson method failed.\");\n            }\n            \n            x0 = x0 - fx / dfx; // Update x0 using Newton-Raphson formula\n        }\n        \n        throw new RuntimeException(\"Failed to converge to a root within the maximum number of iterations.\");\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Create a list to store the values at indices divisible by three\n        List<Integer> divisibleByThreeValues = new ArrayList<>();\n        \n        // Iterate through the list and collect values at indices divisible by three\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                divisibleByThreeValues.add(l.get(i));\n            }\n        }\n        \n        // Sort the collected values\n        Collections.sort(divisibleByThreeValues);\n        \n        // Place the sorted values back into the original list at the correct positions\n        int sortedIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                l.set(i, divisibleByThreeValues.get(sortedIndex));\n                sortedIndex++;\n            }\n        }\n        \n        return l;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Step 1: Convert the list to a Set to remove duplicates\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        \n        // Step 2: Convert the Set back to a List\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        \n        // Step 3: Sort the list\n        Collections.sort(uniqueList);\n        \n        // Step 4: Return the sorted list\n        return uniqueList;\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int max_element(List<Integer> l) {\n        // Initialize the maximum element to the first element of the list\n        int max = l.get(0);\n        \n        // Iterate through the list starting from the second element\n        for (int i = 1; i < l.size(); i++) {\n            // Update the maximum element if the current element is greater\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        // Return the maximum element found\n        return max;\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numberStr = Integer.toString(i);\n                for (char c : numberStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fizz_buzz(50)); // Output: 0\n        System.out.println(sol.fizz_buzz(78)); // Output: 2\n        System.out.println(sol.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sort_even(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extract values at even indices\n        List<Integer> evenIndexValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndexValues.add(l.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndexValues);\n        \n        // Create the result list\n        List<Integer> result = new ArrayList<>(l);\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i += 2) {\n            result.set(i, evenIndexValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n     */\n    public int prime_fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be a positive integer\");\n        }\n        \n        int count = 0;\n        int a = 0, b = 1;\n        \n        while (true) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                count++;\n                if (count == n) {\n                    return fib;\n                }\n            }\n        }\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        if (num % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.prime_fib(1)); // 2\n        System.out.println(sol.prime_fib(2)); // 3\n        System.out.println(sol.prime_fib(3)); // 5\n        System.out.println(sol.prime_fib(4)); // 13\n        System.out.println(sol.prime_fib(5)); // 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to use the two-pointer technique\n        Collections.sort(l);\n        \n        // Iterate through the list\n        for (int i = 0; i < l.size() - 2; i++) {\n            // Skip duplicates to ensure distinct elements\n            if (i > 0 && l.get(i).equals(l.get(i - 1))) {\n                continue;\n            }\n            \n            int left = i + 1;\n            int right = l.size() - 1;\n            int target = -l.get(i);\n            \n            // Use two-pointer technique to find the pair\n            while (left < right) {\n                int sum = l.get(left) + l.get(right);\n                if (sum == target) {\n                    return true;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        // If no such triplet is found, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function outputs the number of collisions between two sets of cars.\n     */\n    public int car_race_collision(int n) {\n        // The number of collisions is n * n\n        return n * n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream()\n                .map(i -> i + 1)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairs_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) {\n            return \"0\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base;\n            result.append(remainder);\n            x = x / base;\n        }\n        \n        // Since we collected the digits in reverse order, we need to reverse the result\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.change_base(8, 3));  // Output: \"22\"\n        System.out.println(sol.change_base(8, 2));  // Output: \"1000\"\n        System.out.println(sol.change_base(7, 2));  // Output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n     */\n    public double triangle_area(double a, double h) {\n        // Calculate the area using the formula\n        double area = 0.5 * a * h;\n        return area;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array to store the last four computed values\n        int[] fib4Values = new int[4];\n        fib4Values[0] = 0; // fib4(0)\n        fib4Values[1] = 0; // fib4(1)\n        fib4Values[2] = 2; // fib4(2)\n        fib4Values[3] = 0; // fib4(3)\n\n        // Compute the sequence iteratively up to n\n        for (int i = 4; i <= n; i++) {\n            int nextValue = fib4Values[0] + fib4Values[1] + fib4Values[2] + fib4Values[3];\n            // Shift the values to the left\n            fib4Values[0] = fib4Values[1];\n            fib4Values[1] = fib4Values[2];\n            fib4Values[2] = fib4Values[3];\n            fib4Values[3] = nextValue;\n        }\n\n        // The result is the last computed value\n        return fib4Values[3];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    8.0\n     */\n    public double median(List<Integer> l) {\n        // Sort the list\n        Collections.sort(l);\n        \n        int size = l.size();\n        \n        // Check if the size is odd or even\n        if (size % 2 == 1) {\n            // If odd, return the middle element\n            return l.get(size / 2);\n        } else {\n            // If even, return the average of the two middle elements\n            int mid1 = l.get(size / 2 - 1);\n            int mid2 = l.get(size / 2);\n            return (mid1 + mid2) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.median(Arrays.asList(3, 1, 2, 4, 5))); // 3\n        System.out.println(solution.median(Arrays.asList(-10, 4, 6, 1000, 10, 20))); // 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n     */\n    public boolean is_palindrome(String text) {\n        // An empty string is considered a palindrome\n        if (text.isEmpty()) {\n            return true;\n        }\n        \n        // Use two pointers to compare characters from the start and end of the string\n        int left = 0;\n        int right = text.length() - 1;\n        \n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n        // Base case: 2^0 % p = 1\n        if (n == 0) {\n            return 1;\n        }\n        \n        // Initialize result to 1\n        int result = 1;\n        int base = 2;\n        \n        // Use iterative approach to compute 2^n % p\n        while (n > 0) {\n            // If n is odd, multiply base with result and take modulo p\n            if (n % 2 == 1) {\n                result = (result * base) % p;\n            }\n            // n must be even now\n            n = n >> 1; // n = n / 2\n            base = (base * base) % p; // Change base to base^2 % p\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.modp(3, 5)); // Output: 3\n        System.out.println(sol.modp(1101, 101)); // Output: 2\n        System.out.println(sol.modp(0, 101)); // Output: 1\n        System.out.println(sol.modp(3, 11)); // Output: 8\n        System.out.println(sol.modp(100, 101)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Calculate the original character by shifting back by 5\n            char originalChar = (char) ('a' + ((ch - 5 - 'a' + 26) % 26));\n            sb.append(originalChar);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String remove_vowels(String text) {\n        // Define a string containing all vowels\n        String vowels = \"aeiouAEIOU\";\n        \n        // Use a StringBuilder to construct the result string\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input text\n        for (int i = 0; i < text.length(); i++) {\n            char currentChar = text.charAt(i);\n            \n            // If the current character is not a vowel, append it to the result\n            if (vowels.indexOf(currentChar) == -1) {\n                result.append(currentChar);\n            }\n        }\n        \n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/53", "generation": "// File: Solution.java\npublic class Solution {\n    /**\n     * Add two numbers x and y\n     * @param x the first number\n     * @param y the second number\n     * @return the sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if two words have the same kind of characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create frequency maps for both strings\n        Map<Character, Integer> freqMap0 = new HashMap<>();\n        Map<Character, Integer> freqMap1 = new HashMap<>();\n        \n        // Populate the frequency map for s0\n        for (char c : s0.toCharArray()) {\n            freqMap0.put(c, freqMap0.getOrDefault(c, 0) + 1);\n        }\n        \n        // Populate the frequency map for s1\n        for (char c : s1.toCharArray()) {\n            freqMap1.put(c, freqMap1.getOrDefault(c, 0) + 1);\n        }\n        \n        // Compare the frequency maps\n        return freqMap0.equals(freqMap1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        \n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fib(10)); // Output: 55\n        System.out.println(sol.fib(1));  // Output: 1\n        System.out.println(sol.fib(8));  // Output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '<') {\n                stack.push(bracket);\n            } else if (bracket == '>') {\n                if (stack.isEmpty() || stack.pop() != '<') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"<\")); // false\n        System.out.println(solution.correct_bracketing(\"<>\")); // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) {\n            return true; // An empty list or a single element list is trivially monotonic\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        \n        // Find the intersection of the two sets\n        set1.retainAll(set2);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set1);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        int largestPrime = 1;\n        \n        // Check for the smallest prime factor, which is 2\n        while (n % 2 == 0) {\n            largestPrime = 2;\n            n /= 2;\n        }\n        \n        // Now check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestPrime = i;\n                n /= i;\n            }\n        }\n        \n        // If n is still greater than 2, then n itself is a prime number\n        if (n > 2) {\n            largestPrime = n;\n        }\n        \n        return largestPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.largest_prime_factor(13195)); // Output: 29\n        System.out.println(sol.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Output: 465\n        System.out.println(solution.sum_to_n(100)); // Output: 5050\n        System.out.println(solution.sum_to_n(5));   // Output: 15\n        System.out.println(solution.sum_to_n(10));  // Output: 55\n        System.out.println(solution.sum_to_n(1));   // Output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        // Create a stack to keep track of opening brackets\n        Stack<Character> stack = new Stack<>();\n\n        // Iterate through each character in the string\n        for (char bracket : brackets.toCharArray()) {\n            if (bracket == '(') {\n                // If it's an opening bracket, push it onto the stack\n                stack.push(bracket);\n            } else if (bracket == ')') {\n                // If it's a closing bracket, check if there's a corresponding opening bracket\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    // If the stack is empty or the top of the stack is not an opening bracket, return false\n                    return false;\n                }\n            }\n        }\n\n        // If the stack is empty, all opening brackets have been matched with closing brackets\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"(\")); // false\n        System.out.println(solution.correct_bracketing(\"()\")); // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     * >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n     * [1, 4, 12, 20]\n     * >>> derivative(Arrays.asList(1, 2, 3))\n     * [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Start from the coefficient of x^1 (index 1)\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.derivative(Arrays.asList(3, 1, 2, 4, 5))); // [1, 4, 12, 20]\n        System.out.println(solution.derivative(Arrays.asList(1, 2, 3))); // [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n     */\n    public int fibfib(int n) {\n        // Base cases\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        // Initialize the first three FibFib numbers\n        int a = 0, b = 0, c = 1;\n        int result = 0;\n\n        // Compute the n-th FibFib number iteratively\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n     */\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle case insensitivity\n        s = s.toLowerCase();\n        \n        // Initialize the count of vowels\n        int count = 0;\n        \n        // Iterate through each character of the string\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            \n            // Check if the character is a vowel\n            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n                count++;\n            }\n        }\n        \n        // Check if 'y' is at the end of the word and count it as a vowel\n        if (s.length() > 0 && s.charAt(s.length() - 1) == 'y') {\n            count++;\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.vowels_count(\"abcde\")); // Output: 2\n        System.out.println(sol.vowels_count(\"ACEDY\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        int length = numStr.length();\n        \n        // If shift is greater than or equal to the number of digits, return the reversed string\n        if (shift >= length) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Perform the circular shift\n        String shiftedPart = numStr.substring(length - shift);\n        String remainingPart = numStr.substring(0, length - shift);\n        \n        // Concatenate the shifted part with the remaining part\n        return shiftedPart + remainingPart;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(sol.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(sol.circular_shift(12345, 2)); // Output: \"45123\"\n        System.out.println(sol.circular_shift(12345, 5)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                sum += (int) ch;\n            }\n        }\n        \n        return sum;\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Split the string by spaces to isolate the numbers and words\n        String[] parts = s.split(\" \");\n        \n        // Extract the number of apples and oranges\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[2]);\n        \n        // Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        \n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(sol.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Output: 2\n        System.out.println(sol.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(sol.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        // Initialize variables to store the smallest even value and its index\n        int minEvenValue = Integer.MAX_VALUE;\n        int minEvenIndex = -1;\n        \n        // Iterate through the list\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            \n            // Check if the current value is even\n            if (currentValue % 2 == 0) {\n                // If it's the first even value found or it's smaller than the current smallest even value\n                if (currentValue < minEvenValue) {\n                    minEvenValue = currentValue;\n                    minEvenIndex = i;\n                }\n            }\n        }\n        \n        // If no even value was found, return an empty list\n        if (minEvenIndex == -1) {\n            return new ArrayList<>();\n        }\n        \n        // Return the smallest even value and its index\n        List<Integer> result = new ArrayList<>();\n        result.add(minEvenValue);\n        result.add(minEvenIndex);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList())); // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Count the frequency of each integer in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Find the greatest integer that meets the criteria\n        int result = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            if (num > 0 && freq >= num) {\n                if (result == -1 || num > result) {\n                    result = num;\n                }\n            }\n        }\n\n        // Step 3: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list in ascending order\n        Collections.sort(lst);\n        \n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize two pointers\n        int start = 0;\n        int end = lst.size() - 1;\n        \n        // Alternate between picking elements from the start and end\n        while (start <= end) {\n            if (start <= end) {\n                result.add(lst.get(start));\n                start++;\n            }\n            if (start <= end) {\n                result.add(lst.get(end));\n                end--;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // [1, 4, 2, 3]\n        System.out.println(sol.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // [5, 5, 5, 5]\n        System.out.println(sol.strange_sort_list(Arrays.asList())); // []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round the result to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        List<Integer> reversedQ = new ArrayList<>(q);\n        Collections.reverse(reversedQ);\n        if (!q.equals(reversedQ)) {\n            return false;\n        }\n\n        // Calculate the sum of the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to the maximum weight\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n        \n        // Compare elements from both ends towards the center\n        for (int i = 0; i < n / 2; i++) {\n            int left = arr.get(i);\n            int right = arr.get(n - 1 - i);\n            \n            // If the elements are not equal, we need to change one of them\n            if (left != right) {\n                changes++;\n            }\n        }\n        \n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(sol.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper function to calculate the total number of characters in a list of strings.\n     */\n    private int totalChars(List<String> lst) {\n        int total = 0;\n        for (String s : lst) {\n            total += s.length();\n        }\n        return total;\n    }\n\n    /**\n     * Function to compare two lists of strings based on the total number of characters.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int total1 = totalChars(lst1);\n        int total2 = totalChars(lst2);\n\n        if (total1 <= total2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.total_match(Arrays.asList(), Arrays.asList())); // []\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(sol.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(sol.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that the prime number is less then 100.\n    Example:\n    is_multiply_prime(30) == true\n    30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        // Generate all prime numbers less than 100\n        List<Integer> primes = generatePrimes(100);\n        \n        // Check all combinations of three primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + 1; j < primes.size(); j++) {\n                for (int k = j + 1; k < primes.size(); k++) {\n                    if (primes.get(i) * primes.get(j) * primes.get(k) == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Helper method to generate prime numbers less than n using Sieve of Eratosthenes\n    private List<Integer> generatePrimes(int n) {\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.is_multiply_prime(30)); // true\n        System.out.println(sol.is_multiply_prime(20)); // false\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        // If x is 1, it is always a power of any n (n^0 = 1)\n        if (x == 1) {\n            return true;\n        }\n        \n        // If n is 1, the only power of 1 is 1 itself, so x must be 1\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        // Keep dividing x by n\n        while (x % n == 0) {\n            x /= n;\n        }\n        \n        // If x becomes 1, it means x was a power of n\n        return x == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an integer a and returns true\n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> true\n    iscube(2) ==> false\n    iscube(-1) ==> true\n    iscube(64) ==> true\n    iscube(0) ==> true\n    iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        // Compute the cube root of a\n        double cubeRoot = Math.cbrt(a);\n        \n        // Convert the cube root to an integer\n        int intCubeRoot = (int) cubeRoot;\n        \n        // Check if cubing this integer gives back the original number\n        return intCubeRoot * intCubeRoot * intCubeRoot == a;\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // Define the set of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize the count of prime digits\n        int count = 0;\n        \n        // Iterate through each character in the input string\n        for (char c : num.toCharArray()) {\n            // If the character is a prime hexadecimal digit, increment the count\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        // Return the total count of prime hexadecimal digits\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.hex_key(\"AB\")); // Output: 1\n        System.out.println(sol.hex_key(\"1077E\")); // Output: 2\n        System.out.println(sol.hex_key(\"ABED1A33\")); // Output: 4\n        System.out.println(sol.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(sol.hex_key(\"2020\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Wrap the binary string with 'db' at the beginning and end\n        String result = \"db\" + binaryString + \"db\";\n        \n        // Return the final formatted string\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Output: \"db100000db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) {\n            return false;\n        }\n\n        // Iterate through the string and check every set of 3 consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // Check if all three characters are distinct\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n\n        // If all sets of 3 consecutive characters are distinct, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_happy(\"a\")); // false\n        System.out.println(solution.is_happy(\"aa\")); // false\n        System.out.println(solution.is_happy(\"abcd\")); // true\n        System.out.println(solution.is_happy(\"aabb\")); // false\n        System.out.println(solution.is_happy(\"adb\")); // true\n        System.out.println(solution.is_happy(\"xyy\")); // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> letterGrades = solution.numerical_letter_grade(grades);\n        System.out.println(letterGrades); // Output: [A+, B+, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    prime_length(\"Hello\") == true\n    prime_length(\"abcdcba\") == true\n    prime_length(\"kittens\") == true\n    prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Special case: for a single digit, only the number 1 itself qualifies.\n        }\n        int countStartsWith1 = (int) Math.pow(10, n - 1);\n        int countEndsWith1 = (int) Math.pow(10, n - 1);\n        int countBoth = (int) Math.pow(10, n - 2);\n        \n        return countStartsWith1 + countEndsWith1 - countBoth;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer N, return in binary the total sum of its digits.\n\n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n             Constraints: 0 <= N <= 10000.\n    Output:\n         a string of binary number\n     */\n    public String solve(int N) {\n        // Step 1: Calculate the sum of digits\n        int sum = 0;\n        int temp = N;\n        while (temp > 0) {\n            sum += temp % 10; // Add the last digit to the sum\n            temp /= 10;       // Remove the last digit\n        }\n\n        // Step 2: Convert the sum to binary\n        String binarySum = Integer.toBinaryString(sum);\n\n        // Step 3: Return the binary string\n        return binarySum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Output: \"1\"\n        System.out.println(solution.solve(150));  // Output: \"110\"\n        System.out.println(solution.solve(147));  // Output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int total = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                total += lst.get(i);\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.add(Arrays.asList(4, 2, 6, 7))); // Output: 2\n        System.out.println(sol.add(Arrays.asList(1, 3, 5, 7))); // Output: 0\n        System.out.println(sol.add(Arrays.asList(2, 4, 6, 8))); // Output: 4\n        System.out.println(sol.add(Arrays.asList(1, 2, 3, 4, 5, 6))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string into words using space as the delimiter\n        String[] words = s.split(\" \");\n        \n        // Create a list to hold the sorted words\n        List<String> sortedWords = new ArrayList<>();\n        \n        // Iterate over each word\n        for (String word : words) {\n            // Convert the word to a character array\n            char[] chars = word.toCharArray();\n            \n            // Sort the character array based on ASCII values\n            Arrays.sort(chars);\n            \n            // Convert the sorted character array back to a string\n            String sortedWord = new String(chars);\n            \n            // Add the sorted word to the list\n            sortedWords.add(sortedWord);\n        }\n        \n        // Join the sorted words with spaces to form the final string\n        return String.join(\" \", sortedWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Output: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Output: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Output: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // List to store the coordinates\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Traverse the nested list to find occurrences of x\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinates [row, column] to the list\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        \n        // Sort the coordinates\n        coordinates.sort((a, b) -> {\n            // First sort by row in ascending order\n            int rowComparison = a.get(0).compareTo(b.get(0));\n            if (rowComparison != 0) {\n                return rowComparison;\n            }\n            // If rows are the same, sort by column in descending order\n            return b.get(1).compareTo(a.get(1));\n        });\n        \n        return coordinates;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        \n        List<List<Integer>> lst2 = Arrays.asList();\n        System.out.println(solution.get_row(lst2, 1)); // []\n        \n        List<List<Integer>> lst3 = Arrays.asList(\n            Arrays.asList(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the array is empty or has only one element\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Calculate the sum of the first and last elements\n        int firstElement = array.get(0);\n        int lastElement = array.get(array.size() - 1);\n        int sum = firstElement + lastElement;\n\n        // Create a copy of the array to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Sort the array based on the sum's parity\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                // Shift lowercase letters by 4 places\n                char newChar = (char) ((c - 'a' + 4) % 26 + 'a');\n                encrypted.append(newChar);\n            } else if (Character.isUpperCase(c)) {\n                // Shift uppercase letters by 4 places\n                char newChar = (char) ((c - 'A' + 4) % 26 + 'A');\n                encrypted.append(newChar);\n            } else {\n                // Non-alphabetic characters remain unchanged\n                encrypted.append(c);\n            }\n        }\n        \n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(sol.encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(sol.encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(sol.encrypt(\"et\")); // Output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * Returns null if there is no such element.\n     * \n     * @param lst The list of integers.\n     * @return Optional containing the 2nd smallest element or empty if not found.\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Edge case: if the list is empty or has only one unique element\n        if (lst.isEmpty() || lst.size() == 1) {\n            return Optional.empty();\n        }\n\n        // Initialize the smallest and 2nd smallest elements\n        int smallest = Integer.MAX_VALUE;\n        int secondSmallest = Integer.MAX_VALUE;\n\n        // Iterate through the list to find the smallest and 2nd smallest elements\n        for (int num : lst) {\n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else if (num < secondSmallest && num != smallest) {\n                secondSmallest = num;\n            }\n        }\n\n        // If the 2nd smallest element is still Integer.MAX_VALUE, it means there is no 2nd smallest element\n        if (secondSmallest == Integer.MAX_VALUE) {\n            return Optional.empty();\n        }\n\n        return Optional.of(secondSmallest);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList())); // Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1))); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        // Split the string into sentences using the delimiters '.', '?', and '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        // Initialize a counter for boredoms\n        int boredomCount = 0;\n        \n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim any leading or trailing whitespace from the sentence\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (sentence.startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n        \n        // Return the count of boredoms\n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\")); // Output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n        System.out.println(solution.is_bored(\"I am bored. I need something to do! I think I will go for a walk.\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are integers\n        if (!(x instanceof Integer) || !(y instanceof Integer) || !(z instanceof Integer)) {\n            return false;\n        }\n\n        // Convert the inputs to integers\n        int a = (Integer) x;\n        int b = (Integer) y;\n        int c = (Integer) z;\n\n        // Check if any of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a message, and encodes in such a\n    way that it swaps case of all letters, replaces all vowels in\n    the message with the letter that appears 2 places ahead of that\n    vowel in the english alphabet.\n    Assume only letters.\n\n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead\n                if (\"aeiouAEIOU\".indexOf(swappedCaseChar) != -1) {\n                    char base = Character.isUpperCase(swappedCaseChar) ? 'A' : 'a';\n                    swappedCaseChar = (char) (base + (swappedCaseChar - base + 2) % 26);\n                }\n                \n                encodedMessage.append(swappedCaseChar);\n            } else {\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encode(\"test\")); // \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to check if a number is prime.\n     * @param num The number to check.\n     * @return True if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2) return true; // 2 is the only even prime number\n        if (num % 2 == 0) return false; // Other even numbers are not prime\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Helper method to sum the digits of a number.\n     * @param num The number whose digits are to be summed.\n     * @return The sum of the digits of the number.\n     */\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Method to find the largest prime value in the list and return the sum of its digits.\n     * @param lst The list of integers.\n     * @return The sum of the digits of the largest prime in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        int largestPrime = -1;\n        \n        // Find the largest prime in the list\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n        \n        // If no prime was found, return 0 (or handle as needed)\n        if (largestPrime == -1) {\n            return 0;\n        }\n        \n        // Return the sum of the digits of the largest prime\n        return sumOfDigits(largestPrime);\n    }\n}\n\npublic class Java94 {\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(sol.skjkasdkd(lst1)); // Output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(sol.skjkasdkd(lst2)); // Output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(sol.skjkasdkd(lst3)); // Output: 13\n        \n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(sol.skjkasdkd(lst4)); // Output: 11\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a map, return True if all keys are strings and all keys are in lower case or  in upper case, else return False.\n    The function should return False is the given map is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the map is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        // Iterate through the keys in the map\n        for (Object key : dict.keySet()) {\n            // Check if the key is a string\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            // Cast the key to a string\n            String strKey = (String) key;\n\n            // Check if the key is in lower case or upper case\n            if (!strKey.equals(strKey.toLowerCase()) && !strKey.equals(strKey.toUpperCase())) {\n                return false;\n            }\n        }\n\n        // If all checks pass, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"a\", \"apple\");\n        map1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(map1)); // True\n\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"a\", \"apple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(map2)); // False\n\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"a\", \"apple\");\n        map3.put(8, \"banana\");\n        map3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(map3)); // False\n\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n        System.out.println(solution.check_dict_case(map4)); // False\n\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(map5)); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        if (n <= 2) {\n            return primes; // No primes less than 2\n        }\n        \n        // Step 1: Initialize a boolean array where index represents the number\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        \n        // 0 and 1 are not prime numbers\n        isPrime[0] = false;\n        isPrime[1] = false;\n        \n        // Step 2: Mark non-prime numbers\n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Step 3: Collect prime numbers\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.count_up_to(5));  // Output: [2, 3]\n        System.out.println(sol.count_up_to(11)); // Output: [2, 3, 5, 7]\n        System.out.println(sol.count_up_to(0));  // Output: []\n        System.out.println(sol.count_up_to(20)); // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(sol.count_up_to(1));  // Output: []\n        System.out.println(sol.count_up_to(18)); // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digit of the first integer\n        int unitDigitA = Math.abs(a) % 10;\n        \n        // Extract the unit digit of the second integer\n        int unitDigitB = Math.abs(b) % 10;\n        \n        // Multiply the unit digits\n        int result = unitDigitA * unitDigitB;\n        \n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        \n        // Iterate through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            if (uppercaseVowels.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\")); // Output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        // Parse the string to a double\n        double number = Double.parseDouble(value);\n        \n        // Check if the number is exactly halfway between two integers\n        if (number % 1 == 0.5) {\n            // If the number is positive, round up\n            if (number > 0) {\n                return (int) Math.ceil(number);\n            }\n            // If the number is negative, round down\n            else {\n                return (int) Math.floor(number);\n            }\n        } else {\n            // For other cases, use standard rounding\n            return (int) Math.round(number);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.closest_integer(\"10\"));    // 10\n        System.out.println(sol.closest_integer(\"15.3\"));  // 15\n        System.out.println(sol.closest_integer(\"14.5\"));  // 15\n        System.out.println(sol.closest_integer(\"-14.5\")); // -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int current = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            if (current % 2 == 0) {\n                current += 2; // Next even number\n            } else {\n                current += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.make_a_pile(3)); // Output: [3, 5, 7]\n        System.out.println(sol.make_a_pile(4)); // Output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> words_string(String s) {\n        // Split the string using the regular expression that matches spaces or commas with optional spaces around them\n        String[] words = s.split(\"\\\\s+|,\\\\s*\");\n        // Convert the array to a list and return it\n        return Arrays.asList(words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n        System.out.println(solution.words_string(\"Hello   world,  this is a test\")); // [\"Hello\", \"world\", \"this\", \"is\", \"a\", \"test\"]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure the range is valid\n        if (x > y) {\n            return -1;\n        }\n        \n        // Iterate from y down to x to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n        \n        // If no even number is found, return -1\n        return -1;\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Step 1: Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n        \n        // Step 2: Calculate the sum of integers from n to m\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        // Step 3: Compute the average\n        int count = m - n + 1;\n        double average = (double) sum / count;\n        \n        // Step 4: Round the average to the nearest integer\n        int roundedAverage = (int) Math.round(average);\n        \n        // Step 5: Convert the rounded average to binary\n        String binaryRepresentation = Integer.toBinaryString(roundedAverage);\n        \n        return binaryRepresentation;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.rounded_avg(1, 5)); // Output: \"11\"\n        System.out.println(sol.rounded_avg(7, 5)); // Output: -1\n        System.out.println(sol.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(sol.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all\n     * elements that hasn't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     *\n     * For example:\n     * >>> unique_digits(Arrays.asList(15, 33, 1422, 1))\n     * [1, 15, 33]\n     * >>> unique_digits(Arrays.asList(152, 323, 1422, 10))\n     * []\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!containsEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n    \n    private boolean containsEvenDigit(int num) {\n        String numStr = String.valueOf(num);\n        for (char c : numStr.toCharArray()) {\n            int digit = c - '0';\n            if (digit % 2 == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.unique_digits(Arrays.asList(15, 33, 1422, 1))); // [1, 15, 33]\n        System.out.println(sol.unique_digits(Arrays.asList(152, 323, 1422, 10))); // []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter the array to include only integers between 1 and 9 inclusive\n        List<Integer> filteredArr = new ArrayList<>();\n        for (int num : arr) {\n            if (num >= 1 && num <= 9) {\n                filteredArr.add(num);\n            }\n        }\n\n        // Step 2: Sort the filtered array\n        Collections.sort(filteredArr);\n\n        // Step 3: Reverse the sorted array\n        Collections.reverse(filteredArr);\n\n        // Step 4: Replace each digit with its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredArr) {\n            result.add(getNumberName(num));\n        }\n\n        return result;\n    }\n\n    private String getNumberName(int num) {\n        switch (num) {\n            case 1: return \"One\";\n            case 2: return \"Two\";\n            case 3: return \"Three\";\n            case 4: return \"Four\";\n            case 5: return \"Five\";\n            case 6: return \"Six\";\n            case 7: return \"Seven\";\n            case 8: return \"Eight\";\n            case 9: return \"Nine\";\n            default: return \"\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Output: [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n        List<Integer> arr2 = Arrays.asList();\n        System.out.println(solution.by_length(arr2)); // Output: []\n\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Output: [\"One\"]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Compute factorial of i\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Compute sum of numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.f(5)); // Output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n    \n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int len = str.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(sol.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     * >>> count_nums(Arrays.asList()) == 0\n     * >>> count_nums(Arrays.asList(-1, 11, -11)) == 1\n     * >>> count_nums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            int sumOfDigits = 0;\n            int absNum = Math.abs(num);\n            \n            while (absNum > 0) {\n                sumOfDigits += absNum % 10;\n                absNum /= 10;\n            }\n            \n            if (sumOfDigits > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(sol.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(sol.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true;\n\n        int n = arr.size();\n        int pivot = -1;\n\n        // Find the pivot where the sequence breaks\n        for (int i = 0; i < n; i++) {\n            if (arr.get(i) > arr.get((i + 1) % n)) {\n                if (pivot != -1) return false; // More than one break point\n                pivot = i;\n            }\n        }\n\n        // If no pivot found, the array is already sorted\n        if (pivot == -1) return true;\n\n        // Check if the array is sorted after rotating around the pivot\n        for (int i = 0; i < n - 1; i++) {\n            int current = (pivot + 1 + i) % n;\n            int next = (pivot + 2 + i) % n;\n            if (arr.get(current) > arr.get(next)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count the number of odd elements in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        // Count the number of even elements in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // Check if we have enough even elements in lst2 to replace all odd elements in lst1\n        if (evenCountInLst2 >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // \"YES\"\n        System.out.println(sol.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Step 1: Split the input string into individual letters\n        String[] letters = test.split(\" \");\n        \n        // Step 2: Use a map to count the frequency of each letter\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String letter : letters) {\n            frequencyMap.put(letter, frequencyMap.getOrDefault(letter, 0) + 1);\n        }\n        \n        // Step 3: Determine the maximum frequency\n        int maxFrequency = 0;\n        for (int count : frequencyMap.values()) {\n            if (count > maxFrequency) {\n                maxFrequency = count;\n            }\n        }\n        \n        // Step 4: Filter letters by the maximum frequency\n        Map<String, Integer> resultMap = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() == maxFrequency) {\n                resultMap.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        return resultMap;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set of characters to be removed for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // StringBuilder to store the resulting string after removal\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through the string s and append characters not in charsToRemove\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                result.append(ch);\n            }\n        }\n\n        // Convert the StringBuilder to a string\n        String resultString = result.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = isPalindrome(resultString);\n\n        // Return the result as a list containing the string and the boolean\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n\n        return resultList;\n    }\n\n    // Helper method to check if a string is a palindrome\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.reverse_delete(\"abcde\", \"ae\")); // [\"bcd\", false]\n        System.out.println(sol.reverse_delete(\"abcdef\", \"b\")); // [\"acdef\", false]\n        System.out.println(sol.reverse_delete(\"abcdedcba\", \"ab\")); // [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n            int oddCount = 0;\n            \n            // Count the number of odd digits in the string\n            for (char ch : str.toCharArray()) {\n                if (Character.isDigit(ch) && (ch - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            \n            // Construct the output string\n            String output = String.format(\"the number of odd elements %dn the str%dng %d of the %dnput.\", oddCount, oddCount, oddCount, oddCount);\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.odd_count(Arrays.asList(\"1234567\")));\n        // Expected output: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        System.out.println(sol.odd_count(Arrays.asList(\"3\", \"11111111\")));\n        // Expected output: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        // Initialize the minimum sum ending here and the minimum sum so far\n        int minEndingHere = nums.get(0);\n        int minSoFar = nums.get(0);\n\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < nums.size(); i++) {\n            // Update minEndingHere to be the minimum of the current element or the current element plus minEndingHere\n            minEndingHere = Math.min(nums.get(i), minEndingHere + nums.get(i));\n            // Update minSoFar to be the minimum of minSoFar and minEndingHere\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n\n        // Return the minimum sum found\n        return minSoFar;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Output: 1\n        System.out.println(sol.minSubArraySum(Arrays.asList(-1, -2, -3))); // Output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalBucketsLowered = 0;\n        \n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n            for (int unit : row) {\n                if (unit == 1) {\n                    waterUnits++;\n                }\n            }\n            // Calculate the number of times the bucket needs to be lowered\n            int timesLowered = (int) Math.ceil((double) waterUnits / capacity);\n            totalBucketsLowered += timesLowered;\n        }\n        \n        return totalBucketsLowered;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(sol.max_fill(grid1, capacity1)); // Output: 6\n        \n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(sol.max_fill(grid2, capacity2)); // Output: 5\n        \n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(sol.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    In this Kata, you have to sort an array of integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n    <p>\n    It must be implemented like this:\n    >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n    >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n    >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort the array using a custom comparator\n        arr.sort(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                // Count the number of ones in the binary representation\n                int countOnesA = Integer.bitCount(a);\n                int countOnesB = Integer.bitCount(b);\n                \n                // Compare based on the number of ones\n                if (countOnesA != countOnesB) {\n                    return countOnesA - countOnesB;\n                } else {\n                    // If the number of ones is the same, compare based on decimal value\n                    return a - b;\n                }\n            }\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList(1, 5, 2, 3, 4))); // [1, 2, 4, 3, 5]\n        System.out.println(solution.sort_array(Arrays.asList(-2, -3, -4, -5, -6))); // [-4, -2, -6, -5, -3]\n        System.out.println(solution.sort_array(Arrays.asList(1, 0, 2, 3, 4))); // [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // List to store the result\n        List<String> result = new ArrayList<>();\n        \n        // If the input string is empty, return the empty list\n        if (s.isEmpty()) {\n            return result;\n        }\n        \n        // Split the string into words\n        String[] words = s.split(\" \");\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Count the number of consonants in the word\n            int consonantCount = countConsonants(word);\n            \n            // If the consonant count matches n, add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n    \n    // Helper method to count consonants in a word\n    private int countConsonants(String word) {\n        int count = 0;\n        // Convert the word to lowercase to handle case insensitivity\n        word = word.toLowerCase();\n        \n        // Iterate through each character in the word\n        for (char c : word.toCharArray()) {\n            // Check if the character is a consonant\n            if (isConsonant(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    // Helper method to check if a character is a consonant\n    private boolean isConsonant(char c) {\n        // Define the set of vowels\n        String vowels = \"aeiou\";\n        \n        // Check if the character is a letter and not a vowel\n        return Character.isLetter(c) && vowels.indexOf(c) == -1;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        // Define the set of vowels (case sensitive)\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Traverse the word from right to left\n        for (int i = word.length() - 1; i >= 0; i--) {\n            char currentChar = word.charAt(i);\n            \n            // Check if the current character is a vowel\n            if (vowels.contains(currentChar)) {\n                // Check if it is between two consonants\n                if (i > 0 && i < word.length() - 1) {\n                    char prevChar = word.charAt(i - 1);\n                    char nextChar = word.charAt(i + 1);\n                    \n                    // Check if both previous and next characters are consonants\n                    if (!vowels.contains(prevChar) && !vowels.contains(nextChar)) {\n                        return String.valueOf(currentChar);\n                    }\n                }\n            }\n        }\n        \n        // If no such vowel is found, return an empty string\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.get_closest_vowel(\"yogurt\")); // \"u\"\n        System.out.println(sol.get_closest_vowel(\"FULL\"));   // \"U\"\n        System.out.println(sol.get_closest_vowel(\"quick\"));  // \"\"\n        System.out.println(sol.get_closest_vowel(\"ab\"));     // \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int openCount = 0;\n        int closeCount = 0;\n\n        // Count the number of opening and closing parentheses in both strings\n        for (String str : lst) {\n            for (char ch : str.toCharArray()) {\n                if (ch == '(') {\n                    openCount++;\n                } else if (ch == ')') {\n                    closeCount++;\n                }\n            }\n        }\n\n        // Check if the counts of opening and closing parentheses are equal\n        if (openCount == closeCount) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.match_parens(Arrays.asList(\"()(\", \")\"))); // Output: \"Yes\"\n        System.out.println(sol.match_parens(Arrays.asList(\")\", \")\"))); // Output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in ascending order\n        Collections.sort(arr);\n        \n        // Step 2: Select the top k elements from the end of the sorted array\n        List<Integer> result = new ArrayList<>();\n        for (int i = arr.size() - k; i < arr.size(); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Step 3: Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3)); // Output: [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2)); // Output: [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0) { // Check if the index is even\n                if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                    sum += lst.get(i);\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        \n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            int num = arr.get(i);\n            \n            // Check if the number has at most two digits\n            if (num >= 0 && num <= 99) {\n                sum += num;\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        \n        int result = sol.add_elements(arr, k);\n        System.out.println(result); // Output should be 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddNumbers = new ArrayList<>();\n        \n        // Start with the given number\n        int current = n;\n        \n        // Loop until we reach 1\n        while (current != 1) {\n            // Check if the current number is odd\n            if (current % 2 != 0) {\n                oddNumbers.add(current);\n            }\n            \n            // Generate the next number in the sequence\n            if (current % 2 == 0) {\n                current = current / 2;\n            } else {\n                current = 3 * current + 1;\n            }\n        }\n        \n        // Add 1 to the list as it is always the last number in the sequence\n        oddNumbers.add(1);\n        \n        // Sort the list in increasing order\n        Collections.sort(oddNumbers);\n        \n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Output: [1, 5]\n        System.out.println(solution.get_odd_collatz(1)); // Output: [1]\n        System.out.println(solution.get_odd_collatz(10)); // Output: [1, 5]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Validates a given date string and returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\n     *    And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\n     *    And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * @param date The date string to validate.\n     * @return true if the date is valid, false otherwise.\n     */\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Check if the date string matches the format mm-dd-yyyy\n        if (!date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) {\n            return false;\n        }\n\n        // Split the date string into month, day, and year\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is valid\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Check if the day is valid based on the month\n        if (month == 2) {\n            // February can have 29 days in a leap year, otherwise 28\n            if (day < 1 || day > 29) {\n                return false;\n            }\n            // Check for leap year\n            if (day == 29 && !isLeapYear(year)) {\n                return false;\n            }\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            // April, June, September, November have 30 days\n            if (day < 1 || day > 30) {\n                return false;\n            }\n        } else {\n            // All other months have 31 days\n            if (day < 1 || day > 31) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    /**\n     * Helper method to determine if a given year is a leap year.\n     * @param year The year to check.\n     * @return true if the year is a leap year, false otherwise.\n     */\n    private boolean isLeapYear(int year) {\n        if (year % 4 == 0) {\n            if (year % 100 == 0) {\n                return year % 400 == 0;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-00-2040\")); // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        \n        // Check for commas\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        }\n        \n        // Count lowercase letters with odd alphabet indices\n        int oddCount = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 != 0) {\n                    oddCount++;\n                }\n            }\n        }\n        \n        return oddCount;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(sol.split_words(\"abcdef\")); // 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // If the list is empty or has only one element, it is trivially sorted\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        // Use a HashMap to count the occurrences of each number\n        Map<Integer, Integer> countMap = new HashMap<>();\n\n        // Iterate through the list to check for sorting and count occurrences\n        for (int i = 0; i < lst.size() - 1; i++) {\n            int current = lst.get(i);\n            int next = lst.get(i + 1);\n\n            // Check if the list is not sorted\n            if (current > next) {\n                return false;\n            }\n\n            // Update the count of the current number\n            countMap.put(current, countMap.getOrDefault(current, 0) + 1);\n\n            // If any number appears more than twice, return false\n            if (countMap.get(current) > 2) {\n                return false;\n            }\n        }\n\n        // Check the last element in the list\n        int lastElement = lst.get(lst.size() - 1);\n        countMap.put(lastElement, countMap.getOrDefault(lastElement, 0) + 1);\n        if (countMap.get(lastElement) > 2) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n        \n        int intersectionStart = Math.max(start1, start2);\n        int intersectionEnd = Math.min(end1, end2);\n        \n        if (intersectionStart <= intersectionEnd) {\n            int lengthOfIntersection = intersectionEnd - intersectionStart + 1;\n            if (isPrime(lengthOfIntersection)) {\n                return \"YES\";\n            }\n        }\n        \n        return \"NO\";\n    }\n    \n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int sumOfMagnitudes = 0;\n\n        for (int num : arr) {\n            if (num > 0) {\n                signProduct *= 1;\n            } else if (num < 0) {\n                signProduct *= -1;\n            } else {\n                signProduct *= 0;\n            }\n            sumOfMagnitudes += Math.abs(num);\n        }\n\n        return Optional.of(sumOfMagnitudes * signProduct);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1))); // Output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList())); // Output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        List<Integer> minPath = null;\n\n        // BFS queue\n        Queue<int[]> queue = new LinkedList<>();\n        // Initialize the queue with all starting points\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                queue.offer(new int[]{i, j, 0});\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int length = current[2];\n\n            // If the path length is k, we need to compare and update the minimum path\n            if (length == k) {\n                List<Integer> currentPath = new ArrayList<>();\n                for (int[] step : queue) {\n                    currentPath.add(grid.get(step[0]).get(step[1]));\n                }\n                currentPath.add(grid.get(x).get(y));\n\n                if (minPath == null || isLexicographicallySmaller(currentPath, minPath)) {\n                    minPath = currentPath;\n                }\n                continue;\n            }\n\n            // Explore all possible moves\n            for (int[] dir : directions) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n\n                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {\n                    queue.offer(new int[]{newX, newY, length + 1});\n                }\n            }\n        }\n\n        return minPath;\n    }\n\n    private boolean isLexicographicallySmaller(List<Integer> path1, List<Integer> path2) {\n        for (int i = 0; i < path1.size(); i++) {\n            if (path1.get(i) < path2.get(i)) {\n                return true;\n            } else if (path1.get(i) > path2.get(i)) {\n                return false;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Base case\n        result.add(3); // tri(1) = 3\n        \n        for (int i = 2; i <= n + 1; i++) {\n            if (i % 2 == 0) {\n                // Even case\n                result.add(1 + i / 2);\n            } else {\n                // Odd case\n                int prev1 = result.get(i - 2); // tri(i - 1)\n                int prev2 = result.get(i - 3); // tri(i - 2)\n                int next1 = 1 + (i + 1) / 2;  // tri(i + 1)\n                result.add(prev1 + prev2 + next1);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.tri(3)); // Output: [3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Initialize the product to 1\n        int product = 1;\n        // Convert the number to a string to iterate through each digit\n        String numStr = Integer.toString(n);\n        // Flag to check if any odd digit is found\n        boolean hasOddDigit = false;\n        \n        // Iterate through each character in the string\n        for (char ch : numStr.toCharArray()) {\n            // Convert the character to an integer\n            int digit = Character.getNumericValue(ch);\n            // Check if the digit is odd\n            if (digit % 2 != 0) {\n                // Multiply the product by the odd digit\n                product *= digit;\n                // Set the flag to true as we found an odd digit\n                hasOddDigit = true;\n            }\n        }\n        \n        // If no odd digit was found, return 0\n        if (!hasOddDigit) {\n            return 0;\n        }\n        \n        // Return the product of the odd digits\n        return product;\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean foundNested = false;\n\n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n            } else if (ch == ']') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                    foundNested = true; // We found a nested pair\n                }\n            }\n        }\n\n        // If we found at least one nested pair, return true\n        return foundNested;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        \n        for (Double num : lst) {\n            // Round up to the nearest integer\n            int roundedNum = (int) Math.ceil(num);\n            // Square the rounded number\n            int squaredNum = roundedNum * roundedNum;\n            // Add to the sum\n            sum += squaredNum;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(sol.sum_squares(lst1)); // Output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(sol.sum_squares(lst2)); // Output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(sol.sum_squares(lst3)); // Output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(sol.sum_squares(lst4)); // Output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(sol.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt.isEmpty()) {\n            return false;\n        }\n\n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is an alphabetical character\n        if (Character.isLetter(lastChar)) {\n            // Check if the last character is not part of a word\n            // This means the last character should be followed by spaces or be the last character in the string\n            if (txt.length() == 1 || txt.charAt(txt.length() - 2) == ' ') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(sol.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(sol.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(sol.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < arr.size(); i++) {\n            // Check if the current element is not greater than or equal to the previous element\n            if (arr.get(i) < arr.get(i - 1)) {\n                // Return the index of the current element\n                return i;\n            }\n        }\n        // If no such element is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (!largestNegative.isPresent() || num > largestNegative.get()) {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // (Optional.empty(), Optional.empty())\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        // Convert inputs to a common type for comparison\n        double valA = convertToDouble(a);\n        double valB = convertToDouble(b);\n\n        // Compare the values\n        if (valA > valB) {\n            return Optional.of(a);\n        } else if (valB > valA) {\n            return Optional.of(b);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    private double convertToDouble(Object obj) {\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        } else if (obj instanceof Float) {\n            return ((Float) obj).doubleValue();\n        } else if (obj instanceof Double) {\n            return (Double) obj;\n        } else if (obj instanceof String) {\n            String str = (String) obj;\n            // Replace commas with dots for floating point numbers\n            str = str.replace(',', '.');\n            return Double.parseDouble(str);\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass());\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "public class Java138 {\n    public boolean is_equal_to_sum_even(int n) {\n        int originalN = n; // Store the original value of n\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 0) {\n                sum += digit;\n            }\n            n /= 10;\n        }\n        return sum == originalN; // Compare sum with the original value of n\n    }\n\n    public static void main(String[] args) {\n        Java138 obj = new Java138();\n        System.out.println(obj.is_equal_to_sum_even(246)); // Example usage\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to calculate the factorial of a given number.\n     * @param num The number to calculate the factorial for.\n     * @return The factorial of the number.\n     */\n    private long factorial(int num) {\n        long result = 1;\n        for (int i = 1; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    /**\n     * Method to calculate the Brazilian factorial of a given number.\n     * @param n The number to calculate the Brazilian factorial for.\n     * @return The Brazilian factorial of the number.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = n; i >= 1; i--) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.special_factorial(4)); // Output should be 288\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Replace all single spaces with underscores\n        text = text.replace(\" \", \"_\");\n        \n        // Use a regular expression to find sequences of more than 2 consecutive underscores\n        // and replace them with a single hyphen\n        text = text.replaceAll(\"_{2,}\", \"-\");\n        \n        return text;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\")); // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\")); // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\")); // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\")); // \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotIndex = file_name.indexOf('.');\n        if (dotIndex == -1 || dotIndex != file_name.lastIndexOf('.')) {\n            return \"No\";\n        }\n\n        // Split the file name into prefix and suffix\n        String prefix = file_name.substring(0, dotIndex);\n        String suffix = file_name.substring(dotIndex + 1);\n\n        // Check if the prefix is not empty and starts with a Latin alphabet letter\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check if the suffix is one of the allowed extensions\n        Set<String> allowedExtensions = new HashSet<>(Arrays.asList(\"txt\", \"exe\", \"dll\"));\n        if (!allowedExtensions.contains(suffix)) {\n            return \"No\";\n        }\n\n        // Count the digits in the prefix\n        int digitCount = 0;\n        for (char c : prefix.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n                if (digitCount > 3) {\n                    return \"No\";\n                }\n            }\n        }\n\n        // If all conditions are met, return \"Yes\"\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.file_name_check(\"example.txt\")); // => \"Yes\"\n        System.out.println(solution.file_name_check(\"1example.dll\")); // => \"No\"\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int value = lst.get(i);\n            \n            if (i % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                value = value * value;\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the value if index is a multiple of 4 but not a multiple of 3\n                value = value * value * value;\n            }\n            \n            // Add the transformed value to the sum\n            sum += value;\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(sol.sum_squares(lst1)); // Output: 6\n        \n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(sol.sum_squares(lst2)); // Output: 0\n        \n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(sol.sum_squares(lst3)); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to collect the words with prime length\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Check if the length of the word is a prime number\n            if (isPrime(word.length())) {\n                // Append the word to the result\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        // Return the resulting string\n        return result.toString();\n    }\n    \n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(sol.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the input fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n        \n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n        \n        // Compute the product of the two fractions\n        int numeratorProduct = numeratorX * numeratorN;\n        int denominatorProduct = denominatorX * denominatorN;\n        \n        // Simplify the resulting fraction\n        int gcd = gcd(numeratorProduct, denominatorProduct);\n        numeratorProduct /= gcd;\n        denominatorProduct /= gcd;\n        \n        // Check if the simplified fraction is a whole number\n        return denominatorProduct == 1;\n    }\n    \n    // Helper method to compute the greatest common divisor (GCD)\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (original number, sum of digits)\n        List<Pair> pairs = new ArrayList<>();\n        \n        for (int num : nums) {\n            pairs.add(new Pair(num, sumOfDigits(num)));\n        }\n        \n        // Sort the list of pairs based on the sum of digits\n        Collections.sort(pairs, Comparator.comparingInt(Pair::getSumOfDigits));\n        \n        // Extract the sorted numbers from the pairs\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.getNum());\n        }\n        \n        return sortedNums;\n    }\n    \n    // Helper method to calculate the sum of digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n        \n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        \n        return isNegative ? -sum : sum;\n    }\n    \n    // Helper class to store the original number and its sum of digits\n    private static class Pair {\n        private final int num;\n        private final int sumOfDigits;\n        \n        public Pair(int num, int sumOfDigits) {\n            this.num = num;\n            this.sumOfDigits = sumOfDigits;\n        }\n        \n        public int getNum() {\n            return num;\n        }\n        \n        public int getSumOfDigits() {\n            return sumOfDigits;\n        }\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an array of numbers as input and returns\n    the number of elements in the array that are greater than 10 and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n    specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        \n        for (int num : nums) {\n            if (num > 10) {\n                int absNum = Math.abs(num);\n                int lastDigit = absNum % 10;\n                \n                // Extract the first digit\n                while (absNum >= 10) {\n                    absNum /= 10;\n                }\n                int firstDigit = absNum;\n                \n                // Check if both first and last digits are odd\n                if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Generate the array a\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Step 2: Initialize the count of valid triples\n        int count = 0;\n\n        // Step 3: Iterate through all possible triples (i, j, k)\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    // Step 4: Check if the sum of a[i], a[j], a[k] is a multiple of 3\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Step 5: Return the count of valid triples\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.get_max_triples(5)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    );\n\n    public List<String> bf(String planet1, String planet2) {\n        // Validate the input planets\n        if (!PLANETS.contains(planet1) || !PLANETS.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        // Find the indices of the planets\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for consistency\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Extract the planets between index1 and index2 (exclusive)\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\")); // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\")); // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Step 2: Sort the filtered list\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                // First, compare by length\n                int lengthCompare = Integer.compare(s1.length(), s2.length());\n                if (lengthCompare != 0) {\n                    return lengthCompare;\n                }\n                // If lengths are the same, compare alphabetically\n                return s1.compareTo(s2);\n            }\n        });\n\n        // Step 3: Return the sorted list\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        List<String> result1 = solution.sorted_list_sum(test1);\n        System.out.println(result1); // Output: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        List<String> result2 = solution.sorted_list_sum(test2);\n        System.out.println(result2); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        // Handle the case where n is less than 2\n        if (n < 2) {\n            return y;\n        }\n        \n        // Check for primality\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return y; // n is not a prime\n            }\n        }\n        \n        // If no divisors were found, n is a prime\n        return x;\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n        \n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num;\n                }\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the lists\n        for (int i = 0; i < game.size(); i++) {\n            int gameScore = game.get(i);\n            int guessScore = guess.get(i);\n            \n            // Compare the scores\n            if (gameScore == guessScore) {\n                result.add(0);\n            } else {\n                result.add(Math.abs(gameScore - guessScore));\n            }\n        }\n        \n        // Return the result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2))); // [0, 0, 0, 0, 3, 3]\n        System.out.println(solution.compare(Arrays.asList(0, 5, 0, 0, 0, 4), Arrays.asList(4, 1, 1, 0, 0, -2))); // [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            int capCount = 0;\n            int smCount = 0;\n\n            // Count the number of uppercase and lowercase letters\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    capCount++;\n                } else if (Character.isLowerCase(c)) {\n                    smCount++;\n                }\n            }\n\n            // Calculate the strength of the extension\n            int strength = capCount - smCount;\n\n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Output: \"Slices.SErviNGSliCes\"\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Output: \"my_class.AA\"\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate b with itself to generate all rotations\n        String concatenated = b + b;\n        \n        // Check if the first word a is a substring of the concatenated string\n        return concatenated.contains(a);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(sol.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(sol.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(sol.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(sol.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(sol.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer, return a list that has the number of even and odd digits respectively.\n    \n     Example:\n        even_odd_count(-12) ==> [1, 1]\n        even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to its absolute value to handle negative numbers\n        num = Math.abs(num);\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Loop through each digit of the number\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                evenCount++; // Increment even count if the digit is even\n            } else {\n                oddCount++; // Increment odd count if the digit is odd\n            }\n            num /= 10; // Remove the last digit\n        }\n        \n        // Return the counts as a list\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.even_odd_count(-12)); // Output: [1, 1]\n        System.out.println(sol.even_odd_count(123)); // Output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == \"xix\"\n    >>> int_to_mini_roman(152) == \"clii\"\n    >>> int_to_mini_roman(426) == \"cdxxvi\"\n     */\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        \n        StringBuilder roman = new StringBuilder();\n        \n        // Iterate through the values and symbols\n        for (int i = 0; i < values.length; i++) {\n            // While the current value can be subtracted from the number\n            while (number >= values[i]) {\n                // Subtract the value from the number\n                number -= values[i];\n                // Append the corresponding symbol to the result\n                roman.append(symbols[i]);\n            }\n        }\n        \n        // Return the result as a string\n        return roman.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Identify the longest side\n        int maxSide = Math.max(a, Math.max(b, c));\n        \n        // Check which side is the longest and apply the Pythagorean theorem\n        if (maxSide == a) {\n            return a * a == b * b + c * c;\n        } else if (maxSide == b) {\n            return b * b == a * a + c * c;\n        } else {\n            return c * c == a * a + b * b;\n        }\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            // Use a HashSet to count unique characters in the word\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            int uniqueCount = uniqueChars.size();\n\n            // Check if the current word has more unique characters\n            // or if it has the same number but is lexicographically smaller\n            if (uniqueCount > maxUniqueChars || (uniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))); // \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots eaten\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate the number of carrots left\n        int carrotsLeft = Math.max(0, remaining - need);\n        \n        // Return the result as a list\n        return Arrays.asList(totalEaten, carrotsLeft);\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a list to hold the tokens of the expression\n        List<String> tokens = new ArrayList<>();\n        \n        // Add the first operand\n        tokens.add(String.valueOf(operand.get(0)));\n        \n        // Iterate through the operators and operands to build the expression\n        for (int i = 0; i < operator.size(); i++) {\n            tokens.add(operator.get(i));\n            tokens.add(String.valueOf(operand.get(i + 1)));\n        }\n        \n        // Evaluate the expression using a stack-based approach\n        return evaluateExpression(tokens);\n    }\n    \n    private int evaluateExpression(List<String> tokens) {\n        // Define the precedence of operators\n        Map<String, Integer> precedence = new HashMap<>();\n        precedence.put(\"**\", 3);\n        precedence.put(\"*\", 2);\n        precedence.put(\"/\", 2);\n        precedence.put(\"+\", 1);\n        precedence.put(\"-\", 1);\n        \n        Stack<Integer> operands = new Stack<>();\n        Stack<String> operators = new Stack<>();\n        \n        for (String token : tokens) {\n            if (token.matches(\"\\\\d+\")) {\n                // If the token is an operand, push it to the operands stack\n                operands.push(Integer.parseInt(token));\n            } else {\n                // If the token is an operator, handle the precedence and evaluate\n                while (!operators.isEmpty() && precedence.get(operators.peek()) >= precedence.get(token)) {\n                    int b = operands.pop();\n                    int a = operands.pop();\n                    String op = operators.pop();\n                    int result = applyOperation(a, b, op);\n                    operands.push(result);\n                }\n                operators.push(token);\n            }\n        }\n        \n        // Evaluate any remaining operators\n        while (!operators.isEmpty()) {\n            int b = operands.pop();\n            int a = operands.pop();\n            String op = operators.pop();\n            int result = applyOperation(a, b, op);\n            operands.push(result);\n        }\n        \n        // The final result should be the only element left in the operands stack\n        return operands.pop();\n    }\n    \n    private int applyOperation(int a, int b, String operator) {\n        switch (operator) {\n            case \"+\":\n                return a + b;\n            case \"-\":\n                return a - b;\n            case \"*\":\n                return a * b;\n            case \"/\":\n                return a / b; // Floor division\n            case \"**\":\n                return (int) Math.pow(a, b); // Exponentiation\n            default:\n                throw new IllegalArgumentException(\"Invalid operator: \" + operator);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        System.out.println(sol.do_algebra(operator, operand)); // Output: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean containsLetter = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                break;\n            }\n        }\n\n        // If the string contains no letters, reverse the string\n        if (!containsLetter) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // If the string contains letters, process each character\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Reverse the case of the letter\n                if (Character.isUpperCase(c)) {\n                    result.append(Character.toLowerCase(c));\n                } else {\n                    result.append(Character.toUpperCase(c));\n                }\n            } else {\n                // Keep non-letter characters as they are\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solve(\"1234\")); // Output: \"4321\"\n        System.out.println(sol.solve(\"ab\"));   // Output: \"AB\"\n        System.out.println(sol.solve(\"#a@C\")); // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Check if the input string is empty\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Create a MessageDigest instance for MD5\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        // Compute the MD5 hash of the input string\n        byte[] messageDigest = md.digest(text.getBytes());\n\n        // Convert the byte array to a BigInteger\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert the BigInteger to a hexadecimal string\n        String hashtext = no.toString(16);\n\n        // Pad the hexadecimal string with leading zeros if necessary\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        // Return the hexadecimal string wrapped in an Optional\n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Define the even digits less than 10\n        List<Integer> evenDigits = Arrays.asList(2, 4, 6, 8);\n        \n        // Determine the range [min, max]\n        int min = Math.min(a, b);\n        int max = Math.max(a, b);\n        \n        // Create a list to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the range and add even digits to the result\n        for (int i = min; i <= max; i++) {\n            if (evenDigits.contains(i)) {\n                result.add(i);\n            }\n        }\n        \n        // Return the result\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(sol.generate_integers(10, 14)); // []\n    }\n}\n"}
