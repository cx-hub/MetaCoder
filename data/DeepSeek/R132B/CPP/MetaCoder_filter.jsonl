{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    \n    sort(numbers.begin(), numbers.end());\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = fabs(numbers[i+1] - numbers[i]);\n        if (diff < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "To solve this problem, we need to identify and extract all valid parentheses groups from a given string. A valid parentheses group is defined as a sequence of parentheses that are properly nested and closed. \n\n### Approach\nThe approach involves iterating through each character in the string while maintaining a balance counter. The balance counter helps us track whether we are inside a valid parentheses group. Here's a step-by-step breakdown:\n\n1. **Initialize Variables**: We use `temp_str` to build the current group of parentheses, `result` to store all valid groups found, and `balance` to keep track of the nesting level.\n\n2. **Iterate Through Each Character**:\n   - For each opening parenthesis '(', we increment the balance counter.\n   - For each closing parenthesis ')', we decrement the balance counter.\n   - If the balance counter drops below zero, it indicates an invalid group starting with a closing parenthesis, so we reset `temp_str` and continue.\n\n3. **Check for Valid Group**:\n   - After processing each character, if the balance counter reaches zero, it means we have found a valid parentheses group. We add this group to our result list and reset `temp_str` to start building the next potential group.\n\n4. **Edge Cases**: The solution handles edge cases such as an empty string or strings with no valid groups by returning an empty list.\n\n### Solution Code\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    return number - integer_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int current_balance = 0;\n    for (int op : operations) {\n        current_balance += op;\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f;\n    \n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n    \n    sum = 0.0f;\n    for (float num : numbers) {\n        sum += abs(num - mean);\n    }\n    \n    return sum / numbers.size();\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    int n = numbers.size();\n    for (int i = 0; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    istringstream iss(paren_string);\n    string group;\n    \n    while (iss >> group) { // Split the input into groups separated by whitespace\n        int current_depth = 0;\n        int max_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else { // When encountering ')'\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const auto& s : strings) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(const string& s) {\n    int n = s.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (s[i] != s[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring make_palindrome(const string& str) {\n    for (int i = 0; i < str.size(); ++i) {\n        string substr = str.substr(i);\n        if (is_palindrome(substr)) {\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result;\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] != b[i]) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    string result = strings[0];\n    int max_len = result.length();\n    \n    for (size_t i = 1; i < strings.size(); ++i) {\n        const string& s = strings[i];\n        int len = s.length();\n        if (len > max_len) {\n            max_len = len;\n            result = s;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <cstdlib>\n\nint greatest_common_divisor(int a, int b) {\n    a = std::abs(a);\n    b = std::abs(b);\n    if (b == 0) {\n        return a;\n    } else {\n        return greatest_common_divisor(b, a % b);\n    }\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    for (int i = 1; i <= str.size(); ++i) {\n        string prefix = str.substr(0, i);\n        result.push_back(prefix);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        if (i != 0) {\n            result += \" \";\n        }\n        result += to_string(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <set>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> unique_chars;\n    for (char c : str) {\n        char lower_c = tolower(c);\n        unique_chars.insert(lower_c);\n    }\n    return unique_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    istringstream iss(music_string);\n    string token;\n    \n    while (iss >> token) {\n        if (token == \"o\") {\n            result.push_back(4);\n        } else if (token.size() >= 2 && token[0] == 'o' && token[1] == '|') {\n            result.push_back(2);\n        } else if (token == \".|\") {\n            result.push_back(1);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int len_str = str.length();\n    int len_sub = substring.length();\n\n    if (len_sub == 0 || len_str < len_sub) {\n        return 0;\n    }\n\n    for (int i = 0; i <= len_str - len_sub; ++i) {\n        string current = str.substr(i, len_sub);\n        if (current == substring) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <string>\n#include <vector>\n#include <sstream>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(const string& numbers) {\n    // Mapping from numeral strings to their integer values\n    unordered_map<string, int> number_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into individual words\n    vector<string> words;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Sort the words based on their numeric values using the map\n    sort(words.begin(), words.end(), [&number_map](const string& a, const string& b) {\n        return number_map[a] < number_map[b];\n    });\n\n    // Join the sorted words into a single string separated by spaces\n    stringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << words[i];\n    }\n\n    return oss.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = FLT_MAX;\n    vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return vector<float>(numbers.size(), 0.0f);\n    }\n    \n    vector<float> result;\n    for (float x : numbers) {\n        result.push_back((x - min_val) / (max_val - min_val));\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (auto& elem : values) {\n        if (elem.type() == typeid(int)) {\n            int val = boost::any_cast<int>(elem);\n            result.push_back(val);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    if (n <= 1) return factors; // No prime factors for numbers less than or equal to 1\n\n    int i = 2;\n    while (i * i <= n) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        ++i;\n    }\n\n    if (n > 1) {\n        factors.push_back(n); // The remaining n is a prime factor\n    }\n\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> freq;\n    for (int num : numbers) {\n        freq[num]++;\n    }\n    vector<int> result;\n    for (int num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (int i = 0; i < str.size(); ++i) {\n        char c = str[i];\n        if (islower(static_cast<unsigned char>(c))) {\n            str[i] = toupper(c);\n        } else if (isupper(static_cast<unsigned char>(c))) {\n            str[i] = tolower(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& s : strings) {\n        result += s;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const string& s : strings) {\n        if (s.size() >= prefix.size()) {\n            if (s.substr(0, prefix.size()) == prefix) {\n                result.push_back(s);\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1)\n        return false;\n    if (n == 2 || n == 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    \n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\nusing namespace std;\n\nint find_zero(const vector<int>& arr) {\n    // Function implementation goes here\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    sort(third_elements.begin(), third_elements.end());\n    \n    vector<int> result = l;\n    int j = 0;\n    for (int i = 0; i < result.size(); ++i) {\n        if (i % 3 == 0) {\n            result[i] = third_elements[j];\n            j++;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    if (l.empty()) return {};\n\n    sort(l.begin(), l.end());\n\n    vector<int> result;\n    result.push_back(l[0]);\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] != result.back()) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return 0; // Assuming handling empty case by returning 0, though problem expects non-empty.\n    }\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "int fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num != 0) {\n                int digit = num % 10;\n                if (digit == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> evens;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            evens.push_back(l[i]);\n        }\n    }\n    sort(evens.begin(), evens.end());\n    \n    vector<float> result;\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(evens[even_index]);\n            even_index++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Move the last character to the front\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\nlong long fib(int n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);\n}\n\nbool is_prime(int num) {\n    if (num <= 1)\n        return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int count = 0;\n    long long k = 0;\n    while (true) {\n        long long fib_num = fib(k);\n        if (is_prime(fib_num)) {\n            count++;\n            if (count == n)\n                return fib_num;\n        }\n        k++;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Implementation will go here\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> s;\n    for (int num : l) {\n        if (s.count(-num)) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base > 36) {\n        return \"\"; // Invalid base case, though problem assumes valid input.\n    }\n\n    bool negative = false;\n    if (x == 0) {\n        return \"0\";\n    } else if (x < 0) {\n        negative = true;\n        x = -x;\n    }\n\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    vector<char> digits;\n\n    while (x > 0) {\n        int rem = x % base;\n        digits.push_back(chars[rem]);\n        x /= base;\n    }\n\n    reverse(digits.begin(), digits.end());\n\n    if (negative) {\n        digits.insert(digits.begin(), '-');\n    }\n\n    return string(digits.begin(), digits.end());\n}\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2.0f;\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n    \n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float a = l[(n / 2) - 1];\n        float b = l[n / 2];\n        return (a + b) / 2.0f;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int len = text.size();\n    if (len <= 1)\n        return true;\n    for (int i = 0; i < len / 2; ++i) {\n        if (text[i] != text[len - 1 - i])\n            return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "int modp(int n, int p) {\n    if (p == 1) return 0;\n    long result = 1;\n    long base = 2 % p;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return (int)result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // returns decoded string by shifting every character back by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        // Ensure non-negative result\n        if (w < 0) {\n            w += 26;\n        }\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        char lower_c = tolower(c);\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <string>\n#include <stack>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else { // c is '>'\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    int n = l.size();\n    if (n <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        float current = l[i];\n        float next = l[i + 1];\n        \n        if (current > next) {\n            increasing = false;\n        } else if (current < next) {\n            decreasing = false;\n        }\n        \n        // Early exit if both flags are false\n        if (!increasing && !decreasing) {\n            return false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort and remove duplicates for the first list\n    sort(l1.begin(), l1.end());\n    auto last1 = unique(l1.begin(), l1.end());\n    l1.erase(last1, l1.end());\n\n    // Sort and remove duplicates for the second list\n    sort(l2.begin(), l2.end());\n    auto last2 = unique(l2.begin(), l2.end());\n    l2.erase(last2, l2.end());\n\n    // Find the intersection of both lists\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(),\n                     l2.begin(), l2.end(),\n                     back_inserter(result));\n\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int max_prime = -1;\n    \n    // Divide out 2s\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n /= 2;\n    }\n    \n    // Check odd numbers up to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n            n /= i;\n        }\n    }\n    \n    // If remaining n is a prime\n    if (n > 2)\n        max_prime = n;\n        \n    return max_prime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> res;\n    if (xs.size() <= 1) return res; // Return empty for size 0 or 1\n    for (int i = 1; i < xs.size(); ++i) {\n        res.push_back(xs[i] * i);\n    }\n    return res;\n}\n"}
{"task_id": "CPP/63", "generation": "int fibfib(int n) {\n    if (n == 0 || n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n    \n    int a = 0, b = 0, c = 1;\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n    \n    return c;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    size_t n = s.size();\n    \n    if (n == 0) {\n        return 0;\n    }\n    \n    for (size_t i = 0; i < n - 1; ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check the last character\n    char last_c = tolower(s.back());\n    if (last_c == 'a' || last_c == 'e' || last_c == 'i' || last_c == 'o' || last_c == 'u' || last_c == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int len = s.length();\n    \n    if (len == 0) {\n        return \"\";\n    }\n    \n    if (shift > len) {\n        reverse(s.begin(), s.end());\n        return s;\n    } else {\n        int k = shift;\n        string shifted = s.substr(len - k, k) + s.substr(0, len - k);\n        return shifted;\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    size_t and_pos = s.find(\"and\");\n    string left = s.substr(0, and_pos);\n    string right = s.substr(and_pos + 4); // \"and\" is 3 letters plus a space\n\n    size_t space_left = left.find(' ');\n    string apples_str = left.substr(0, space_left);\n    int apples = stoi(apples_str);\n\n    size_t space_right = right.find(' ');\n    string oranges_str = right.substr(0, space_right);\n    int oranges = stoi(oranges_str);\n\n    return n - (apples + oranges);\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <climits>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_val = INT_MAX;\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (min_val == INT_MAX || arr[i] < min_val) {\n                min_val = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_val, min_index};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    \n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_candidate = -1;\n    \n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        \n        if (count >= num && num > 0) {\n            if (num > max_candidate) {\n                max_candidate = num;\n            }\n        }\n    }\n    \n    return max_candidate != -1 ? max_candidate : -1;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strangeSort(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    vector<int> res;\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        res.push_back(nums[left]);\n        left++;\n        if (left <= right) {\n            res.push_back(nums[right]);\n            right--;\n        }\n    }\n    return res;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return -1;\n    }\n    \n    vector<float> sides = {a, b, c};\n    sort(sides.begin(), sides.end());\n    \n    float x = sides[0];\n    float y = sides[1];\n    float z = sides[2];\n    \n    if (x + y <= z) {\n        return -1;\n    }\n    \n    float s = (a + b + c) / 2.0f;\n    float area_sq = s * (s - a) * (s - b) * (s - c);\n    \n    if (area_sq <= 0) {\n        return -1;\n    }\n    \n    float area = sqrt(area_sq);\n    area = round(area * 100.0f) / 100.0f;\n    \n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    \n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int count = 0;\n    int n = arr.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0;\n    for (const string& s : lst1) {\n        sum1 += s.size();\n    }\n    int sum2 = 0;\n    for (const string& s : lst2) {\n        sum2 += s.size();\n    }\n\n    if (sum1 < sum2) {\n        return lst1;\n    } else if (sum2 < sum1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Forward declaration of is_multiply_prime\nbool is_multiply_prime(int n);\n\nbool isPrime(int n)  {\n    if  (n <= 1) return false;\n    for  (int i = 2; i * i <= n; ++i)  {\n        if  (n % i == 0) return false;\n     }\n    return true;\n}\n\nint countPrimeFactors(int n)  {\n    int count = 0;\n    if  (isPrime(n))  {\n        count++;\n        return count;\n     }\n    for  (int i = 2; i * i <= n; ++i)  {\n        if  (n % i == 0 && isPrime(i))  {\n            count++;\n            while  (n % i == 0)  {\n                n /= i;\n             }\n         }\n     }\n    if  (n > 1 && isPrime(n))  {\n        count++;\n     }\n    return count;\n}\n\nbool is_multiply_prime(int n)  {\n    int factors = countPrimeFactors(n);\n    return factors == 3;\n}\n"}
{"task_id": "CPP/76", "generation": "To solve this problem, we need to determine if a given number `x` can be expressed as `n` raised to some integer power `k`. This means checking if there exists an integer `k` such that \\( n^k = x \\).\n\n### Approach\nThe approach involves several key steps and checks:\n\n1. **Special Cases Handling**:\n   - If both `x` and `n` are zero, return true because \\( 0^k = 0 \\) for any positive integer `k`.\n   - If `x` is zero but `n` is not zero, return false because no power of a non-zero number can be zero.\n   - If `n` is 1, then `x` must also be 1 because \\( 1^k = 1 \\) for any integer `k`.\n   - If `n` is -1, then `x` must be either 1 or -1 because \\( (-1)^k \\) alternates between 1 and -1 depending on whether `k` is even or odd.\n   - If `n` is zero, then `x` must also be zero because any non-zero number cannot be expressed as a power of zero.\n\n2. **Iterative Check**:\n   - Start with an initial value of `current = 1` (which corresponds to \\( n^0 \\)).\n   - Multiply `current` by `n` iteratively and check if it equals `x`.\n   - If at any point `current` exceeds the absolute value of `x`, break the loop as further multiplications will only increase the value beyond `x`.\n\n### Solution Code\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool isPalindrome(int number) {\n    string numStr = to_string(number);\n    int left = 0;\n    int right = numStr.length() - 1;\n    \n    while (left < right) {\n        if (numStr[left] != numStr[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nbool iscube(int n) {\n    int cube_plus_100 = n * n * n + 100;\n    return isPalindrome(cube_plus_100);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    \n    string binary_str;\n    while (decimal > 0) {\n        int rem = decimal % 2;\n        binary_str += (rem ? '1' : '0');\n        decimal /= 2;\n    }\n    reverse(binary_str.begin(), binary_str.end());\n    \n    return \"db\" + binary_str + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i <= s.size() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float gpa : grades) {\n        if (gpa >= 4.0) {\n            result.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            result.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            result.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            result.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            result.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            result.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            result.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            result.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            result.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            result.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            result.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\nusing namespace std;\n\nbool prime_length(string str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    \n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0)\n            return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    } else {\n        return 18 * pow(10, n - 2);\n    }\n}\n"}
{"task_id": "CPP/84", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    int n = N; // Make a copy of N to avoid modifying the original value\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    \n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    string binary;\n    while (sum > 0) {\n        int rem = sum % 2;\n        binary += (rem ? '1' : '0');\n        sum /= 2;\n    }\n    reverse(binary.begin(), binary.end());\n    \n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort each word in a string based on ASCII values\nstring anti_shuffle(string s) {\n    // Split the string into words and process each one\n    // [Your implementation here]\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        for (int j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        } else {\n            return a[1] > b[1];\n        }\n    });\n    \n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.size() <= 1) {\n        return array;\n    }\n    \n    int first = array[0];\n    int last = array.back();\n    int sum = first + last;\n    \n    if (sum % 2 == 1) { // Sum is odd\n        sort(array.begin(), array.end());\n    } else { // Sum is even\n        sort(array.begin(), array.end(), greater<int>());\n    }\n    \n    return array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    for (int i = 0; i < s.size(); ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            int shifted = (c - 'a' + 4) % 26;\n            s[i] = 'a' + shifted;\n        } else if (c >= 'A' && c <= 'Z') {\n            int shifted = (c - 'A' + 4) % 26;\n            s[i] = 'A' + shifted;\n        }\n    }\n    return s;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <set>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    set<int> s(lst.begin(), lst.end());\n    if (s.size() < 2) {\n        return -1;\n    }\n    auto it = s.begin();\n    ++it; // Move to the second element\n    return *it;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> splitIntoSentences(const string &s) {\n    vector<string> sentences;\n    size_t start = 0;\n    while (start < s.size()) {\n        size_t dotPos = s.find('.', start);\n        size_t qmarkPos = s.find('?', start);\n        size_t exclamPos = s.find('!', start);\n\n        size_t minPos = s.size();\n\n        if (dotPos != string::npos) {\n            minPos = dotPos;\n        }\n        if (qmarkPos != string::npos && qmarkPos < minPos) {\n            minPos = qmarkPos;\n        }\n        if (exclamPos != string::npos && exclamPos < minPos) {\n            minPos = exclamPos;\n        }\n\n        sentences.push_back(s.substr(start, minPos - start));\n        start = minPos + 1;\n\n        if (minPos == s.size()) {\n            break;\n        }\n    }\n    return sentences;\n}\n\nstring trim(const string &s) {\n    size_t first = s.find_first_not_of(\" \\t\\n\\r\");\n    if (first == string::npos) {\n        return \"\";\n    }\n    size_t last = s.find_last_not_of(\" \\t\\n\\r\");\n    return s.substr(first, (last - first + 1));\n}\n\nint is_bored(string S) {\n    vector<string> sentences = splitIntoSentences(S);\n    int count = 0;\n    \n    for (string sentence : sentences) {\n        string trimmedSentence = trim(sentence);\n        if (!trimmedSentence.empty() && trimmedSentence[0] == 'I') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != (float)(int)a || b != (float)(int)b || c != (float)(int)c) {\n        return false;\n    }\n    \n    int ia = (int)a;\n    int ib = (int)b;\n    int ic = (int)c;\n    \n    // Check the three conditions\n    if (ia == ib + ic || ib == ia + ic || ic == ia + ib) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/93", "generation": "#include<string>\nusing namespace std;\n\nstring encode(string message) {\n    // Function implementation will go here\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    if (n == 2)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n    // Handle case where no primes are found, though problem states there is at least one\n    if (max_prime == -1)\n        return 0; // This line may not be necessary based on problem constraints\n    \n    int sum = 0;\n    while (max_prime != 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <unordered_map>\n#include <cctype>\n\nusing namespace std;\n\nbool check_dict_case(const unordered_map<string, string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool has_lower = false;\n    bool has_upper = false;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) {\n            return false;\n        }\n\n        bool current_is_lower = true;\n        bool current_is_upper = true;\n\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (c >= 'a' && c <= 'z') {\n                current_is_upper = false;\n            } else {\n                current_is_lower = false;\n            }\n        }\n\n        if (!current_is_lower && !current_is_upper) {\n            return false;\n        }\n\n        if (current_is_lower) {\n            has_lower = true;\n        } else {\n            has_upper = true;\n        }\n    }\n\n    return !(has_lower && has_upper);\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int j = 3; j * j <= num; j += 2) {\n        if (num % j == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <cstdlib> // For abs function\n\nint multiply(int a, int b) {\n    int unit_a = abs(a) % 10;\n    int unit_b = abs(b) % 10;\n    return unit_a * unit_b;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value);\n    return (int)round(num);\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(n + 2 * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string current;\n\n    for (char c : s) {\n        if (c != ',' && c != ' ') {\n            current += c;\n        } else {\n            if (!current.empty()) {\n                result.push_back(current);\n                current.clear();\n            }\n        }\n    }\n\n    if (!current.empty()) {\n        result.push_back(current);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    int count = m - n + 1;\n    long long sum = (long long)(n + m) * count / 2;\n    long long average = sum / count;\n    \n    if (average == 0) {\n        return \"0\";\n    }\n    \n    bool isNegative = false;\n    if (average < 0) {\n        isNegative = true;\n        average = -average; // take absolute value for processing\n    }\n    \n    string binary;\n    while (average > 0) {\n        int remainder = average % 2;\n        binary.push_back(remainder + '0');\n        average /= 2;\n    }\n    reverse(binary.begin(), binary.end());\n    \n    if (isNegative) {\n        binary.insert(0, 1, '-');\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        bool hasEven = false;\n        int n = num; // Make a copy to process each digit\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 0) {\n                hasEven = true;\n                break;\n            }\n            n /= 10;\n        }\n        if (!hasEven) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n    if (filtered.empty()) {\n        return {};\n    }\n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n    \n    vector<string> names = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // even\n            int fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n            }\n            result.push_back(fact);\n        } else { // odd\n            int sum = i * (i + 1) / 2;\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        string s = to_string(i);\n        string rev(s.rbegin(), s.rend());\n        if (s == rev) { // Check if palindrome\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return {even, odd};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue; // Skip as sum is zero\n        \n        bool is_negative = (num < 0);\n        int abs_num = abs(num);\n        \n        vector<int> digits;\n        int temp = abs_num;\n        while (temp > 0) {\n            int digit = temp % 10;\n            digits.push_back(digit);\n            temp /= 10;\n        }\n        reverse(digits.begin(), digits.end());\n        \n        int sum_digits = 0;\n        for (int i = 0; i < digits.size(); ++i) {\n            if (i == 0 && is_negative) {\n                sum_digits += (-digits[i]);\n            } else {\n                sum_digits += digits[i];\n            }\n        }\n        \n        if (sum_digits > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty() || arr.size() == 1) {\n        return true;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < arr.size() - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n    \n    if (count == 0) {\n        return true;\n    } else if (count == 1 && arr.back() <= arr.front()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(const vector<int>& v1, const vector<int>& v2) {\n    int oddCount = 0;\n    for (int num : v1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n    \n    int evenCount = 0;\n    for (int num : v2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n    \n    return (oddCount <= evenCount) ? \"YES\" : \"NO\";\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <sstream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    if (test.empty()) {\n        return {};\n    }\n\n    map<char, int> counts;\n    stringstream ss(test);\n    string word;\n\n    while (ss >> word) {\n        char c = word[0];\n        counts[c]++;\n    }\n\n    int max_count = 0;\n    for (const auto& pair : counts) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    map<char, int> result;\n\n    for (const auto& pair : counts) {\n        if (pair.second == max_count) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> c_chars(c.begin(), c.end());\n    string filtered_s;\n    \n    for (char ch : s) {\n        if (c_chars.find(ch) == c_chars.end()) {\n            filtered_s.push_back(ch);\n        }\n    }\n    \n    string reversed_str = filtered_s;\n    reverse(reversed_str.begin(), reversed_str.end());\n    bool is_palindrome = (filtered_s == reversed_str);\n    \n    vector<string> result;\n    result.push_back(filtered_s);\n    result.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                int digit = c - '0';\n                if (digit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX;\n    int n = nums.size();\n    \n    for (int i = 0; i < n; ++i) {\n        long long current_sum = 0;\n        for (int j = i; j < n; ++j) {\n            current_sum += nums[j];\n            if (current_sum < min_sum) {\n                min_sum = current_sum;\n            }\n        }\n    }\n    \n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    for (const auto& row : grid) {\n        int sum = 0;\n        for (int num : row) {\n            sum += num;\n        }\n        if (sum == 0) continue;\n        int lowers_needed = (sum + capacity - 1) / capacity;\n        total_lowers += lowers_needed;\n    }\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// To solve this problem, we need to sort an array of integers based on the number of 1s in their binary representation.\n// If two numbers have the same number of 1s, they should be sorted in ascending order.\n\nvector<int> sort_array(vector<int> arr){\n     // Custom comparator function\n    auto countOnes = [](int n) {\n        int ones = 0;\n        n = abs(n);  // Take absolute value to handle negative numbers\n        while (n > 0) {\n            ones += n & 1;\n            n >>= 1;\n         }\n        return ones;\n     };\n\n    sort(arr.begin(), arr.end(), [countOnes](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA != countB) {\n            return countA < countB;\n         } else {\n            return a < b;\n         }\n     });\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(const string& s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result;\n    }\n    \n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            char lower_c = tolower(c);\n            if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Define vowels for quick lookup\nconst string VOWELS = \"aeiouAEIOU\";\n\nstring get_closest_vowel(string word) {\n    int n = word.size();\n    \n    // Iterate from the second last character to the second character\n    for (int i = n - 2; i >= 1; --i) {\n        if (VOWELS.find(word[i]) != string::npos) {\n            // Check if previous and next characters are consonants\n            bool prevIsConsonant = VOWELS.find(word[i-1]) == string::npos;\n            bool nextIsConsonant = VOWELS.find(word[i+1]) == string::npos;\n            \n            if (prevIsConsonant && nextIsConsonant) {\n                return string(1, word[i]);\n            }\n        }\n    }\n    \n    // Return empty string if no vowel found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Implementation of the function\n    return \"\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    if (k == 0) {\n        return vector<int>();\n    }\n    \n    // Sort the array in descending order to get largest elements first\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Extract the top k elements\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Sort the result in ascending order before returning\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (abs(num) <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    if (n % 2 == 1) {\n        result.push_back(n);\n    }\n    while (n > 1) {\n        n = (n - 1) / 2;\n        if (n % 2 == 1) {\n            result.push_back(n);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n    \n    // Check length is 10\n    if (date.length() != 10) return false;\n    \n    // Check hyphens are at correct positions\n    if (date[2] != '-' || date[5] != '-') return false;\n    \n    // Check each part for digits only\n    for (int i = 0; i < 2; ++i) {\n        if (!isdigit(date[i])) return false;\n    }\n    for (int i = 3; i < 5; ++i) {\n        if (!isdigit(date[i])) return false;\n    }\n    for (int i = 6; i < 10; ++i) {\n        if (!isdigit(date[i])) return false;\n    }\n    \n    // Extract month, day, year\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));  // Year is not used beyond this\n    \n    // Check valid month\n    if (month < 1 || month > 12) return false;\n    \n    // Determine maximum days for the given month\n    int max_day;\n    switch(month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            max_day = 31;\n            break;\n        case 4: case 6: case 9: case 11:\n            max_day = 30;\n            break;\n        case 2:\n            max_day = 29;  // Assuming no leap year check\n            break;\n        default:\n            return false;  // Shouldn't reach here\n    }\n    \n    // Check valid day\n    if (day < 1 || day > max_day) return false;\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check if there are spaces in the string\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on spaces\n        string current_word;\n        for (char c : txt) {\n            if (c == ' ') {\n                result.push_back(current_word);\n                current_word.clear();\n            } else {\n                current_word += c;\n            }\n        }\n        result.push_back(current_word);  // Add the last word\n    } else {\n        // Check if there are commas in the string\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            string current_part;\n            for (char c : txt) {\n                if (c == ',') {\n                    result.push_back(current_part);\n                    current_part.clear();\n                } else {\n                    current_part += c;\n                }\n            }\n            result.push_back(current_part);  // Add the last part\n        } else {\n            // Count lowercase letters with odd order in the alphabet\n            int count = 0;\n            for (char c : txt) {\n                if (islower(c)) {\n                    int ord = c - 'a';\n                    if (ord % 2 == 1) {  // Check if odd\n                        count++;\n                    }\n                }\n            }\n            result.push_back(to_string(count));\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    // Check if the list is sorted in ascending order\n    for (int i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Check for consecutive duplicates exceeding two occurrences\n    int count = 1;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            count = 1;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) {\n        return \"NO\";\n    }\n    \n    int length = end - start + 1;\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cstdlib>  // For abs function\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {  // Function name corrected to match problem statement\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum_mag = 0;\n    int product_sign = 1;\n    \n    for (int num : arr) {\n        sum_mag += abs(num);\n        \n        int sign;\n        if (num == 0) {\n            sign = 0;\n        } else if (num > 0) {\n            sign = 1;\n        } else {\n            sign = -1;\n        }\n        \n        product_sign *= sign;\n        \n        // Early exit if product becomes zero\n        if (product_sign == 0) {\n            break;\n        }\n    }\n    \n    return sum_mag * product_sign;\n}\n"}
{"task_id": "CPP/129", "generation": "To solve this problem, we need to find the lexicographically smallest path of exactly `k` steps starting from a given cell in a grid. Each step can move up, down, left, or right, and each cell can be visited only once per path (no cycles).\n\n### Approach\n1. **Problem Analysis**: We are given a grid, a starting position, and the number of steps `k`. The goal is to find the lexicographically smallest path of exactly `k` steps. If no such path exists, we return an empty list.\n\n2. **Intuition**: Since we need the lexicographically smallest path, we can use a priority queue (min-heap) to explore paths in order of their current lex order. This ensures that once we find a valid path of length `k`, it is the smallest possible.\n\n3. **Algorithm Selection**: We use Breadth-First Search (BFS) with a priority queue to explore all possible paths starting from the given cell. Each state in the priority queue includes the current path, position, number of steps taken, and visited cells to avoid cycles.\n\n4. **Complexity Analysis**: The time complexity is influenced by the number of states explored, which can be large for bigger grids or larger `k`. However, using a priority queue ensures that we explore paths in lex order efficiently.\n\n### Solution Code\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    if (n >= 0) result[0] = 1;\n    if (n >= 1) result[1] = 3;\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + (i / 2);\n        } else {\n            int next_even = i + 1;\n            if (next_even > n) {\n                // Handle cases where next_even exceeds the desired size\n                result[i] = result[i-1] + result[i-2];\n            } else {\n                result[i] = result[i-1] + result[i-2] + result[next_even];\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        int d = n % 10;\n        if (d % 2 != 0) {\n            product *= d;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n\nusing namespace std;\n\nbool is_nested(const string& str) {\n    int depth = 0;\n    for (char c : str) {\n        if (c == '[') {\n            depth++;\n        } else if (c == ']') {\n            if (depth >= 2) {\n                return true;\n            }\n            depth--;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int total = 0;\n    for (float num : lst) {\n        int rounded = static_cast<int>(ceil(num));\n        total += rounded * rounded;\n    }\n    return total;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) return false;  // Empty after trimming\n    \n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical letter\n    if (!isalpha(lastChar)) return false;\n    \n    // Ensure it's not part of a word (i.e., either at position 0 or preceded by space)\n    if (end == 0) return true;  // Only one character\n    \n    char prevChar = txt[end - 1];\n    return prevChar == ' ';\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int max_index = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) {\n            if (i > max_index) {\n                max_index = i;\n            }\n        }\n    }\n    return max_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> result(2);\n    \n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n    \n    result[0] = (max_neg == INT_MIN) ? 0 : max_neg;\n    result[1] = (min_pos == INT_MAX) ? 0 : min_pos;\n    \n    return result;\n}\n"}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n#include <algorithm> // for replace\n#include <stdexcept>\n\nusing namespace std;\n\nfloat parse_value(const boost::any& x) {\n    if (x.type() == typeid(int)) {\n        return boost::any_cast<int>(x);\n    } else if (x.type() == typeid(float)) {\n        return boost::any_cast<float>(x);\n    } else if (x.type() == typeid(double)) {\n        return static_cast<float>(boost::any_cast<double>(x));\n    } else if (x.type() == typeid(string)) {\n        string s = boost::any_cast<string>(x);\n        replace(s.begin(), s.end(), ',', '.');\n        try {\n            return stof(s);\n        } catch (const invalid_argument& e) {\n            throw runtime_error(\"Invalid number format: \" + s);\n        }\n    } else {\n        throw runtime_error(\"Unsupported type\");\n    }\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_val = parse_value(a);\n    float b_val = parse_value(b);\n\n    if (a_val == b_val) {\n        return string(\"None\");\n    } else if (a_val > b_val) {\n        return a;\n    } else {\n        return b;\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    return (n >= 8 && n % 2 == 0);\n}\n"}
{"task_id": "CPP/139", "generation": "long long special_factorial(int n) {\n    long long total = 1;\n    long long current_fact = 1;\n    for (int i = 1; i <= n; ++i) {\n        current_fact *= i;\n        total *= current_fact;\n    }\n    return total;\n}\n"}
{"task_id": "CPP/140", "generation": "#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 0) {\n                if (count == 1) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                count = 0;\n            }\n            result += c;\n        }\n    }\n\n    // Handle any remaining spaces at the end\n    if (count > 0) {\n        if (count == 1) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    size_t first_dot = file_name.find('.');\n    if (first_dot == string::npos || file_name.find('.', first_dot + 1) != string::npos) {\n        return \"No\";\n    }\n\n    string prefix = file_name.substr(0, first_dot);\n    string suffix = file_name.substr(first_dot + 1);\n\n    if (prefix.empty() || suffix.empty()) {\n        return \"No\";\n    }\n\n    unordered_set<string> allowed_suffixes = {\"txt\", \"exe\", \"dll\"};\n    if (allowed_suffixes.find(suffix) == allowed_suffixes.end()) {\n        return \"No\";\n    }\n\n    if (!isalpha(prefix[0])) {\n        return \"No\";\n    }\n\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val *= val;\n        } else if (i % 4 == 0) {\n            val *= val * val;\n        }\n        sum += val;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    if (n == 2)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    \n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    vector<string> primes_words;\n    for (auto &w : words) {\n        if (is_prime(w.length())) {\n            primes_words.push_back(w);\n        }\n    }\n    \n    if (primes_words.empty()) {\n        return \"\";\n    }\n    \n    string result = primes_words[0];\n    for (size_t i = 1; i < primes_words.size(); ++i) {\n        result += \" \" + primes_words[i];\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse first fraction x into numerator and denominator\n    size_t pos = x.find('/');\n    long long x_num = stoll(x.substr(0, pos));\n    long long x_den = stoll(x.substr(pos + 1));\n\n    // Parse second fraction n into numerator and denominator\n    pos = n.find('/');\n    long long n_num = stoll(n.substr(0, pos));\n    long long n_den = stoll(n.substr(pos + 1));\n\n    // Compute the product's numerator and denominator\n    long long product_num = x_num * n_num;\n    long long product_den = x_den * n_den;\n\n    // Check if the product is an integer by verifying divisibility\n    return (product_num % product_den) == 0;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Element {\n    int sum;\n    int idx;\n    int val;\n};\n\nint get_sum(int n) {\n    if (n == 0) return 0;\n    int sign = n < 0 ? -1 : 1;\n    string s_num = to_string(abs(n));\n    int sum = 0;\n    sum += (s_num[0] - '0') * sign;\n    for (size_t i = 1; i < s_num.size(); ++i) {\n        sum += (s_num[i] - '0');\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {  // Renamed function to match the declaration\n    vector<Element> elements;\n    for (int i = 0; i < nums.size(); ++i) {\n        int n = nums[i];\n        int s = get_sum(n);\n        elements.push_back({s, i, n});\n    }\n    sort(elements.begin(), elements.end(), [](const Element& a, const Element& b) {\n        if (a.sum != b.sum) {\n            return a.sum < b.sum;\n        } else {\n            return a.idx < b.idx;\n        }\n    });\n    vector<int> result;\n    for (auto& e : elements) {\n        result.push_back(e.val);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int last_digit = num % 10;\n            int n = num;\n            while (n >= 10) {\n                n /= 10;\n            }\n            int first_digit = n;\n            \n            if ((last_digit % 2 != 0) && (first_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count0 = 0, count1 = 0, count2 = 0;\n    for (int num : a) {\n        switch(num % 3) {\n            case 0: count0++; break;\n            case 1: count1++; break;\n            case 2: count2++; break;\n        }\n    }\n    \n    int total = 0;\n    // All three same\n    if (count0 >= 3) total += count0 * (count0 - 1) * (count0 - 2) / 6;\n    if (count1 >= 3) total += count1 * (count1 - 1) * (count1 - 2) / 6;\n    if (count2 >= 3) total += count2 * (count2 - 1) * (count2 - 2) / 6;\n    \n    // One from each\n    total += count0 * count1 * count2;\n    \n    return total;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1 = -1;\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            break;\n        }\n    }\n    \n    int index2 = -1;\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet2) {\n            index2 = i;\n            break;\n        }\n    }\n    \n    if (index1 == -1 || index2 == -1) {\n        return vector<string>();\n    }\n    \n    int start = min(index1, index2);\n    int end = max(index1, index2);\n    \n    vector<string> result;\n    for (int i = start + 1; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n    for (const string& s : lst) {\n        if (s.size() % 2 == 0) {\n            filtered.push_back(s);\n        }\n    }\n\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        } else {\n            return a < b;\n        }\n    });\n\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath>\nusing namespace std;\n\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n    int limit = sqrt(n);\n    for (int i = 3; i <= limit; i += 2) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && floor(num) == num) { // Check if it's a non-negative integer\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) { // Check if the number is odd\n                sum += n * n; // Add the square of the number to the sum\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <climits> // For INT_MIN\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_ext;\n\n    for (const string& ext : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : ext) {\n            if (c >= 'A' && c <= 'Z') {\n                cap++;\n            } else if (c >= 'a' && c <= 'z') {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_ext;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    int n = a.size();\n    int m = b.size();\n    \n    if (m == 0)\n        return true;\n    if (n < m)\n        return false;\n        \n    string s = b + b;\n    for (int i = 0; i < m; ++i) {\n        string rotated = s.substr(i, m);\n        if (a.find(rotated) != string::npos)\n            return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    if (num == 0) {\n        return {1, 0};\n    }\n    int n = abs(num);\n    int even = 0, odd = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            even++;\n        } else {\n            odd++;\n        }\n        n /= 10;\n    }\n    return {even, odd};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int num) {\n    vector<pair<int, string>> val = { \n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result;\n    for (auto& p : val) {\n        while (num >= p.first) {\n            result += p.second;\n            num -= p.first;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool right_angled_triangle(float a, float b, float c) {\n    // Check if any side is non-positive\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n    \n    vector<float> sides = {a, b, c};\n    sort(sides.begin(), sides.end());\n    float x = sides[0];\n    float y = sides[1];\n    float z = sides[2];\n    \n    // Check triangle inequality\n    if (x + y <= z) {\n        return false;\n    }\n    \n    // Compute squares\n    float sum_squares = x * x + y * y;\n    float z_square = z * z;\n    \n    // Compare with epsilon to handle floating point precision issues\n    const float EPSILON = 1e-6f; // Using float for consistency\n    \n    return abs(sum_squares - z_square) < EPSILON;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_unique = -1;\n    string result;\n\n    for (string word : words) {\n        set<char> s(word.begin(), word.end());\n        int unique_count = s.size();\n\n        if (max_unique == -1 || unique_count > max_unique) {\n            max_unique = unique_count;\n            result = word;\n        } else if (unique_count == max_unique) {\n            if (word < result) {\n                result = word;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int amount_eaten = (need <= remaining) ? need : remaining;\n    return {number + amount_eaten, remaining - amount_eaten};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nint precedence(const string& op) {\n    if (op == \"+\" || op == \"-\") return 1;\n    if (op == \"*\" || op == \"/\") return 2;\n    if (op == \"**\") return 3;\n    return 0;\n}\n\nvector<string> infix_to_postfix(const vector<string>& operators, const vector<int>& operands) {\n    vector<string> postfix;\n    stack<string> op_stack;\n\n    for (size_t i = 0; i < operands.size(); ++i) {\n        postfix.push_back(to_string(operands[i]));\n        if (i < operators.size()) {\n            string current_op = operators[i];\n            while (!op_stack.empty() && precedence(op_stack.top()) >= precedence(current_op)) {\n                postfix.push_back(op_stack.top());\n                op_stack.pop();\n            }\n            op_stack.push(current_op);\n        }\n    }\n\n    while (!op_stack.empty()) {\n        postfix.push_back(op_stack.top());\n        op_stack.pop();\n    }\n\n    return postfix;\n}\n\nint evaluate_postfix(const vector<string>& postfix) {\n    stack<int> operand_stack;\n\n    for (const string& token : postfix) {\n        if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\" || token == \"**\") {\n            int b = operand_stack.top();\n            operand_stack.pop();\n            int a = operand_stack.top();\n            operand_stack.pop();\n\n            if (token == \"+\") operand_stack.push(a + b);\n            else if (token == \"-\") operand_stack.push(a - b);\n            else if (token == \"*\") operand_stack.push(a * b);\n            else if (token == \"/\") operand_stack.push(a / b); // Assuming integer division\n            else if (token == \"**\") operand_stack.push(pow(a, b));\n        } else {\n            operand_stack.push(stoi(token));\n        }\n    }\n\n    return operand_stack.top();\n}\n\nint do_algebra(const vector<string>& operators, const vector<int>& operands) {\n    vector<string> postfix = infix_to_postfix(operators, operands);\n    return evaluate_postfix(postfix);\n}\n"}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        reverse(s.begin(), s.end());\n    } else {\n        for (int i = 0; i < s.size(); ++i) {\n            char &c = s[i];\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n    \n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.c_str(), text.size());\n    MD5_Final(digest, &ctx);\n    \n    char hexdigest[2 * MD5_DIGEST_LENGTH + 1];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        sprintf(hexdigest + 2*i, \"%02x\", digest[i]);\n    }\n    hexdigest[2*MD5_DIGEST_LENGTH] = '\\0';\n    \n    return string(hexdigest);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int low = min(a, b);\n    int high = max(a, b);\n\n    for (int x = low; x <= high; ++x) {\n        if (x >= 0 && x < 10 && x % 2 == 0) {\n            result.push_back(x);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
