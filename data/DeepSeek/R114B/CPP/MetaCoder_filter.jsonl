{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < numbers.size(); ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove all spaces from the input string\n    string cleaned;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned += c;\n        }\n    }\n\n    vector<string> groups;\n    int start = 0;\n    int level = 0;\n\n    for (int i = 0; i < cleaned.size(); ++i) {\n        if (cleaned[i] == '(') {\n            level++;\n        } else if (cleaned[i] == ')') {\n            level--;\n            // When level returns to 0, we found a complete group\n            if (level == 0) {\n                groups.push_back(cleaned.substr(start, i - start + 1));\n                start = i + 1;\n            }\n        }\n    }\n\n    return groups;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(number);\n    return number - integer_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int current_balance = 0;\n    for (int op : operations) {\n        current_balance += op;\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0f; // Handle empty vector case\n    \n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n    float mad_sum = 0.0f;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    return mad_sum / n;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<string> groups;\n    istringstream iss(paren_string);\n    string group;\n    \n    // Split the input string into individual groups\n    while (iss >> group) {\n        groups.push_back(group);\n    }\n    \n    vector<int> result;\n    \n    for (auto &grp : groups) {\n        int current_depth = 0;\n        int max_depth = 0;\n        for (char c : grp) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const string& s : strings) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    \n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result; // Return empty vector if input is empty\n    }\n    int max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n        }\n        result.push_back(max_so_far);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring make_palindrome(string str) {\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        string substr = str.substr(i);\n        string reversed_substr(substr.rbegin(), substr.rend());\n        if (substr == reversed_substr) {\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    // This line is theoretically unreachable\n    return str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <algorithm> // For std::max\n\nstring string_xor(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad both strings with leading zeros to make them of length max_len\n    string padded_a = a;\n    if (len_a < max_len) {\n        int zeros_needed = max_len - len_a;\n        padded_a = string(zeros_needed, '0') + a;\n    }\n\n    string padded_b = b;\n    if (len_b < max_len) {\n        int zeros_needed = max_len - len_b;\n        padded_b = string(zeros_needed, '0') + b;\n    }\n\n    string result;\n\n    for (int i = 0; i < max_len; ++i) {\n        bool a_bit = (padded_a[i] == '1');\n        bool b_bit = (padded_b[i] == '1');\n        if (a_bit != b_bit) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    int max_len = 0;\n    string result = \"\";\n    \n    for (const string& s : strings) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n            result = s;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <cstdlib> // For abs function\n\nint greatest_common_divisor(int a, int b) {\n    if (a == 0 && b == 0) {\n        return 0;\n    }\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = a % b;\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    int n = str.size();\n    for (int i = 1; i <= n; ++i) {\n        string prefix = str.substr(0, i);\n        result.push_back(prefix);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        if (result.empty()) {\n            result = to_string(i);\n        } else {\n            result += \" \";\n            result += to_string(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    vector<bool> seen(256, false);\n    int count = 0;\n    for (char c : str) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        unsigned char index = static_cast<unsigned char>(c);\n        if (!seen[index]) {\n            seen[index] = true;\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    stringstream ss(music_string);\n    string token;\n    \n    while (ss >> token) {\n        if (token == \"o\") {\n            result.push_back(4);\n        } else if (token == \"o|\") {\n            result.push_back(2);\n        } else if (token == \".|\") {\n            result.push_back(1);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int m = substring.length();\n    if (m == 0 || str.length() < m) {\n        return 0;\n    }\n    for (int i = 0; i <= str.size() - m; ++i) {\n        if (str.substr(i, m) == substring) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from number words to their corresponding integer values\n    map<string, int> number_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, \n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    \n    // Split the input string into individual words\n    vector<string> words;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    // Sort the words based on their numeric values using a custom comparator\n    sort(words.begin(), words.end(), [&number_map](const string& a, const string& b) {\n        return number_map[a] < number_map[b];\n    });\n    \n    // Join the sorted words into a single string with spaces\n    stringstream result_ss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            result_ss << \" \";\n        }\n        result_ss << words[i];\n    }\n    return result_ss.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm> // For sort function\n#include <cmath>     // For FLT_MAX and abs function\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {}; // Assuming input has at least two elements as per problem statement.\n    }\n\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = FLT_MAX;\n    vector<float> closest_pair = {numbers[0], numbers[1]};\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i+1] - numbers[i]);\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_pair = {numbers[i], numbers[i+1]};\n        }\n    }\n\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_values;\n    float range_val = max_val - min_val;\n\n    if (range_val == 0) {\n        // All elements are the same; return a vector of zeros\n        scaled_values.resize(numbers.size(), 0.0f);\n    } else {\n        for (float num : numbers) {\n            float scaled = (num - min_val) / range_val;\n            // Clamp to avoid floating point errors\n            if (scaled < 0.0f) scaled = 0.0f;\n            if (scaled > 1.0f) scaled = 1.0f;\n            scaled_values.push_back(scaled);\n        }\n    }\n\n    return scaled_values;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <boost/any.hpp>\n#include <list>\n#include <vector>\n#include <typeinfo>\n\nusing namespace std;\nusing namespace boost;\n\ntypedef list<any> list_any;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& elem : values) {\n        if (elem.type() == typeid(int)) {\n            int val = any_cast<int>(elem);\n            result.push_back(val);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n"}
{"task_id": "CPP/24", "generation": "int largest_divisor(int n) {\n    for (int i = n - 1; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return -1; // This line is theoretically unreachable for n >= 2.\n}\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Handle division by 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Now check odd numbers from 3 upwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> counts;\n    vector<int> result;\n    unordered_set<int> added;\n\n    // Count the frequency of each number\n    for (int num : numbers) {\n        counts[num]++;\n    }\n\n    // Collect numbers that appear exactly once, maintaining order\n    for (int num : numbers) {\n        if (counts[num] == 1 && added.find(num) == added.end()) {\n            result.push_back(num);\n            added.insert(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <string>\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (int i = 0; i < str.size(); ++i) {\n        char c = str[i];\n        if ('a' <= c && c <= 'z') {\n            str[i] = c - 32;\n        } else if ('A' <= c && c <= 'Z') {\n            str[i] = c + 32;\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& s : strings) {\n        result += s;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& s : strings) {\n        if (s.size() >= prefix.size()) {\n            if (s.substr(0, prefix.size()) == prefix) {\n                result.push_back(s);\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath> // Include cmath for sqrt function\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    long long max_divisor = static_cast<long long>(sqrt(n)) + 1;\n    for (long long d = 3; d <= max_divisor; d += 2) {\n        if (n % d == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n     Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n     */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. It returns only one zero point, even if there are many.\n    Moreover, find_zero only takes lists xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n}\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisible_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_elements.push_back(l[i]);\n        }\n    }\n    sort(divisible_elements.begin(), divisible_elements.end());\n    \n    vector<int> l_prime;\n    int pos = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l_prime.push_back(divisible_elements[pos]);\n            pos++;\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s;\n    for (int num : l) {\n        s.insert(num);\n    }\n    return vector<int>(s.begin(), s.end());\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        // Handle empty vector case as needed; here we return NaN.\n        return NAN;\n    }\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "int fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit == 7) {\n                    total++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return total;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    // Extract elements at even indices\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    // Sort the extracted even elements\n    sort(even_elements.begin(), even_elements.end());\n    \n    vector<float> result;\n    int even_ptr = 0; // Pointer to track the current position in even_elements\n    \n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) { // Even index\n            result.push_back(even_elements[even_ptr]);\n            even_ptr++;\n        } else { // Odd index, retain original value\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "The role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n\n1. **Initial Analysis**: Examine the encoded message for patterns, repeated sequences, or structural clues that might hint at the cipher type.\n\n2. **Frequency Analysis**: Check for letter frequencies to identify common English letters like E, T, A, which could help in deciphering if a Caesar cipher is used.\n\n3. **Caesar Cipher Test**: Attempt different shift values (e.g., shifting each letter by +9) to see if the plaintext becomes readable.\n\n4. **Vigen\u00e8re Consideration**: If single shifts fail, explore polyalphabetic ciphers like Vigen\u00e8re, potentially using keys based on message length or known plaintext.\n\n5. **Substitution and Transposition**: Investigate possibilities of substitution combined with transposition methods, such as reversing letters or rearranging groups.\n\n6. **Iterative Testing**: Continuously test hypotheses, adjust approaches, and seek patterns or partial successes that could lead to deciphering the message.\n\n7. **Clue Utilization**: If stuck, revisit earlier steps or look for additional clues within the cipher structure.\n\nBy methodically exploring these avenues, the goal is to systematically unravel the encoded message, leveraging both analytical techniques and creative problem-solving."}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    if (num == 2) {\n        return true;\n    }\n    if (num % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n <= 0) {\n        return -1; // Indicate invalid input\n    }\n\n    int a = 0, b = 1;\n    int count = 0;\n    int fib_num;\n\n    while (true) {\n        fib_num = a;\n        if (is_prime(fib_num)) {\n            count++;\n            if (count == n) {\n                return fib_num;\n            }\n        }\n        // Move to next Fibonacci number\n        int next = a + b;\n        a = b;\n        b = next;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    if (l.size() < 3) return false;\n    sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue;\n        int left = i + 1, right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum > 0) right--;\n            else left++;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int x : l) {\n        if (seen.find(-x) != seen.end()) {\n            return true;\n        }\n        seen.insert(x);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0)\n        return \"0\";\n    string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.push_back('0' + remainder);\n        x /= base;\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2;\n}\n"}
{"task_id": "CPP/46", "generation": "int fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    int a = 0; // Represents fib4(0)\n    int b = 0; // Represents fib4(1)\n    int c = 2; // Represents fib4(2)\n    int d = 0; // Represents fib4(3)\n\n    for (int i = 4; i <= n; ++i) {\n        int next_val = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_val;\n    }\n\n    return d;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float a = l[(n / 2) - 1];\n        float b = l[n / 2];\n        return (a + b) / 2.0f;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int len = text.length();\n    if (len <= 1) {\n        return true;\n    }\n    for (int i = 0; i < len / 2; ++i) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nusing namespace std;\n\nunsigned long long modp(int n, int p) {\n    if (p == 1)\n        return 0;\n    unsigned long long result = 1;\n    unsigned long long base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <string>\n\nusing namespace std;\n\nstring decode_shift(string s) {\n    string out;\n    for (char c : s) {\n        int pos = c - 'a'; // Convert character to 0-25 range\n        int decoded_pos = (pos - 5 + 26) % 26; // Reverse the shift and handle wrap-around\n        char decoded_char = 'a' + decoded_pos; // Convert back to character\n        out += decoded_char;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <cctype> // for tolower function\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        char lower_c = tolower(c);\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "int add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> set0(s0.begin(), s0.end());\n    set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stack>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i + 1]) {\n            increasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n    vector<int> res;\n    \n    for (int num : s1) {\n        if (s2.find(num) != s2.end()) {\n            res.push_back(num);\n        }\n    }\n    \n    return res;\n}\n"}
{"task_id": "CPP/59", "generation": "int largest_prime_factor(int n) {\n    if (n <= 1) {\n        return -1; // Assuming n should be >1 as per problem constraints.\n    }\n    \n    int max_factor = -1;\n    \n    // Check divisibility by 2\n    if (n % 2 == 0) {\n        max_factor = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n    }\n    \n    // Check odd factors from 3 upwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            max_factor = i;\n            n /= i;\n        }\n    }\n    \n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        max_factor = n;\n    }\n    \n    return max_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> res;\n    for (size_t j = 1; j < xs.size(); ++j) {\n        res.push_back(j * xs[j]);\n    }\n    return res;\n}\n"}
{"task_id": "CPP/63", "generation": "int fibfib(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Represents fib(i-3), fib(i-2), fib(i-1)\n    for (int i = 3; i <= n; ++i) {\n        int current = a + b + c;\n        a = b;\n        b = c;\n        c = current;\n    }\n    return c;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <cctype>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        char lower_c = tolower(c);\n        if (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u') {\n            count++;\n        }\n    }\n    if (!s.empty()) {\n        char last_char = tolower(s.back());\n        if (last_char == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int len = s.length();\n    \n    if (shift >= len) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n    \n    int effective_shift = shift % len;\n    if (effective_shift == 0) {\n        return s;\n    }\n    \n    string shifted_part = s.substr(len - effective_shift);\n    s = shifted_part + s.substr(0, len - effective_shift);\n    \n    return s;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<string> tokens;\n    istringstream iss(s);\n    string token;\n    \n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n    \n    int apples = stoi(tokens[0]);\n    int oranges = stoi(tokens[3]);\n    \n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <climits> // for INT_MAX\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int min_even = INT_MAX;\n    int min_index = -1;\n    bool found = false;\n\n    for (size_t i = 0; i < arr.size(); ++i) {\n        int num = arr[i];\n        if (num % 2 == 0) { // check if even\n            if (!found || num < min_even) {\n                min_even = num;\n                min_index = i;\n                found = true;\n            }\n        }\n    }\n\n    if (found) {\n        return { min_even, min_index };\n    } else {\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (auto& pair : freq) {\n        if (pair.second >= pair.first && pair.first > max_num) {\n            max_num = pair.first;\n        }\n    }\n    \n    return max_num;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> sorted = lst;\n    sort(sorted.begin(), sorted.end());\n    \n    vector<int> result;\n    int left = 0;\n    int right = sorted.size() - 1;\n    bool takeMin = true;\n    \n    while (left <= right) {\n        if (takeMin) {\n            result.push_back(sorted[left]);\n            left++;\n        } else {\n            result.push_back(sorted[right]);\n            right--;\n        }\n        takeMin = !takeMin;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <cmath> // For sqrt and round functions\n\nfloat triangle_area(float a, float b, float c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    float s = (a + b + c) / 2.0f;\n    float area_sq = s * (s - a) * (s - b) * (s - c);\n    if (area_sq <= 0) { // Handle potential floating point errors\n        return -1;\n    }\n    float area = sqrt(area_sq);\n    area = std::round(area * 100.0f) / 100.0f;\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    bool is_palindrome = true;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    return is_palindrome && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0;\n    for (string s : lst1) {\n        sum1 += s.length();\n    }\n    \n    int sum2 = 0;\n    for (string s : lst2) {\n        sum2 += s.length();\n    }\n    \n    if (sum1 < sum2) {\n        return lst1;\n    } else if (sum2 < sum1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    if (a <= 0) return false;\n    \n    int count = 0;\n    for (int i = 2; i * i <= a; ++i) {\n        while (a % i == 0) {\n            count++;\n            a /= i;\n        }\n    }\n    if (a > 1) {\n        count++;\n    }\n    \n    return count == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == -1) {\n        return x == 1 || x == -1;\n    }\n\n    long current = 1;\n    while (current <= x) {\n        if (current == x) {\n            return true;\n        }\n        current *= n;\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    \n    int sign = (a > 0) ? 1 : -1;\n    int abs_a = abs(a);\n    \n    double cube_root_approx = pow(abs_a, 1.0/3.0);\n    int k_approx = round(cube_root_approx);\n    \n    for (int k : {k_approx - 1, k_approx, k_approx + 1}) {\n        if (pow(k, 3) * sign == a) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    unordered_set<int> primes = {2, 3, 5, 7, 11, 13};\n    for (char c : num) {\n        int val;\n        if (isdigit(c)) {\n            val = c - '0';\n        } else {\n            val = (c - 'A') + 10;\n        }\n        if (primes.count(val)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <string>\n#include <algorithm> // For std::reverse\n\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    \n    string binaryStr = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binaryStr += (remainder + '0');\n        decimal /= 2;\n    }\n    \n    reverse(binaryStr.begin(), binaryStr.end());\n    \n    return \"db\" + binaryStr + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i <= s.size() - 3; ++i) {\n        char c1 = s[i];\n        char c2 = s[i + 1];\n        char c3 = s[i + 2];\n        if (c1 == c2 || c1 == c3 || c2 == c3) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    // Function to convert numerical grades to letter grades based on GPA thresholds\n    vector<string> result;\n    for (float gpa : grades) {\n        if (gpa >= 4.0f) {\n            result.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            result.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            result.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            result.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            result.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            result.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            result.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            result.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            result.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            result.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            result.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\n\nusing namespace std;\n\nbool prime_length(string str) {\n    int n = str.length();\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    int sqrt_n = static_cast<int>(sqrt(n)) + 1;\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1)\n        return 1;\n    else\n        return 9 * pow(10, n-2) + 9;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    if (N == 0) {\n        sum = 0;\n    } else {\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n    }\n    \n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    vector<int> bits;\n    int s = sum;\n    while (s > 0) {\n        int rem = s % 2;\n        bits.push_back(rem);\n        s /= 2;\n    }\n    \n    reverse(bits.begin(), bits.end());\n    \n    string result;\n    for (int bit : bits) {\n        result += to_string(bit);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Split the string into words based on spaces\n    vector<string> words;\n    string current_word = \"\";\n    for (char c : s) {\n        if (c == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += c;\n        }\n    }\n    // Add the last word if it's not empty\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort each word's characters based on ASCII values\n    for (string &word : words) {\n        sort(word.begin(), word.end());\n    }\n\n    // Reconstruct the string with sorted words and original spaces\n    string result = \"\";\n    size_t last_pos = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (s[i] == ' ') {\n            // Add a space at the position where it was in the original string\n            result += \" \";\n            last_pos = i;\n        }\n    }\n\n    // Now, fill in the sorted words into the spaces\n    size_t word_index = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (s[i] == ' ') {\n            result[last_pos + 1] = words[word_index][0];\n            // Continue filling the rest of the characters\n            for (size_t j = 1; j < words[word_index].size(); ++j) {\n                result[last_pos + j + 1] = words[word_index][j];\n            }\n            word_index++;\n        }\n    }\n\n    return result;\n}\n\n/* The sorted version of \"World!!!\" based on ASCII values is \"!!!Wdlor\". */\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        for (int j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        } else {\n            return a[1] > b[1];\n        }\n    });\n    \n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    vector<int> result = array;\n    if (result.size() <= 1) return result;\n\n    int first = result[0];\n    int last = result.back();\n    int sum = first + last;\n\n    sort(result.begin(), result.end());\n\n    if (sum % 2 == 0) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            int shifted = (s[i] - 'a' + 4) % 26;\n            s[i] = 'a' + shifted;\n        }\n    }\n    return s;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findSecondSmallest(vector<int>& lst) {\n    if (lst.size() < 2) {\n        return -1;\n    }\n    sort(lst.begin(), lst.end());\n    int first = lst[0];\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] > first) {\n            return lst[i];\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to trim whitespace from both ends of a string\nstring trim_whitespace(const string &s) {\n    size_t start = s.find_first_not_of(\" \\t\\n\\r\");\n    if (start == string::npos) return \"\";\n    size_t end = s.find_last_not_of(\" \\t\\n\\r\");\n    return s.substr(start, end - start + 1);\n}\n\nint is_bored(const string &s) {\n    vector<string> sentences;\n    string current_sentence;\n\n    for (char c : s) {\n        if (c == '.' || c == '!' || c == '?') {\n            // Trim the current sentence and add to list if not empty\n            string trimmed = trim_whitespace(current_sentence);\n            if (!trimmed.empty()) {\n                sentences.push_back(trimmed);\n            }\n            current_sentence.clear();\n        } else {\n            current_sentence += c;\n        }\n    }\n\n    // Process the last sentence after loop ends\n    string trimmed_last = trim_whitespace(current_sentence);\n    if (!trimmed_last.empty()) {\n        sentences.push_back(trimmed_last);\n    }\n\n    int count = 0;\n    for (const string &sentence : sentences) {\n        if (!sentence.empty() && sentence[0] == 'I') {\n            ++count;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    bool aInt = (a == static_cast<int>(a));\n    bool bInt = (b == static_cast<int>(b));\n    bool cInt = (c == static_cast<int>(c));\n\n    if (!aInt || !bInt || !cInt) {\n        return false;\n    }\n\n    // Check if any one number is the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring encode(string message) {\n    string vowels_lower = \"aeiou\";\n    string vowels_upper = \"AEIOU\";\n    \n    for (char &c : message) {\n        if (vowels_lower.find(c) != string::npos) {\n            char base = 'a';\n            int shift = 2;\n            c = ((c - base + shift) % 26) + base;\n        } else if (vowels_upper.find(c) != string::npos) {\n            char base = 'A';\n            int shift = 2;\n            c = ((c - base + shift) % 26) + base;\n        }\n    }\n    return message;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n    if (max_prime == -1) return 0; // No primes found\n    int sum = 0;\n    int n = max_prime;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <cctype>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nbool check_dict_case(const map<string, string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check all characters are alphabetic\n        bool all_alpha = true;\n        for (char c : key) {\n            if (!isalpha(c)) {\n                all_alpha = false;\n                break;\n            }\n        }\n\n        if (!all_alpha) {\n            return false;\n        }\n\n        char first_char = key[0];\n        bool is_first_lower = islower(first_char);\n        bool is_first_upper = isupper(first_char);\n\n        // Check case consistency\n        if (is_first_lower) {\n            for (char c : key) {\n                if (!islower(c)) {\n                    return false;\n                }\n            }\n        } else if (is_first_upper) {\n            for (char c : key) {\n                if (!isupper(c)) {\n                    return false;\n                }\n            }\n        } else {\n            // This case should not occur as all characters are alphabetic\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <cstdlib> // For abs function\n\nint multiply(int a, int b) {\n    int unitA = abs(a) % 10;\n    int unitB = abs(b) % 10;\n    return unitA * unitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0) { // Check if index is even\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = atof(value.c_str());\n    return round(num);\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        current += 2;\n    }\n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces\n    string modified_s;\n    for (char c : s) {\n        if (c == ',') {\n            modified_s += ' ';\n        } else {\n            modified_s += c;\n        }\n    }\n\n    // Split the modified string into words using istringstream\n    vector<string> result;\n    istringstream iss(modified_s);\n    string word;\n    while (iss >> word) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    int candidate = (y % 2 == 0) ? y : y - 1;\n    if (candidate >= x) {\n        return candidate;\n    } else {\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the average\n    double avg = (n + m) / 2.0;\n    \n    // Round to nearest integer (towards zero)\n    long long rounded = static_cast<long long>(avg);\n    \n    // Convert to binary string\n    if (rounded == 0) {\n        return \"0\";\n    }\n    \n    string binary;\n    while (rounded > 0) {\n        binary = (rounded % 2 == 0 ? \"0\" : \"1\") + binary;\n        rounded /= 2;\n    }\n    \n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_all_odd_digits(int num) {\n    if (num == 0) return false;\n    while (num > 0) {\n        int d = num % 10;\n        if (d % 2 == 0) {\n            return false;\n        }\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> res;\n    for (int num : x) {\n        if (has_all_odd_digits(num)) {\n            res.push_back(num);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n\n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \n                            \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // even index, compute factorial\n            int fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n            }\n            result.push_back(fact);\n        } else { // odd index, compute sum of 1 to i\n            int sum = i * (i + 1) / 2;\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        int original = i;\n        int reversed = 0;\n        int temp = original;\n        while (temp > 0) {\n            reversed = reversed * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (reversed == original) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        \n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n        }\n        \n        string digits_str = to_string(abs(num));\n        int sum_d = 0;\n        \n        for (size_t i = 0; i < digits_str.size(); ++i) {\n            char c = digits_str[i];\n            int digit = c - '0';\n            \n            if (i == 0 && is_negative) {\n                digit *= -1;\n            }\n            \n            sum_d += digit;\n        }\n        \n        if (sum_d > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int count = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n; ++i) {\n        // Check if current element is greater than next, considering circular nature\n        if (arr[i] > arr[(i + 1) % n]) {\n            ++count;\n        }\n    }\n    \n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odds = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odds++;\n        }\n    }\n\n    int evens = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evens++;\n        }\n    }\n\n    return (evens >= odds) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <sstream>\n#include <map>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freq;\n    istringstream iss(test);\n    string token;\n    \n    // Count frequency of each character\n    while (iss >> token) {\n        if (!token.empty()) {\n            char c = token[0];\n            freq[c]++;\n        }\n    }\n    \n    // If no characters were found, return empty map\n    if (freq.empty()) {\n        return {};\n    }\n    \n    // Find the maximum frequency\n    int max_count = 0;\n    for (auto& pair : freq) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n    \n    // Collect all characters with maximum frequency\n    map<char, int> result;\n    for (auto& pair : freq) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> remove_chars(c.begin(), c.end());\n    string filtered;\n    \n    for (char ch : s) {\n        if (remove_chars.find(ch) == remove_chars.end()) {\n            filtered.push_back(ch);\n        }\n    }\n    \n    string reversed = filtered;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = (filtered == reversed);\n    \n    vector<string> result;\n    result.push_back(filtered);\n    result.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    // For each string in the input vector, count the number of odd digits.\n    vector<int> counts;\n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (isdigit(c)) { // Check if the character is a digit\n                int digit = c - '0';\n                if (digit % 2 != 0) { // Check if the digit is odd\n                    count++;\n                }\n            }\n        }\n        counts.push_back(count);\n    }\n\n    vector<string> result;\n    string template_str = \"the number of odd elements i in the strin g i of the input.\";\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        string modified_str = template_str;\n        // Replace every 'i' with the count value\n        replace(modified_str.begin(), modified_str.end(), 'i', to_string(counts[i])[0]);\n        result.push_back(modified_str);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm> // For std::min\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) {\n        return 0; // Handle empty vector case, though problem may assume non-empty\n    }\n    \n    long long current_min = nums[0];\n    long long global_min = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = min(nums[i], current_min + nums[i]);\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n    \n    return global_min;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <numeric> // For accumulate\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    for (auto &row : grid) {\n        int sum = accumulate(row.begin(), row.end(), 0);\n        if (sum == 0) continue;\n        int ops = (sum + capacity - 1) / capacity;\n        total_operations += ops;\n    }\n    return total_operations;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Define a helper lambda to count the number of 1s in binary representation\n    auto countOnes = [](int x) {\n        int count = 0;\n        int n = abs(x);\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    };\n\n    // Sort the array using a custom comparator\n    sort(arr.begin(), arr.end(), [&](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA != onesB) {\n            return onesA < onesB;\n        } else {\n            return a < b;\n        }\n    });\n\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result;\n    }\n    \n    istringstream iss(s);\n    string word;\n    \n    while (iss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            char lower_c = tolower(c);\n            if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.size();\n    if (n <= 2) return \"\";\n\n    int middle = n / 2;\n\n    for (int i = middle; i >= 0; --i) {\n        if (!isVowel(word[i])) continue;\n        \n        if (i == 0 || i == n - 1) continue;\n\n        bool prevConsonant = !isVowel(word[i-1]);\n        bool nextConsonant = !isVowel(word[i+1]);\n\n        if (prevConsonant && nextConsonant) {\n            return string(1, word[i]);\n        }\n    }\n\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Function implementation goes here\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    if (k == 0) {\n        return {};\n    }\n    \n    sort(arr.begin(), arr.end());\n    \n    int n = arr.size();\n    return vector<int>(arr.begin() + (n - k), arr.end());\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\n\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    int current = n;\n    \n    while (current != 1) {\n        if (current % 2 == 1) {\n            odds.push_back(current);\n        }\n        \n        if (current % 2 == 0) {\n            current /= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    // Add the final 1 to the vector\n    odds.push_back(1);\n    \n    return odds;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // This function validates whether a given date string is in the correct format MM-DD-YYYY.\n    // Approach:\n    // 1. Check Length: Ensure the date string has exactly 10 characters.\n    // 2. Check Hyphens: Verify that the date string contains hyphens at positions 2 and 5.\n    // 3. Extract Parts: Split the date string into month, day, and year parts.\n    // 4. Validate Numeric Values: Ensure each part consists only of numeric characters.\n    // 5. Convert to Integers: Convert the extracted strings into integers for validation.\n    // 6. Check Month Range: The month must be between 1 and 12.\n    // 7. Determine Maximum Days: Based on the month, determine the maximum number of days.\n    // 8. Validate Day Range: Ensure the day is within the valid range for the given month.\n\n    // Solution Code:\n    if (date.length() != 10) {\n        return false;\n    }\n\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    string mm = date.substr(0, 2);\n    string dd = date.substr(3, 2);\n    string yyyy = date.substr(6, 4);\n\n    for (char c : mm) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    for (char c : dd) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    for (char c : yyyy) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    int month = stoi(mm);\n    int day = stoi(dd);\n    int year = stoi(yyyy);\n\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    int max_day;\n\n    if (month == 2) {\n        // Check for leap year\n        bool leap_year = false;\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n            leap_year = true;\n        }\n        max_day = leap_year ? 29 : 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        max_day = 30;\n    } else {\n        max_day = 31;\n    }\n\n    if (day < 1 || day > max_day) {\n        return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n    \n    if (txt.empty()) {\n        return result;\n    }\n    \n    size_t first_whitespace = txt.find_first_of(\" \\t\\n\");\n    if (first_whitespace != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n    } else {\n        size_t first_comma = txt.find(',');\n        if (first_comma != string::npos) {\n            size_t start = 0;\n            size_t end = txt.find(',', start);\n            while (end != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n                end = txt.find(',', start);\n            }\n            // Add the last part after the last comma\n            result.push_back(txt.substr(start));\n        } else {\n            int count = 0;\n            for (char c : txt) {\n                if (islower(c)) {\n                    if ((c - 'a') % 2 == 1) { // Check if position is odd\n                        count++;\n                    }\n                }\n            }\n            result.push_back(to_string(count));\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is non-decreasing\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1]) {\n            return false;\n        }\n    }\n\n    // Count occurrences of each number\n    unordered_map<int, int> countMap;\n    for (int num : lst) {\n        countMap[num]++;\n    }\n\n    // Check if any number appears more than twice\n    for (auto& pair : countMap) {\n        if (pair.second > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <algorithm> // For std::max and std::min\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    int length = end - start;\n    \n    if (length <= 0) {\n        return \"NO\";\n    }\n    \n    return is_prime(length) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum = 0;\n    for (int num : arr) {\n        sum += abs(num);\n    }\n    \n    int product = 1;\n    for (int num : arr) {\n        if (num == 0) {\n            product = 0;\n            break;\n        } else if (num < 0) {\n            product *= -1;\n        }\n    }\n    \n    return sum * product;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    // Implement the solution here\n}\n"}
{"task_id": "CPP/130", "generation": "To compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n\n**Algorithm:**\n\n1. **Check if `n` is even or odd.**\n2. **If `n` is even:**\n   - Compute `tri(n) = 1 + (n / 2)`\n3. **If `n` is odd:**\n   - Compute `tri(n) = ((n + 3) // 2)^2 - 1`\n\n**Examples:**\n\n- For `n = 7` (odd):\n  - `(7 + 3) // 2 = 5`\n  - `5^2 - 1 = 24`\n  \n- For `n = 8` (even):\n  - `1 + (8 / 2) = 5`\n\n**Code Implementation:**\n\n"}
{"task_id": "CPP/131", "generation": "int digits(int n) {\n    int product = 1;\n    bool has_odd = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10; // Move to the next digit\n    }\n\n    return has_odd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "// Include necessary headers\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Declare the function before its usage\nbool is_nested(const string& s) {\n    int depth = 0;\n    for (char c : s) {\n        if (c == '(') {\n            depth++;\n        } else if (c == ')') {\n            if (depth > 0) {\n                depth--;\n            } else {\n                return false;\n            }\n        }\n    }\n    return depth == 0;\n}\n\n// Define the main function\n"}
{"task_id": "CPP/133", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiled = ceil(num);\n        sum += ceiled * ceiled;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n    \n    char last = txt.back();\n    // Check if the last character is a letter\n    if (!(last >= 'a' && last <= 'z') && !(last >= 'A' && last <= 'Z')) {\n        return false;\n    }\n    \n    if (txt.size() == 1) {\n        return true;\n    } else {\n        char prev = txt[txt.size() - 2];\n        if (prev == ' ') {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = n - 1; i >= 1; --i) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(const vector<int>& nums) {\n    bool has_negative = false;\n    int max_neg = INT_MIN; \n\n    bool has_positive = false;\n    int min_pos = INT_MAX; \n\n    for (int num : nums) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n\n    int a = has_negative ? max_neg : 0;\n    int b = has_positive ? min_pos : 0;\n\n    return {a, b};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n#include <typeinfo>\n\nusing namespace std;\n\nboost::any parse(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string s = any_cast<string>(value);\n        // Replace commas with periods for decimal points\n        replace(s.begin(), s.end(), ',', '.');\n        try {\n            return stod(s);\n        } catch (...) {\n            // Handle invalid format, though per problem statement inputs are valid numbers\n            return boost::any();\n        }\n    } else if (value.type() == typeid(int)) {\n        return any_cast<int>(value);\n    } else if (value.type() == typeid(double)) {\n        return any_cast<double>(value);\n    }\n    // Add more type checks if necessary\n    return boost::any();\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Parse both values to their numerical representations\n    auto a_parsed = parse(a);\n    auto b_parsed = parse(b);\n\n    // Check if parsing failed (though per problem statement inputs are valid)\n    if (!a_parsed || !b_parsed) {\n        return \"None\";\n    }\n\n    double a_num, b_num;\n    try {\n        a_num = any_cast<double>(a_parsed);\n        b_num = any_cast<double>(b_parsed);\n    } catch (...) {\n        // In case of unexpected types (though unlikely given parse function)\n        return \"None\";\n    }\n\n    if (a_num == b_num) {\n        return string(\"None\");\n    } else if (a_num > b_num) {\n        return a;\n    } else {\n        return b;\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    return (n >= 8 && n % 2 == 0);\n}\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    long long current_fact = 1;\n    for (int i = 1; i <= n; ++i) {\n        current_fact *= i;\n        result *= current_fact;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int current_count = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            current_count++;\n        } else {\n            if (current_count > 0) {\n                if (current_count <= 2) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                current_count = 0;\n            }\n            result += c;\n        }\n    }\n    \n    // Handle trailing spaces\n    if (current_count > 0) {\n        if (current_count <= 2) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <string>  // Include necessary header for std::string\n\n// Function prototype declaration before main()\nstd::string file_name_check(const std::string& file_name) {\n    // Function implementation here\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nusing namespace std;\n\nint sum_squares(const vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> selected_words;\n    stringstream ss(sentence);\n    string word;\n    \n    while (ss >> word) {\n        int len = word.length();\n        if (is_prime(len)) {\n            selected_words.push_back(word);\n        }\n    }\n    \n    if (selected_words.empty()) return \"\";\n    \n    string result;\n    for (size_t i = 0; i < selected_words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += selected_words[i];\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the input strings to extract numerators and denominators\n    size_t slashPos = x.find('/');\n    int numX = stoi(x.substr(0, slashPos));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    slashPos = n.find('/');\n    int numN = stoi(n.substr(0, slashPos));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Compute the product numerator and denominator\n    long productNum = static_cast<long>(numX) * numN;\n    long productDen = static_cast<long>(denX) * denN;\n\n    // Check if the product is an integer by verifying divisibility\n    return (productNum % productDen == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct Element {\n    int value;\n    size_t index;\n};\n\nint compute_digit_sum(int n) {\n    if (n == 0) return 0;\n    bool is_negative = false;\n    if (n < 0) {\n        is_negative = true;\n        n = abs(n);\n    }\n    vector<int> digits;\n    while (n > 0) {\n        digits.push_back(n % 10);\n        n /= 10;\n    }\n    reverse(digits.begin(), digits.end());\n    if (is_negative && !digits.empty()) {\n        digits[0] *= -1;\n    }\n    return accumulate(digits.begin(), digits.end(), 0);\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<Element> elements;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        elements.push_back({nums[i], i});\n    }\n\n    sort(elements.begin(), elements.end(), [](const Element& a, const Element& b) {\n        int sum_a = compute_digit_sum(a.value);\n        int sum_b = compute_digit_sum(b.value);\n        if (sum_a == sum_b) {\n            return a.index < b.index;\n        }\n        return sum_a < sum_b;\n    });\n\n    vector<int> result;\n    for (const auto& elem : elements) {\n        result.push_back(elem.value);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        int n = abs(num);\n        if (n <= 10) continue; // Skip numbers that are too small to have two digits\n        \n        int last_digit = n % 10;\n        if (last_digit % 2 != 1) continue; // Last digit must be odd\n        \n        int temp = n;\n        while (temp >= 10) {\n            temp /= 10;\n        }\n        int first_digit = temp;\n        \n        if (first_digit % 2 == 1) { // First digit must be odd\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "The number of valid triples is calculated by considering two groups: one with elements that are 0 mod3 (c0) and another with elements that are not 0 mod3 (c1). The size of these groups determines the possible combinations.\n\n**Answer:**  \nThe total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\)."}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun\n    const vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planet1 and planet2 are valid planet names\n    size_t index1 = -1, index2 = -1;\n    for (size_t i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) {\n        return {};\n    }\n    \n    // Ensure that index1 is less than index2 to determine the correct range\n    size_t start = min(index1, index2);\n    size_t end = max(index1, index2);\n    \n    vector<string> result;\n    for (size_t i = start + 1; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered.push_back(s);\n        }\n    }\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.size() != b.size()) {\n            return a.size() < b.size();\n        } else {\n            return a < b;\n        }\n    });\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long total = 0;\n    for (float num : lst) {\n        if (num < 0) continue;          // Ignore negative numbers\n        if (num != static_cast<int>(num)) continue; // Skip non-integers\n        int integer_num = static_cast<int>(num);\n        if (integer_num % 2 != 0) {     // Check if the number is odd\n            total += integer_num * integer_num; // Add square to total\n        }\n    }\n    return total;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <climits>\n#include <cctype>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n    \n    int max_strength = INT_MIN;\n    int best_extension_index = 0;\n    \n    for (int i = 0; i < extensions.size(); ++i) {\n        string ext = extensions[i];\n        int cap_count = 0, sm_count = 0;\n        \n        for (char c : ext) {\n            if (isupper(static_cast<unsigned char>(c))) {\n                cap_count++;\n            } else if (islower(static_cast<unsigned char>(c))) {\n                sm_count++;\n            }\n        }\n        \n        int strength = cap_count - sm_count;\n        \n        if (strength > max_strength) {\n            max_strength = strength;\n            best_extension_index = i;\n        }\n    }\n    \n    return class_name + \".\" + extensions[best_extension_index];\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Handle edge cases\n    if (len_b == 0) return true;\n    if (len_a < len_b) return false;\n\n    // Create the concatenated string to generate all rotations of b\n    string temp = b + b;\n\n    for (int i = 0; i < len_b; ++i) {\n        // Extract substring of length len_b starting at index i\n        string rotated = temp.substr(i, len_b);\n\n        // Check if this rotation exists in a\n        if (a.find(rotated) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    if (num == 0) {\n        return {1, 0};\n    }\n    num = abs(num);\n    int even_count = 0;\n    int odd_count = 0;\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"},\n        {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"},\n        {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\n        {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result;\n\n    for (const auto& value_pair : roman_numerals) {\n        while (number >= value_pair.first) {\n            result += value_pair.second;\n            number -= value_pair.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Check if any side is non-positive\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n    \n    // Create an array to hold the sides and sort them\n    float sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Assign sorted values to side1, side2, side3\n    float side1 = sides[0];\n    float side2 = sides[1];\n    float side3 = sides[2];\n    \n    // Check if the sum of squares of side1 and side2 equals square of side3\n    return (side1 * side1 + side2 * side2) == side3 * side3;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_count = -1;\n    string result_word;\n\n    for (const string& word : words) {\n        bool seen[256] = {false};\n        int count = 0;\n\n        for (char c : word) {\n            if (!seen[c]) {\n                seen[c] = true;\n                count++;\n            }\n        }\n\n        if (count > max_count || (count == max_count && word < result_word)) {\n            max_count = count;\n            result_word = word;\n        }\n    }\n\n    return result_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\n#include <algorithm> // For std::min\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    int amount = std::min(need, remaining);\n    int total_eaten = number + amount;\n    int rem_after = remaining - amount;\n    return {total_eaten, rem_after};\n}\n"}
{"task_id": "CPP/160", "generation": "The final answer is \\boxed{0.000009155273}."}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    string result;\n    for (char c : s) {\n        if (isalpha(static_cast<unsigned char>(c))) { \n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n            hasLetters = true;\n        } else {\n            result += c;\n        }\n    }\n    if (!hasLetters) {\n        reverse(result.begin(), result.end());\n    }\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    const static char hex_chars[] = \"0123456789abcdef\";\n    string md5_str;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        md5_str += hex_chars[(digest[i] >> 4) & 0xF];\n        md5_str += hex_chars[digest[i] & 0xF];\n    }\n\n    return md5_str;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int i = start; i <= end; ++i) {\n        string s = to_string(i);\n        bool valid = true;\n        for (char c : s) {\n            if (c != '0' && c != '2' && c != '4' && c != '6' && c != '8') {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\n"}
