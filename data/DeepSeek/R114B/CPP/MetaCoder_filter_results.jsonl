{"task_id": "CPP/1", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove all spaces from the input string\n    string cleaned;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned += c;\n        }\n    }\n\n    vector<string> groups;\n    int start = 0;\n    int level = 0;\n\n    for (int i = 0; i < cleaned.size(); ++i) {\n        if (cleaned[i] == '(') {\n            level++;\n        } else if (cleaned[i] == ')') {\n            level--;\n            // When level returns to 0, we found a complete group\n            if (level == 0) {\n                groups.push_back(cleaned.substr(start, i - start + 1));\n                start = i + 1;\n            }\n        }\n    }\n\n    return groups;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/3", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int current_balance = 0;\n    for (int op : operations) {\n        current_balance += op;\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/8", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    \n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/2", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(number);\n    return number - integer_part;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/14", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    int n = str.size();\n    for (int i = 1; i <= n; ++i) {\n        string prefix = str.substr(0, i);\n        result.push_back(prefix);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"\"),{}));\n    assert (issame(all_prefixes(\"asdfgh\") ,{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}));\n     assert (issame(all_prefixes(\"WWW\") ,{\"W\", \"WW\", \"WWW\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/4", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0f; // Handle empty vector case\n    \n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n    float mad_sum = 0.0f;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    return mad_sum / n;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/7", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const string& s : strings) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/12", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    int max_len = 0;\n    string result = \"\";\n    \n    for (const string& s : strings) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n            result = s;\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"x\", \"y\", \"z\"}) == \"x\");\n    assert (longest({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/9", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result; // Return empty vector if input is empty\n    }\n    int max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n        }\n        result.push_back(max_so_far);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/0", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < numbers.size(); ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/13", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cstdlib> // For abs function\n\nint greatest_common_divisor(int a, int b) {\n    if (a == 0 && b == 0) {\n        return 0;\n    }\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = a % b;\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 7) == 1);\n     assert (greatest_common_divisor(10, 15) == 5);\n      assert (greatest_common_divisor(49, 14) == 7);\n     assert (greatest_common_divisor(144, 60) == 12);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/6", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<string> groups;\n    istringstream iss(paren_string);\n    string group;\n    \n    // Split the input string into individual groups\n    while (iss >> group) {\n        groups.push_back(group);\n    }\n    \n    vector<int> result;\n    \n    for (auto &grp : groups) {\n        int current_depth = 0;\n        int max_depth = 0;\n        for (char c : grp) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/5", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/10", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring make_palindrome(string str) {\n    int n = str.size();\n    for (int i = 0; i < n; ++i) {\n        string substr = str.substr(i);\n        string reversed_substr(substr.rbegin(), substr.rend());\n        if (substr == reversed_substr) {\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    // This line is theoretically unreachable\n    return str;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"x\") == \"x\");\n     assert (make_palindrome(\"xyz\") == \"xyzyx\");\n     assert (make_palindrome(\"xyx\") == \"xyx\") ;\n     assert (make_palindrome(\"jerry\") == \"jerryrrej\");\n}\n\n\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/11", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <algorithm> // For std::max\n\nstring string_xor(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad both strings with leading zeros to make them of length max_len\n    string padded_a = a;\n    if (len_a < max_len) {\n        int zeros_needed = max_len - len_a;\n        padded_a = string(zeros_needed, '0') + a;\n    }\n\n    string padded_b = b;\n    if (len_b < max_len) {\n        int zeros_needed = max_len - len_b;\n        padded_b = string(zeros_needed, '0') + b;\n    }\n\n    string result;\n\n    for (int i = 0; i < max_len; ++i) {\n        bool a_bit = (padded_a[i] == '1');\n        bool b_bit = (padded_b[i] == '1');\n        if (a_bit != b_bit) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"111000\", \"101010\") == \"010010\");\n     assert (string_xor(\"1\", \"1\") == \"0\");\n    assert (string_xor(\"0101\", \"0000\") == \"0101\");\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/15", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        if (result.empty()) {\n            result = to_string(i);\n        } else {\n            result += \" \";\n            result += to_string(i);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(3) == \"0 1 2 3\");\n     assert (string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/16", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    vector<bool> seen(256, false);\n    int count = 0;\n    for (char c : str) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        unsigned char index = static_cast<unsigned char>(c);\n        if (!seen[index]) {\n            seen[index] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"\") == 0);\n    assert (count_distinct_characters(\"abcde\") == 5);\n    assert (count_distinct_characters(\"abcdecadeCADE\") == 5);\n    assert (count_distinct_characters(\"aaaaAAAAaaaa\") == 1);\n    assert (count_distinct_characters(\"Jerry jERRY JeRRRY\") == 5);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/18", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int m = substring.length();\n    if (m == 0 || str.length() < m) {\n        return 0;\n    }\n    for (int i = 0; i <= str.size() - m; ++i) {\n        if (str.substr(i, m) == substring) {\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"x\") == 0);\n    assert (how_many_times(\"xyxyxyx\", \"x\") == 4);\n     assert (how_many_times(\"cacacacac\", \"cac\") == 4);\n    assert (how_many_times(\"john doe\", \"john\") == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/17", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    stringstream ss(music_string);\n    string token;\n    \n    while (ss >> token) {\n        if (token == \"o\") {\n            result.push_back(4);\n        } else if (token == \"o|\") {\n            result.push_back(2);\n        } else if (token == \".|\") {\n            result.push_back(1);\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"\") , {}));\n     assert (issame(parse_music(\"o o o o\") ,{4, 4, 4, 4}));\n      assert (issame(parse_music(\".| .| .| .|\") , {1, 1, 1, 1}));\n assert (issame(parse_music(\"o| o| .| .| o o o o\") , {2, 2, 1, 1, 4, 4, 4, 4}));\n  assert (issame(parse_music(\"o| .| o| .| o o| o o|\") , {2, 1, 2, 1, 4, 2, 4, 2}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/23", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"x\") == 1);\n     assert (strlen(\"asdasnakj\") == 9);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/27", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (int i = 0; i < str.size(); ++i) {\n        char c = str[i];\n        if ('a' <= c && c <= 'z') {\n            str[i] = c - 32;\n        } else if ('A' <= c && c <= 'Z') {\n            str[i] = c + 32;\n        }\n    }\n    return str;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (flip_case(\"\") == \"\");\n    assert (flip_case(\"Hello!\") == \"hELLO!\");\n    assert (flip_case(\"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/24", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return -1; // This line is theoretically unreachable for n >= 2.\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/20", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // For sort function\n#include <cmath>     // For FLT_MAX and abs function\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {}; // Assuming input has at least two elements as per problem statement.\n    }\n\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = FLT_MAX;\n    vector<float> closest_pair = {numbers[0], numbers[1]};\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i+1] - numbers[i]);\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_pair = {numbers[i], numbers[i+1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    assert (issame(find_closest_elements({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n      assert (issame(find_closest_elements({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/21", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_values;\n    float range_val = max_val - min_val;\n\n    if (range_val == 0) {\n        // All elements are the same; return a vector of zeros\n        scaled_values.resize(numbers.size(), 0.0f);\n    } else {\n        for (float num : numbers) {\n            float scaled = (num - min_val) / range_val;\n            // Clamp to avoid floating point errors\n            if (scaled < 0.0f) scaled = 0.0f;\n            if (scaled > 1.0f) scaled = 1.0f;\n            scaled_values.push_back(scaled);\n        }\n    }\n\n    return scaled_values;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({2.0, 49.9}) , {0.0, 1.0}));\n     assert (issame(rescale_to_unit({100.0, 49.9}) ,{1.0, 0.0})); \n     assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n    assert (issame(rescale_to_unit({2.0, 1.0, 5.0, 3.0, 4.0}) , {0.25, 0.0, 1.0, 0.5, 0.75}));\n     assert (issame(rescale_to_unit({12.0, 11.0, 15.0, 13.0, 14.0}) ,{0.25, 0.0, 1.0, 0.5, 0.75}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/25", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Handle division by 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Now check odd numbers from 3 upwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(2) , {2}));\n    assert (issame(factorize(4) , {2, 2}));\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(3 * 19) , {3, 19}));\n    assert (issame(factorize(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    assert (issame(factorize(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    assert (issame(factorize(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    assert (issame(factorize(3 * 2 * 3) , {2, 3, 3}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/22", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <boost/any.hpp>\n#include <list>\n#include <vector>\n#include <typeinfo>\n\nusing namespace std;\nusing namespace boost;\n\ntypedef list<any> list_any;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& elem : values) {\n        if (elem.type() == typeid(int)) {\n            int val = any_cast<int>(elem);\n            result.push_back(val);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({}),{}));\n\n    assert (issame(filter_integers({4,  {},23.2, 9, string(\"adasd\")}) ,{4, 9}));\n    assert (issame(filter_integers({3, 'c', 3, 3, 'a', 'b'}) ,{3, 3, 3}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/19", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from number words to their corresponding integer values\n    map<string, int> number_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, \n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    \n    // Split the input string into individual words\n    vector<string> words;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    // Sort the words based on their numeric values using a custom comparator\n    sort(words.begin(), words.end(), [&number_map](const string& a, const string& b) {\n        return number_map[a] < number_map[b];\n    });\n    \n    // Join the sorted words into a single string with spaces\n    stringstream result_ss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            result_ss << \" \";\n        }\n        result_ss << words[i];\n    }\n    return result_ss.str();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/26", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> counts;\n    vector<int> result;\n    unordered_set<int> added;\n\n    // Count the frequency of each number\n    for (int num : numbers) {\n        counts[num]++;\n    }\n\n    // Collect numbers that appear exactly once, maintaining order\n    for (int num : numbers) {\n        if (counts[num] == 1 && added.find(num) == added.end()) {\n            result.push_back(num);\n            added.insert(num);\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(remove_duplicates({}) , {}));\n     assert (issame(remove_duplicates({1, 2, 3, 4}) , {1, 2, 3, 4}));\n      assert (issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}) , {1, 4, 5}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/28", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& s : strings) {\n        result += s;\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n     assert (concatenate({\"x\", \"y\", \"z\"}) == \"xyz\");\n    assert (concatenate({\"x\", \"y\", \"z\", \"w\", \"k\"}) == \"xyzwk\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/29", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& s : strings) {\n        if (s.size() >= prefix.size()) {\n            if (s.substr(0, prefix.size()) == prefix) {\n                result.push_back(s);\n            }\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"john\") , {}));\n    assert (issame(filter_by_prefix({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\") , {\"xxx\", \"xxxAAA\", \"xxx\"}));\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/31", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cmath> // Include cmath for sqrt function\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    long long max_divisor = static_cast<long long>(sqrt(n)) + 1;\n    for (long long d = 3; d <= max_divisor; d += 2) {\n        if (n % d == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n    assert (is_prime(5) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(17) == true);\n    assert (is_prime(5 * 17) == false);\n    assert (is_prime(11 * 7) == false);\n    assert (is_prime(13441 * 19) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/36", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit == 7) {\n                    total++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n    assert (fizz_buzz(100) == 3);\n    assert (fizz_buzz(200) == 6);\n    assert (fizz_buzz(4000) == 192);\n    assert (fizz_buzz(10000) == 639);\n    assert (fizz_buzz(100000) == 8026);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/30", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, -2, 4, 5, 6}) , {4, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}) , {5, 3, 2, 3, 3, 9, 123, 1}));\n     assert (issame(get_positive({-1, -2}) , {} ));\n     assert (issame(get_positive({}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/35", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        // Handle empty vector case as needed; here we return NaN.\n        return NAN;\n    }\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/38", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nThe role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n\n1. **Initial Analysis**: Examine the encoded message for patterns, repeated sequences, or structural clues that might hint at the cipher type.\n\n2. **Frequency Analysis**: Check for letter frequencies to identify common English letters like E, T, A, which could help in deciphering if a Caesar cipher is used.\n\n3. **Caesar Cipher Test**: Attempt different shift values (e.g., shifting each letter by +9) to see if the plaintext becomes readable.\n\n4. **Vigen\u00e8re Consideration**: If single shifts fail, explore polyalphabetic ciphers like Vigen\u00e8re, potentially using keys based on message length or known plaintext.\n\n5. **Substitution and Transposition**: Investigate possibilities of substitution combined with transposition methods, such as reversing letters or rearranging groups.\n\n6. **Iterative Testing**: Continuously test hypotheses, adjust approaches, and seek patterns or partial successes that could lead to deciphering the message.\n\n7. **Clue Utilization**: If stuck, revisit earlier steps or look for additional clues within the cipher structure.\n\nBy methodically exploring these avenues, the goal is to systematically unravel the encoded message, leveraging both analytical techniques and creative problem-solving.\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n", "result": "failed: compilation error: test.cpp:19:138: error: stray \u2018\\303\u2019 in program\n   19 | The role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n      |                                                                                                                                          ^\ntest.cpp:19:139: error: stray \u2018\\250\u2019 in program\n   19 | The role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n      |                                                                                                                                           ^\ntest.cpp:19:181: warning: missing terminating ' character\n   19 | The role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n      |                                                                                                                                                                                     ^\ntest.cpp:19:181: error: missing terminating ' character\n   19 | The role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n      |                                                                                                                                                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ntest.cpp:27:11: error: stray \u2018\\303\u2019 in program\n   27 | 4. **Vigen\u00e8re Consideration**: If single shifts fail, explore polyalphabetic ciphers like Vigen\u00e8re, potentially using keys based on message length or known plaintext.\n      |           ^\ntest.cpp:27:12: error: stray \u2018\\250\u2019 in program\n   27 | 4. **Vigen\u00e8re Consideration**: If single shifts fail, explore polyalphabetic ciphers like Vigen\u00e8re, potentially using keys based on message length or known plaintext.\n      |            ^\ntest.cpp:27:97: error: stray \u2018\\303\u2019 in program\n   27 | 4. **Vigen\u00e8re Consideration**: If single shifts fail, explore polyalphabetic ciphers like Vigen\u00e8re, potentially using keys based on message length or known plaintext.\n      |                                                                                                 ^\ntest.cpp:27:98: error: stray \u2018\\250\u2019 in program\n   27 | 4. **Vigen\u00e8re Consideration**: If single shifts fail, explore polyalphabetic ciphers like Vigen\u00e8re, potentially using keys based on message length or known plaintext.\n      |                                                                                                  ^\ntest.cpp:19:1: error: \u2018The\u2019 does not name a type\n   19 | The role involves solving a cipher through a systematic approach, considering various cryptographic methods such as Caesar ciphers, Vigen\u00e8re, substitution, and transposition. Here's a structured summary of the thought process:\n      | ^~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/33", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisible_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_elements.push_back(l[i]);\n        }\n    }\n    sort(divisible_elements.begin(), divisible_elements.end());\n    \n    vector<int> l_prime;\n    int pos = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l_prime.push_back(divisible_elements[pos]);\n            pos++;\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (issame(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (issame(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/34", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s;\n    for (int num : l) {\n        s.insert(num);\n    }\n    return vector<int>(s.begin(), s.end());\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/39", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    if (num == 2) {\n        return true;\n    }\n    if (num % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n <= 0) {\n        return -1; // Indicate invalid input\n    }\n\n    int a = 0, b = 1;\n    int count = 0;\n    int fib_num;\n\n    while (true) {\n        fib_num = a;\n        if (is_prime(fib_num)) {\n            count++;\n            if (count == n) {\n                return fib_num;\n            }\n        }\n        // Move to next Fibonacci number\n        int next = a + b;\n        a = b;\n        b = next;\n    }\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n    assert (prime_fib(6) == 233);\n    assert (prime_fib(7) == 1597);\n    assert (prime_fib(8) == 28657);\n    assert (prime_fib(9) == 514229);\n    assert (prime_fib(10) == 433494437);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/37", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    // Extract elements at even indices\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    // Sort the extracted even elements\n    sort(even_elements.begin(), even_elements.end());\n    \n    vector<float> result;\n    int even_ptr = 0; // Pointer to track the current position in even_elements\n    \n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) { // Even index\n            result.push_back(even_elements[even_ptr]);\n            even_ptr++;\n        } else { // Odd index, retain original value\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/32", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n     Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n     */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. It returns only one zero point, even if there are many.\n    Moreover, find_zero only takes lists xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (abs(poly(coeffs, solution))< 1e-3);\n    }\n}\n", "result": "failed: a.out: test.cpp:58: int main(): Assertion `abs(poly(coeffs, solution))< 1e-3' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/40", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    if (l.size() < 3) return false;\n    sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue;\n        int left = i + 1, right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum > 0) right--;\n            else left++;\n        }\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -1}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({1, 2, 5, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert (triples_sum_to_zero({1}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -100}) == false);\n    assert (triples_sum_to_zero({100, 3, 5, -100}) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/41", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (car_race_collision(2) == 4);\n    assert (car_race_collision(3) == 9);\n    assert (car_race_collision(4) == 16);\n    assert (car_race_collision(8) == 64);\n    assert (car_race_collision(10) == 100);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/42", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/44", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0)\n        return \"0\";\n    string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.push_back('0' + remainder);\n        x /= base;\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(9, 3) == \"100\");\n    assert (change_base(234, 2) == \"11101010\");\n    assert (change_base(16, 2) == \"10000\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n    for (int x=2;x<8;x++)\n        assert (change_base(x, x + 1) == to_string(x));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/43", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int x : l) {\n        if (seen.find(-x) != seen.end()) {\n            return true;\n        }\n        seen.insert(x);\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert (pairs_sum_to_zero({1}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 30}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 31}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 30}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 31}) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/45", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n    assert (abs(triangle_area(2, 2) - 2.0)<1e-4);\n    assert (abs(triangle_area(10, 8) - 40.0)<1e-4);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/46", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    int a = 0; // Represents fib4(0)\n    int b = 0; // Represents fib4(1)\n    int c = 2; // Represents fib4(2)\n    int d = 0; // Represents fib4(3)\n\n    for (int i = 4; i <= n; ++i) {\n        int next_val = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_val;\n    }\n\n    return d;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(8) == 28);\n    assert (fib4(10) == 104);\n    assert (fib4(12) == 386);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/49", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n\nusing namespace std;\n\nunsigned long long modp(int n, int p) {\n    if (p == 1)\n        return 0;\n    unsigned long long result = 1;\n    unsigned long long base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n    assert (modp(30, 5) == 4);\n    assert (modp(31, 5) == 3);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/48", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int len = text.length();\n    if (len <= 1) {\n        return true;\n    }\n    for (int i = 0; i < len / 2; ++i) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n    assert (is_palindrome(\"xywyx\") == true);\n    assert (is_palindrome(\"xywyz\") == false);\n    assert (is_palindrome(\"xywzx\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/50", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring decode_shift(string s) {\n    string out;\n    for (char c : s) {\n        int pos = c - 'a'; // Convert character to 0-25 range\n        int decoded_pos = (pos - 5 + 26) % 26; // Reverse the shift and handle wrap-around\n        char decoded_char = 'a' + decoded_pos; // Convert back to character\n        out += decoded_char;\n    }\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n", "result": "failed: compilation error: test.cpp: In function \u2018int main()\u2019:\ntest.cpp:46:30: error: \u2018encode_shift\u2019 was not declared in this scope; did you mean \u2018decode_shift\u2019?\n   46 |         string encoded_str = encode_shift(str);\n      |                              ^~~~~~~~~~~~\n      |                              decode_shift\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/47", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float a = l[(n / 2) - 1];\n        float b = l[n / 2];\n        return (a + b) / 2.0f;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n    assert (abs(median({5}) - 5)<1e-4);\n    assert (abs(median({6, 5}) - 5.5)<1e-4);\n    assert (abs(median({8, 1, 3, 9, 9, 2, 7}) - 7)<1e-4 );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/51", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cctype> // for tolower function\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        char lower_c = tolower(c);\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"fedcba\") == \"fdcb\");\n    assert (remove_vowels(\"eeeee\") == \"\");\n    assert (remove_vowels(\"acBAA\") == \"cB\");\n    assert (remove_vowels(\"EcBOO\") == \"cB\");\n    assert (remove_vowels(\"ybcd\") == \"ybcd\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/53", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(0, 1) == 1);\n    assert (add(1, 0) == 1);\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n    assert (add(7, 5) == 12);\n    for (int i=0;i<100;i+=1)\n    {\n        int x=rand()%1000;\n        int y=rand()%1000;\n        assert (add(x, y) == x + y);\n    }\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/52", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/54", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> set0(s0.begin(), s0.end());\n    set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/55", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n    assert (fib(11) == 89);\n    assert (fib(12) == 144);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/56", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (correct_bracketing(\"<><><<><>><>\"));\n    assert (correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n    assert (not (correct_bracketing(\"<<<><>>>>\")));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n    assert (not (correct_bracketing(\"<<<<\")));\n    assert (not (correct_bracketing(\">\")));\n    assert (not (correct_bracketing(\"<<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>><<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>>><>\")));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/57", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i + 1]) {\n            increasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 2, 4, 20}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n    assert (monotonic({4, 1, 1, 0}) == true);\n    assert (monotonic({1, 2, 3, 2, 5, 60}) == false);\n    assert (monotonic({1, 2, 3, 4, 5, 60}) == true);\n    assert (monotonic({9, 9, 9, 9}) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/59", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    if (n <= 1) {\n        return -1; // Assuming n should be >1 as per problem constraints.\n    }\n    \n    int max_factor = -1;\n    \n    // Check divisibility by 2\n    if (n % 2 == 0) {\n        max_factor = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n    }\n    \n    // Check odd factors from 3 upwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            max_factor = i;\n            n /= i;\n        }\n    }\n    \n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        max_factor = n;\n    }\n    \n    return max_factor;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/58", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n    vector<int> res;\n    \n    for (int num : s1) {\n        if (s2.find(num) != s2.end()) {\n            res.push_back(num);\n        }\n    }\n    \n    return res;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n    assert (issame(common({4, 3, 2, 8}, {3, 2, 4}) , {2, 3, 4}));\n    assert (issame(common({4, 3, 2, 8}, {}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/60", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(6) == 21);\n    assert (sum_to_n(11) == 66);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/61", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (correct_bracketing(\"()()(()())()\"));\n    assert (correct_bracketing(\"()()((()()())())(()()(()))\"));\n    assert (not (correct_bracketing(\"((()())))\")));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n    assert (not (correct_bracketing(\"((((\")));\n    assert (not (correct_bracketing(\")\")));\n    assert (not (correct_bracketing(\"(()\")));\n    assert (not (correct_bracketing(\"()()(()())())(()\")));\n    assert (not (correct_bracketing(\"()()(()())()))()\")));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/62", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> res;\n    for (size_t j = 1; j < xs.size(); ++j) {\n        res.push_back(j * xs[j]);\n    }\n    return res;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n    assert (issame(derivative({3, 2, 1}) , {2, 2}));\n    assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));\n    assert (issame(derivative({1}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/63", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Represents fib(i-3), fib(i-2), fib(i-1)\n    for (int i = 3; i <= n; ++i) {\n        int current = a + b + c;\n        a = b;\n        b = c;\n        c = current;\n    }\n    return c;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(2) == 1);\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n    assert (fibfib(10) == 81);\n    assert (fibfib(12) == 274);\n    assert (fibfib(14) == 927);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/64", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <cctype>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        char lower_c = tolower(c);\n        if (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u') {\n            count++;\n        }\n    }\n    if (!s.empty()) {\n        char last_char = tolower(s.back());\n        if (last_char == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"Alone\") == 3);\n    assert (vowels_count(\"key\") == 2);\n    assert (vowels_count(\"bye\") == 1);\n    assert (vowels_count(\"keY\") == 2);\n    assert (vowels_count(\"bYe\") == 1);\n    assert (vowels_count(\"ACEDY\") == 3);\n   \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/67", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<string> tokens;\n    istringstream iss(s);\n    string token;\n    \n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n    \n    int apples = stoi(tokens[0]);\n    int oranges = stoi(tokens[3]);\n    \n    return n - apples - oranges;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"5 apples and 6 oranges\",21) == 10);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"1 apples and 0 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",5) == 0);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/66", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <cctype>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n    assert (digitSum(\" How are yOu?\") == 151);\n    assert (digitSum(\"You arE Very Smart\") == 327);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/65", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int len = s.length();\n    \n    if (shift >= len) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n    \n    int effective_shift = shift % len;\n    if (effective_shift == 0) {\n        return s;\n    }\n    \n    string shifted_part = s.substr(len - effective_shift);\n    s = shifted_part + s.substr(0, len - effective_shift);\n    \n    return s;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(100, 2) == \"001\");\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(97, 8) == \"79\");\n    assert (circular_shift(12, 1) == \"21\");\n    assert (circular_shift(11, 101) == \"11\");\n}\n", "result": "failed: a.out: test.cpp:44: int main(): Assertion `circular_shift(12, 2) == \"12\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/68", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <climits> // for INT_MAX\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int min_even = INT_MAX;\n    int min_index = -1;\n    bool found = false;\n\n    for (size_t i = 0; i < arr.size(); ++i) {\n        int num = arr[i];\n        if (num % 2 == 0) { // check if even\n            if (!found || num < min_even) {\n                min_even = num;\n                min_index = i;\n                found = true;\n            }\n        }\n    }\n\n    if (found) {\n        return { min_even, min_index };\n    } else {\n        return {};\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n    assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));\n    assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));\n    assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));\n    assert (issame(pluck({7, 9, 7, 1}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/69", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (auto& pair : freq) {\n        if (pair.second >= pair.first && pair.first > max_num) {\n            max_num = pair.first;\n        }\n    }\n    \n    return max_num;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({5, 5, 5, 5, 1}) == 1);\n    assert (search({4, 1, 4, 1, 4, 4}) == 4);\n    assert (search({3, 3}) == -1);\n    assert (search({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    assert (search({2, 3, 3, 2, 2}) == 2);\n    assert (search({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    assert (search({3, 2, 8, 2}) == 2);\n    assert (search({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    assert (search({8, 8, 3, 6, 5, 6, 4}) == -1);\n    assert (search({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    assert (search({1, 9, 10, 1, 3}) == 1);\n    assert (search({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    assert (search({1}) == 1);\n    assert (search({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    assert (search({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    assert (search({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    assert (search({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    assert (search({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    assert (search({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    assert (search({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    assert (search({10}) == -1);\n    assert (search({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    assert (search({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    assert (search({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    assert (search({3, 10, 10, 9, 2}) == -1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/70", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> sorted = lst;\n    sort(sorted.begin(), sorted.end());\n    \n    vector<int> result;\n    int left = 0;\n    int right = sorted.size() - 1;\n    bool takeMin = true;\n    \n    while (left <= right) {\n        if (takeMin) {\n            result.push_back(sorted[left]);\n            left++;\n        } else {\n            result.push_back(sorted[right]);\n            right--;\n        }\n        takeMin = !takeMin;\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9}) , {5, 9, 6, 8, 7}));\n    assert (issame(strange_sort_list({1, 2, 3, 4, 5}) , {1, 5, 2, 4, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9, 1}) , {1, 9, 5, 8, 6, 7}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n    assert (issame(strange_sort_list({1,2,3,4,5,6,7,8}) , {1, 8, 2, 7, 3, 6, 4, 5}));\n    assert (issame(strange_sort_list({0,2,2,2,5,5,-5,-5}) , {-5, 5, -5, 5, 0, 2, 2, 2}));\n    assert (issame(strange_sort_list({111111}) , {111111}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/72", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    bool is_palindrome = true;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    return is_palindrome && sum <= w;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n    assert (will_it_fly({1, 2, 3}, 6) ==false);\n    assert (will_it_fly({5}, 5) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/71", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cmath> // For sqrt and round functions\n\nfloat triangle_area(float a, float b, float c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    float s = (a + b + c) / 2.0f;\n    float area_sq = s * (s - a) * (s - b) * (s - c);\n    if (area_sq <= 0) { // Handle potential floating point errors\n        return -1;\n    }\n    float area = sqrt(area_sq);\n    area = std::round(area * 100.0f) / 100.0f;\n    return area;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n    assert (abs(triangle_area(4, 8, 5) -8.18)<0.01);\n    assert (abs(triangle_area(2, 2, 2) -1.73)<0.01);\n    assert (abs(triangle_area(1, 2, 3) +1)<0.01);\n    assert (abs(triangle_area(10, 5, 7) - 16.25)<0.01);\n    assert (abs(triangle_area(2, 6, 3) +1)<0.01);\n    assert (abs(triangle_area(1, 1, 1) -0.43)<0.01);\n    assert (abs(triangle_area(2, 2, 10) +1)<0.01);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/73", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 4, 2}) == 1);\n    assert (smallest_change({1, 4, 4, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n    assert (smallest_change({1}) == 0);\n    assert (smallest_change({0, 1}) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/75", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    if (a <= 0) return false;\n    \n    int count = 0;\n    for (int i = 2; i * i <= a; ++i) {\n        while (a % i == 0) {\n            count++;\n            a /= i;\n        }\n    }\n    if (a > 1) {\n        count++;\n    }\n    \n    return count == 3;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(5) == false);\n    assert (is_multiply_prime(30) == true);\n    assert (is_multiply_prime(8) == true);\n    assert (is_multiply_prime(10) == false);\n    assert (is_multiply_prime(125) == true);\n    assert (is_multiply_prime(3 * 5 * 7) == true);\n    assert (is_multiply_prime(3 * 6 * 7) == false);\n    assert (is_multiply_prime(9 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 13 * 7) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/76", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == -1) {\n        return x == 1 || x == -1;\n    }\n\n    long current = 1;\n    while (current <= x) {\n        if (current == x) {\n            return true;\n        }\n        current *= n;\n    }\n    return false;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n    assert (is_simple_power(16, 2)== true);\n    assert (is_simple_power(143214, 16)== false);\n    assert (is_simple_power(4, 2)==true);\n    assert (is_simple_power(9, 3)==true);\n    assert (is_simple_power(16, 4)==true);\n    assert (is_simple_power(24, 2)==false);\n    assert (is_simple_power(128, 4)==false);\n    assert (is_simple_power(12, 6)==false);\n    assert (is_simple_power(1, 1)==true);\n    assert (is_simple_power(1, 12)==true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/74", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0;\n    for (string s : lst1) {\n        sum1 += s.length();\n    }\n    \n    int sum2 = 0;\n    for (string s : lst2) {\n        sum2 += s.length();\n    }\n    \n    if (sum1 < sum2) {\n        return lst1;\n    } else if (sum2 < sum1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({}, {\"this\"}) , {}));\n    assert (issame(total_match({\"this\"}, {}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/77", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cmath>\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    \n    int sign = (a > 0) ? 1 : -1;\n    int abs_a = abs(a);\n    \n    double cube_root_approx = pow(abs_a, 1.0/3.0);\n    int k_approx = round(cube_root_approx);\n    \n    for (int k : {k_approx - 1, k_approx, k_approx + 1}) {\n        if (pow(k, 3) * sign == a) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscube(1) == true);\n    assert (iscube(2) == false);\n    assert (iscube(-1) == true);\n    assert (iscube(64) == true);\n    assert (iscube(180) == false);\n    assert (iscube(1000) == true);\n    assert (iscube(0) == true);\n    assert (iscube(1729) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/79", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm> // For std::reverse\n\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    \n    string binaryStr = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binaryStr += (remainder + '0');\n        decimal /= 2;\n    }\n    \n    reverse(binaryStr.begin(), binaryStr.end());\n    \n    return \"db\" + binaryStr + \"db\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(0) == \"db0db\");\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(103) == \"db1100111db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/80", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i <= s.size() - 3; ++i) {\n        char c1 = s[i];\n        char c2 = s[i + 1];\n        char c3 = s[i + 2];\n        if (c1 == c2 || c1 == c3 || c2 == c3) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n    assert (is_happy(\"iopaxpoi\") == true );\n    assert (is_happy(\"iopaxioi\") == false );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/78", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    unordered_set<int> primes = {2, 3, 5, 7, 11, 13};\n    for (char c : num) {\n        int val;\n        if (isdigit(c)) {\n            val = c - '0';\n        } else {\n            val = (c - 'A') + 10;\n        }\n        if (primes.count(val)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n    assert (hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12 );\n    assert (hex_key(\"\") == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/82", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nbool prime_length(string str) {\n    int n = str.length();\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    int sqrt_n = static_cast<int>(sqrt(n)) + 1;\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n    assert (prime_length(\"wow\") == true);\n    assert (prime_length(\"world\") == true);\n    assert (prime_length(\"MadaM\") == true);\n    assert (prime_length(\"Wow\") == true);\n    assert (prime_length(\"\") == false);\n    assert (prime_length(\"HI\") == true);\n    assert (prime_length(\"go\") == true);\n    assert (prime_length(\"gogo\") == false);\n    assert (prime_length(\"aaaaaaaaaaaaaaa\") == false);\n    assert (prime_length(\"Madam\") == true);\n    assert (prime_length(\"M\") == false);\n    assert (prime_length(\"0\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/81", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    // Function to convert numerical grades to letter grades based on GPA thresholds\n    vector<string> result;\n    for (float gpa : grades) {\n        if (gpa >= 4.0f) {\n            result.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            result.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            result.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            result.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            result.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            result.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            result.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            result.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            result.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            result.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            result.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n    assert (issame(numerical_letter_grade({1.2}) , {\"D+\"}));\n    assert (issame(numerical_letter_grade({0.5}) , {\"D-\"}));\n    assert (issame(numerical_letter_grade({0.0}) , {\"E\"}));\n    assert (issame(numerical_letter_grade({1, 0.3, 1.5, 2.8, 3.3}) , {\"D\", \"D-\", \"C-\", \"B\", \"B+\"}));\n    assert (issame(numerical_letter_grade({0, 0.7}) , {\"E\", \"D-\"}));\n    \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/83", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1)\n        return 1;\n    else\n        return 9 * pow(10, n-2) + 9;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (starts_one_ends(1) == 1);\n    assert (starts_one_ends(2) == 18);\n    assert (starts_one_ends(3) == 180);\n    assert (starts_one_ends(4) == 1800);\n    assert (starts_one_ends(5) == 18000);\n}\n", "result": "failed: a.out: test.cpp:33: int main(): Assertion `starts_one_ends(3) == 180' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/85", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 88}) == 88);\n    assert (add({4, 5, 6, 7, 2, 122}) == 122);\n    assert (add({4, 0, 6, 7}) == 0);\n    assert (add({4, 4, 6, 8}) == 12);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/84", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    if (N == 0) {\n        sum = 0;\n    } else {\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n    }\n    \n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    vector<int> bits;\n    int s = sum;\n    while (s > 0) {\n        int rem = s % 2;\n        bits.push_back(rem);\n        s /= 2;\n    }\n    \n    reverse(bits.begin(), bits.end());\n    \n    string result;\n    for (int bit : bits) {\n        result += to_string(bit);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/88", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    vector<int> result = array;\n    if (result.size() <= 1) return result;\n\n    int first = result[0];\n    int last = result.back();\n    int sum = first + last;\n\n    sort(result.begin(), result.end());\n\n    if (sum % 2 == 0) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n    assert (issame(sort_array({2, 1}) , {1, 2}));\n    assert (issame(sort_array({15, 42, 87, 32 ,11, 0}) , {0, 11, 15, 32, 42, 87}));\n    assert (issame(sort_array({21, 14, 23, 11}) , {23, 21, 14, 11}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/90", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findSecondSmallest(vector<int>& lst) {\n    if (lst.size() < 2) {\n        return -1;\n    }\n    sort(lst.begin(), lst.end());\n    int first = lst[0];\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] > first) {\n            return lst[i];\n        }\n    }\n    return -1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n    assert (next_smallest({1,1,1,1,0}) == 1);\n    assert (next_smallest({-35, 34, 12, -45}) == -35);\n}\n", "result": "failed: compilation error: In file included from test.cpp:36:\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:38:13: error: \u2018next_smallest\u2019 was not declared in this scope\n   38 |     assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n      |             ^~~~~~~~~~~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/87", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        for (int j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        } else {\n            return a[1] > b[1];\n        }\n    });\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6}}, 2) , {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,1,3,4,5,6},\n        {1,2,1,4,5,6},\n        {1,2,3,1,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1) , {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{1}}, 2) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/89", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            int shifted = (s[i] - 'a' + 4) % 26;\n            s[i] = 'a' + shifted;\n        }\n    }\n    return s;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n    assert (encrypt(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    assert (encrypt(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    assert (encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    assert (encrypt(\"a\")==\"e\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/86", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Split the string into words based on spaces\n    vector<string> words;\n    string current_word = \"\";\n    for (char c : s) {\n        if (c == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += c;\n        }\n    }\n    // Add the last word if it's not empty\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort each word's characters based on ASCII values\n    for (string &word : words) {\n        sort(word.begin(), word.end());\n    }\n\n    // Reconstruct the string with sorted words and original spaces\n    string result = \"\";\n    size_t last_pos = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (s[i] == ' ') {\n            // Add a space at the position where it was in the original string\n            result += \" \";\n            last_pos = i;\n        }\n    }\n\n    // Now, fill in the sorted words into the spaces\n    size_t word_index = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (s[i] == ' ') {\n            result[last_pos + 1] = words[word_index][0];\n            // Continue filling the rest of the characters\n            for (size_t j = 1; j < words[word_index].size(); ++j) {\n                result[last_pos + j + 1] = words[word_index][j];\n            }\n            word_index++;\n        }\n    }\n\n    return result;\n}\n\n/* The sorted version of \"World!!!\" based on ASCII values is \"!!!Wdlor\". */\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"number\") == \"bemnru\");\n    assert (anti_shuffle(\"abcd\") == \"abcd\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    assert (anti_shuffle(\"\") == \"\");\n    assert (anti_shuffle(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n", "result": "failed: a.out: test.cpp:76: int main(): Assertion `anti_shuffle(\"Hi\") == \"Hi\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/92", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    bool aInt = (a == static_cast<int>(a));\n    bool bInt = (b == static_cast<int>(b));\n    bool cInt = (c == static_cast<int>(c));\n\n    if (!aInt || !bInt || !cInt) {\n        return false;\n    }\n\n    // Check if any one number is the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(2, 3, 1)==true);\n    assert (any_int(2.5, 2, 3)==false);\n    assert (any_int(1.5, 5, 3.5)==false);\n    assert (any_int(2, 6, 2)==false);\n    assert (any_int(4, 2, 2)==true);\n    assert (any_int(2.2, 2.2, 2.2)==false);\n    assert (any_int(-4, 6, 2)==true);\n    assert (any_int(2,1,1)==true);\n    assert (any_int(3,4,7)==true);\n    assert (any_int(3.01,4,7)==false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/91", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to trim whitespace from both ends of a string\nstring trim_whitespace(const string &s) {\n    size_t start = s.find_first_not_of(\" \\t\\n\\r\");\n    if (start == string::npos) return \"\";\n    size_t end = s.find_last_not_of(\" \\t\\n\\r\");\n    return s.substr(start, end - start + 1);\n}\n\nint is_bored(const string &s) {\n    vector<string> sentences;\n    string current_sentence;\n\n    for (char c : s) {\n        if (c == '.' || c == '!' || c == '?') {\n            // Trim the current sentence and add to list if not empty\n            string trimmed = trim_whitespace(current_sentence);\n            if (!trimmed.empty()) {\n                sentences.push_back(trimmed);\n            }\n            current_sentence.clear();\n        } else {\n            current_sentence += c;\n        }\n    }\n\n    // Process the last sentence after loop ends\n    string trimmed_last = trim_whitespace(current_sentence);\n    if (!trimmed_last.empty()) {\n        sentences.push_back(trimmed_last);\n    }\n\n    int count = 0;\n    for (const string &sentence : sentences) {\n        if (!sentence.empty() && sentence[0] == 'I') {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"Is the sky blue?\") == 0);\n    assert (is_bored(\"I love It !\") == 1);\n    assert (is_bored(\"bIt\") == 0);\n    assert (is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert (is_bored(\"You and I are going for a walk\") == 0);\n}\n", "result": "failed: a.out: test.cpp:66: int main(): Assertion `is_bored(\"Is the sky blue?\") == 0' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/94", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n    if (max_prime == -1) return 0; // No primes found\n    int sum = 0;\n    int n = max_prime;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/93", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring encode(string message) {\n    string vowels_lower = \"aeiou\";\n    string vowels_upper = \"AEIOU\";\n    \n    for (char &c : message) {\n        if (vowels_lower.find(c) != string::npos) {\n            char base = 'a';\n            int shift = 2;\n            c = ((c - base + shift) % 26) + base;\n        } else if (vowels_upper.find(c) != string::npos) {\n            char base = 'A';\n            int shift = 2;\n            c = ((c - base + shift) % 26) + base;\n        }\n    }\n    return message;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"TEST\") == \"tgst\");\n    assert (encode(\"Mudasir\") == \"mWDCSKR\");\n    assert (encode(\"YES\") == \"ygs\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    assert (encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n}\n", "result": "failed: a.out: test.cpp:42: int main(): Assertion `encode(\"TEST\") == \"tgst\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/95", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <cctype>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nbool check_dict_case(const map<string, string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check all characters are alphabetic\n        bool all_alpha = true;\n        for (char c : key) {\n            if (!isalpha(c)) {\n                all_alpha = false;\n                break;\n            }\n        }\n\n        if (!all_alpha) {\n            return false;\n        }\n\n        char first_char = key[0];\n        bool is_first_lower = islower(first_char);\n        bool is_first_upper = isupper(first_char);\n\n        // Check case consistency\n        if (is_first_lower) {\n            for (char c : key) {\n                if (!islower(c)) {\n                    return false;\n                }\n            }\n        } else if (is_first_upper) {\n            for (char c : key) {\n                if (!isupper(c)) {\n                    return false;\n                }\n            }\n        } else {\n            // This case should not occur as all characters are alphabetic\n            return false;\n        }\n    }\n\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    assert (check_dict_case({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    assert (check_dict_case({}) == false);\n}\n", "result": "failed: a.out: test.cpp:74: int main(): Assertion `check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/96", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(6) , {2,3,5}));\n    assert (issame(count_up_to(7) , {2,3,5}));\n    assert (issame(count_up_to(10) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(22) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n    assert (issame(count_up_to(47) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}));\n    assert (issame(count_up_to(101) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/97", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cstdlib> // For abs function\n\nint multiply(int a, int b) {\n    int unitA = abs(a) % 10;\n    int unitB = abs(b) % 10;\n    return unitA * unitB;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n    assert (multiply(76, 67) == 42    );\n    assert (multiply(17, 27) == 49    );\n    assert (multiply(0, 1) == 0);\n    assert (multiply(0, 0) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/98", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0) { // Check if index is even\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n    assert (count_upper(\"B\")  == 0);\n    assert (count_upper(\"U\")  == 1);\n    assert (count_upper(\"\") == 0);\n    assert (count_upper(\"EEEE\") == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/99", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = atof(value.c_str());\n    return round(num);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"14.5\") == 15);\n    assert (closest_integer(\"-15.5\") == -16);\n    assert (closest_integer(\"15.3\") == 15);\n    assert (closest_integer(\"0\") == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/100", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        current += 2;\n    }\n    return pile;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n    assert (issame(make_a_pile(4) , {4,6,8,10}));\n    assert (issame(make_a_pile(5) , {5, 7, 9, 11, 13}));\n    assert (issame(make_a_pile(6) , {6, 8, 10, 12, 14, 16}));\n    assert (issame(make_a_pile(8) , {8, 10, 12, 14, 16, 18, 20, 22}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/102", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    int candidate = (y % 2 == 0) ? y : y - 1;\n    if (candidate >= x) {\n        return candidate;\n    } else {\n        return -1;\n    }\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n    assert (choose_num(33, 12354) == 12354);\n    assert (choose_num(5234, 5233) == -1);\n    assert (choose_num(6, 29) == 28);\n    assert (choose_num(27, 10) == -1);\n    assert (choose_num(7, 7) == -1);\n    assert (choose_num(546, 546) == 546);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/103", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the average\n    double avg = (n + m) / 2.0;\n    \n    // Round to nearest integer (towards zero)\n    long long rounded = static_cast<long long>(avg);\n    \n    // Convert to binary string\n    if (rounded == 0) {\n        return \"0\";\n    }\n    \n    string binary;\n    while (rounded > 0) {\n        binary = (rounded % 2 == 0 ? \"0\" : \"1\") + binary;\n        rounded /= 2;\n    }\n    \n    return binary;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 13) == \"1010\");\n    assert (rounded_avg(964,977) == \"1111001010\");\n    assert (rounded_avg(996,997) == \"1111100100\");\n    assert (rounded_avg(560,851) == \"1011000001\");  \n    assert (rounded_avg(185,546) == \"101101101\");\n    assert (rounded_avg(362,496) == \"110101101\");\n    assert (rounded_avg(350,902) == \"1001110010\");\n    assert (rounded_avg(197,233) == \"11010111\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(5, 1) == \"-1\");\n    assert (rounded_avg(5, 5) == \"101\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/101", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces\n    string modified_s;\n    for (char c : s) {\n        if (c == ',') {\n            modified_s += ' ';\n        } else {\n            modified_s += c;\n        }\n    }\n\n    // Split the modified string into words using istringstream\n    vector<string> result;\n    istringstream iss(modified_s);\n    string word;\n    while (iss >> word) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"Hi, my name\") , {\"Hi\", \"my\", \"name\"}));\n    assert (issame(words_string(\"One,, two, three, four, five, six,\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"\") , {}));\n    assert (issame(words_string(\"ahmed     , gamal\") , {\"ahmed\", \"gamal\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/104", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_all_odd_digits(int num) {\n    if (num == 0) return false;\n    while (num > 0) {\n        int d = num % 10;\n        if (d % 2 == 0) {\n            return false;\n        }\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> res;\n    for (int num : x) {\n        if (has_all_odd_digits(num)) {\n            res.push_back(num);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n    assert (issame(unique_digits({12345, 2033, 111, 151}) , {111, 151}));\n    assert (issame(unique_digits({135, 103, 31}) , {31, 135}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/105", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n\n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \n                            \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n    assert (issame(by_length({1, -1, 3, 2}) , {\"Three\", \"Two\", \"One\"}));\n    assert (issame(by_length({9, 4, 8}) , {\"Nine\", \"Eight\", \"Four\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/106", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // even index, compute factorial\n            int fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n            }\n            result.push_back(fact);\n        } else { // odd index, compute sum of 1 to i\n            int sum = i * (i + 1) / 2;\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n    assert (issame(f(7) , {1, 2, 6, 24, 15, 720, 28}));\n    assert (issame(f(1) , {1}));\n    assert (issame(f(3) , {1, 2, 6}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/107", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        int original = i;\n        int reversed = 0;\n        int temp = original;\n        while (temp > 0) {\n            reversed = reversed * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (reversed == original) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n    return {even_count, odd_count};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(123) , {8, 13}));\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n    assert (issame(even_odd_palindrome(63) , {6, 8}));\n    assert (issame(even_odd_palindrome(25) , {5, 6}));\n    assert (issame(even_odd_palindrome(19) , {4, 6}));\n    assert (issame(even_odd_palindrome(9) , {4, 5}));\n    assert (issame(even_odd_palindrome(1) , {0, 1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/109", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int count = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n; ++i) {\n        // Check if current element is greater than next, considering circular nature\n        if (arr[i] > arr[(i + 1) % n]) {\n            ++count;\n        }\n    }\n    \n    return count <= 1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 10, 1, 2})==true);\n    assert (move_one_ball({4, 3, 1, 2})==false);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n    assert (move_one_ball({})==true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/108", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        \n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n        }\n        \n        string digits_str = to_string(abs(num));\n        int sum_d = 0;\n        \n        for (size_t i = 0; i < digits_str.size(); ++i) {\n            char c = digits_str[i];\n            int digit = c - '0';\n            \n            if (i == 0 && is_negative) {\n                digit *= -1;\n            }\n            \n            sum_d += digit;\n        }\n        \n        if (sum_d > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, -2, 0}) == 0);\n    assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);\n    assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);\n    assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);\n    assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);\n    assert (count_nums({-0, 1}) == 1);\n    assert (count_nums({1}) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/110", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odds = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odds++;\n        }\n    }\n\n    int evens = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evens++;\n        }\n    }\n\n    return (evens >= odds) ? \"YES\" : \"NO\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/111", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <map>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freq;\n    istringstream iss(test);\n    string token;\n    \n    // Count frequency of each character\n    while (iss >> token) {\n        if (!token.empty()) {\n            char c = token[0];\n            freq[c]++;\n        }\n    }\n    \n    // If no characters were found, return empty map\n    if (freq.empty()) {\n        return {};\n    }\n    \n    // Find the maximum frequency\n    int max_count = 0;\n    for (auto& pair : freq) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n    \n    // Collect all characters with maximum frequency\n    map<char, int> result;\n    for (auto& pair : freq) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c d g\") , {{'a', 1}, {'b', 1}, {'c', 1}, {'d', 1}, {'g', 1}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"\") , {}));\n    assert (issame(histogram(\"a\") , {{'a', 1}}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/112", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> remove_chars(c.begin(), c.end());\n    string filtered;\n    \n    for (char ch : s) {\n        if (remove_chars.find(ch) == remove_chars.end()) {\n            filtered.push_back(ch);\n        }\n    }\n    \n    string reversed = filtered;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = (filtered == reversed);\n    \n    vector<string> result;\n    result.push_back(filtered);\n    result.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (issame(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (issame(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (issame(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/114", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // For std::min\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) {\n        return 0; // Handle empty vector case, though problem may assume non-empty\n    }\n    \n    long long current_min = nums[0];\n    long long global_min = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = min(nums[i], current_min + nums[i]);\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n    \n    return global_min;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n    assert (minSubArraySum({-1, -2, -3, 2, -10}) == -14);\n    assert (minSubArraySum({-9999999999999999}) == -9999999999999999);\n    assert (minSubArraySum({0, 10, 20, 1000000}) == 0);\n    assert (minSubArraySum({-1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({100, -1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({10, 11, 13, 8, 3, 4}) == 3);\n    assert (minSubArraySum({100, -33, 32, -1, 0, -2}) == -33);\n    assert (minSubArraySum({-10}) == -10);\n    assert (minSubArraySum({7}) == 7);\n    assert (minSubArraySum({1, -1}) == -1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/115", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <numeric> // For accumulate\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    for (auto &row : grid) {\n        int sum = accumulate(row.begin(), row.end(), 0);\n        if (sum == 0) continue;\n        int ops = (sum + capacity - 1) / capacity;\n        total_operations += ops;\n    }\n    return total_operations;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/116", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Define a helper lambda to count the number of 1s in binary representation\n    auto countOnes = [](int x) {\n        int count = 0;\n        int n = abs(x);\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    };\n\n    // Sort the array using a custom comparator\n    sort(arr.begin(), arr.end(), [&](int a, int b) {\n        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n        if (onesA != onesB) {\n            return onesA < onesB;\n        } else {\n            return a < b;\n        }\n    });\n\n    return arr;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({2,5,77,4,5,3,5,7,2,3,4}) , {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}));\n    assert (issame(sort_array({3,6,44,12,32,5}) , {32, 3, 5, 6, 12, 44}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/118", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.size();\n    if (n <= 2) return \"\";\n\n    int middle = n / 2;\n\n    for (int i = middle; i >= 0; --i) {\n        if (!isVowel(word[i])) continue;\n        \n        if (i == 0 || i == n - 1) continue;\n\n        bool prevConsonant = !isVowel(word[i-1]);\n        bool nextConsonant = !isVowel(word[i+1]);\n\n        if (prevConsonant && nextConsonant) {\n            return string(1, word[i]);\n        }\n    }\n\n    return \"\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"full\") == \"u\");\n    assert (get_closest_vowel(\"easy\") == \"\");\n    assert (get_closest_vowel(\"eAsy\") == \"\");\n    assert (get_closest_vowel(\"ali\") == \"\");\n    assert (get_closest_vowel(\"bad\") == \"a\");\n    assert (get_closest_vowel(\"most\") ==\"o\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"ba\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n    assert (get_closest_vowel(\"anime\") == \"i\");\n    assert (get_closest_vowel(\"Asia\") == \"\");\n    assert (get_closest_vowel(\"Above\") == \"o\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/113", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    // For each string in the input vector, count the number of odd digits.\n    vector<int> counts;\n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (isdigit(c)) { // Check if the character is a digit\n                int digit = c - '0';\n                if (digit % 2 != 0) { // Check if the digit is odd\n                    count++;\n                }\n            }\n        }\n        counts.push_back(count);\n    }\n\n    vector<string> result;\n    string template_str = \"the number of odd elements i in the strin g i of the input.\";\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        string modified_str = template_str;\n        // Replace every 'i' with the count value\n        replace(modified_str.begin(), modified_str.end(), 'i', to_string(counts[i])[0]);\n        result.push_back(modified_str);\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    assert (issame(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n}\n", "result": "failed: a.out: test.cpp:60: int main(): Assertion `issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/117", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result;\n    }\n    \n    istringstream iss(s);\n    string word;\n    \n    while (iss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            char lower_c = tolower(c);\n            if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n    assert (issame(select_words(\"\", 4) , {}));\n    assert (issame(select_words(\"a b c d e f\", 1) , {\"b\", \"c\", \"d\", \"f\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/121", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solution({5, 8, 7, 1})    == 12);\n    assert (solution({3, 3, 3, 3, 3}) == 9);\n    assert (solution({30, 13, 24, 321}) == 0);\n    assert (solution({5, 9}) == 5);\n    assert (solution({2, 4, 8}) == 0);\n    assert (solution({30, 13, 23, 32}) == 23);\n    assert (solution({3, 13, 2, 9}) == 3);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/119", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Function implementation goes here\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n    assert (match_parens({\"(()(())\", \"())())\"}) == \"No\");\n    assert (match_parens({\")())\", \"(()()(\"}) == \"Yes\");\n    assert (match_parens({\"(())))\", \"(()())((\"}) == \"Yes\");\n    assert (match_parens({\"()\", \"())\"}) == \"No\");\n    assert (match_parens({\"(()(\", \"()))()\"}) == \"Yes\");\n    assert (match_parens({\"((((\", \"((())\"}) == \"No\");\n    assert (match_parens({\")(()\", \"(()(\"}) == \"No\");\n    assert (match_parens({\")(\", \")(\"}) == \"No\");\n    assert (match_parens({\"(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \"(\"}) == \"Yes\" );\n}\n", "result": "failed: a.out: test.cpp:28: int main(): Assertion `match_parens({\"()(\", \")\"}) == \"Yes\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/120", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    if (k == 0) {\n        return {};\n    }\n    \n    sort(arr.begin(), arr.end());\n    \n    int n = arr.size();\n    return vector<int>(arr.begin() + (n - k), arr.end());\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n    assert (issame(maximum({123, -123, 20, 0 , 1, 2, -3}, 3) , {2, 20, 123}));\n    assert (issame(maximum({-123, 20, 0 , 1, 2, -3}, 4) , {0, 1, 2, 20}));\n    assert (issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7) , {-13, -8, 0, 0, 3, 5, 15}));\n    assert (issame(maximum({-1, 0, 2, 5, 3, -10}, 2) , {3, 5}));\n    assert (issame(maximum({1, 0, 5, -7}, 1) , {5}));\n    assert (issame(maximum({4, -4}, 2) , {-4, 4}));\n    assert (issame(maximum({-10, 10}, 2) , {-10, 10}));\n    assert (issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/122", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib> // for abs function\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    assert (add_elements({111,121,3,4000,5,6}, 2) == 0);\n    assert (add_elements({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    assert (add_elements({1}, 1) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/123", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    int current = n;\n    \n    while (current != 1) {\n        if (current % 2 == 1) {\n            odds.push_back(current);\n        }\n        \n        if (current % 2 == 0) {\n            current /= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    // Add the final 1 to the vector\n    odds.push_back(1);\n    \n    return odds;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17}));\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n    assert (issame(get_odd_collatz(12) , {1, 3, 5}));\n    assert (issame(get_odd_collatz(1) , {1}));\n}\n", "result": "failed: a.out: test.cpp:55: int main(): Assertion `issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/124", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // This function validates whether a given date string is in the correct format MM-DD-YYYY.\n    // Approach:\n    // 1. Check Length: Ensure the date string has exactly 10 characters.\n    // 2. Check Hyphens: Verify that the date string contains hyphens at positions 2 and 5.\n    // 3. Extract Parts: Split the date string into month, day, and year parts.\n    // 4. Validate Numeric Values: Ensure each part consists only of numeric characters.\n    // 5. Convert to Integers: Convert the extracted strings into integers for validation.\n    // 6. Check Month Range: The month must be between 1 and 12.\n    // 7. Determine Maximum Days: Based on the month, determine the maximum number of days.\n    // 8. Validate Day Range: Ensure the day is within the valid range for the given month.\n\n    // Solution Code:\n    if (date.length() != 10) {\n        return false;\n    }\n\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    string mm = date.substr(0, 2);\n    string dd = date.substr(3, 2);\n    string yyyy = date.substr(6, 4);\n\n    for (char c : mm) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    for (char c : dd) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    for (char c : yyyy) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n\n    int month = stoi(mm);\n    int day = stoi(dd);\n    int year = stoi(yyyy);\n\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    int max_day;\n\n    if (month == 2) {\n        // Check for leap year\n        bool leap_year = false;\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n            leap_year = true;\n        }\n        max_day = leap_year ? 29 : 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        max_day = 30;\n    } else {\n        max_day = 31;\n    }\n\n    if (day < 1 || day > max_day) {\n        return false;\n    }\n\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/125", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n    \n    if (txt.empty()) {\n        return result;\n    }\n    \n    size_t first_whitespace = txt.find_first_of(\" \\t\\n\");\n    if (first_whitespace != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n    } else {\n        size_t first_comma = txt.find(',');\n        if (first_comma != string::npos) {\n            size_t start = 0;\n            size_t end = txt.find(',', start);\n            while (end != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n                end = txt.find(',', start);\n            }\n            // Add the last part after the last comma\n            result.push_back(txt.substr(start));\n        } else {\n            int count = 0;\n            for (char c : txt) {\n                if (islower(c)) {\n                    if ((c - 'a') % 2 == 1) { // Check if position is odd\n                        count++;\n                    }\n                }\n            }\n            result.push_back(to_string(count));\n        }\n    }\n    \n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (issame(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n    assert (issame(split_words(\"aaabb\") , {\"2\"}));\n    assert (issame(split_words(\"aaaBb\") , {\"1\"}));\n    assert (issame(split_words(\"\") ,{\"0\"}));\n}\n", "result": "failed: a.out: test.cpp:84: int main(): Assertion `issame(split_words(\"\") ,{\"0\"})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/126", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is non-decreasing\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1]) {\n            return false;\n        }\n    }\n\n    // Count occurrences of each number\n    unordered_map<int, int> countMap;\n    for (int num : lst) {\n        countMap[num]++;\n    }\n\n    // Check if any number appears more than twice\n    for (auto& pair : countMap) {\n        if (pair.second > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({}) == true);\n    assert (is_sorted({1}) == true);\n    assert (is_sorted({3, 2, 1}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 3, 3, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert (is_sorted({1, 2, 3, 4}) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/127", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // For std::max and std::min\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    int length = end - start;\n    \n    if (length <= 0) {\n        return \"NO\";\n    }\n    \n    return is_prime(length) ? \"YES\" : \"NO\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n    assert (intersection({-2, 2}, {-4, 0}) == \"YES\");\n    assert (intersection({-11, 2}, {-1, -1}) == \"NO\");\n    assert (intersection({1, 2}, {3, 5}) == \"NO\");\n    assert (intersection({1, 2}, {1, 2}) == \"NO\");\n    assert (intersection({-2, -2}, {-3, -2}) == \"NO\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/128", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib> // for abs function\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum = 0;\n    for (int num : arr) {\n        sum += abs(num);\n    }\n    \n    int product = 1;\n    for (int num : arr) {\n        if (num == 0) {\n            product = 0;\n            break;\n        } else if (num < 0) {\n            product *= -1;\n        }\n    }\n    \n    return sum * product;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);\n    assert (prod_signs({}) == -32768);\n    assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);\n    assert (prod_signs({-1, 1, -1, 1}) == 4);\n    assert (prod_signs({-1, 1, 1, 1}) == -4);\n    assert (prod_signs({-1, 1, 1, 0}) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/130", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nTo compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n\n**Algorithm:**\n\n1. **Check if `n` is even or odd.**\n2. **If `n` is even:**\n   - Compute `tri(n) = 1 + (n / 2)`\n3. **If `n` is odd:**\n   - Compute `tri(n) = ((n + 3) // 2)^2 - 1`\n\n**Examples:**\n\n- For `n = 7` (odd):\n  - `(7 + 3) // 2 = 5`\n  - `5^2 - 1 = 24`\n  \n- For `n = 8` (even):\n  - `1 + (8 / 2) = 5`\n\n**Code Implementation:**\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n    assert (issame(tri(4) , {1, 3, 2, 8, 3}));\n    assert (issame(tri(5) , {1, 3, 2, 8, 3, 15}));\n    assert (issame(tri(6) , {1, 3, 2, 8, 3, 15, 4}));\n    assert (issame(tri(7) , {1, 3, 2, 8, 3, 15, 4, 24}));\n    assert (issame(tri(8) , {1, 3, 2, 8, 3, 15, 4, 24, 5}));\n    assert (issame(tri(9) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35}));\n    assert (issame(tri(20) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11}));\n    assert (issame(tri(0) , {1}));\n    assert (issame(tri(1) , {1, 3}));\n}\n", "result": "failed: compilation error: test.cpp:19:25: error: stray \u2018`\u2019 in program\n   19 | To compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n      |                         ^\ntest.cpp:19:32: error: stray \u2018`\u2019 in program\n   19 | To compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n      |                                ^\ntest.cpp:19:97: error: stray \u2018`\u2019 in program\n   19 | To compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n      |                                                                                                 ^\ntest.cpp:19:99: error: stray \u2018`\u2019 in program\n   19 | To compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n      |                                                                                                   ^\ntest.cpp:23:15: error: stray \u2018`\u2019 in program\n   23 | 1. **Check if `n` is even or odd.**\n      |               ^\ntest.cpp:23:17: error: stray \u2018`\u2019 in program\n   23 | 1. **Check if `n` is even or odd.**\n      |                 ^\ntest.cpp:24:9: error: stray \u2018`\u2019 in program\n   24 | 2. **If `n` is even:**\n      |         ^\ntest.cpp:24:11: error: stray \u2018`\u2019 in program\n   24 | 2. **If `n` is even:**\n      |           ^\ntest.cpp:25:14: error: stray \u2018`\u2019 in program\n   25 |    - Compute `tri(n) = 1 + (n / 2)`\n      |              ^\ntest.cpp:25:35: error: stray \u2018`\u2019 in program\n   25 |    - Compute `tri(n) = 1 + (n / 2)`\n      |                                   ^\ntest.cpp:26:9: error: stray \u2018`\u2019 in program\n   26 | 3. **If `n` is odd:**\n      |         ^\ntest.cpp:26:11: error: stray \u2018`\u2019 in program\n   26 | 3. **If `n` is odd:**\n      |           ^\ntest.cpp:27:14: error: stray \u2018`\u2019 in program\n   27 |    - Compute `tri(n) = ((n + 3) // 2)^2 - 1`\n      |              ^\ntest.cpp:31:7: error: stray \u2018`\u2019 in program\n   31 | - For `n = 7` (odd):\n      |       ^\ntest.cpp:31:13: error: stray \u2018`\u2019 in program\n   31 | - For `n = 7` (odd):\n      |             ^\ntest.cpp:32:5: error: stray \u2018`\u2019 in program\n   32 |   - `(7 + 3) // 2 = 5`\n      |     ^\ntest.cpp:33:5: error: stray \u2018`\u2019 in program\n   33 |   - `5^2 - 1 = 24`\n      |     ^\ntest.cpp:33:18: error: stray \u2018`\u2019 in program\n   33 |   - `5^2 - 1 = 24`\n      |                  ^\ntest.cpp:35:7: error: stray \u2018`\u2019 in program\n   35 | - For `n = 8` (even):\n      |       ^\ntest.cpp:35:13: error: stray \u2018`\u2019 in program\n   35 | - For `n = 8` (even):\n      |             ^\ntest.cpp:36:5: error: stray \u2018`\u2019 in program\n   36 |   - `1 + (8 / 2) = 5`\n      |     ^\ntest.cpp:36:21: error: stray \u2018`\u2019 in program\n   36 |   - `1 + (8 / 2) = 5`\n      |                     ^\ntest.cpp:19:1: error: \u2018To\u2019 does not name a type\n   19 | To compute the function `tri(n)` efficiently, we can use a closed-form formula based on whether `n` is even or odd.\n      | ^~\nIn file included from test.cpp:42:\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:52:20: error: \u2018tri\u2019 was not declared in this scope\n   52 |     assert (issame(tri(3) , {1, 3, 2, 8}));\n      |                    ^~~\ntest.cpp:52:13: error: \u2018issame\u2019 was not declared in this scope; did you mean \u2018isspace\u2019?\n   52 |     assert (issame(tri(3) , {1, 3, 2, 8}));\n      |             ^~~~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/131", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10; // Move to the next digit\n    }\n\n    return has_odd ? product : 0;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(5) == 5);\n    assert (digits(54) == 5);\n    assert (digits(120) ==1);\n    assert (digits(5014) == 5);\n    assert (digits(98765) == 315);\n    assert (digits(5576543) == 2625);\n    assert (digits(2468) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/133", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiled = ceil(num);\n        sum += ceiled * ceiled;\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1.0,2,3})==14);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n    assert (sum_squares({100,1,15,2})==10230);\n    assert (sum_squares({10000,10000})==200000000);\n    assert (sum_squares({-1.4,4.6,6.3})==75);\n    assert (sum_squares({-1.4,17.9,18.9,19.9})==1086);\n    assert (sum_squares({0})==0);\n    assert (sum_squares({-1})==1);\n    assert (sum_squares({-1,1,0})==2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/129", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    // Implement the solution here\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n", "result": "failed: a.out: test.cpp:35: int main(): Assertion `issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/134", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n    \n    char last = txt.back();\n    // Check if the last character is a letter\n    if (!(last >= 'a' && last <= 'z') && !(last >= 'A' && last <= 'Z')) {\n        return false;\n    }\n    \n    if (txt.size() == 1) {\n        return true;\n    } else {\n        char prev = txt[txt.size() - 2];\n        if (prev == ' ') {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"eeeee\") == false);\n    assert (check_if_last_char_is_a_letter(\"A\") == true);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie \") == false);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie 1\") == false);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"eeeee e \") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/132", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n// Include necessary headers\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Declare the function before its usage\nbool is_nested(const string& s) {\n    int depth = 0;\n    for (char c : s) {\n        if (c == '(') {\n            depth++;\n        } else if (c == ')') {\n            if (depth > 0) {\n                depth--;\n            } else {\n                return false;\n            }\n        }\n    }\n    return depth == 0;\n}\n\n// Define the main function\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested((\"[]\")) == false);\n    assert (is_nested(\"[[[[]]]]\") == true);\n    assert (is_nested(\"[]]]]]]]]]]\") == false);\n    assert (is_nested(\"[][][[]]\") == true);\n    assert (is_nested(\"[[]\") == false);\n    assert (is_nested(\"[]]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n    assert (is_nested(\"\") == false);\n    assert (is_nested(\"[[[[[[[[\") == false);\n    assert (is_nested(\"]]]]]]]]\") == false);\n}\n", "result": "failed: a.out: test.cpp:45: int main(): Assertion `is_nested(\"[]]]]]]][[[[[]\") == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/136", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(const vector<int>& nums) {\n    bool has_negative = false;\n    int max_neg = INT_MIN; \n\n    bool has_positive = false;\n    int min_pos = INT_MAX; \n\n    for (int num : nums) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n\n    int a = has_negative ? max_neg : 0;\n    int b = has_positive ? min_pos : 0;\n\n    return {a, b};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7, 0}) , {0, 1}));\n    assert (issame(largest_smallest_integers({1, 3, 2, 4, 5, 6, -2}) , {-2, 1}));\n    assert (issame(largest_smallest_integers({4, 5, 3, 6, 2, 7, -7}) , {-7, 2}));\n    assert (issame(largest_smallest_integers({7, 3, 8, 4, 9, 2, 5, -9}) , {-9, 2}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6, 0}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, 1}) , {-3, 1}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, -100, 1}) , {-3, 1}));\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/135", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = n - 1; i >= 1; --i) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,4,5})==-1);\n    assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);\n    assert (can_arrange({4,8,5,7,3})==4);\n    assert (can_arrange({})==-1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/137", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <boost/any.hpp>\n#include <string>\n#include <typeinfo>\n\nusing namespace std;\n\nboost::any parse(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string s = any_cast<string>(value);\n        // Replace commas with periods for decimal points\n        replace(s.begin(), s.end(), ',', '.');\n        try {\n            return stod(s);\n        } catch (...) {\n            // Handle invalid format, though per problem statement inputs are valid numbers\n            return boost::any();\n        }\n    } else if (value.type() == typeid(int)) {\n        return any_cast<int>(value);\n    } else if (value.type() == typeid(double)) {\n        return any_cast<double>(value);\n    }\n    // Add more type checks if necessary\n    return boost::any();\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Parse both values to their numerical representations\n    auto a_parsed = parse(a);\n    auto b_parsed = parse(b);\n\n    // Check if parsing failed (though per problem statement inputs are valid)\n    if (!a_parsed || !b_parsed) {\n        return \"None\";\n    }\n\n    double a_num, b_num;\n    try {\n        a_num = any_cast<double>(a_parsed);\n        b_num = any_cast<double>(b_parsed);\n    } catch (...) {\n        // In case of unexpected types (though unlikely given parse function)\n        return \"None\";\n    }\n\n    if (a_num == b_num) {\n        return string(\"None\");\n    } else if (a_num > b_num) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "result": "failed: compilation error: test.cpp: In function \u2018boost::any parse(const boost::any&)\u2019:\ntest.cpp:25:20: error: \u2018any_cast\u2019 was not declared in this scope; did you mean \u2018boost::any_cast\u2019?\n   25 |         string s = any_cast<string>(value);\n      |                    ^~~~~~~~\n      |                    boost::any_cast\nIn file included from test.cpp:17:\n/usr/include/boost/any.hpp:303:22: note: \u2018boost::any_cast\u2019 declared here\n  303 |     inline ValueType any_cast(any&& operand)\n      |                      ^~~~~~~~\ntest.cpp:25:35: error: expected primary-expression before \u2018>\u2019 token\n   25 |         string s = any_cast<string>(value);\n      |                                   ^\ntest.cpp:35:16: error: \u2018any_cast\u2019 was not declared in this scope; did you mean \u2018boost::any_cast\u2019?\n   35 |         return any_cast<int>(value);\n      |                ^~~~~~~~\n      |                boost::any_cast\nIn file included from test.cpp:17:\n/usr/include/boost/any.hpp:303:22: note: \u2018boost::any_cast\u2019 declared here\n  303 |     inline ValueType any_cast(any&& operand)\n      |                      ^~~~~~~~\ntest.cpp:35:25: error: expected primary-expression before \u2018int\u2019\n   35 |         return any_cast<int>(value);\n      |                         ^~~\ntest.cpp:35:25: error: expected \u2018;\u2019 before \u2018int\u2019\n   35 |         return any_cast<int>(value);\n      |                         ^~~\n      |                         ;\ntest.cpp:35:28: error: expected unqualified-id before \u2018>\u2019 token\n   35 |         return any_cast<int>(value);\n      |                            ^\ntest.cpp:37:16: error: \u2018any_cast\u2019 was not declared in this scope; did you mean \u2018boost::any_cast\u2019?\n   37 |         return any_cast<double>(value);\n      |                ^~~~~~~~\n      |                boost::any_cast\nIn file included from test.cpp:17:\n/usr/include/boost/any.hpp:303:22: note: \u2018boost::any_cast\u2019 declared here\n  303 |     inline ValueType any_cast(any&& operand)\n      |                      ^~~~~~~~\ntest.cpp:37:25: error: expected primary-expression before \u2018double\u2019\n   37 |         return any_cast<double>(value);\n      |                         ^~~~~~\ntest.cpp:37:25: error: expected \u2018;\u2019 before \u2018double\u2019\n   37 |         return any_cast<double>(value);\n      |                         ^~~~~~\n      |                         ;\ntest.cpp:37:31: error: expected unqualified-id before \u2018>\u2019 token\n   37 |         return any_cast<double>(value);\n      |                               ^\ntest.cpp: In function \u2018boost::any compare_one(boost::any, boost::any)\u2019:\ntest.cpp:49:9: error: no match for \u2018operator!\u2019 (operand type is \u2018boost::any\u2019)\n   49 |     if (!a_parsed || !b_parsed) {\n      |         ^~~~~~~~~\ntest.cpp:49:9: note: candidate: \u2018operator!(bool)\u2019 <built-in>\ntest.cpp:49:9: note:   no known conversion for argument 1 from \u2018boost::any\u2019 to \u2018bool\u2019\ntest.cpp:49:22: error: no match for \u2018operator!\u2019 (operand type is \u2018boost::any\u2019)\n   49 |     if (!a_parsed || !b_parsed) {\n      |                      ^~~~~~~~~\ntest.cpp:49:22: note: candidate: \u2018operator!(bool)\u2019 <built-in>\ntest.cpp:49:22: note:   no known conversion for argument 1 from \u2018boost::any\u2019 to \u2018bool\u2019\ntest.cpp:55:17: error: \u2018any_cast\u2019 was not declared in this scope; did you mean \u2018boost::any_cast\u2019?\n   55 |         a_num = any_cast<double>(a_parsed);\n      |                 ^~~~~~~~\n      |                 boost::any_cast\nIn file included from test.cpp:17:\n/usr/include/boost/any.hpp:303:22: note: \u2018boost::any_cast\u2019 declared here\n  303 |     inline ValueType any_cast(any&& operand)\n      |                      ^~~~~~~~\ntest.cpp:55:26: error: expected primary-expression before \u2018double\u2019\n   55 |         a_num = any_cast<double>(a_parsed);\n      |                          ^~~~~~\ntest.cpp:56:26: error: expected primary-expression before \u2018double\u2019\n   56 |         b_num = any_cast<double>(b_parsed);\n      |                          ^~~~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/138", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    return (n >= 8 && n % 2 == 0);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n    assert (is_equal_to_sum_even(10) == true);\n    assert (is_equal_to_sum_even(11) == false);\n    assert (is_equal_to_sum_even(12) == true);\n    assert (is_equal_to_sum_even(13) == false);\n    assert (is_equal_to_sum_even(16) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/139", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    long long current_fact = 1;\n    for (int i = 1; i <= n; ++i) {\n        current_fact *= i;\n        result *= current_fact;\n    }\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n    assert (special_factorial(5) == 34560);\n    assert (special_factorial(7) == 125411328000);\n    assert (special_factorial(1) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/142", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(const vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/140", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int current_count = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            current_count++;\n        } else {\n            if (current_count > 0) {\n                if (current_count <= 2) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                current_count = 0;\n            }\n            result += c;\n        }\n    }\n    \n    // Handle trailing spaces\n    if (current_count > 0) {\n        if (current_count <= 2) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n    \n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Mudasir Hanif \") == \"Mudasir_Hanif_\");\n    assert (fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\");\n    assert (fix_spaces(\"Exa   mple\") == \"Exa-mple\");\n    assert (fix_spaces(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\n", "result": "failed: a.out: test.cpp:59: int main(): Assertion `fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/143", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> selected_words;\n    stringstream ss(sentence);\n    string word;\n    \n    while (ss >> word) {\n        int len = word.length();\n        if (is_prime(len)) {\n            selected_words.push_back(word);\n        }\n    }\n    \n    if (selected_words.empty()) return \"\";\n    \n    string result;\n    for (size_t i = 0; i < selected_words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += selected_words[i];\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert (words_in_sentence(\"there is no place available here\") == \"there is no place\");\n    assert (words_in_sentence(\"Hi I am Hussein\") == \"Hi am Hussein\");\n    assert (words_in_sentence(\"go for it\") == \"go for it\");\n    assert (words_in_sentence(\"here\") == \"\");\n    assert (words_in_sentence(\"here is\") == \"is\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/141", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <string>  // Include necessary header for std::string\n\n// Function prototype declaration before main()\nstd::string file_name_check(const std::string& file_name) {\n    // Function implementation here\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n    assert (file_name_check(\"s1sdf3.asd\") == \"No\");\n    assert (file_name_check(\"K.dll\") == \"Yes\");\n    assert (file_name_check(\"MY16FILE3.exe\") == \"Yes\");\n    assert (file_name_check(\"His12FILE94.exe\") == \"No\");\n    assert (file_name_check(\"_Y.txt\") == \"No\");\n    assert (file_name_check(\"?aREYA.exe\") == \"No\");\n    assert (file_name_check(\"/this_is_valid.dll\") == \"No\");\n    assert (file_name_check(\"this_is_valid.wow\") == \"No\");\n    assert (file_name_check(\"this_is_valid.txt\") == \"Yes\");\n    assert (file_name_check(\"this_is_valid.txtexe\") == \"No\");\n    assert (file_name_check(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert (file_name_check(\"@this1_is6_valid.exe\") == \"No\");\n    assert (file_name_check(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert (file_name_check(\"all.exe.txt\") == \"No\");\n    assert (file_name_check(\"I563_No.exe\") == \"Yes\");\n    assert (file_name_check(\"Is3youfault.txt\") == \"Yes\");\n    assert (file_name_check(\"no_one#knows.dll\") == \"Yes\");\n    assert (file_name_check(\"1I563_Yes3.exe\") == \"No\");\n    assert (file_name_check(\"I563_Yes3.txtt\") == \"No\");\n    assert (file_name_check(\"final..txt\") == \"No\");\n    assert (file_name_check(\"final132\") == \"No\");\n    assert (file_name_check(\"_f4indsartal132.\") == \"No\");\n    assert (file_name_check(\".txt\") == \"No\");\n    assert (file_name_check(\"s.\") == \"No\");\n}\n", "result": "failed: ", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/144", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the input strings to extract numerators and denominators\n    size_t slashPos = x.find('/');\n    int numX = stoi(x.substr(0, slashPos));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    slashPos = n.find('/');\n    int numN = stoi(n.substr(0, slashPos));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Compute the product numerator and denominator\n    long productNum = static_cast<long>(numX) * numN;\n    long productDen = static_cast<long>(denX) * denN;\n\n    // Check if the product is an integer by verifying divisibility\n    return (productNum % productDen == 0);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"5/1\", \"3/1\") == true);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n    assert (simplify(\"2/10\", \"50/10\") == true);\n    assert (simplify(\"7/2\", \"4/2\") == true);\n    assert (simplify(\"11/6\", \"6/1\") == true);\n    assert (simplify(\"2/3\", \"5/2\") == false);\n    assert (simplify(\"5/2\", \"3/5\") == false);\n    assert (simplify(\"2/4\", \"8/4\") == true);\n    assert (simplify(\"2/4\", \"4/2\") == true);\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/5\", \"1/5\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/147", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nThe number of valid triples is calculated by considering two groups: one with elements that are 0 mod3 (c0) and another with elements that are not 0 mod3 (c1). The size of these groups determines the possible combinations.\n\n**Answer:**  \nThe total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_max_triples(5) == 1);\n    assert (get_max_triples(6) == 4);\n    assert (get_max_triples(10) == 36);\n    assert (get_max_triples(100) == 53361);\n}\n", "result": "failed: compilation error: test.cpp:22:38: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                      ^\ntest.cpp:22:45: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                             ^\ntest.cpp:22:63: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                               ^\ntest.cpp:22:87: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                       ^\ntest.cpp:22:96: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                ^\ntest.cpp:22:101: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                     ^\ntest.cpp:22:109: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                             ^\ntest.cpp:22:124: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                            ^\ntest.cpp:22:130: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                                  ^\ntest.cpp:22:138: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                                          ^\ntest.cpp:22:145: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                                                 ^\ntest.cpp:22:162: error: stray \u2018\\\u2019 in program\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                                                                  ^\ntest.cpp:19:1: error: \u2018The\u2019 does not name a type\n   19 | The number of valid triples is calculated by considering two groups: one with elements that are 0 mod3 (c0) and another with elements that are not 0 mod3 (c1). The size of these groups determines the possible combinations.\n      | ^~~\ntest.cpp:22:79: error: expected unqualified-id before \u2018,\u2019 token\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                               ^\ntest.cpp:22:88: error: expected constructor, destructor, or type conversion before \u2018(\u2019 token\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                        ^\ntest.cpp:22:120: error: expected unqualified-id before \u2018{\u2019 token\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                        ^\ntest.cpp:22:125: error: \u2018right\u2019 does not name a type\n   22 | The total number of valid triples is \\boxed{\\dbinom{c_0}{3} + \\dbinom{c_1}{3}}, where \\( c_0 = \\left\\lfloor \\dfrac{N+1}{3} \\right\\rfloor \\) and \\( c_1 = N - c_0 \\).\n      |                                                                                                                             ^~~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/145", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct Element {\n    int value;\n    size_t index;\n};\n\nint compute_digit_sum(int n) {\n    if (n == 0) return 0;\n    bool is_negative = false;\n    if (n < 0) {\n        is_negative = true;\n        n = abs(n);\n    }\n    vector<int> digits;\n    while (n > 0) {\n        digits.push_back(n % 10);\n        n /= 10;\n    }\n    reverse(digits.begin(), digits.end());\n    if (is_negative && !digits.empty()) {\n        digits[0] *= -1;\n    }\n    return accumulate(digits.begin(), digits.end(), 0);\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<Element> elements;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        elements.push_back({nums[i], i});\n    }\n\n    sort(elements.begin(), elements.end(), [](const Element& a, const Element& b) {\n        int sum_a = compute_digit_sum(a.value);\n        int sum_b = compute_digit_sum(b.value);\n        if (sum_a == sum_b) {\n            return a.index < b.index;\n        }\n        return sum_a < sum_b;\n    });\n\n    vector<int> result;\n    for (const auto& elem : elements) {\n        result.push_back(elem.value);\n    }\n\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (issame(order_by_points({}) , {}));\n    assert (issame(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (issame(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (issame(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/150", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n    assert (x_or_y(3, 33, 5212) == 33);\n    assert (x_or_y(1259, 3, 52) == 3);\n    assert (x_or_y(7919, -1, 12) == -1);\n    assert (x_or_y(3609, 1245, 583) == 583);\n    assert (x_or_y(91, 56, 129) == 129);\n    assert (x_or_y(6, 34, 1234) == 1234);\n    assert (x_or_y(1, 2, 0) == 0);\n    assert (x_or_y(2, 2, 0) == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/148", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun\n    const vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planet1 and planet2 are valid planet names\n    size_t index1 = -1, index2 = -1;\n    for (size_t i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) {\n        return {};\n    }\n    \n    // Ensure that index1 is less than index2 to determine the correct range\n    size_t start = min(index1, index2);\n    size_t end = max(index1, index2);\n    \n    vector<string> result;\n    for (size_t i = start + 1; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    assert (issame(bf(\"Neptune\", \"Venus\") , {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Earth\") , {}));\n    assert (issame(bf(\"Mars\", \"Earth\") , {}));\n    assert (issame(bf(\"Jupiter\", \"Makemake\") , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/146", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        int n = abs(num);\n        if (n <= 10) continue; // Skip numbers that are too small to have two digits\n        \n        int last_digit = n % 10;\n        if (last_digit % 2 != 1) continue; // Last digit must be odd\n        \n        int temp = n;\n        while (temp >= 10) {\n            temp /= 10;\n        }\n        int first_digit = temp;\n        \n        if (first_digit % 2 == 1) { // First digit must be odd\n            count++;\n        }\n    }\n    return count;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({5, -2, 1, -5}) == 0  );\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    assert (specialFilter({43, -12, 93, 125, 121, 109}) == 4);\n    assert (specialFilter({71, -2, -33, 75, 21, 19}) == 3);\n    assert (specialFilter({1}) == 0              );\n    assert (specialFilter({}) == 0                   );\n}\n", "result": "failed: a.out: test.cpp:47: int main(): Assertion `specialFilter({15, -73, 14, -15}) == 1' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/149", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered.push_back(s);\n        }\n    }\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.size() != b.size()) {\n            return a.size() < b.size();\n        } else {\n            return a < b;\n        }\n    });\n    return filtered;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (issame(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (issame(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (issame(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/151", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long total = 0;\n    for (float num : lst) {\n        if (num < 0) continue;          // Ignore negative numbers\n        if (num != static_cast<int>(num)) continue; // Skip non-integers\n        int integer_num = static_cast<int>(num);\n        if (integer_num % 2 != 0) {     // Check if the number is odd\n            total += integer_num * integer_num; // Add square to total\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({}) == 0);\n    assert (double_the_difference({5, 4}) == 25);\n    assert (double_the_difference({0.1, 0.2, 0.3}) == 0 );\n    assert (double_the_difference({-10, -20, -30}) == 0 );\n    assert (double_the_difference({-1, -2, 8}) == 0);\n    assert (double_the_difference({0.2, 3, 5}) == 34);\n    \n    \n    long long odd_sum=0;\n    vector<float> lst={};\n\n    for (int i=-99;i<100;i+=2)\n    {\n        lst.push_back(i+0.0);\n        if (i>0 and i%2==1) odd_sum+=i*i;\n    }\n  \n    assert (double_the_difference(lst) == odd_sum );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/152", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,0,0,0,0,0},{0,0,0,0,0,0}),{0,0,0,0,0,0}));\n    assert (issame(compare({1,2,3},{-1,-2,-3}),{2,4,6}));\n    assert (issame(compare({1,2,3,5},{-1,2,3,4}),{2,0,0,1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/154", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Handle edge cases\n    if (len_b == 0) return true;\n    if (len_a < len_b) return false;\n\n    // Create the concatenated string to generate all rotations of b\n    string temp = b + b;\n\n    for (int i = 0; i < len_b; ++i) {\n        // Extract substring of length len_b starting at index i\n        string rotated = temp.substr(i, len_b);\n\n        // Check if this rotation exists in a\n        if (a.find(rotated) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"xyzw\",\"xyw\") == false );\n    assert  (cycpattern_check(\"yello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whattup\",\"ptut\") == false );\n    assert  (cycpattern_check(\"efef\",\"fee\") == true );\n    assert  (cycpattern_check(\"abab\",\"aabb\") == false );\n    assert  (cycpattern_check(\"winemtt\",\"tinem\") == true );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/153", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <climits>\n#include <cctype>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n    \n    int max_strength = INT_MIN;\n    int best_extension_index = 0;\n    \n    for (int i = 0; i < extensions.size(); ++i) {\n        string ext = extensions[i];\n        int cap_count = 0, sm_count = 0;\n        \n        for (char c : ext) {\n            if (isupper(static_cast<unsigned char>(c))) {\n                cap_count++;\n            } else if (islower(static_cast<unsigned char>(c))) {\n                sm_count++;\n            }\n        }\n        \n        int strength = cap_count - sm_count;\n        \n        if (strength > max_strength) {\n            max_strength = strength;\n            best_extension_index = i;\n        }\n    }\n    \n    return class_name + \".\" + extensions[best_extension_index];\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"Watashi\", {\"tEN\", \"niNE\", \"eIGHt8OKe\"}) == \"Watashi.eIGHt8OKe\");\n    assert (Strongest_Extension(\"Boku123\", {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}) == \"Boku123.YEs.WeCaNe\");\n    assert (Strongest_Extension(\"__YESIMHERE\", {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}) == \"__YESIMHERE.NuLl__\");\n    assert (Strongest_Extension(\"K\", {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}) == \"K.TAR\");\n    assert (Strongest_Extension(\"__HAHA\", {\"Tab\", \"123\", \"781345\", \"-_-\"}) == \"__HAHA.123\");\n    assert (Strongest_Extension(\"YameRore\", {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}) == \"YameRore.okIWILL123\");\n    assert (Strongest_Extension(\"finNNalLLly\", {\"Die\", \"NowW\", \"Wow\", \"WoW\"}) == \"finNNalLLly.WoW\");\n    assert (Strongest_Extension(\"_\", {\"Bb\", \"91245\"}) == \"_.Bb\");\n    assert (Strongest_Extension(\"Sp\", {\"671235\", \"Bb\"}) == \"Sp.671235\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/155", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    if (num == 0) {\n        return {1, 0};\n    }\n    num = abs(num);\n    int even_count = 0;\n    int odd_count = 0;\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n    return {even_count, odd_count};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(7) , {0, 1}));\n    assert (issame(even_odd_count(-78) , {1, 1}));\n    assert (issame(even_odd_count(3452) , {2, 2}));\n    assert (issame(even_odd_count(346211) , {3, 3}));\n    assert (issame(even_odd_count(-345821) , {3, 3}));\n    assert (issame(even_odd_count(-2) , {1, 0}));\n    assert (issame(even_odd_count(-45347) , {2, 3}));\n    assert (issame(even_odd_count(0) , {1, 0}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/156", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"},\n        {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"},\n        {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\n        {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result;\n\n    for (const auto& value_pair : roman_numerals) {\n        while (number >= value_pair.first) {\n            result += value_pair.second;\n            number -= value_pair.first;\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_roman(19) == \"xix\");\n    assert (int_to_mini_roman(152) == \"clii\");\n    assert (int_to_mini_roman(251) == \"ccli\");\n    assert (int_to_mini_roman(426) == \"cdxxvi\");\n    assert (int_to_mini_roman(500) == \"d\");\n    assert (int_to_mini_roman(1) == \"i\");\n    assert (int_to_mini_roman(4) == \"iv\");\n    assert (int_to_mini_roman(43) == \"xliii\");\n    assert (int_to_mini_roman(90) == \"xc\");\n    assert (int_to_mini_roman(94) == \"xciv\");\n    assert (int_to_mini_roman(532) == \"dxxxii\");\n    assert (int_to_mini_roman(900) == \"cm\");\n    assert (int_to_mini_roman(994) == \"cmxciv\");\n    assert (int_to_mini_roman(1000) == \"m\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/157", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Check if any side is non-positive\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n    \n    // Create an array to hold the sides and sort them\n    float sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Assign sorted values to side1, side2, side3\n    float side1 = sides[0];\n    float side2 = sides[1];\n    float side3 = sides[2];\n    \n    // Check if the sum of squares of side1 and side2 equals square of side3\n    return (side1 * side1 + side2 * side2) == side3 * side3;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n    assert (right_angle_triangle(10, 6, 8) == true);\n    assert (right_angle_triangle(2, 2, 2) == false);\n    assert (right_angle_triangle(7, 24, 25) == true);\n    assert (right_angle_triangle(10, 5, 7) == false);\n    assert (right_angle_triangle(5, 12, 13) == true);\n    assert (right_angle_triangle(15, 8, 17) == true);\n    assert (right_angle_triangle(48, 55, 73) == true);\n    assert (right_angle_triangle(1, 1, 1) == false);\n    assert (right_angle_triangle(2, 2, 10) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/158", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_count = -1;\n    string result_word;\n\n    for (const string& word : words) {\n        bool seen[256] = {false};\n        int count = 0;\n\n        for (char c : word) {\n            if (!seen[c]) {\n                seen[c] = true;\n                count++;\n            }\n        }\n\n        if (count > max_count || (count == max_count && word < result_word)) {\n            max_count = count;\n            result_word = word;\n        }\n    }\n\n    return result_word;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n    assert ((find_max({\"abc\", \"cba\"}) == \"abc\"));\n    assert ((find_max({\"play\", \"this\", \"game\", \"of\",\"footbott\"}) == \"footbott\"));\n    assert ((find_max({\"we\", \"are\", \"gonna\", \"rock\"}) == \"gonna\"));\n    assert ((find_max({\"we\", \"are\", \"a\", \"mad\", \"nation\"}) == \"nation\"));\n    assert ((find_max({\"this\", \"is\", \"a\", \"prrk\"}) == \"this\"));\n    assert ((find_max({\"b\"}) == \"b\"));\n    assert ((find_max({\"play\", \"play\", \"play\"}) == \"play\"));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/160", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nThe final answer is \\boxed{0.000009155273}.\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n", "result": "failed: compilation error: test.cpp:19:21: error: stray \u2018\\\u2019 in program\n   19 | The final answer is \\boxed{0.000009155273}.\n      |                     ^\ntest.cpp:19:1: error: \u2018The\u2019 does not name a type\n   19 | The final answer is \\boxed{0.000009155273}.\n      | ^~~\ntest.cpp:19:43: error: expected unqualified-id before \u2018.\u2019 token\n   19 | The final answer is \\boxed{0.000009155273}.\n      |                                           ^\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/159", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <algorithm> // For std::min\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    int amount = std::min(need, remaining);\n    int total_eaten = number + amount;\n    int rem_after = remaining - amount;\n    return {total_eaten, rem_after};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n    \n    assert (issame(eat(4, 5, 7) , {9, 2}));\n    assert (issame(eat(4, 5, 1) , {5, 0}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/161", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    string result;\n    for (char c : s) {\n        if (isalpha(static_cast<unsigned char>(c))) { \n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n            hasLetters = true;\n        } else {\n            result += c;\n        }\n    }\n    if (!hasLetters) {\n        reverse(result.begin(), result.end());\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"AsDf\") == \"aSdF\");\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n    assert (solve(\"#AsdfW^45\") == \"#aSDFw^45\");\n    assert (solve(\"#6@2\") == \"2@6#\");\n    assert (solve(\"#$a^D\") == \"#$A^d\");\n    assert (solve(\"#ccc\") == \"#CCC\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/162", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    const static char hex_chars[] = \"0123456789abcdef\";\n    string md5_str;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        md5_str += hex_chars[(digest[i] >> 4) & 0xF];\n        md5_str += hex_chars[digest[i] & 0xF];\n    }\n\n    return md5_str;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert (string_to_md5(\"\") == \"None\");\n    assert (string_to_md5(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert (string_to_md5(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n", "result": "failed: a.out: test.cpp:44: int main(): Assertion `string_to_md5(\"\") == \"None\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/163", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int i = start; i <= end; ++i) {\n        string s = to_string(i);\n        bool valid = true;\n        for (char c : s) {\n            if (c != '0' && c != '2' && c != '4' && c != '6' && c != '8') {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(17,89) , {}));\n}\n", "result": "failed: a.out: test.cpp:57: int main(): Assertion `issame(generate_integers(132, 2) , {2, 4, 6, 8})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
