{"task_id": "CPP/5", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    \n    result.push_back(numbers.back());\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/10", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string reversed(str.rbegin(), str.rend());\n    return str == reversed;\n}\n\nstring make_palindrome(string str) {\n    int n = str.size();\n    for (int l = n; l >= 1; --l) {\n        if (is_palindrome(str.substr(n - l, l))) {\n            string prefix = str.substr(0, n - l);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    return str;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"x\") == \"x\");\n     assert (make_palindrome(\"xyz\") == \"xyzyx\");\n     assert (make_palindrome(\"xyx\") == \"xyx\") ;\n     assert (make_palindrome(\"jerry\") == \"jerryrrej\");\n}\n\n\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/2", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    return number - integer_part;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/4", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f;\n    }\n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n    float total_abs_diff = 0.0f;\n    for (float num : numbers) {\n        total_abs_diff += fabs(num - mean);\n    }\n    float mad = total_abs_diff / numbers.size();\n    return mad;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/3", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int current_balance = 0;\n    for (int op : operations) {\n        current_balance += op;\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/6", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    istringstream iss(paren_string);\n    string group;\n    \n    while (iss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/13", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cstdlib> // For abs()\n\nint greatest_common_divisor(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    \n    while (b != 0) {\n        int r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 7) == 1);\n     assert (greatest_common_divisor(10, 15) == 5);\n      assert (greatest_common_divisor(49, 14) == 7);\n     assert (greatest_common_divisor(144, 60) == 12);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/0", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For fabs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    \n    sort(numbers.begin(), numbers.end());\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i+1] - numbers[i]) < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/12", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    size_t max_length = 0;\n    string result = \"\";\n    \n    for (const string& s : strings) {\n        size_t current_length = s.length();\n        if (current_length > max_length) {\n            max_length = current_length;\n            result = s;\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"x\", \"y\", \"z\"}) == \"x\");\n    assert (longest({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/11", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>  // Include for std::max\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = max(len_a, len_b);\n    \n    // Helper function to pad the string with leading zeros\n    auto padString = [](const string &s, int target_length) {\n        if (s.length() >= target_length) return s;\n        string padding(target_length - s.length(), '0');\n        return padding + s;\n    };\n    \n    string padded_a = padString(a, max_len);\n    string padded_b = padString(b, max_len);\n    \n    string result;\n    for (int i = 0; i < max_len; ++i) {\n        if (padded_a[i] != padded_b[i]) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n    }\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"111000\", \"101010\") == \"010010\");\n     assert (string_xor(\"1\", \"1\") == \"0\");\n    assert (string_xor(\"0101\", \"0000\") == \"0101\");\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/9", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/14", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.size(); ++i) {\n        string prefix = str.substr(0, i);\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"\"),{}));\n    assert (issame(all_prefixes(\"asdfgh\") ,{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}));\n     assert (issame(all_prefixes(\"WWW\") ,{\"W\", \"WW\", \"WWW\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/7", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const string& s : strings) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/1", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // This function separates groups of nested parentheses into a vector of strings.\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}", "result": "failed: a.out: test.cpp:38: int main(): Assertion `issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/8", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/18", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int len_str = str.length();\n    int len_sub = substring.length();\n\n    // Handle edge cases where substring is empty or longer than the string\n    if (len_sub == 0 || len_sub > len_str) {\n        return 0;\n    }\n\n    int count = 0;\n\n    for (int i = 0; i <= len_str - len_sub; ++i) {\n        bool match = true;\n        for (int j = 0; j < len_sub; ++j) {\n            if (str[i + j] != substring[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"x\") == 0);\n    assert (how_many_times(\"xyxyxyx\", \"x\") == 4);\n     assert (how_many_times(\"cacacacac\", \"cac\") == 4);\n    assert (how_many_times(\"john doe\", \"john\") == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/15", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    bool first = true;\n\n    for (int i = 0; i <= n; ++i) {\n        if (!first) {\n            result += \" \";\n        }\n        result += to_string(i);\n        first = false;\n    }\n\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(3) == \"0 1 2 3\");\n     assert (string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/17", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string token;\n    \n    while (ss >> token) {\n        if (token == \"o\") {\n            beats.push_back(4);\n        } else if (token == \"o|\") {\n            beats.push_back(2);\n        } else if (token == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"\") , {}));\n     assert (issame(parse_music(\"o o o o\") ,{4, 4, 4, 4}));\n      assert (issame(parse_music(\".| .| .| .|\") , {1, 1, 1, 1}));\n assert (issame(parse_music(\"o| o| .| .| o o o o\") , {2, 2, 1, 1, 4, 4, 4, 4}));\n  assert (issame(parse_music(\"o| .| o| .| o o| o o|\") , {2, 1, 2, 1, 4, 2, 4, 2}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/27", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cctype> // Include for tolower and toupper functions\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Iterate over each character reference\n        if (islower(c)) { // If character is lowercase\n            c = toupper(c); // Convert to uppercase\n        } else if (isupper(c)) { // If character is uppercase\n            c = tolower(c); // Convert to lowercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (flip_case(\"\") == \"\");\n    assert (flip_case(\"Hello!\") == \"hELLO!\");\n    assert (flip_case(\"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/23", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"x\") == 1);\n     assert (strlen(\"asdasnakj\") == 9);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/25", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    if (n < 2) {\n        return factors; // Return empty for n less than 2\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(2) , {2}));\n    assert (issame(factorize(4) , {2, 2}));\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(3 * 19) , {3, 19}));\n    assert (issame(factorize(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    assert (issame(factorize(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    assert (issame(factorize(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    assert (issame(factorize(3 * 2 * 3) , {2, 3, 3}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/16", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <unordered_set>\n#include <cctype>\n\nint count_distinct_characters(std::string str) {\n    std::unordered_set<char> uniqueChars;\n    for (char c : str) {\n        char lowerC = std::tolower(c);\n        uniqueChars.insert(lowerC);\n    }\n    return uniqueChars.size();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"\") == 0);\n    assert (count_distinct_characters(\"abcde\") == 5);\n    assert (count_distinct_characters(\"abcdecadeCADE\") == 5);\n    assert (count_distinct_characters(\"aaaaAAAAaaaa\") == 1);\n    assert (count_distinct_characters(\"Jerry jERRY JeRRRY\") == 5);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/24", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n    // Iterate from n-1 down to 1 to find the largest proper divisor\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // This line is theoretically unreachable for n >= 2\n    return 1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/21", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    float range = max_val - min_val;\n\n    vector<float> result;\n    if (range == 0) {\n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result.push_back(0.5f);\n        }\n    } else {\n        for (size_t i = 0; i < numbers.size(); ++i) {\n            float scaled = (numbers[i] - min_val) / range;\n            result.push_back(scaled);\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({2.0, 49.9}) , {0.0, 1.0}));\n     assert (issame(rescale_to_unit({100.0, 49.9}) ,{1.0, 0.0})); \n     assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n    assert (issame(rescale_to_unit({2.0, 1.0, 5.0, 3.0, 4.0}) , {0.25, 0.0, 1.0, 0.5, 0.75}));\n     assert (issame(rescale_to_unit({12.0, 11.0, 15.0, 13.0, 14.0}) ,{0.25, 0.0, 1.0, 0.5, 0.75}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/20", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {}; // Handle cases where input has less than two elements, though problem states at least two.\n    }\n    \n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = numeric_limits<float>::infinity();\n    vector<float> closest_pair;\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i+1] - numbers[i]);\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_pair = {numbers[i], numbers[i+1]};\n        }\n    }\n    \n    return closest_pair;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    assert (issame(find_closest_elements({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n      assert (issame(find_closest_elements({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/19", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping each word to its corresponding number\n    map<string, int> word_to_num = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into individual words\n    vector<string> words;\n    string current_word = \"\";\n    for (char c : numbers) {\n        if (c == ' ') {\n            words.push_back(current_word);\n            current_word = \"\";\n        } else {\n            current_word += c;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort the words based on their numerical values\n    sort(words.begin(), words.end(), [&word_to_num](const string& a, const string& b) {\n        return word_to_num[a] < word_to_num[b];\n    });\n\n    // Join the sorted words into a single string\n    string result = \"\";\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/28", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& s : strings) {\n        result += s;\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n     assert (concatenate({\"x\", \"y\", \"z\"}) == \"xyz\");\n    assert (concatenate({\"x\", \"y\", \"z\", \"w\", \"k\"}) == \"xyzwk\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/26", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> freq;\n    \n    // Count the frequency of each number\n    for (int num : numbers) {\n        freq[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Build the result list with elements that occur exactly once\n    for (int num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(remove_duplicates({}) , {}));\n     assert (issame(remove_duplicates({1, 2, 3, 4}) , {1, 2, 3, 4}));\n      assert (issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}) , {1, 4, 5}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/22", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <boost/any.hpp>\n#include <list>\n#include <iostream>\n\nusing namespace std;\nusing namespace boost;\n\ntypedef list<any> list_any;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> count;\n    int counter = 0;\n    for (auto& elem : values) {\n        if (typeid(elem).name() == typeid(int).name()) {\n            ++counter;\n        }\n    }\n    count.push_back(counter);\n    return count;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({}),{}));\n\n    assert (issame(filter_integers({4,  {},23.2, 9, string(\"adasd\")}) ,{4, 9}));\n    assert (issame(filter_integers({3, 'c', 3, 3, 'a', 'b'}) ,{3, 3, 3}));\n}", "result": "failed: a.out: test.cpp:50: int main(): Assertion `issame(filter_integers({}),{})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/29", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& s : strings) {\n        if (s.length() >= prefix.length()) {\n            if (s.substr(0, prefix.length()) == prefix) {\n                result.push_back(s);\n            }\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"john\") , {}));\n    assert (issame(filter_by_prefix({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\") , {\"xxx\", \"xxxAAA\", \"xxx\"}));\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/32", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nTo determine the interval [a, b] where the root lies using the False Position method, we perform searches in both positive and negative directions from an initial guess x0. The process involves expanding the search range by doubling the delta until a sign change is detected, indicating the presence of a root within that interval.\n\n**Step-by-Step Explanation:**\n\n1. **Initialization:**\n   - Start with an initial guess `x0`.\n   - Set the initial delta to 1.0 for both positive and negative searches.\n\n2. **Positive Search:**\n   - Calculate `x` as `x0 + delta`.\n   - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n   - If no sign change is found, update `previous_x` to the current `x`, double the delta, and repeat.\n\n3. **Negative Search:**\n   - If the positive search fails to find a root, reset delta to 1.0.\n   - Calculate `x` as `x0 - delta`.\n   - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n   - Continue expanding the search by doubling delta if no sign change is detected.\n\n4. **Termination:**\n   - The process stops once a valid interval [a, b] containing the root is identified.\n\n**Answer:**\n\nThe interval where the root lies is determined through iterative expansion in both positive and negative directions from an initial guess until a sign change indicates the presence of the root within that interval. Thus, the final interval found using this method is:\n\n\\boxed{[a, b]}\n#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (abs(poly(coeffs, solution))< 1e-3);\n    }\n}\n", "result": "failed: compilation error: test.cpp:24:34: error: stray \u2018`\u2019 in program\n   24 |    - Start with an initial guess `x0`.\n      |                                  ^\ntest.cpp:24:37: error: stray \u2018`\u2019 in program\n   24 |    - Start with an initial guess `x0`.\n      |                                     ^\ntest.cpp:28:16: error: stray \u2018`\u2019 in program\n   28 |    - Calculate `x` as `x0 + delta`.\n      |                ^\ntest.cpp:28:18: error: stray \u2018`\u2019 in program\n   28 |    - Calculate `x` as `x0 + delta`.\n      |                  ^\ntest.cpp:28:23: error: stray \u2018`\u2019 in program\n   28 |    - Calculate `x` as `x0 + delta`.\n      |                       ^\ntest.cpp:28:34: error: stray \u2018`\u2019 in program\n   28 |    - Calculate `x` as `x0 + delta`.\n      |                                  ^\ntest.cpp:29:38: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                      ^\ntest.cpp:29:41: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                         ^\ntest.cpp:29:47: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                               ^\ntest.cpp:29:49: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                 ^\ntest.cpp:29:72: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                        ^\ntest.cpp:29:89: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                         ^\ntest.cpp:29:124: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                            ^\ntest.cpp:29:127: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                               ^\ntest.cpp:29:133: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                                     ^\ntest.cpp:29:135: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                                       ^\ntest.cpp:29:145: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                                                 ^\ntest.cpp:29:152: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                                                        ^\ntest.cpp:29:158: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                                                              ^\ntest.cpp:29:164: error: stray \u2018`\u2019 in program\n   29 |    - Check if the function values at `x0` and `x` have opposite signs (`f(x0) * f(x) < 0`). If true, a root exists between `x0` and `x`, so set `a = x0` and `b = x`.\n      |                                                                                                                                                                    ^\ntest.cpp:30:41: error: stray \u2018`\u2019 in program\n   30 |    - If no sign change is found, update `previous_x` to the current `x`, double the delta, and repeat.\n      |                                         ^\ntest.cpp:30:52: error: stray \u2018`\u2019 in program\n   30 |    - If no sign change is found, update `previous_x` to the current `x`, double the delta, and repeat.\n      |                                                    ^\ntest.cpp:30:69: error: stray \u2018`\u2019 in program\n   30 |    - If no sign change is found, update `previous_x` to the current `x`, double the delta, and repeat.\n      |                                                                     ^\ntest.cpp:30:71: error: stray \u2018`\u2019 in program\n   30 |    - If no sign change is found, update `previous_x` to the current `x`, double the delta, and repeat.\n      |                                                                       ^\ntest.cpp:33:66: error: too many decimal points in number\n   33 |    - If the positive search fails to find a root, reset delta to 1.0.\n      |                                                                  ^~~~\ntest.cpp:34:16: error: stray \u2018`\u2019 in program\n   34 |    - Calculate `x` as `x0 - delta`.\n      |                ^\ntest.cpp:34:18: error: stray \u2018`\u2019 in program\n   34 |    - Calculate `x` as `x0 - delta`.\n      |                  ^\ntest.cpp:34:23: error: stray \u2018`\u2019 in program\n   34 |    - Calculate `x` as `x0 - delta`.\n      |                       ^\ntest.cpp:34:34: error: stray \u2018`\u2019 in program\n   34 |    - Calculate `x` as `x0 - delta`.\n      |                                  ^\ntest.cpp:35:36: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                    ^\ntest.cpp:35:38: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                      ^\ntest.cpp:35:44: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                            ^\ntest.cpp:35:47: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                               ^\ntest.cpp:35:64: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                                                ^\ntest.cpp:35:70: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                                                      ^\ntest.cpp:35:76: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                                                            ^\ntest.cpp:35:83: error: stray \u2018`\u2019 in program\n   35 |    - Check for sign change between `x` and `x0`. If found, set `a = x` and `b = x0`.\n      |                                                                                   ^\ntest.cpp:45:1: error: stray \u2018\\\u2019 in program\n   45 | \\boxed{[a, b]}\n      | ^\ntest.cpp:19:1: error: \u2018To\u2019 does not name a type\n   19 | To determine the interval [a, b] where the root lies using the False Position method, we perform searches in both positive and negative directions from an initial guess x0. The process involves expanding the search range by doubling the delta until a sign change is detected, indicating the presence of a root within that interval.\n      | ^~\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:63:20: error: \u2018find_zero\u2019 was not declared in this scope\n   63 |         solution = find_zero(coeffs);\n      |                    ^~~~~~~~~\nIn file included from test.cpp:47:\ntest.cpp:64:21: error: \u2018poly\u2019 was not declared in this scope\n   64 |         assert (abs(poly(coeffs, solution))< 1e-3);\n      |                     ^~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/30", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float x : l) {\n        if (x > 0) {\n            result.push_back(x);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, -2, 4, 5, 6}) , {4, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}) , {5, 3, 2, 3, 3, 9, 123, 1}));\n     assert (issame(get_positive({-1, -2}) , {} ));\n     assert (issame(get_positive({}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/31", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    long long max_divisor = sqrt(n);\n    for (long long i = 3; i <= max_divisor; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n    assert (is_prime(5) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(17) == true);\n    assert (is_prime(5 * 17) == false);\n    assert (is_prime(11 * 7) == false);\n    assert (is_prime(13441 * 19) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/36", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string s = to_string(i);\n            for (char c : s) {\n                if (c == '7') {\n                    total++;\n                }\n            }\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n    assert (fizz_buzz(100) == 3);\n    assert (fizz_buzz(200) == 6);\n    assert (fizz_buzz(4000) == 192);\n    assert (fizz_buzz(10000) == 639);\n    assert (fizz_buzz(100000) == 8026);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/33", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> extracted;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            extracted.push_back(l[i]);\n        }\n    }\n\n    sort(extracted.begin(), extracted.end());\n\n    vector<int> result;\n    size_t j = 0;\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0 && j < extracted.size()) {\n            result.push_back(extracted[j]);\n            j++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (issame(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (issame(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/38", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring decode_cyclic(string s) {\n    string output;\n    for (int i = 0; i < s.size(); i += 3) {\n        string chunk = s.substr(i, 3);\n        if (chunk.length() == 3) {\n            char last_char = chunk[2];\n            chunk = last_char + chunk.substr(0, 2);\n        }\n        output += chunk;\n    }\n    return output;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n", "result": "failed: compilation error: test.cpp: In function \u2018int main()\u2019:\ntest.cpp:48:30: error: \u2018encode_cyclic\u2019 was not declared in this scope; did you mean \u2018decode_cyclic\u2019?\n   48 |         string encoded_str = encode_cyclic(str);\n      |                              ^~~~~~~~~~~~~\n      |                              decode_cyclic\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/35", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // for std::max_element\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    auto it = max_element(l.begin(), l.end());\n    return *it;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/37", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> evens;\n    vector<float> odds;\n\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) { // even index\n            evens.push_back(l[i]);\n        } else {\n            odds.push_back(l[i]);\n        }\n    }\n\n    sort(evens.begin(), evens.end());\n\n    vector<float> result;\n    int e = 0, o = 0;\n\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) { \n            result.push_back(evens[e]);\n            e++;\n        } else {\n            result.push_back(odds[o]);\n            o++;\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/40", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    /* Check if there are at least three elements */\n    if (l.size() < 3) {\n        return false;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        for (int j = i + 1; j < l.size(); ++j) {\n            for (int k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count > 0;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -1}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({1, 2, 5, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert (triples_sum_to_zero({1}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -100}) == false);\n    assert (triples_sum_to_zero({100, 3, 5, -100}) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/41", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\n// Declare the function\nint car_race_collision(int n);\n\nint car_race_collision(int n) {\n    // Implementation of the function\n    return n * n;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (car_race_collision(2) == 4);\n    assert (car_race_collision(3) == 9);\n    assert (car_race_collision(4) == 16);\n    assert (car_race_collision(8) == 64);\n    assert (car_race_collision(10) == 100);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/42", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int x : l) {\n        result.push_back(x + 1);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/39", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\nusing namespace std;\n\nint prime_fib(int n) {\n    /* To solve this problem, we need to find the n-th prime number in the sequence of Fibonacci numbers.\n       The Fibonacci sequence is a series where each number is the sum of the two preceding ones, starting from 0 and 1. \n       A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. */\n\n    /* ### Approach */\n    /* The approach involves generating Fibonacci numbers sequentially and checking each one for primality until we find the n-th prime number. Here are the steps: */\n\n    /* 1. Generate Fibonacci Numbers: Start with the initial values of the Fibonacci sequence (0, 1) and generate subsequent numbers by summing the two preceding ones. */\n    /* 2. Check Primality: For each generated Fibonacci number, check if it is a prime number using a helper function. */\n    /* 3. Count Primes: Maintain a count of how many prime Fibonacci numbers have been found. Stop when this count reaches n and return the current Fibonacci number. */\n\n    /* ### Solution Code */\n    // Implement the logic here to find the n-th prime Fibonacci number\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n    assert (prime_fib(6) == 233);\n    assert (prime_fib(7) == 1597);\n    assert (prime_fib(8) == 28657);\n    assert (prime_fib(9) == 514229);\n    assert (prime_fib(10) == 433494437);\n}\n", "result": "failed: a.out: test.cpp:40: int main(): Assertion `prime_fib(1) == 2' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/43", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert (pairs_sum_to_zero({1}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 30}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 31}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 30}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 31}) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/44", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    string result;\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder;\n        result.push_back(digit);\n        x /= base;\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(9, 3) == \"100\");\n    assert (change_base(234, 2) == \"11101010\");\n    assert (change_base(16, 2) == \"10000\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n    for (int x=2;x<8;x++)\n        assert (change_base(x, x + 1) == to_string(x));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/45", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2.0f;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n    assert (abs(triangle_area(2, 2) - 2.0)<1e-4);\n    assert (abs(triangle_area(10, 8) - 40.0)<1e-4);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/47", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float a = l[(n / 2) - 1];\n        float b = l[n / 2];\n        return (a + b) / 2.0f;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n    assert (abs(median({5}) - 5)<1e-4);\n    assert (abs(median({6, 5}) - 5.5)<1e-4);\n    assert (abs(median({8, 1, 3, 9, 9, 2, 7}) - 7)<1e-4 );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/34", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s(l.begin(), l.end());\n    return vector<int>(s.begin(), s.end());\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/49", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1)\n        return 0;\n    if (n == 0)\n        return 1;\n\n    long long result = 1;\n    long long base = 2; // Using long long to prevent overflow during squaring\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If the current bit is 1\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base for next iteration\n        n /= 2; // Move to the next bit\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n    assert (modp(30, 5) == 4);\n    assert (modp(31, 5) == 3);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/46", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n <= 0) return 0;\n    int a = 1, b = 1, c = 1, d = 1;\n    if (n == 1 || n == 2 || n == 3 || n == 4) return 1;\n    for (int i = 5; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(8) == 28);\n    assert (fib4(10) == 104);\n    assert (fib4(12) == 386);\n}\n", "result": "failed: a.out: test.cpp:39: int main(): Assertion `fib4(8) == 28' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/48", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int begin = 0;\n    int end = text.length() - 1;\n    \n    while (begin <= end) {\n        if (text[begin] != text[end]) {\n            return false;\n        }\n        begin++;\n        end--;\n    }\n    \n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n    assert (is_palindrome(\"xywyx\") == true);\n    assert (is_palindrome(\"xywyz\") == false);\n    assert (is_palindrome(\"xywzx\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/53", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(0, 1) == 1);\n    assert (add(1, 0) == 1);\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n    assert (add(7, 5) == 12);\n    for (int i=0;i<100;i+=1)\n    {\n        int x=rand()%1000;\n        int y=rand()%1000;\n        assert (add(x, y) == x + y);\n    }\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/52", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/51", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    string result;\n    for (char c : text) {\n        if (!vowels.count(c)) {\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"fedcba\") == \"fdcb\");\n    assert (remove_vowels(\"eeeee\") == \"\");\n    assert (remove_vowels(\"acBAA\") == \"cB\");\n    assert (remove_vowels(\"EcBOO\") == \"cB\");\n    assert (remove_vowels(\"ybcd\") == \"ybcd\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/50", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\n/* \n * This function encodes a string by shifting every character by 5 positions in the alphabet.\n */\nstring encode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n/*\n * This function decodes a string that has been encoded using the encode_shift function.\n * It shifts each character back by 5 positions in the alphabet.\n */\nstring decode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        if (w < 0) {\n            w += 26;\n        }\n        out += (char)w;\n    }\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n", "result": "failed: a.out: test.cpp:63: int main(): Assertion `decode_shift(encoded_str) == str' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/55", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 2) {\n        return 1;\n    }\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n    assert (fib(11) == 89);\n    assert (fib(12) == 144);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/54", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    unordered_set<char> set0;\n    for (char c : s0) {\n        set0.insert(c);\n    }\n    \n    unordered_set<char> set1;\n    for (char c : s1) {\n        set1.insert(c);\n    }\n    \n    return set0 == set1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/56", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(const string& s) {\n    stack<char> st;\n    for (char c : s) {\n        if (c == '<') {\n            st.push(c);\n        } else if (c == '>') {\n            if (st.empty()) {\n                return false;\n            }\n            st.pop();\n        }\n    }\n    return st.empty();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (correct_bracketing(\"<><><<><>><>\"));\n    assert (correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n    assert (not (correct_bracketing(\"<<<><>>>>\")));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n    assert (not (correct_bracketing(\"<<<<\")));\n    assert (not (correct_bracketing(\">\")));\n    assert (not (correct_bracketing(\"<<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>><<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>>><>\")));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/57", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    bool non_decreasing = true;\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] < l[i - 1]) {\n            non_decreasing = false;\n            break;\n        }\n    }\n    \n    if (non_decreasing) {\n        return true;\n    }\n    \n    bool non_increasing = true;\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            non_increasing = false;\n            break;\n        }\n    }\n    \n    return non_increasing;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 2, 4, 20}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n    assert (monotonic({4, 1, 1, 0}) == true);\n    assert (monotonic({1, 2, 3, 2, 5, 60}) == false);\n    assert (monotonic({1, 2, 3, 4, 5, 60}) == true);\n    assert (monotonic({9, 9, 9, 9}) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/58", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    vector<int> result;\n    set_intersection(s1.begin(), s1.end(),\n                    s2.begin(), s2.end(),\n                    back_inserter(result));\n\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n    assert (issame(common({4, 3, 2, 8}, {3, 2, 4}) , {2, 3, 4}));\n    assert (issame(common({4, 3, 2, 8}, {}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/59", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest = -1;\n    \n    // Check divisibility by 2\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    // Now check for odd factors up to sqrt(n)\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    // If remaining n is a prime\n    if (n > 2) {\n        largest = n;\n    }\n    \n    return largest;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/60", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(6) == 21);\n    assert (sum_to_n(11) == 66);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/62", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> res;\n    if (xs.empty()) {\n        return res;\n    }\n    for (size_t i = 1; i < xs.size(); ++i) {\n        res.push_back(static_cast<float>(i) * xs[i]);\n    }\n    return res;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n    assert (issame(derivative({3, 2, 1}) , {2, 2}));\n    assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));\n    assert (issame(derivative({1}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/61", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (correct_bracketing(\"()()(()())()\"));\n    assert (correct_bracketing(\"()()((()()())())(()()(()))\"));\n    assert (not (correct_bracketing(\"((()())))\")));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n    assert (not (correct_bracketing(\"((((\")));\n    assert (not (correct_bracketing(\")\")));\n    assert (not (correct_bracketing(\"(()\")));\n    assert (not (correct_bracketing(\"()()(()())())(()\")));\n    assert (not (correct_bracketing(\"()()(()())()))()\")));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/64", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cctype> // For tolower function\n\nint vowels_count(string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    // Check the last character for 'y'\n    if (!s.empty()) {\n        char last = tolower(s.back());\n        if (last == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"Alone\") == 3);\n    assert (vowels_count(\"key\") == 2);\n    assert (vowels_count(\"bye\") == 1);\n    assert (vowels_count(\"keY\") == 2);\n    assert (vowels_count(\"bYe\") == 1);\n    assert (vowels_count(\"ACEDY\") == 3);\n   \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/63", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0; // Represents fibfib(n-3)\n    int b = 0; // Represents fibfib(n-2)\n    int c = 1; // Represents fibfib(n-1)\n\n    for (int i = 3; i <= n; ++i) {\n        int next_val = a + b + c;\n        a = b;\n        b = c;\n        c = next_val;\n    }\n\n    return c;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(2) == 1);\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n    assert (fibfib(10) == 81);\n    assert (fibfib(12) == 274);\n    assert (fibfib(14) == 927);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/66", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <cctype>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int total = 0;\n    for (char c : s) {\n        if (isupper(static_cast<unsigned char>(c))) {\n            total += static_cast<int>(c);\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n    assert (digitSum(\" How are yOu?\") == 151);\n    assert (digitSum(\"You arE Very Smart\") == 327);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/65", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int n = s.length();\n    if (n == 0) return \"\";\n    \n    int effective_shift = shift % n;\n    if (effective_shift < 0) {\n        effective_shift += n;\n    }\n    if (effective_shift == 0) {\n        return s;\n    }\n    \n    string shifted_part = s.substr(n - effective_shift);\n    string non_shifted_part = s.substr(0, n - effective_shift);\n    return shifted_part + non_shifted_part;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(100, 2) == \"001\");\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(97, 8) == \"79\");\n    assert (circular_shift(12, 1) == \"21\");\n    assert (circular_shift(11, 101) == \"11\");\n}\n", "result": "failed: a.out: test.cpp:43: int main(): Assertion `circular_shift(97, 8) == \"79\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/68", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int min_even = -1;\n    int min_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        int current_val = arr[i];\n        if (current_val % 2 == 0) { // Check if the number is even\n            if (min_even == -1) { // First even found\n                min_even = current_val;\n                min_index = i;\n            } else {\n                if (current_val < min_even) { // Update if smaller even found\n                    min_even = current_val;\n                    min_index = i;\n                }\n            }\n        }\n    }\n    \n    if (min_even == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n    assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));\n    assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));\n    assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));\n    assert (issame(pluck({7, 9, 7, 1}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/70", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    if (lst.empty()) return result;\n\n    sort(lst.begin(), lst.end());\n    int left = 0;\n    int right = lst.size() - 1;\n\n    while (left <= right) {\n        if (result.size() % 2 == 0) { // even, take from left\n            result.push_back(lst[left]);\n            left++;\n        } else { // odd, take from right\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9}) , {5, 9, 6, 8, 7}));\n    assert (issame(strange_sort_list({1, 2, 3, 4, 5}) , {1, 5, 2, 4, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9, 1}) , {1, 9, 5, 8, 6, 7}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n    assert (issame(strange_sort_list({1,2,3,4,5,6,7,8}) , {1, 8, 2, 7, 3, 6, 4, 5}));\n    assert (issame(strange_sort_list({0,2,2,2,5,5,-5,-5}) , {-5, 5, -5, 5, 0, 2, 2, 2}));\n    assert (issame(strange_sort_list({111111}) , {111111}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/69", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    vector<int> unique_nums;\n    for (auto& pair : freq) {\n        unique_nums.push_back(pair.first);\n    }\n    \n    sort(unique_nums.begin(), unique_nums.end(), greater<int>());\n    \n    for (int x : unique_nums) {\n        if (freq[x] >= x) {\n            return x;\n        }\n    }\n    \n    return -1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({5, 5, 5, 5, 1}) == 1);\n    assert (search({4, 1, 4, 1, 4, 4}) == 4);\n    assert (search({3, 3}) == -1);\n    assert (search({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    assert (search({2, 3, 3, 2, 2}) == 2);\n    assert (search({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    assert (search({3, 2, 8, 2}) == 2);\n    assert (search({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    assert (search({8, 8, 3, 6, 5, 6, 4}) == -1);\n    assert (search({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    assert (search({1, 9, 10, 1, 3}) == 1);\n    assert (search({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    assert (search({1}) == 1);\n    assert (search({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    assert (search({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    assert (search({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    assert (search({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    assert (search({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    assert (search({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    assert (search({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    assert (search({10}) == -1);\n    assert (search({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    assert (search({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    assert (search({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    assert (search({3, 10, 10, 9, 2}) == -1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/71", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    \n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2.0f;\n    \n    // Compute area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Round to two decimal places\n    return round(area * 100) / 100;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n    assert (abs(triangle_area(4, 8, 5) -8.18)<0.01);\n    assert (abs(triangle_area(2, 2, 2) -1.73)<0.01);\n    assert (abs(triangle_area(1, 2, 3) +1)<0.01);\n    assert (abs(triangle_area(10, 5, 7) - 16.25)<0.01);\n    assert (abs(triangle_area(2, 6, 3) +1)<0.01);\n    assert (abs(triangle_area(1, 1, 1) -0.43)<0.01);\n    assert (abs(triangle_area(2, 2, 10) +1)<0.01);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/72", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    bool isPalindrome = true;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            isPalindrome = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check both conditions\n    return isPalindrome && (sum <= w);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n    assert (will_it_fly({1, 2, 3}, 6) ==false);\n    assert (will_it_fly({5}, 5) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/73", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 4, 2}) == 1);\n    assert (smallest_change({1, 4, 4, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n    assert (smallest_change({1}) == 0);\n    assert (smallest_change({0, 1}) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/76", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Determine if x is a power of n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (n == 0) {\n        return (x == 0);\n    }\n    if (n == 1 || n == -1) {\n        return (x == 1 || x == -1);\n    }\n\n    // Main logic to check power\n    int current = 1;\n    while (current <= abs(x)) {\n        if (current == abs(x)) {\n            return (x > 0);  // Ensure result matches sign of x and n\n        }\n        current *= abs(n);\n        if (n < 0 && current != abs(current)) {  // Check for negative powers\n            break;\n        }\n    }\n    return false;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n    assert (is_simple_power(16, 2)== true);\n    assert (is_simple_power(143214, 16)== false);\n    assert (is_simple_power(4, 2)==true);\n    assert (is_simple_power(9, 3)==true);\n    assert (is_simple_power(16, 4)==true);\n    assert (is_simple_power(24, 2)==false);\n    assert (is_simple_power(128, 4)==false);\n    assert (is_simple_power(12, 6)==false);\n    assert (is_simple_power(1, 1)==true);\n    assert (is_simple_power(1, 12)==true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/74", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = accumulate(lst1.begin(), lst1.end(), 0,\n        [](int acc, const string& s) { return acc + s.size(); });\n    int sum2 = accumulate(lst2.begin(), lst2.end(), 0,\n        [](int acc, const string& s) { return acc + s.size(); });\n\n    if (sum1 < sum2) {\n        return lst1;\n    } else if (sum2 < sum1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({}, {\"this\"}) , {}));\n    assert (issame(total_match({\"this\"}, {}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/78", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        int val;\n        if (c >= '0' && c <= '9') {\n            val = c - '0';\n        } else {\n            switch(c) {\n                case 'A': val = 10; break;\n                case 'B': val = 11; break;\n                case 'C': val = 12; break;\n                case 'D': val = 13; break;\n                case 'E': val = 14; break;\n                case 'F': val = 15; break;\n                default: val = 0; // This case should not occur as per problem constraints\n            }\n        }\n        if (val == 2 || val == 3 || val == 5 || val == 7 || val == 11 || val == 13) {\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n    assert (hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12 );\n    assert (hex_key(\"\") == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/75", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    // Function implementation here\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(5) == false);\n    assert (is_multiply_prime(30) == true);\n    assert (is_multiply_prime(8) == true);\n    assert (is_multiply_prime(10) == false);\n    assert (is_multiply_prime(125) == true);\n    assert (is_multiply_prime(3 * 5 * 7) == true);\n    assert (is_multiply_prime(3 * 6 * 7) == false);\n    assert (is_multiply_prime(9 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 13 * 7) == true);\n}\n", "result": "failed: a.out: test.cpp:29: int main(): Assertion `is_multiply_prime(5) == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/79", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm> // For reverse\n\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    \n    string binary_str;\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary_str.push_back(remainder + '0');\n        decimal /= 2;\n    }\n    \n    reverse(binary_str.begin(), binary_str.end());\n    \n    return \"db\" + binary_str + \"db\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(0) == \"db0db\");\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(103) == \"db1100111db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/80", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        char a = s[i];\n        char b = s[i + 1];\n        char c = s[i + 2];\n        if (a == b || b == c || a == c) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n    assert (is_happy(\"iopaxpoi\") == true );\n    assert (is_happy(\"iopaxioi\") == false );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/77", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int num) {\n    // Function implementation here\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscube(1) == true);\n    assert (iscube(2) == false);\n    assert (iscube(-1) == true);\n    assert (iscube(64) == true);\n    assert (iscube(180) == false);\n    assert (iscube(1000) == true);\n    assert (iscube(0) == true);\n    assert (iscube(1729) == false);\n}\n", "result": "failed: a.out: test.cpp:29: int main(): Assertion `iscube(1) == true' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/83", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nTo determine how many n-digit numbers exist that either start with 1 or end with 1, we can use the principle of inclusion-exclusion.\n\n1. **Numbers starting with 1 (A):** There are \\(10^{n-1}\\) such numbers because the first digit is fixed as 1, and the remaining \\(n-1\\) digits can be any digit from 0 to 9.\n\n2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n\n3. **Numbers that both start with 1 and end with 1 (C):** There are \\(10^{n-2}\\) such numbers because the first digit is fixed as 1, the last digit is fixed as 1, and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n\nUsing inclusion-exclusion principle:\n\\[ |A \\cup B| = |A| + |B| - |C| \\]\n\nSubstituting the values:\n\\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n\\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n\\[ |A \\cup B| = 10^{n-2} (10 + 8) \\]\n\\[ |A \\cup B| = 18 \\times 10^{n-2} \\]\n\nThus, the number of n-digit numbers that either start with 1 or end with 1 is:\n\n\\[\n\\boxed{18 \\times 10^{n-2}}\n\\]\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (starts_one_ends(1) == 1);\n    assert (starts_one_ends(2) == 18);\n    assert (starts_one_ends(3) == 180);\n    assert (starts_one_ends(4) == 1800);\n    assert (starts_one_ends(5) == 18000);\n}\n", "result": "failed: compilation error: test.cpp:21:47: error: stray \u2018\\\u2019 in program\n   21 | 1. **Numbers starting with 1 (A):** There are \\(10^{n-1}\\) such numbers because the first digit is fixed as 1, and the remaining \\(n-1\\) digits can be any digit from 0 to 9.\n      |                                               ^\ntest.cpp:21:57: error: stray \u2018\\\u2019 in program\n   21 | 1. **Numbers starting with 1 (A):** There are \\(10^{n-1}\\) such numbers because the first digit is fixed as 1, and the remaining \\(n-1\\) digits can be any digit from 0 to 9.\n      |                                                         ^\ntest.cpp:21:130: error: stray \u2018\\\u2019 in program\n   21 | 1. **Numbers starting with 1 (A):** There are \\(10^{n-1}\\) such numbers because the first digit is fixed as 1, and the remaining \\(n-1\\) digits can be any digit from 0 to 9.\n      |                                                                                                                                  ^\ntest.cpp:21:135: error: stray \u2018\\\u2019 in program\n   21 | 1. **Numbers starting with 1 (A):** There are \\(10^{n-1}\\) such numbers because the first digit is fixed as 1, and the remaining \\(n-1\\) digits can be any digit from 0 to 9.\n      |                                                                                                                                       ^\ntest.cpp:23:45: error: stray \u2018\\\u2019 in program\n   23 | 2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                             ^\ntest.cpp:23:49: error: stray \u2018\\\u2019 in program\n   23 | 2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                 ^\ntest.cpp:23:64: error: stray \u2018\\\u2019 in program\n   23 | 2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                ^\ntest.cpp:23:164: warning: missing terminating ' character\n   23 | 2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                                                                                                                    ^\ntest.cpp:23:164: error: missing terminating ' character\n   23 | 2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                                                                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ntest.cpp:25:69: error: stray \u2018\\\u2019 in program\n   25 | 3. **Numbers that both start with 1 and end with 1 (C):** There are \\(10^{n-2}\\) such numbers because the first digit is fixed as 1, the last digit is fixed as 1, and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                     ^\ntest.cpp:25:79: error: stray \u2018\\\u2019 in program\n   25 | 3. **Numbers that both start with 1 and end with 1 (C):** There are \\(10^{n-2}\\) such numbers because the first digit is fixed as 1, the last digit is fixed as 1, and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                               ^\ntest.cpp:25:182: error: stray \u2018\\\u2019 in program\n   25 | 3. **Numbers that both start with 1 and end with 1 (C):** There are \\(10^{n-2}\\) such numbers because the first digit is fixed as 1, the last digit is fixed as 1, and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                                                                                                                                      ^\ntest.cpp:25:187: error: stray \u2018\\\u2019 in program\n   25 | 3. **Numbers that both start with 1 and end with 1 (C):** There are \\(10^{n-2}\\) such numbers because the first digit is fixed as 1, the last digit is fixed as 1, and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                                                                                                                                           ^\ntest.cpp:28:1: error: stray \u2018\\\u2019 in program\n   28 | \\[ |A \\cup B| = |A| + |B| - |C| \\]\n      | ^\ntest.cpp:28:7: error: stray \u2018\\\u2019 in program\n   28 | \\[ |A \\cup B| = |A| + |B| - |C| \\]\n      |       ^\ntest.cpp:28:33: error: stray \u2018\\\u2019 in program\n   28 | \\[ |A \\cup B| = |A| + |B| - |C| \\]\n      |                                 ^\ntest.cpp:31:1: error: stray \u2018\\\u2019 in program\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      | ^\ntest.cpp:31:7: error: stray \u2018\\\u2019 in program\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      |       ^\ntest.cpp:31:30: error: stray \u2018\\\u2019 in program\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      |                              ^\ntest.cpp:31:57: error: stray \u2018\\\u2019 in program\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      |                                                         ^\ntest.cpp:32:1: error: stray \u2018\\\u2019 in program\n   32 | \\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n      | ^\ntest.cpp:32:7: error: stray \u2018\\\u2019 in program\n   32 | \\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n      |       ^\ntest.cpp:32:30: error: stray \u2018\\\u2019 in program\n   32 | \\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n      |                              ^\ntest.cpp:32:46: error: stray \u2018\\\u2019 in program\n   32 | \\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n      |                                              ^\ntest.cpp:33:1: error: stray \u2018\\\u2019 in program\n   33 | \\[ |A \\cup B| = 10^{n-2} (10 + 8) \\]\n      | ^\ntest.cpp:33:7: error: stray \u2018\\\u2019 in program\n   33 | \\[ |A \\cup B| = 10^{n-2} (10 + 8) \\]\n      |       ^\ntest.cpp:33:35: error: stray \u2018\\\u2019 in program\n   33 | \\[ |A \\cup B| = 10^{n-2} (10 + 8) \\]\n      |                                   ^\ntest.cpp:34:1: error: stray \u2018\\\u2019 in program\n   34 | \\[ |A \\cup B| = 18 \\times 10^{n-2} \\]\n      | ^\ntest.cpp:34:7: error: stray \u2018\\\u2019 in program\n   34 | \\[ |A \\cup B| = 18 \\times 10^{n-2} \\]\n      |       ^\ntest.cpp:34:20: error: stray \u2018\\\u2019 in program\n   34 | \\[ |A \\cup B| = 18 \\times 10^{n-2} \\]\n      |                    ^\ntest.cpp:34:36: error: stray \u2018\\\u2019 in program\n   34 | \\[ |A \\cup B| = 18 \\times 10^{n-2} \\]\n      |                                    ^\ntest.cpp:38:1: error: stray \u2018\\\u2019 in program\n   38 | \\[\n      | ^\ntest.cpp:39:1: error: stray \u2018\\\u2019 in program\n   39 | \\boxed{18 \\times 10^{n-2}}\n      | ^\ntest.cpp:39:11: error: stray \u2018\\\u2019 in program\n   39 | \\boxed{18 \\times 10^{n-2}}\n      |           ^\ntest.cpp:40:1: error: stray \u2018\\\u2019 in program\n   40 | \\]\n      | ^\ntest.cpp:19:1: error: \u2018To\u2019 does not name a type\n   19 | To determine how many n-digit numbers exist that either start with 1 or end with 1, we can use the principle of inclusion-exclusion.\n      | ^~\ntest.cpp:21:58: error: expected unqualified-id before \u2018)\u2019 token\n   21 | 1. **Numbers starting with 1 (A):** There are \\(10^{n-1}\\) such numbers because the first digit is fixed as 1, and the remaining \\(n-1\\) digits can be any digit from 0 to 9.\n      |                                                          ^\ntest.cpp:23:65: error: expected unqualified-id before \u2018)\u2019 token\n   23 | 2. **Numbers ending with 1 (B):** There are \\(9 \\times 10^{n-2}\\) such numbers because the last digit is fixed as 1, the first digit can be any of 1 to 9 (since it's an n-digit number), and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                 ^\ntest.cpp:25:80: error: expected unqualified-id before \u2018)\u2019 token\n   25 | 3. **Numbers that both start with 1 and end with 1 (C):** There are \\(10^{n-2}\\) such numbers because the first digit is fixed as 1, the last digit is fixed as 1, and the remaining \\(n-2\\) digits can be any digit from 0 to 9.\n      |                                                                                ^\ntest.cpp:31:26: error: expected unqualified-id before \u2018+\u2019 token\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      |                          ^\ntest.cpp:31:46: error: expected unqualified-id before \u2018-\u2019 token\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      |                                              ^\ntest.cpp:31:58: error: expected unqualified-id before \u2018]\u2019 token\n   31 | \\[ |A \\cup B| = 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} \\]\n      |                                                          ^\ntest.cpp:32:26: error: expected unqualified-id before \u2018+\u2019 token\n   32 | \\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n      |                          ^\ntest.cpp:32:47: error: expected unqualified-id before \u2018]\u2019 token\n   32 | \\[ |A \\cup B| = 10^{n-1} + 8 \\times 10^{n-2} \\]\n      |                                               ^\ntest.cpp:33:27: error: expected unqualified-id before numeric constant\n   33 | \\[ |A \\cup B| = 10^{n-2} (10 + 8) \\]\n      |                           ^~\ntest.cpp:33:27: error: expected \u2018)\u2019 before numeric constant\n   33 | \\[ |A \\cup B| = 10^{n-2} (10 + 8) \\]\n      |                          ~^~\n      |                           )\ntest.cpp:34:37: error: expected unqualified-id before \u2018]\u2019 token\n   34 | \\[ |A \\cup B| = 18 \\times 10^{n-2} \\]\n      |                                     ^\ntest.cpp:40:2: error: expected unqualified-id before \u2018]\u2019 token\n   40 | \\]\n      |  ^\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/82", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nbool prime_length(string str) {\n    int n = str.size();\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n    assert (prime_length(\"wow\") == true);\n    assert (prime_length(\"world\") == true);\n    assert (prime_length(\"MadaM\") == true);\n    assert (prime_length(\"Wow\") == true);\n    assert (prime_length(\"\") == false);\n    assert (prime_length(\"HI\") == true);\n    assert (prime_length(\"go\") == true);\n    assert (prime_length(\"gogo\") == false);\n    assert (prime_length(\"aaaaaaaaaaaaaaa\") == false);\n    assert (prime_length(\"Madam\") == true);\n    assert (prime_length(\"M\") == false);\n    assert (prime_length(\"0\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/81", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float gpa : grades) {\n        string grade;\n        if (gpa == 4.0f) {\n            grade = \"A+\";\n        } else if (gpa > 3.7f) {\n            grade = \"A\";\n        } else if (gpa > 3.3f) {\n            grade = \"A-\";\n        } else if (gpa > 3.0f) {\n            grade = \"B+\";\n        } else if (gpa > 2.7f) {\n            grade = \"B\";\n        } else if (gpa > 2.3f) {\n            grade = \"B-\";\n        } else if (gpa > 2.0f) {\n            grade = \"C+\";\n        } else if (gpa > 1.7f) {\n            grade = \"C\";\n        } else if (gpa > 1.3f) {\n            grade = \"C-\";\n        } else if (gpa > 1.0f) {\n            grade = \"D+\";\n        } else if (gpa > 0.7f) {\n            grade = \"D\";\n        } else if (gpa > 0.0f) {\n            grade = \"D-\";\n        } else {\n            grade = \"E\";\n        }\n        result.push_back(grade);\n    }\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n    assert (issame(numerical_letter_grade({1.2}) , {\"D+\"}));\n    assert (issame(numerical_letter_grade({0.5}) , {\"D-\"}));\n    assert (issame(numerical_letter_grade({0.0}) , {\"E\"}));\n    assert (issame(numerical_letter_grade({1, 0.3, 1.5, 2.8, 3.3}) , {\"D\", \"D-\", \"C-\", \"B\", \"B+\"}));\n    assert (issame(numerical_letter_grade({0, 0.7}) , {\"E\", \"D-\"}));\n    \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/84", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string solve(int N) {\n    int sum = 0;\n    int temp = N;\n    while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::vector<int> bits;\n    while (sum > 0) {\n        int rem = sum % 2;\n        bits.push_back(rem);\n        sum /= 2;\n    }\n    std::reverse(bits.begin(), bits.end());\n\n    std::string binary_str;\n    for (int bit : bits) {\n        binary_str += std::to_string(bit);\n    }\n\n    return binary_str;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/85", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int total = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 88}) == 88);\n    assert (add({4, 5, 6, 7, 2, 122}) == 122);\n    assert (add({4, 0, 6, 7}) == 0);\n    assert (add({4, 4, 6, 8}) == 12);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/67", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    regex re(\"([0-9]+) apples and ([0-9]+) oranges\");\n    smatch match;\n    if (regex_search(s, match, re)) {\n        int apples = stoi(match[1]);\n        int oranges = stoi(match[2]);\n        return n - apples - oranges;\n    }\n    // According to the problem statement, this case should not occur\n    return 0;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"5 apples and 6 oranges\",21) == 10);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"1 apples and 0 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",5) == 0);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/86", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Split the string into words based on spaces\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n            words.push_back(\" \");  // Keep track of the space\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    // Process each word (and spaces) to sort characters\n    for (string& w : words) {\n        if (w != \" \") {  // If it's a space, leave it as is\n            sort(w.begin(), w.end());\n        }\n    }\n\n    // Reconstruct the string from processed words and spaces\n    string result;\n    for (const string& w : words) {\n        result += w;\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"number\") == \"bemnru\");\n    assert (anti_shuffle(\"abcd\") == \"abcd\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    assert (anti_shuffle(\"\") == \"\");\n    assert (anti_shuffle(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/89", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    for (int i = 0; i < s.size(); ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            int new_pos = (c - 'a' + 4) % 26;\n            s[i] = 'a' + new_pos;\n        }\n    }\n    return s;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n    assert (encrypt(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    assert (encrypt(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    assert (encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    assert (encrypt(\"a\")==\"e\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/87", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        const auto& current_row = lst[i];\n        for (int j = 0; j < current_row.size(); ++j) {\n            if (current_row[j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        } else {\n            return a[1] > b[1]; // Higher column comes first\n        }\n    });\n    \n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6}}, 2) , {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,1,3,4,5,6},\n        {1,2,1,4,5,6},\n        {1,2,3,1,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1) , {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{1}}, 2) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/92", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    if (a != static_cast<int>(a)) return false;\n    if (b != static_cast<int>(b)) return false;\n    if (c != static_cast<int>(c)) return false;\n\n    // Check if any number is the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(2, 3, 1)==true);\n    assert (any_int(2.5, 2, 3)==false);\n    assert (any_int(1.5, 5, 3.5)==false);\n    assert (any_int(2, 6, 2)==false);\n    assert (any_int(4, 2, 2)==true);\n    assert (any_int(2.2, 2.2, 2.2)==false);\n    assert (any_int(-4, 6, 2)==true);\n    assert (any_int(2,1,1)==true);\n    assert (any_int(3,4,7)==true);\n    assert (any_int(3.01,4,7)==false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/90", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <algorithm>\n\nint next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1;\n    }\n    \n    std::sort(lst.begin(), lst.end());\n    \n    int first = lst[0];\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] > first) {\n            return lst[i];\n        }\n    }\n    \n    return -1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n    assert (next_smallest({1,1,1,1,0}) == 1);\n    assert (next_smallest({-35, 34, 12, -45}) == -35);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/88", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    vector<int> result = array; // Create a copy to avoid modifying the original\n    \n    if (result.size() <= 1) {\n        return result;\n    }\n    \n    int sum = result[0] + result.back();\n    \n    if (sum % 2 == 1) {\n        sort(result.begin(), result.end());\n    } else {\n        sort(result.begin(), result.end(), [](int a, int b) { return a > b; });\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n    assert (issame(sort_array({2, 1}) , {1, 2}));\n    assert (issame(sort_array({15, 42, 87, 32 ,11, 0}) , {0, 11, 15, 32, 42, 87}));\n    assert (issame(sort_array({21, 14, 23, 11}) , {23, 21, 14, 11}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/94", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_digits(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n    return sum_digits(max_prime);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/93", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring encode(string message) {\n    // Iterate through each character in the string\n    for (int i = 0; i < message.size(); ++i) {\n        char c = message[i];\n        \n        // Check if the character is a vowel\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            \n            // Shift vowel by two places\n            if (c >= 'a' && c <= 'y') {\n                message[i] = c + 2;\n            } else if (c == 'z' || c == 'Z') {\n                message[i] = 'b'; // Wrap around for 'z'\n            }\n            \n            // Swap case\n            if (islower(c)) {\n                message[i] = toupper(c);\n            } else {\n                message[i] = tolower(c);\n            }\n        } else {\n            // Swap case for non-vowel characters\n            if (islower(c)) {\n                message[i] = toupper(c);\n            } else {\n                message[i] = tolower(c);\n            }\n        }\n    }\n    \n    return message;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"TEST\") == \"tgst\");\n    assert (encode(\"Mudasir\") == \"mWDCSKR\");\n    assert (encode(\"YES\") == \"ygs\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    assert (encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n}\n", "result": "failed: a.out: test.cpp:59: int main(): Assertion `encode(\"TEST\") == \"tgst\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/91", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nint countSentences(const string &text) {\n    int count = 0;\n    size_t start = 0;\n    while (true) {\n        size_t dotSpace = text.find(\". \", start);\n        if (dotSpace == string::npos) {\n            // Check the remaining part of the text\n            string sentence = text.substr(start);\n            size_t firstNonSpace = sentence.find_first_not_of(\" \");\n            if (firstNonSpace != string::npos) {\n                size_t lastNonSpace = sentence.find_last_not_of(\" \");\n                sentence = sentence.substr(firstNonSpace, lastNonSpace - firstNonSpace + 1);\n                if (!sentence.empty()) {\n                    count++;\n                }\n            }\n            break;\n        } else {\n            string sentence = text.substr(start, dotSpace - start);\n            size_t firstNonSpace = sentence.find_first_not_of(\" \");\n            if (firstNonSpace != string::npos) {\n                size_t lastNonSpace = sentence.find_last_not_of(\" \");\n                sentence = sentence.substr(firstNonSpace, lastNonSpace - firstNonSpace + 1);\n                if (!sentence.empty()) {\n                    count++;\n                }\n            }\n            start = dotSpace + 2; // Move past \". \"\n        }\n    }\n    return count;\n}\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    size_t pos = 0;\n    while (pos < S.length()) {\n        // Skip any leading whitespace\n        while (pos < S.length() && isspace(S[pos])) {\n            pos++;\n        }\n        \n        if (pos >= S.length()) {\n            break;\n        }\n        \n        // Check if the sentence starts with \"I\"\n        if (S[pos] == 'I' && (pos == 0 || isspace(S[pos-1]))) {\n            boredomCount++;\n        }\n        \n        // Move to next sentence\n        while (pos < S.length() && !isspace(S[pos])) {\n            pos++;\n        }\n    }\n    \n    return boredomCount;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"Is the sky blue?\") == 0);\n    assert (is_bored(\"I love It !\") == 1);\n    assert (is_bored(\"bIt\") == 0);\n    assert (is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert (is_bored(\"You and I are going for a walk\") == 0);\n}\n", "result": "failed: a.out: test.cpp:85: int main(): Assertion `is_bored(\"Is the sky blue?\") == 0' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/96", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false; // Even numbers greater than 2 are not prime\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(6) , {2,3,5}));\n    assert (issame(count_up_to(7) , {2,3,5}));\n    assert (issame(count_up_to(10) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(22) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n    assert (issame(count_up_to(47) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}));\n    assert (issame(count_up_to(101) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/95", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <map>\n#include <cctype>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    for (auto& pair : dict) {\n        string key = pair.first;\n        \n        if (key.empty()) {\n            return false;\n        }\n        \n        bool allLower = true;\n        bool allUpper = true;\n        \n        for (char c : key) {\n            if (!islower(c)) {\n                allLower = false;\n            }\n            if (!isupper(c)) {\n                allUpper = false;\n            }\n        }\n        \n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    assert (check_dict_case({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    assert (check_dict_case({}) == false);\n}\n", "result": "failed: a.out: test.cpp:59: int main(): Assertion `check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/97", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract unit digits of both numbers\n    int unitA = abs(a) % 10;\n    int unitB = abs(b) % 10;\n    \n    // Compute the product of the unit digits\n    return unitA * unitB;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n    assert (multiply(76, 67) == 42    );\n    assert (multiply(17, 27) == 49    );\n    assert (multiply(0, 1) == 0);\n    assert (multiply(0, 0) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/98", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0 && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n                count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n    assert (count_upper(\"B\")  == 0);\n    assert (count_upper(\"U\")  == 1);\n    assert (count_upper(\"\") == 0);\n    assert (count_upper(\"EEEE\") == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/99", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cmath> // For std::round\n\nint closest_integer(string value) {\n    double num = stod(value);\n    double fractional_part = num - floor(num);\n    \n    if (fractional_part == 0.5) {\n        return static_cast<int>(std::ceil(num));\n    } else {\n        return static_cast<int>(num + 0.5);\n    }\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"14.5\") == 15);\n    assert (closest_integer(\"-15.5\") == -16);\n    assert (closest_integer(\"15.3\") == 15);\n    assert (closest_integer(\"0\") == 0);\n}\n", "result": "failed: a.out: test.cpp:37: int main(): Assertion `closest_integer(\"-15.5\") == -16' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/100", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        current += 2;\n    }\n    return pile;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n    assert (issame(make_a_pile(4) , {4,6,8,10}));\n    assert (issame(make_a_pile(5) , {5, 7, 9, 11, 13}));\n    assert (issame(make_a_pile(6) , {6, 8, 10, 12, 14, 16}));\n    assert (issame(make_a_pile(8) , {8, 10, 12, 14, 16, 18, 20, 22}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/102", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\nusing namespace std;\n\n/* \nThis function takes two positive numbers x and y and returns the\nbiggest even integer number that is in the range [x, y] inclusive. If \nthere's no such number, then the function should return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    \n    int largest_even = y % 2 == 0 ? y : y - 1;\n    \n    if (largest_even >= x) {\n        return largest_even;\n    } else {\n        return -1;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n    assert (choose_num(33, 12354) == 12354);\n    assert (choose_num(5234, 5233) == -1);\n    assert (choose_num(6, 29) == 28);\n    assert (choose_num(27, 10) == -1);\n    assert (choose_num(7, 7) == -1);\n    assert (choose_num(546, 546) == 546);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/101", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm> // For std::replace\n#include <sstream>   // For istringstream\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces\n    replace(s.begin(), s.end(), ',', ' ');\n    \n    vector<string> result;\n    string word;\n    istringstream iss(s);\n    \n    while (iss >> word) {\n        result.push_back(word);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"Hi, my name\") , {\"Hi\", \"my\", \"name\"}));\n    assert (issame(words_string(\"One,, two, three, four, five, six,\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"\") , {}));\n    assert (issame(words_string(\"ahmed     , gamal\") , {\"ahmed\", \"gamal\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/103", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    long long sum = static_cast<long long>(n) + m;\n    long long avg = sum / 2;\n    \n    if (avg == 0) return \"0\";\n    \n    string binary;\n    while (avg > 0) {\n        int remainder = avg % 2;\n        binary += remainder ? '1' : '0';\n        avg /= 2;\n    }\n    reverse(binary.begin(), binary.end());\n    return binary;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 13) == \"1010\");\n    assert (rounded_avg(964,977) == \"1111001010\");\n    assert (rounded_avg(996,997) == \"1111100100\");\n    assert (rounded_avg(560,851) == \"1011000001\");  \n    assert (rounded_avg(185,546) == \"101101101\");\n    assert (rounded_avg(362,496) == \"110101101\");\n    assert (rounded_avg(350,902) == \"1001110010\");\n    assert (rounded_avg(197,233) == \"11010111\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(5, 1) == \"-1\");\n    assert (rounded_avg(5, 5) == \"101\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/106", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> sequence(n);\n    for (int j = 0; j < n; ++j) {\n        int k = j + 1;\n        if (k % 2 == 0) {\n            // Compute factorial of k\n            int fact = 1;\n            for (int i = 1; i <= k; ++i) {\n                fact *= i;\n            }\n            sequence[j] = fact;\n        } else {\n            // Compute sum from 1 to k\n            sequence[j] = k * (k + 1) / 2;\n        }\n    }\n    return sequence;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n    assert (issame(f(7) , {1, 2, 6, 24, 15, 720, 28}));\n    assert (issame(f(1) , {1}));\n    assert (issame(f(3) , {1, 2, 6}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/104", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        bool has_even = false;\n        string s = to_string(num);\n        for (char c : s) {\n            int digit = c - '0';\n            if (digit % 2 == 0) {\n                has_even = true;\n                break;\n            }\n        }\n        if (!has_even) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n    assert (issame(unique_digits({12345, 2033, 111, 151}) , {111, 151}));\n    assert (issame(unique_digits({135, 103, 31}) , {31, 135}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/107", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    int reversed = 0;\n    int original = num;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return (reversed == original);\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(123) , {8, 13}));\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n    assert (issame(even_odd_palindrome(63) , {6, 8}));\n    assert (issame(even_odd_palindrome(25) , {5, 6}));\n    assert (issame(even_odd_palindrome(19) , {4, 6}));\n    assert (issame(even_odd_palindrome(9) , {4, 5}));\n    assert (issame(even_odd_palindrome(1) , {0, 1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/105", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n\n    const vector<string> numberNames = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n    assert (issame(by_length({1, -1, 3, 2}) , {\"Three\", \"Two\", \"One\"}));\n    assert (issame(by_length({9, 4, 8}) , {\"Nine\", \"Eight\", \"Four\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/109", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    \n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            ++count;\n        }\n    }\n    \n    return count <= 1;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 10, 1, 2})==true);\n    assert (move_one_ball({4, 3, 1, 2})==false);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n    assert (move_one_ball({})==true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/108", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <algorithm>\n\nint calculate_signed_digit_sum(int num) {\n    if (num == 0) return 0;\n    bool is_negative = false;\n    if (num < 0) {\n        is_negative = true;\n        num = abs(num);\n    }\n    int sum = 0;\n    std::vector<int> digits;\n    while (num > 0) {\n        digits.push_back(num % 10);\n        num /= 10;\n    }\n    std::reverse(digits.begin(), digits.end());\n    for (size_t i = 0; i < digits.size(); ++i) {\n        if (is_negative && i == 0) { // first digit\n            sum -= digits[i];\n        } else {\n            sum += digits[i];\n        }\n    }\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (calculate_signed_digit_sum(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, -2, 0}) == 0);\n    assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);\n    assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);\n    assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);\n    assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);\n    assert (count_nums({-0, 1}) == 1);\n    assert (count_nums({1}) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/110", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odds_in_lst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odds_in_lst1++;\n        }\n    }\n\n    int evens_in_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evens_in_lst2++;\n        }\n    }\n\n    return (evens_in_lst2 >= odds_in_lst1) ? \"YES\" : \"NO\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/112", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nstd::vector<std::string> reverse_delete(std::string s, std::string c) {\n    std::unordered_set<char> remove_chars(c.begin(), c.end());\n    std::string filtered_s;\n    \n    for (char ch : s) {\n        if (remove_chars.find(ch) == remove_chars.end()) {\n            filtered_s.push_back(ch);\n        }\n    }\n    \n    std::string reversed = filtered_s;\n    std::reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = (filtered_s == reversed);\n    \n    return {filtered_s, is_palindrome ? \"True\" : \"False\"};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (issame(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (issame(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (issame(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/111", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <sstream>\n#include <unordered_map>\n#include <map>\n\nstd::map<char, int> histogram(std::string test) {\n    std::map<char, int> result;\n    if (test.empty()) {\n        return result;\n    }\n\n    std::istringstream iss(test);\n    std::string token;\n    std::unordered_map<char, int> counts;\n\n    while (iss >> token) {\n        char c = token[0];\n        counts[c]++;\n    }\n\n    if (counts.empty()) {\n        return result;\n    }\n\n    int max_count = 0;\n    for (const auto& pair : counts) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    for (const auto& pair : counts) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c d g\") , {{'a', 1}, {'b', 1}, {'c', 1}, {'d', 1}, {'g', 1}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"\") , {}));\n    assert (issame(histogram(\"a\") , {{'a', 1}}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/113", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            int digit = c - '0';\n            if (digit % 2 != 0) {\n                count++;\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    assert (issame(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/114", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\nTo solve this problem, we need to find the contiguous subarray within a given array that has the smallest sum. This is a classic problem in computer science and can be efficiently solved using a dynamic programming approach.\n\n### Approach\nThe key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n\n1. **Initialization**: Start by setting both `current_min` and `global_min` to the first element of the array.\n2. **Iteration**: For each subsequent element in the array:\n   - Calculate the potential new minimum sum if we extend the subarray ending at the previous position.\n   - Update `current_min` to be the minimum of the current element itself or the sum of the current element and `current_min`.\n   - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n3. **Result**: After iterating through all elements, `global_min` will hold the smallest sum of any contiguous subarray.\n\nThis approach ensures that we efficiently find the minimum subarray sum in linear time, O(n), where n is the number of elements in the array.\n\n### Solution Code\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n    assert (minSubArraySum({-1, -2, -3, 2, -10}) == -14);\n    assert (minSubArraySum({-9999999999999999}) == -9999999999999999);\n    assert (minSubArraySum({0, 10, 20, 1000000}) == 0);\n    assert (minSubArraySum({-1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({100, -1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({10, 11, 13, 8, 3, 4}) == 3);\n    assert (minSubArraySum({100, -33, 32, -1, 0, -2}) == -33);\n    assert (minSubArraySum({-10}) == -10);\n    assert (minSubArraySum({7}) == 7);\n    assert (minSubArraySum({1, -1}) == -1);\n}\n", "result": "failed: compilation error: test.cpp:21:1: error: stray \u2018##\u2019 in program\n   21 | ### Approach\n      | ^~\ntest.cpp:21:3: error: stray \u2018#\u2019 in program\n   21 | ### Approach\n      |   ^\ntest.cpp:22:79: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                               ^\ntest.cpp:22:91: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                           ^\ntest.cpp:22:97: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                                 ^\ntest.cpp:22:108: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                                            ^\ntest.cpp:22:115: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                                                   ^\ntest.cpp:22:127: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                                                               ^\ntest.cpp:22:211: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                                                                                                                                                   ^\ntest.cpp:22:222: error: stray \u2018`\u2019 in program\n   22 | The key idea is to iterate through the array while maintaining two variables: `current_min` and `global_min`. The `current_min` keeps track of the minimum sum of subarrays ending at the current position, while `global_min` stores the smallest sum encountered so far.\n      |                                                                                                                                                                                                                              ^\ntest.cpp:24:46: error: stray \u2018`\u2019 in program\n   24 | 1. **Initialization**: Start by setting both `current_min` and `global_min` to the first element of the array.\n      |                                              ^\ntest.cpp:24:58: error: stray \u2018`\u2019 in program\n   24 | 1. **Initialization**: Start by setting both `current_min` and `global_min` to the first element of the array.\n      |                                                          ^\ntest.cpp:24:64: error: stray \u2018`\u2019 in program\n   24 | 1. **Initialization**: Start by setting both `current_min` and `global_min` to the first element of the array.\n      |                                                                ^\ntest.cpp:24:75: error: stray \u2018`\u2019 in program\n   24 | 1. **Initialization**: Start by setting both `current_min` and `global_min` to the first element of the array.\n      |                                                                           ^\ntest.cpp:27:13: error: stray \u2018`\u2019 in program\n   27 |    - Update `current_min` to be the minimum of the current element itself or the sum of the current element and `current_min`.\n      |             ^\ntest.cpp:27:25: error: stray \u2018`\u2019 in program\n   27 |    - Update `current_min` to be the minimum of the current element itself or the sum of the current element and `current_min`.\n      |                         ^\ntest.cpp:27:113: error: stray \u2018`\u2019 in program\n   27 |    - Update `current_min` to be the minimum of the current element itself or the sum of the current element and `current_min`.\n      |                                                                                                                 ^\ntest.cpp:27:125: error: stray \u2018`\u2019 in program\n   27 |    - Update `current_min` to be the minimum of the current element itself or the sum of the current element and `current_min`.\n      |                                                                                                                             ^\ntest.cpp:28:22: error: stray \u2018`\u2019 in program\n   28 |    - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n      |                      ^\ntest.cpp:28:34: error: stray \u2018`\u2019 in program\n   28 |    - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n      |                                  ^\ntest.cpp:28:52: error: stray \u2018`\u2019 in program\n   28 |    - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n      |                                                    ^\ntest.cpp:28:63: error: stray \u2018`\u2019 in program\n   28 |    - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n      |                                                               ^\ntest.cpp:28:73: error: stray \u2018`\u2019 in program\n   28 |    - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n      |                                                                         ^\ntest.cpp:28:84: error: stray \u2018`\u2019 in program\n   28 |    - If this updated `current_min` is smaller than `global_min`, update `global_min`.\n      |                                                                                    ^\ntest.cpp:29:54: error: stray \u2018`\u2019 in program\n   29 | 3. **Result**: After iterating through all elements, `global_min` will hold the smallest sum of any contiguous subarray.\n      |                                                      ^\ntest.cpp:29:65: error: stray \u2018`\u2019 in program\n   29 | 3. **Result**: After iterating through all elements, `global_min` will hold the smallest sum of any contiguous subarray.\n      |                                                                 ^\ntest.cpp:33:1: error: stray \u2018##\u2019 in program\n   33 | ### Solution Code\n      | ^~\ntest.cpp:33:3: error: stray \u2018#\u2019 in program\n   33 | ### Solution Code\n      |   ^\ntest.cpp:19:1: error: \u2018To\u2019 does not name a type\n   19 | To solve this problem, we need to find the contiguous subarray within a given array that has the smallest sum. This is a classic problem in computer science and can be efficiently solved using a dynamic programming approach.\n      | ^~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/115", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total = 0;\n    for (auto& row : grid) {\n        int sum_water = 0;\n        for (int cell : row) {\n            sum_water += cell;\n        }\n        if (sum_water == 0) continue;\n        int times = (sum_water + capacity - 1) / capacity;\n        total += times;\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/118", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    c = tolower(c);\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nstring findClosestVowel(string word) {\n    for (int i = word.size() - 1; i >= 0; --i) {\n        if (isVowel(word[i])) {\n            // Check if it's not the first or last character\n            if (i > 0 && i < word.size() - 1) {\n                char prev = word[i-1];\n                char next = word[i+1];\n                if (!isVowel(prev) && !isVowel(next)) {\n                    return string(1, word[i]);\n                }\n            }\n        }\n    }\n    // If no such vowel found\n    return \"\";\n}\n\nstring get_closest_vowel(string word) {\n    for (int i = word.size() - 1; i >= 0; --i) {\n        if (isVowel(word[i])) {\n            // Check if it's not the first or last character\n            if (i > 0 && i < word.size() - 1) {\n                char prev = word[i-1];\n                char next = word[i+1];\n                if (!isVowel(prev) && !isVowel(next)) {\n                    return string(1, word[i]);\n                }\n            }\n        }\n    }\n    // If no such vowel found\n    return \"\";\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"full\") == \"u\");\n    assert (get_closest_vowel(\"easy\") == \"\");\n    assert (get_closest_vowel(\"eAsy\") == \"\");\n    assert (get_closest_vowel(\"ali\") == \"\");\n    assert (get_closest_vowel(\"bad\") == \"a\");\n    assert (get_closest_vowel(\"most\") ==\"o\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"ba\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n    assert (get_closest_vowel(\"anime\") == \"i\");\n    assert (get_closest_vowel(\"Asia\") == \"\");\n    assert (get_closest_vowel(\"Above\") == \"o\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/117", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <sstream>\n#include <cctype>\n#include <set>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) return result;\n\n    stringstream ss(s);\n    string word;\n    static const set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\n    while (ss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            char lower_c = tolower(c);\n            if (isalpha(c) && vowels.find(lower_c) == vowels.end()) {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n    assert (issame(select_words(\"\", 4) , {}));\n    assert (issame(select_words(\"a b c d e f\", 1) , {\"b\", \"c\", \"d\", \"f\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/119", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string &s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string order1 = lst[0] + lst[1];\n    string order2 = lst[1] + lst[0];\n    return is_balanced(order1) || is_balanced(order2) ? \"Yes\" : \"No\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n    assert (match_parens({\"(()(())\", \"())())\"}) == \"No\");\n    assert (match_parens({\")())\", \"(()()(\"}) == \"Yes\");\n    assert (match_parens({\"(())))\", \"(()())((\"}) == \"Yes\");\n    assert (match_parens({\"()\", \"())\"}) == \"No\");\n    assert (match_parens({\"(()(\", \"()))()\"}) == \"Yes\");\n    assert (match_parens({\"((((\", \"((())\"}) == \"No\");\n    assert (match_parens({\")(()\", \"(()(\"}) == \"No\");\n    assert (match_parens({\")(\", \")(\"}) == \"No\");\n    assert (match_parens({\"(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \"(\"}) == \"Yes\" );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/116", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // For sort\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), [&](int a, int b) {\n        // Count the number of '1's in binary representation\n        auto count_ones = [](int x) {\n            return __builtin_popcount(x); // Efficiently counts set bits\n        };\n        \n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n        \n        if (count_a == count_b) {\n            // If counts are equal, compare their original positions\n            // To find the original position of 'a' and 'b', we need to search in 'arr'\n            auto it_a = find(arr.begin(), arr.end(), a);\n            auto it_b = find(arr.begin(), arr.end(), b);\n            \n            return distance(arr.begin(), it_a) < distance(arr.begin(), it_b);\n        } else {\n            return count_a > count_b; // Higher count comes first\n        }\n    });\n    \n    return arr;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({2,5,77,4,5,3,5,7,2,3,4}) , {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}));\n    assert (issame(sort_array({3,6,44,12,32,5}) , {32, 3, 5, 6, 12, 44}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n}\n", "result": "failed: a.out: test.cpp:57: int main(): Assertion `issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/121", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solution({5, 8, 7, 1})    == 12);\n    assert (solution({3, 3, 3, 3, 3}) == 9);\n    assert (solution({30, 13, 24, 321}) == 0);\n    assert (solution({5, 9}) == 5);\n    assert (solution({2, 4, 8}) == 0);\n    assert (solution({30, 13, 23, 32}) == 23);\n    assert (solution({3, 13, 2, 9}) == 3);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/120", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    vector<int> result;\n    if (k == 0) return result;\n    \n    sort(arr.begin(), arr.end());\n    int n = arr.size();\n    for (int i = n - k; i < n; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n    assert (issame(maximum({123, -123, 20, 0 , 1, 2, -3}, 3) , {2, 20, 123}));\n    assert (issame(maximum({-123, 20, 0 , 1, 2, -3}, 4) , {0, 1, 2, 20}));\n    assert (issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7) , {-13, -8, 0, 0, 3, 5, 15}));\n    assert (issame(maximum({-1, 0, 2, 5, 3, -10}, 2) , {3, 5}));\n    assert (issame(maximum({1, 0, 5, -7}, 1) , {5}));\n    assert (issame(maximum({4, -4}, 2) , {-4, 4}));\n    assert (issame(maximum({-10, 10}, 2) , {-10, 10}));\n    assert (issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/122", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nint add_elements(const vector<int>& arr, int k) {\n    int total = 0;\n    for (int i = 0; i < k; ++i) {\n        if (abs(arr[i]) <= 99) {\n            total += arr[i];\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    assert (add_elements({111,121,3,4000,5,6}, 2) == 0);\n    assert (add_elements({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    assert (add_elements({1}, 1) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/124", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Implementation of the valid_date function goes here\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n", "result": "failed: a.out: test.cpp:27: int main(): Assertion `valid_date(\"03-11-2000\") == true' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/123", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    if (n % 2 != 0) {\n        odds.push_back(n);\n    }\n    \n    int current = n;\n    while (current != 1) {\n        if (current % 2 == 0) {\n            current /= 2;\n        } else {\n            current = 3 * current + 1;\n            if (current != 1 && current % 2 != 0) {\n                odds.push_back(current);\n            }\n        }\n    }\n    \n    sort(odds.begin(), odds.end());\n    return odds;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17}));\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n    assert (issame(get_odd_collatz(12) , {1, 3, 5}));\n    assert (issame(get_odd_collatz(1) , {1}));\n}\n", "result": "failed: a.out: test.cpp:55: int main(): Assertion `issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/125", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> split(const string &s, char delim) {\n    vector<string> res;\n    size_t pos = 0;\n    while (pos < s.length()) {\n        size_t next = s.find(delim, pos);\n        if (next == string::npos)\n            next = s.length();\n        string token = s.substr(pos, next - pos);\n        if (!token.empty())\n            res.push_back(token);\n        pos = next + 1;\n    }\n    return res;\n}\n\nvector<string> split_words(const string &s) {\n    // Check for spaces first\n    size_t space_pos = s.find(' ');\n    if (space_pos != string::npos) {\n        return split(s, ' ');\n    }\n    // If no spaces, check for commas\n    size_t comma_pos = s.find(',');\n    if (comma_pos != string::npos) {\n        return split(s, ',');\n    }\n    // If neither space nor comma is found, count the letters with odd ord\n    int count = 0;\n    for (char c : s) {\n        if (islower(c)) {\n            int ord = c - 'a';\n            if (ord % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return {to_string(count)};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (issame(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n    assert (issame(split_words(\"aaabb\") , {\"2\"}));\n    assert (issame(split_words(\"aaaBb\") , {\"1\"}));\n    assert (issame(split_words(\"\") ,{\"0\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/128", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_magnitude = 0;\n    bool has_zero = false;\n    int count_negatives = 0;\n\n    for (int num : arr) {\n        sum_magnitude += abs(num);\n        if (num == 0) {\n            has_zero = true;\n        }\n        if (num < 0) {\n            count_negatives++;\n        }\n    }\n\n    if (has_zero) {\n        return 0;\n    } else {\n        int product_signs = (count_negatives % 2 == 0) ? 1 : -1;\n        return sum_magnitude * product_signs;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);\n    assert (prod_signs({}) == -32768);\n    assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);\n    assert (prod_signs({-1, 1, -1, 1}) == 4);\n    assert (prod_signs({-1, 1, 1, 1}) == -4);\n    assert (prod_signs({-1, 1, 1, 0}) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/127", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm> // for max and min functions\n\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n    if (n == 2)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int a1 = interval1[0], b1 = interval1[1];\n    int a2 = interval2[0], b2 = interval2[1];\n\n    int max_start = max(a1, a2);\n    int min_end = min(b1, b2);\n\n    if (max_start > min_end) {\n        return \"NO\";\n    }\n\n    int len = min_end - max_start;\n\n    if (len < 2) {\n        return \"NO\";\n    }\n\n    return isPrime(len) ? \"YES\" : \"NO\";\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n    assert (intersection({-2, 2}, {-4, 0}) == \"YES\");\n    assert (intersection({-11, 2}, {-1, -1}) == \"NO\");\n    assert (intersection({1, 2}, {3, 5}) == \"NO\");\n    assert (intersection({1, 2}, {1, 2}) == \"NO\");\n    assert (intersection({-2, -2}, {-3, -2}) == \"NO\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/129", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nint minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    if (n == 0) return -1;\n    int m = grid[0].size();\n    \n    // Create a DP table with dimensions n x m\n    vector<vector<int>> dp(n, vector<int>(m));\n    \n    // Base case: when k=1, the smallest path is the value itself\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    \n    // For k >= 2, compute the DP table\n    if (k > 1) {\n        for (int step = 2; step <= k; ++step) {\n            vector<vector<int>> new_dp(n, vector<int>(m));\n            \n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    int min_val = INT_MAX;\n                    \n                    // Check all possible previous positions\n                    if (i > 0 && j > 0) {\n                        min_val = min(min_val, dp[i-1][j-1]);\n                    }\n                    if (i > 0 && j < m - 1) {\n                        min_val = min(min_val, dp[i-1][j+1]);\n                    }\n                    if (i < n - 1 && j > 0) {\n                        min_val = min(min_val, dp[i+1][j-1]);\n                    }\n                    if (i < n - 1 && j < m - 1) {\n                        min_val = min(min_val, dp[i+1][j+1]);\n                    }\n                    \n                    new_dp[i][j] = grid[i][j] + min_val;\n                }\n            }\n            \n            // Update the DP table for next iteration\n            dp = new_dp;\n        }\n    }\n    \n    // Find the minimum value in the last step of DP table\n    int result = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (dp[i][j] < result) {\n                result = dp[i][j];\n            }\n        }\n    }\n    \n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n", "result": "failed: compilation error: In file included from test.cpp:82:\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:92:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [3]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{1, 2, 3})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{4, 5, 6})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{7, 8, 9})), 3}, std::allocator<int>())})), 3}, std::allocator<std::vector<int> >()), 3)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   92 |     assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:93:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [3]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{5, 9, 3})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{4, 1, 6})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{7, 8, 2})), 3}, std::allocator<int>())})), 3}, std::allocator<std::vector<int> >()), 1)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   93 |     assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:94:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [4]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{1, 2, 3, 4})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{5, 6, 7, 8})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{9, 10, 11, 12})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{13, 14, 15, 16})), 4}, std::allocator<int>())})), 4}, std::allocator<std::vector<int> >()), 4)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   94 |     assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:95:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [4]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{6, 4, 13, 10})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{5, 7, 12, 1})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{3, 16, 11, 15})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{8, 14, 9, 2})), 4}, std::allocator<int>())})), 4}, std::allocator<std::vector<int> >()), 7)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   95 |     assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:96:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [4]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{8, 14, 9, 2})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{6, 4, 13, 15})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{5, 7, 1, 12})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{3, 10, 11, 16})), 4}, std::allocator<int>())})), 4}, std::allocator<std::vector<int> >()), 5)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   96 |     assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:97:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [4]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{11, 8, 7, 2})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{5, 16, 14, 4})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{9, 3, 15, 6})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{12, 13, 10, 1})), 4}, std::allocator<int>())})), 4}, std::allocator<std::vector<int> >()), 9)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   97 |     assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:98:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [4]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{12, 13, 10, 1})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{9, 3, 15, 6})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{5, 16, 14, 4})), 4}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [4]{11, 8, 7, 2})), 4}, std::allocator<int>())})), 4}, std::allocator<std::vector<int> >()), 12)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   98 |     assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:99:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [3]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{2, 7, 4})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{3, 1, 5})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{6, 8, 9})), 3}, std::allocator<int>())})), 3}, std::allocator<std::vector<int> >()), 8)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n   99 |     assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:100:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [3]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{6, 1, 5})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{3, 8, 9})), 3}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [3]{2, 7, 4})), 3}, std::allocator<int>())})), 3}, std::allocator<std::vector<int> >()), 8)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n  100 |     assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:101:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [2]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [2]{1, 2})), 2}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [2]{3, 4})), 2}, std::allocator<int>())})), 2}, std::allocator<std::vector<int> >()), 10)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n  101 |     assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\ntest.cpp:102:27: error: could not convert \u2018minPath(std::vector<std::vector<int> >(std::initializer_list<std::vector<int> >{((const std::vector<int>*)(& const std::vector<int> [2]{std::vector<int>(std::initializer_list<int>{((const int*)(& const int [2]{1, 3})), 2}, std::allocator<int>()), std::vector<int>(std::initializer_list<int>{((const int*)(& const int [2]{3, 2})), 2}, std::allocator<int>())})), 2}, std::allocator<std::vector<int> >()), 10)\u2019 from \u2018int\u2019 to \u2018std::vector<int>\u2019\n  102 |     assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n      |                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n      |                           |\n      |                           int\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/126", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in non-decreasing order\n    for (int i = 0; i < static_cast<int>(lst.size()) - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Count frequency of each element\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    // Check if any element appears more than twice\n    for (const auto& pair : freq) {\n        if (pair.second > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({}) == true);\n    assert (is_sorted({1}) == true);\n    assert (is_sorted({3, 2, 1}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 3, 3, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert (is_sorted({1, 2, 3, 4}) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/130", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    // This function computes the Tribonacci sequence up to the nth term.\n    // The sequence starts with specific initial values and follows different rules for even and odd indices.\n\n    // Base cases:\n    if (n == 0) return {};\n    vector<int> result;\n    result.push_back(1); // tri(1) = 3\n    if (n >= 1) result.push_back(2); // tri(2) = 2\n\n    // Determine the maximum index needed based on whether n is even or odd.\n    int max_index = (n % 2 == 0) ? n : n + 1;\n\n    // Compute all even-indexed terms first.\n    for (int i = 4; i <= max_index; i += 2) {\n        result.push_back(1 + (i / 2));\n    }\n\n    // Compute each odd-indexed term using previously computed values.\n    for (int i = 3; i <= n; i += 2) {\n        int sum = 0;\n        for (int j = 1; j <= i - 1; ++j) {\n            if (j % 2 == 0 || (j + 1) > i / 2) {\n                sum += result[j - 1];\n            }\n        }\n        result.push_back(sum);\n    }\n\n    // Adjust the size of the result to match n.\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n    assert (issame(tri(4) , {1, 3, 2, 8, 3}));\n    assert (issame(tri(5) , {1, 3, 2, 8, 3, 15}));\n    assert (issame(tri(6) , {1, 3, 2, 8, 3, 15, 4}));\n    assert (issame(tri(7) , {1, 3, 2, 8, 3, 15, 4, 24}));\n    assert (issame(tri(8) , {1, 3, 2, 8, 3, 15, 4, 24, 5}));\n    assert (issame(tri(9) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35}));\n    assert (issame(tri(20) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11}));\n    assert (issame(tri(0) , {1}));\n    assert (issame(tri(1) , {1, 3}));\n}\n", "result": "failed: a.out: test.cpp:66: int main(): Assertion `issame(tri(3) , {1, 3, 2, 8})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/131", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string s = to_string(n);\n    int product = 1;\n    bool hasOdd = false;\n    \n    for (char c : s) {\n        int d = c - '0';\n        if (d % 2 != 0) {\n            product *= d;\n            hasOdd = true;\n        }\n    }\n    \n    return hasOdd ? product : 0;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(5) == 5);\n    assert (digits(54) == 5);\n    assert (digits(120) ==1);\n    assert (digits(5014) == 5);\n    assert (digits(98765) == 315);\n    assert (digits(5576543) == 2625);\n    assert (digits(2468) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/135", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,4,5})==-1);\n    assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);\n    assert (can_arrange({4,8,5,7,3})==4);\n    assert (can_arrange({})==-1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/132", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n\nusing namespace std;\n\nbool is_nested(string str) {\n    int count = 0;\n    bool has_nested = false;\n    for (char c : str) {\n        if (c == '[') {\n            count++;\n        } else if (c == ']') {\n            count--;\n            if (count > 0) {\n                has_nested = true;\n                break; // Early exit once nesting is found\n            }\n        }\n    }\n    return has_nested;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested((\"[]\")) == false);\n    assert (is_nested(\"[[[[]]]]\") == true);\n    assert (is_nested(\"[]]]]]]]]]]\") == false);\n    assert (is_nested(\"[][][[]]\") == true);\n    assert (is_nested(\"[[]\") == false);\n    assert (is_nested(\"[]]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n    assert (is_nested(\"\") == false);\n    assert (is_nested(\"[[[[[[[[\") == false);\n    assert (is_nested(\"]]]]]]]]\") == false);\n}\n", "result": "failed: a.out: test.cpp:49: int main(): Assertion `is_nested(\"[[]\") == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/133", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int total = 0;\n    for (float num : lst) {\n        int ceiled = ceil(num);\n        total += ceiled * ceiled;\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1.0,2,3})==14);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n    assert (sum_squares({100,1,15,2})==10230);\n    assert (sum_squares({10000,10000})==200000000);\n    assert (sum_squares({-1.4,4.6,6.3})==75);\n    assert (sum_squares({-1.4,17.9,18.9,19.9})==1086);\n    assert (sum_squares({0})==0);\n    assert (sum_squares({-1})==1);\n    assert (sum_squares({-1,1,0})==2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/134", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Remove leading and trailing whitespace from the input string\n    size_t start = txt.find_first_not_of(\" \");\n    if (start == string::npos) return false;\n    size_t end = txt.find_last_not_of(\" \");\n    txt = txt.substr(start, end - start + 1);\n    \n    // If the trimmed string is empty, return false\n    if (txt.empty()) return false;\n    \n    // Check if the last character is a letter\n    char last_char = txt.back();\n    if (!isalpha(last_char)) return false;\n    \n    // If there's only one character and it's a letter, return true\n    if (txt.size() == 1) return true;\n    \n    // Check the previous character to ensure it's not a letter\n    char prev_char = txt[txt.size() - 2];\n    return !isalpha(prev_char);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"eeeee\") == false);\n    assert (check_if_last_char_is_a_letter(\"A\") == true);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie \") == false);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie 1\") == false);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"eeeee e \") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "result": "failed: a.out: test.cpp:52: int main(): Assertion `check_if_last_char_is_a_letter(\"eeeee e \") == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/136", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_neg = INT_MIN;\n    bool has_negative = false;\n\n    int min_pos = INT_MAX;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > max_neg) {\n                max_neg = num;\n            }\n            has_negative = true;\n        } else if (num > 0) {\n            if (num < min_pos) {\n                min_pos = num;\n            }\n            has_positive = true;\n        }\n    }\n\n    int a = has_negative ? max_neg : 0;\n    int b = has_positive ? min_pos : 0;\n\n    return {a, b};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7, 0}) , {0, 1}));\n    assert (issame(largest_smallest_integers({1, 3, 2, 4, 5, 6, -2}) , {-2, 1}));\n    assert (issame(largest_smallest_integers({4, 5, 3, 6, 2, 7, -7}) , {-7, 2}));\n    assert (issame(largest_smallest_integers({7, 3, 8, 4, 9, 2, 5, -9}) , {-9, 2}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6, 0}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, 1}) , {-3, 1}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, -100, 1}) , {-3, 1}));\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/137", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <boost/any.hpp>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\ndouble get_numeric_value(const boost::any& x) {\n    if (x.type() == typeid(int)) {\n        return static_cast<double>(boost::any_cast<int>(x));\n    } else if (x.type() == typeid(double)) {\n        return boost::any_cast<double>(x);\n    } else if (x.type() == typeid(float)) {\n        return static_cast<double>(boost::any_cast<float>(x));\n    } else if (x.type() == typeid(string)) {\n        string s = boost::any_cast<string>(x);\n        size_t pos;\n        double val = stod(s, &pos);\n        if (pos != s.size()) {\n            // Check for commas and replace\n            string temp = s.substr(pos);\n            if (temp.find(',') != string::npos) {\n                string new_s = s.substr(0, pos) + \".\" + temp;\n                return stod(new_s);\n            }\n        }\n        return val;\n    } else {\n        throw invalid_argument(\"Invalid type for numeric conversion\");\n    }\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double a_val = get_numeric_value(a);\n    double b_val = get_numeric_value(b);\n\n    if (a_val == b_val) {\n        return boost::any(string(\"None\"));\n    } else if (a_val > b_val) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/138", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and even\n    return (n >= 8 && n % 2 == 0);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n    assert (is_equal_to_sum_even(10) == true);\n    assert (is_equal_to_sum_even(11) == false);\n    assert (is_equal_to_sum_even(12) == true);\n    assert (is_equal_to_sum_even(13) == false);\n    assert (is_equal_to_sum_even(16) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/139", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n\nusing namespace std;\n\nlong long special_factorial(int n) {\n    if (n < 1) {\n        return 0;\n    }\n    long long result = 1;\n    long long current_fact = 1;\n    for (int k = 1; k <= n; ++k) {\n        current_fact *= k;\n        result *= current_fact;\n    }\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n    assert (special_factorial(5) == 34560);\n    assert (special_factorial(7) == 125411328000);\n    assert (special_factorial(1) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/140", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    for (int i = 0; i < text.size(); ++i) {\n        if (text[i] == ' ' || text[i] == '\\t') {\n            text[i] = '_';\n        }\n    }\n    return text;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Mudasir Hanif \") == \"Mudasir_Hanif_\");\n    assert (fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\");\n    assert (fix_spaces(\"Exa   mple\") == \"Exa-mple\");\n    assert (fix_spaces(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\n", "result": "failed: a.out: test.cpp:35: int main(): Assertion `fix_spaces(\"Exa   mple\") == \"Exa-mple\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/144", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nvoid parseFraction(const string &s, long long &num, long long &den) {\n    size_t slashPos = s.find('/');\n    if (slashPos == string::npos) {\n        num = stoll(s);\n        den = 1;\n    } else {\n        string numStr = s.substr(0, slashPos);\n        string denStr = s.substr(slashPos + 1);\n        num = stoll(numStr);\n        den = stoll(denStr);\n    }\n}\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        swap(a, b);\n        b %= a;\n    }\n    return a;\n}\n\nvoid simplify(long long &num, long long &den) {\n    if (den == 0) {\n        return; // Handle error case\n    }\n    long long g = gcd(abs(num), abs(den));\n    num /= g;\n    den /= g;\n    if (den < 0) {\n        num *= -1;\n        den *= -1;\n    }\n}\n\nbool isProductInteger(const string &x_str, const string &n_str) {\n    long long x_num, x_den;\n    parseFraction(x_str, x_num, x_den);\n    if (x_num == 0) {\n        return true; // Anything multiplied by zero is integer\n    }\n    simplify(x_num, x_den);\n\n    long long n_num, n_den;\n    parseFraction(n_str, n_num, n_den);\n    if (n_num == 0) {\n        return true;\n    }\n    simplify(n_num, n_den);\n\n    long long product_num = x_num * n_num;\n    long long product_den = x_den * n_den;\n\n    // Check divisibility\n    return (product_num % product_den) == 0;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"5/1\", \"3/1\") == true);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n    assert (simplify(\"2/10\", \"50/10\") == true);\n    assert (simplify(\"7/2\", \"4/2\") == true);\n    assert (simplify(\"11/6\", \"6/1\") == true);\n    assert (simplify(\"2/3\", \"5/2\") == false);\n    assert (simplify(\"5/2\", \"3/5\") == false);\n    assert (simplify(\"2/4\", \"8/4\") == true);\n    assert (simplify(\"2/4\", \"4/2\") == true);\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/5\", \"1/5\") == false);\n}\n", "result": "failed: compilation error: In file included from test.cpp:78:\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:80:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   80 |     assert (simplify(\"1/5\", \"5/1\") == true);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:80:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"1/5\")\u2019 to \u2018long long int&\u2019\n   80 |     assert (simplify(\"1/5\", \"5/1\") == true);\n      |                      ^~~~~\ntest.cpp:81:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   81 |     assert (simplify(\"1/6\", \"2/1\") == false);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:81:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"1/6\")\u2019 to \u2018long long int&\u2019\n   81 |     assert (simplify(\"1/6\", \"2/1\") == false);\n      |                      ^~~~~\ntest.cpp:82:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   82 |     assert (simplify(\"5/1\", \"3/1\") == true);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:82:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"5/1\")\u2019 to \u2018long long int&\u2019\n   82 |     assert (simplify(\"5/1\", \"3/1\") == true);\n      |                      ^~~~~\ntest.cpp:83:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   83 |     assert (simplify(\"7/10\", \"10/2\") == false);\n      |                      ^~~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:83:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"7/10\")\u2019 to \u2018long long int&\u2019\n   83 |     assert (simplify(\"7/10\", \"10/2\") == false);\n      |                      ^~~~~~\ntest.cpp:84:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   84 |     assert (simplify(\"2/10\", \"50/10\") == true);\n      |                      ^~~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:84:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"2/10\")\u2019 to \u2018long long int&\u2019\n   84 |     assert (simplify(\"2/10\", \"50/10\") == true);\n      |                      ^~~~~~\ntest.cpp:85:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   85 |     assert (simplify(\"7/2\", \"4/2\") == true);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:85:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"7/2\")\u2019 to \u2018long long int&\u2019\n   85 |     assert (simplify(\"7/2\", \"4/2\") == true);\n      |                      ^~~~~\ntest.cpp:86:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   86 |     assert (simplify(\"11/6\", \"6/1\") == true);\n      |                      ^~~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:86:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"11/6\")\u2019 to \u2018long long int&\u2019\n   86 |     assert (simplify(\"11/6\", \"6/1\") == true);\n      |                      ^~~~~~\ntest.cpp:87:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   87 |     assert (simplify(\"2/3\", \"5/2\") == false);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:87:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"2/3\")\u2019 to \u2018long long int&\u2019\n   87 |     assert (simplify(\"2/3\", \"5/2\") == false);\n      |                      ^~~~~\ntest.cpp:88:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   88 |     assert (simplify(\"5/2\", \"3/5\") == false);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:88:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"5/2\")\u2019 to \u2018long long int&\u2019\n   88 |     assert (simplify(\"5/2\", \"3/5\") == false);\n      |                      ^~~~~\ntest.cpp:89:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   89 |     assert (simplify(\"2/4\", \"8/4\") == true);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:89:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"2/4\")\u2019 to \u2018long long int&\u2019\n   89 |     assert (simplify(\"2/4\", \"8/4\") == true);\n      |                      ^~~~~\ntest.cpp:90:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   90 |     assert (simplify(\"2/4\", \"4/2\") == true);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:90:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"2/4\")\u2019 to \u2018long long int&\u2019\n   90 |     assert (simplify(\"2/4\", \"4/2\") == true);\n      |                      ^~~~~\ntest.cpp:91:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   91 |     assert (simplify(\"1/5\", \"5/1\") == true);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:91:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"1/5\")\u2019 to \u2018long long int&\u2019\n   91 |     assert (simplify(\"1/5\", \"5/1\") == true);\n      |                      ^~~~~\ntest.cpp:92:22: error: invalid conversion from \u2018const char*\u2019 to \u2018long long int\u2019 [-fpermissive]\n   92 |     assert (simplify(\"1/5\", \"1/5\") == false);\n      |                      ^~~~~\n      |                      |\n      |                      const char*\ntest.cpp:41:26: note:   initializing argument 1 of \u2018void simplify(long long int&, long long int&)\u2019\n   41 | void simplify(long long &num, long long &den) {\n      |               ~~~~~~~~~~~^~~\nIn file included from test.cpp:78:\ntest.cpp:92:22: error: cannot bind rvalue \u2018(long long int)((const char*)\"1/5\")\u2019 to \u2018long long int&\u2019\n   92 |     assert (simplify(\"1/5\", \"1/5\") == false);\n      |                      ^~~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/141", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the filename\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check that the name part is not empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Convert extension to lowercase for uniform comparison\n    transform(ext_part.begin(), ext_part.end(), ext_part.begin(), ::tolower);\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the entire filename and ensure it's <= 3\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n            if (digit_count > 3) {\n                return \"No\";\n            }\n        }\n    }\n\n    // All checks passed\n    return \"Yes\";\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n    assert (file_name_check(\"s1sdf3.asd\") == \"No\");\n    assert (file_name_check(\"K.dll\") == \"Yes\");\n    assert (file_name_check(\"MY16FILE3.exe\") == \"Yes\");\n    assert (file_name_check(\"His12FILE94.exe\") == \"No\");\n    assert (file_name_check(\"_Y.txt\") == \"No\");\n    assert (file_name_check(\"?aREYA.exe\") == \"No\");\n    assert (file_name_check(\"/this_is_valid.dll\") == \"No\");\n    assert (file_name_check(\"this_is_valid.wow\") == \"No\");\n    assert (file_name_check(\"this_is_valid.txt\") == \"Yes\");\n    assert (file_name_check(\"this_is_valid.txtexe\") == \"No\");\n    assert (file_name_check(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert (file_name_check(\"@this1_is6_valid.exe\") == \"No\");\n    assert (file_name_check(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert (file_name_check(\"all.exe.txt\") == \"No\");\n    assert (file_name_check(\"I563_No.exe\") == \"Yes\");\n    assert (file_name_check(\"Is3youfault.txt\") == \"Yes\");\n    assert (file_name_check(\"no_one#knows.dll\") == \"Yes\");\n    assert (file_name_check(\"1I563_Yes3.exe\") == \"No\");\n    assert (file_name_check(\"I563_Yes3.txtt\") == \"No\");\n    assert (file_name_check(\"final..txt\") == \"No\");\n    assert (file_name_check(\"final132\") == \"No\");\n    assert (file_name_check(\"_f4indsartal132.\") == \"No\");\n    assert (file_name_check(\".txt\") == \"No\");\n    assert (file_name_check(\"s.\") == \"No\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/142", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        int num = lst[i];\n        if (i % 3 == 0) {\n            total += num * num;\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total += num * num * num;\n        } else {\n            total += num;\n        }\n    }\n    return total;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/143", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    \n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    vector<string> resultWords;\n    for (const auto& w : words) {\n        int len = w.length();\n        if (isPrime(len)) {\n            resultWords.push_back(w);\n        }\n    }\n    \n    string output;\n    for (size_t i = 0; i < resultWords.size(); ++i) {\n        if (i != 0) {\n            output += \" \";\n        }\n        output += resultWords[i];\n    }\n    \n    return output;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert (words_in_sentence(\"there is no place available here\") == \"there is no place\");\n    assert (words_in_sentence(\"Hi I am Hussein\") == \"Hi am Hussein\");\n    assert (words_in_sentence(\"go for it\") == \"go for it\");\n    assert (words_in_sentence(\"here\") == \"\");\n    assert (words_in_sentence(\"here is\") == \"is\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/146", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string s = to_string(abs(num));\n            char first = s[0];\n            char last = s.back();\n            int fdigit = first - '0';\n            int ldigit = last - '0';\n            if ((fdigit % 2 == 1) && (ldigit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({5, -2, 1, -5}) == 0  );\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    assert (specialFilter({43, -12, 93, 125, 121, 109}) == 4);\n    assert (specialFilter({71, -2, -33, 75, 21, 19}) == 3);\n    assert (specialFilter({1}) == 0              );\n    assert (specialFilter({}) == 0                   );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/145", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint compute_digit_sum(int x) {\n    int n = abs(x);\n    if (n == 0) return 0;\n    vector<int> digits;\n    while (n > 0) {\n        digits.push_back(n % 10);\n        n /= 10;\n    }\n    int sum = 0;\n    for (int d : digits) {\n        sum += d;\n    }\n    if (x < 0 && !digits.empty()) {\n        sum -= digits[0];\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({compute_digit_sum(nums[i]), i});\n    }\n\n    sort(indexed_nums.begin(), indexed_nums.end(),\n         [](const pair<int, int>& a, const pair<int, int>& b) {\n             if (a.first == b.first) {\n                 return a.second < b.second;\n             }\n             return a.first < b.first;\n         });\n\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(nums[p.second]);\n    }\n\n    return result;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (issame(order_by_points({}) , {}));\n    assert (issame(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (issame(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (issame(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n", "result": "failed: a.out: test.cpp:73: int main(): Assertion `issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/147", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Count how many indices give remainder 2 when divided by 3 (group1)\n    // and others (group2)\n    int group1 = 0, group2 = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 3 == 2) {\n            ++group1;\n        } else {\n            ++group2;\n        }\n    }\n    \n    // Compute the number of triplets from each group\n    int count_group1 = group1 >= 3 ? (group1 * (group1 - 1) * (group1 - 2)) / 6 : 0;\n    int count_group2 = group2 >= 3 ? (group2 * (group2 - 1) * (group2 - 2)) / 6 : 0;\n    \n    return count_group1 + count_group2;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_max_triples(5) == 1);\n    assert (get_max_triples(6) == 4);\n    assert (get_max_triples(10) == 36);\n    assert (get_max_triples(100) == 53361);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/149", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n    // Filter out strings with odd lengths\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {\n            filtered.push_back(str);\n        }\n    }\n    // Sort the filtered list by length and then alphabetically\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return filtered;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (issame(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (issame(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (issame(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/150", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n\nusing namespace std;\n\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    // Further implementation details...\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n    assert (x_or_y(3, 33, 5212) == 33);\n    assert (x_or_y(1259, 3, 52) == 3);\n    assert (x_or_y(7919, -1, 12) == -1);\n    assert (x_or_y(3609, 1245, 583) == 583);\n    assert (x_or_y(91, 56, 129) == 129);\n    assert (x_or_y(6, 34, 1234) == 1234);\n    assert (x_or_y(1, 2, 0) == 0);\n    assert (x_or_y(2, 2, 0) == 2);\n}\n", "result": "failed: a.out: test.cpp:32: int main(): Assertion `x_or_y(7, 34, 12) == 34' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/151", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_squares = 0;\n    for (float num : lst) {\n        if (num <= 0) continue;\n        if (num != static_cast<int>(num)) continue;\n        int n = static_cast<int>(num);\n        if (n % 2 != 0) {\n            sum_squares += n * n;\n        }\n    }\n    return sum_squares;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({}) == 0);\n    assert (double_the_difference({5, 4}) == 25);\n    assert (double_the_difference({0.1, 0.2, 0.3}) == 0 );\n    assert (double_the_difference({-10, -20, -30}) == 0 );\n    assert (double_the_difference({-1, -2, 8}) == 0);\n    assert (double_the_difference({0.2, 3, 5}) == 34);\n    \n    \n    long long odd_sum=0;\n    vector<float> lst={};\n\n    for (int i=-99;i<100;i+=2)\n    {\n        lst.push_back(i+0.0);\n        if (i>0 and i%2==1) odd_sum+=i*i;\n    }\n  \n    assert (double_the_difference(lst) == odd_sum );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/148", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Function implementation here...\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    assert (issame(bf(\"Neptune\", \"Venus\") , {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Earth\") , {}));\n    assert (issame(bf(\"Mars\", \"Earth\") , {}));\n    assert (issame(bf(\"Jupiter\", \"Makemake\") , {}));\n}\n", "result": "failed: a.out: test.cpp:36: int main(): Assertion `issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/152", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,0,0,0,0,0},{0,0,0,0,0,0}),{0,0,0,0,0,0}));\n    assert (issame(compare({1,2,3},{-1,-2,-3}),{2,4,6}));\n    assert (issame(compare({1,2,3,5},{-1,2,3,4}),{2,0,0,1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/154", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n\n    if (len_b == 0) {\n        return true;\n    }\n\n    if (len_b > len_a) {\n        return false;\n    }\n\n    for (int i = 0; i < len_b; ++i) {\n        string rot = b.substr(i) + b.substr(0, i);\n        size_t pos = a.find(rot);\n        if (pos != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"xyzw\",\"xyw\") == false );\n    assert  (cycpattern_check(\"yello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whattup\",\"ptut\") == false );\n    assert  (cycpattern_check(\"efef\",\"fee\") == true );\n    assert  (cycpattern_check(\"abab\",\"aabb\") == false );\n    assert  (cycpattern_check(\"winemtt\",\"tinem\") == true );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/153", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_ext;\n\n    for (auto &ext : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : ext) {\n            if (isupper(c)) cap++;\n            else if (islower(c)) sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_ext;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"Watashi\", {\"tEN\", \"niNE\", \"eIGHt8OKe\"}) == \"Watashi.eIGHt8OKe\");\n    assert (Strongest_Extension(\"Boku123\", {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}) == \"Boku123.YEs.WeCaNe\");\n    assert (Strongest_Extension(\"__YESIMHERE\", {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}) == \"__YESIMHERE.NuLl__\");\n    assert (Strongest_Extension(\"K\", {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}) == \"K.TAR\");\n    assert (Strongest_Extension(\"__HAHA\", {\"Tab\", \"123\", \"781345\", \"-_-\"}) == \"__HAHA.123\");\n    assert (Strongest_Extension(\"YameRore\", {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}) == \"YameRore.okIWILL123\");\n    assert (Strongest_Extension(\"finNNalLLly\", {\"Die\", \"NowW\", \"Wow\", \"WoW\"}) == \"finNNalLLly.WoW\");\n    assert (Strongest_Extension(\"_\", {\"Bb\", \"91245\"}) == \"_.Bb\");\n    assert (Strongest_Extension(\"Sp\", {\"671235\", \"Bb\"}) == \"Sp.671235\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/155", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cstdlib> // For std::abs\n#include <string>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    string number_str = to_string(abs(num));\n    \n    for (char c : number_str) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(7) , {0, 1}));\n    assert (issame(even_odd_count(-78) , {1, 1}));\n    assert (issame(even_odd_count(3452) , {2, 2}));\n    assert (issame(even_odd_count(346211) , {3, 3}));\n    assert (issame(even_odd_count(-345821) , {3, 3}));\n    assert (issame(even_odd_count(-2) , {1, 0}));\n    assert (issame(even_odd_count(-45347) , {2, 3}));\n    assert (issame(even_odd_count(0) , {1, 0}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/157", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <cmath> // For sqrt and pow functions\n\nbool right_angle_triangle(float a, float b, float c) {\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n    \n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sorts the array in ascending order\n    float x = sides[0];\n    float y = sides[1];\n    float z = sides[2];\n    \n    if (x + y <= z) {\n        return false;\n    }\n    \n    // Calculate squares with consideration for floating-point precision\n    float x_sq = static_cast<float>(std::pow(x, 2));\n    float y_sq = static_cast<float>(std::pow(y, 2));\n    float z_sq = static_cast<float>(std::pow(z, 2));\n    \n    // Check if the sum of squares of x and y is approximately equal to z squared\n    return std::abs(x_sq + y_sq - z_sq) < 1e-6;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n    assert (right_angle_triangle(10, 6, 8) == true);\n    assert (right_angle_triangle(2, 2, 2) == false);\n    assert (right_angle_triangle(7, 24, 25) == true);\n    assert (right_angle_triangle(10, 5, 7) == false);\n    assert (right_angle_triangle(5, 12, 13) == true);\n    assert (right_angle_triangle(15, 8, 17) == true);\n    assert (right_angle_triangle(48, 55, 73) == true);\n    assert (right_angle_triangle(1, 1, 1) == false);\n    assert (right_angle_triangle(2, 2, 10) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/156", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"},\n        {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"},\n        {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\n        {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n    \n    string result = \"\";\n    \n    for (auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    \n    // Convert to lowercase\n    for (char& c : result) {\n        c = tolower(c);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_roman(19) == \"xix\");\n    assert (int_to_mini_roman(152) == \"clii\");\n    assert (int_to_mini_roman(251) == \"ccli\");\n    assert (int_to_mini_roman(426) == \"cdxxvi\");\n    assert (int_to_mini_roman(500) == \"d\");\n    assert (int_to_mini_roman(1) == \"i\");\n    assert (int_to_mini_roman(4) == \"iv\");\n    assert (int_to_mini_roman(43) == \"xliii\");\n    assert (int_to_mini_roman(90) == \"xc\");\n    assert (int_to_mini_roman(94) == \"xciv\");\n    assert (int_to_mini_roman(532) == \"dxxxii\");\n    assert (int_to_mini_roman(900) == \"cm\");\n    assert (int_to_mini_roman(994) == \"cmxciv\");\n    assert (int_to_mini_roman(1000) == \"m\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/158", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    // Function implementation here\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n    assert ((find_max({\"abc\", \"cba\"}) == \"abc\"));\n    assert ((find_max({\"play\", \"this\", \"game\", \"of\",\"footbott\"}) == \"footbott\"));\n    assert ((find_max({\"we\", \"are\", \"gonna\", \"rock\"}) == \"gonna\"));\n    assert ((find_max({\"we\", \"are\", \"a\", \"mad\", \"nation\"}) == \"nation\"));\n    assert ((find_max({\"this\", \"is\", \"a\", \"prrk\"}) == \"this\"));\n    assert ((find_max({\"b\"}) == \"b\"));\n    assert ((find_max({\"play\", \"play\", \"play\"}) == \"play\"));\n}\n", "result": "failed: a.out: test.cpp:30: int main(): Assertion `(find_max({\"name\", \"of\", \"string\"}) == \"string\")' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/159", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <vector>\n#include <algorithm> // For std::min\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    int amount = std::min(need, remaining);\n    int total_eaten = number + amount;\n    int left = remaining - amount;\n    return {total_eaten, left};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n    \n    assert (issame(eat(4, 5, 7) , {9, 2}));\n    assert (issame(eat(4, 5, 1) , {5, 0}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/161", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    string result;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n            hasLetters = true;\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetters) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"AsDf\") == \"aSdF\");\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n    assert (solve(\"#AsdfW^45\") == \"#aSDFw^45\");\n    assert (solve(\"#6@2\") == \"2@6#\");\n    assert (solve(\"#$a^D\") == \"#$A^d\");\n    assert (solve(\"#ccc\") == \"#CCC\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/160", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n\nint do_algebra(vector<string> operato, vector<int> operand){\n    /* The postfix notation for the given expression is:\n\n    3 4 2 * 1 5 - ^ / +\n\n    Step-by-step explanation:\n\n    1. **Token '3'**: Output: [3]\n    2. **Token '+'**: Stack becomes ['+']\n    3. **Token '4'**: Output: [3, 4]\n    4. **Token '*'**: Push to stack (higher precedence than '+'). Stack: ['+', '*']\n    5. **Token '2'**: Output: [3, 4, 2]\n    6. **Token '/'**: Same precedence as '*', pop '*' and output. Then push '/'. Stack: ['+', '/']\n    7. **Token '('**: Push to stack. Stack: ['+', '/', '(']\n    8. **Token '1'**: Output: [3, 4, 2, *, 1]\n    9. **Token '-'**: Push to stack (inside parentheses). Stack: ['+', '/', '(', '-']\n    10. **Token '5'**: Output: [3, 4, 2, *, 1, 5]\n    11. **Token ')'**: Pop '-' and output. Stack becomes ['+', '/']\n    12. **Token '^'**: Higher precedence than '/', push to stack. Stack: ['+', '/', '^']\n    13. **Token '2'**: Output: [3, 4, 2, *, 1, 5, -, 2]\n    14. **End of tokens**: Pop remaining operators in order: ^, /, +.\n\n    Final postfix expression:\n\n    3 4 2 * 1 5 - ^ / + */\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n", "result": "failed: a.out: test.cpp:56: int main(): Assertion `do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/162", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <openssl/md5.h>\n#include <string>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Function implementation here\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert (string_to_md5(\"\") == \"None\");\n    assert (string_to_md5(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert (string_to_md5(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n", "result": "failed: ", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/163", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    for (int num = min(a, b); num <= max(a, b); ++num) {\n        int digit;\n        while (num > 0) {\n            digit = num % 10;\n            if (digit % 2 == 0 && digit != 0) { // Check if the digit is even and not zero\n                result.push_back(digit);\n            }\n            num /= 10;\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(17,89) , {}));\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
