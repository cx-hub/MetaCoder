{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < numbers.size(); ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> splitBalancedParentheses(string s) {\n    // Remove all spaces from the input string\n    string cleaned;\n    for (char c : s) {\n        if (c != ' ') {\n            cleaned.push_back(c);\n        }\n    }\n\n    vector<string> result;\n    int start = 0;\n    int balance = 0;\n\n    for (int i = 0; i < cleaned.size(); ++i) {\n        char c = cleaned[i];\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n\n        // When balance is zero, we found a complete group\n        if (balance == 0) {\n            result.push_back(cleaned.substr(start, i - start + 1));\n            start = i + 1; // Move to the next character for the next group\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <cmath> // Include cmath for modf function\n\nfloat truncate_number(float number) {\n    double d = number; // Convert float to double for higher precision\n    double fractional_part;\n    int integer_part;\n    modf(d, &integer_part); // Split into integer and fractional parts\n    return (float)fractional_part; // Convert back to float before returning\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int current_balance = 0;\n    for (int op : operations) {\n        current_balance += op;\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0f; // Handle empty vector case\n    \n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n    float mad_sum = 0.0f;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    return mad_sum / n;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<string> groups;\n    istringstream iss(paren_string);\n    string group;\n    \n    // Split the input string into individual groups\n    while (iss >> group) {\n        groups.push_back(group);\n    }\n    \n    vector<int> result;\n    \n    for (auto &grp : groups) {\n        int current_depth = 0;\n        int max_depth = 0;\n        for (char c : grp) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filterStrings(const vector<string>& input, const string& substring) {\n    vector<string> result;\n    size_t pos = 0;\n    for (const string& s : input) {\n        pos = s.find(substring);\n        if (pos != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    \n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result; // Return empty vector if input is empty\n    }\n    int max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n        }\n        result.push_back(max_so_far);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string.h>\n\n"}
{"task_id": "CPP/11", "generation": "#include <algorithm> // For std::max\n\nstring string_xor(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad both strings with leading zeros to make them of length max_len\n    string padded_a = a;\n    if (len_a < max_len) {\n        int zeros_needed = max_len - len_a;\n        padded_a = string(zeros_needed, '0') + a;\n    }\n\n    string padded_b = b;\n    if (len_b < max_len) {\n        int zeros_needed = max_len - len_b;\n        padded_b = string(zeros_needed, '0') + b;\n    }\n\n    string result;\n\n    for (int i = 0; i < max_len; ++i) {\n        bool a_bit = (padded_a[i] == '1');\n        bool b_bit = (padded_b[i] == '1');\n        if (a_bit != b_bit) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    int max_len = 0;\n    string result = \"\";\n    \n    for (const string& s : strings) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n            result = s;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <cstdlib> // For abs function\n\nint greatest_common_divisor(int a, int b) {\n    if (a == 0 && b == 0) {\n        return 0;\n    }\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = a % b;\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    int n = str.size();\n    for (int i = 1; i <= n; ++i) {\n        string prefix = str.substr(0, i);\n        result.push_back(prefix);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result;\n    for (int i = 0; i <= n; ++i) {\n        if (result.empty()) {\n            result = to_string(i);\n        } else {\n            result += \" \";\n            result += to_string(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    vector<bool> seen(256, false);\n    int count = 0;\n    for (char c : str) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        unsigned char index = static_cast<unsigned char>(c);\n        if (!seen[index]) {\n            seen[index] = true;\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    stringstream ss(music_string);\n    string token;\n    \n    while (ss >> token) {\n        if (token == \"o\") {\n            result.push_back(4);\n        } else if (token == \"o|\") {\n            result.push_back(2);\n        } else if (token == \".|\") {\n            result.push_back(1);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int m = substring.length();\n    if (m == 0 || str.length() < m) {\n        return 0;\n    }\n    for (int i = 0; i <= str.size() - m; ++i) {\n        if (str.substr(i, m) == substring) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from number words to their corresponding integer values\n    map<string, int> number_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, \n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    \n    // Split the input string into individual words\n    vector<string> words;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    // Sort the words based on their numeric values using a custom comparator\n    sort(words.begin(), words.end(), [&number_map](const string& a, const string& b) {\n        return number_map[a] < number_map[b];\n    });\n    \n    // Join the sorted words into a single string with spaces\n    stringstream result_ss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            result_ss << \" \";\n        }\n        result_ss << words[i];\n    }\n    return result_ss.str();\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nvector<float> findClosestPair(const vector<float>& numbers) {\n    vector<float> result;\n    if (numbers.size() < 2) {\n        return result; // Return empty if there are fewer than two elements\n    }\n    \n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = numeric_limits<float>::infinity();\n    float first_val, second_val;\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float current_diff = numbers[i+1] - numbers[i];\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            first_val = numbers[i];\n            second_val = numbers[i+1];\n        }\n    }\n    \n    result.push_back(first_val);\n    result.push_back(second_val);\n    \n    return result;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> transformVector(vector<float>& vec) {\n    if (vec.empty()) {\n        return {};\n    }\n\n    float min_val = *min_element(vec.begin(), vec.end());\n    float max_val = *max_element(vec.begin(), vec.end());\n\n    vector<float> result;\n    if (max_val == min_val) {\n        // All elements are the same; set each to 0.5\n        for (float num : vec) {\n            result.push_back(0.5f);\n        }\n    } else {\n        float range = max_val - min_val;\n        for (float num : vec) {\n            result.push_back((num - min_val) / range);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <boost/any.hpp>\n#include <list>\n#include <vector>\n#include <typeinfo>\n\nusing namespace std;\nusing namespace boost;\n\ntypedef list<any> list_any;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& elem : values) {\n        if (elem.type() == typeid(int)) {\n            int val = any_cast<int>(elem);\n            result.push_back(val);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n"}
{"task_id": "CPP/24", "generation": "int largest_divisor(int n) {\n    for (int i = n - 1; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return -1; // This line is theoretically unreachable for n >= 2.\n}\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Handle division by 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Now check odd numbers from 3 upwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "To solve this problem, we need to determine which elements from a given list occur exactly once and maintain their original order. The solution involves counting the frequency of each element and then constructing the result based on these counts.\n\n### Approach\n1. **Read Input**: Read the input values as a list of integers.\n2. **Count Frequencies**: Use a dictionary to count how many times each element appears in the list.\n3. **Construct Result**: Iterate through the original list and include only those elements whose frequency is exactly one, preserving their order.\n\n### Solution Code\n"}
{"task_id": "CPP/27", "generation": "#include <string>\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (int i = 0; i < str.size(); ++i) {\n        char c = str[i];\n        if ('a' <= c && c <= 'z') {\n            str[i] = c - 32;\n        } else if ('A' <= c && c <= 'Z') {\n            str[i] = c + 32;\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& s : strings) {\n        result += s;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& s : strings) {\n        if (s.size() >= prefix.size()) {\n            if (s.substr(0, prefix.size()) == prefix) {\n                result.push_back(s);\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "To solve this problem, we need to determine if a given number is prime. A prime number is defined as a number greater than 1 that has no divisors other than 1 and itself. \n\n### Approach\nThe approach to solve this problem involves the following steps:\n\n1. **Immediate Checks for Small Numbers**: \n   - If the number is less than or equal to 1, it is not prime.\n   - If the number is exactly 2, it is prime (as 2 is the smallest and only even prime number).\n\n2. **Check for Even Numbers**:\n   - If the number is even and greater than 2, it cannot be prime because it will have 2 as a divisor.\n\n3. **Check for Divisors Up to Square Root**:\n   - For numbers greater than 2, we check if they can be divided by any odd number starting from 3 up to the square root of the given number. This is based on the optimization that if a number has a factor larger than its square root, the corresponding co-factor will be smaller than the square root.\n\n### Solution Code\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n\ndouble evaluate(double x, double *coeffs) {\n    int n = coeffs[0];\n    double result = 0.0;\n    for(int i=1; i<=n+1; i++) {\n        if(i == 1) {\n            result += coeffs[i] * pow(x, n - i + 1);\n        } else {\n            result += coeffs[i] * pow(x, n - i + 1);\n        }\n    }\n    return result;\n}\n\ndouble find_root(double *coeffs) {\n    double a = -1.0;\n    double b = 1.0;\n\n    // Bracketing phase\n    while (true) {\n        double fa = evaluate(a, coeffs);\n        double fb = evaluate(b, coeffs);\n\n        if (fa * fb < 0) {\n            break;\n        }\n\n        a *= -2;\n        b *= 2;\n    }\n\n    // Binary search phase\n    for (int i = 0; i < 100; ++i) {\n        double mid = (a + b) / 2.0;\n        double fmid = evaluate(mid, coeffs);\n\n        if (fmid * fa < 0) {\n            b = mid;\n        } else {\n            a = mid;\n        }\n    }\n\n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisible_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_elements.push_back(l[i]);\n        }\n    }\n    sort(divisible_elements.begin(), divisible_elements.end());\n    \n    vector<int> l_prime;\n    int pos = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l_prime.push_back(divisible_elements[pos]);\n            pos++;\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n    \n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s;\n    for (int num : l) {\n        s.insert(num);\n    }\n    return vector<int>(s.begin(), s.end());\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        // Handle empty vector case as needed; here we return NaN.\n        return NAN;\n    }\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "int fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit == 7) {\n                    total++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return total;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even_indices(const vector<float>& l) {\n    vector<float> temp;\n    // Extract elements at even indices\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            temp.push_back(l[i]);\n        }\n    }\n    // Sort the temporary vector\n    sort(temp.begin(), temp.end());\n    // Build the result vector\n    vector<float> res;\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            res.push_back(temp[j]);\n            j++;\n        } else {\n            res.push_back(l[i]);\n        }\n    }\n    return res;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long num) {\n    if (num <= 1)\n        return false;\n    if (num == 2)\n        return true;\n    if (num % 2 == 0)\n        return false;\n    for (long long i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    if (l.size() < 3) return false;\n    sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue;\n        int left = i + 1, right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum > 0) right--;\n            else left++;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "The maximum number of collisions that can occur when arranging N cars alternately as eastbound and westbound is given by floor(N/2). This is because each collision requires one car from each direction, and alternating them allows for the most pairs to collide.\n\n$\\boxed{\\left\\lfloor \\dfrac{N}{2} \\right\\rfloor}$"}
{"task_id": "CPP/42", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int x : l) {\n        if (seen.find(-x) != seen.end()) {\n            return true;\n        }\n        seen.insert(x);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "To solve this problem, we need to convert a given integer into its string representation in a specified base. This involves understanding how number bases work and correctly handling the conversion process.\n\n### Approach\nThe approach to convert an integer to a string in a specified base involves the following steps:\n\n1. **Handle Special Case for Zero**: If the input integer is zero, directly return \"0\" as its string representation.\n2. **Collect Remainders**: Use a loop to repeatedly divide the number by the given base and collect the remainders. These remainders represent the digits of the number in the specified base but collected from least significant to most significant.\n3. **Reverse the Digits**: Since the remainders are collected starting from the least significant digit, reverse the list of collected remainders to get the correct order.\n4. **Convert and Join Digits**: Convert each digit from integer to string and join them to form the final result.\n\n### Solution Code\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2;\n}\n"}
{"task_id": "CPP/46", "generation": "To solve this problem, we need to compute the nth number in a specific sequence defined by the following rules:\n- The first two numbers are both 0.\n- The third number is 2.\n- Each subsequent number is the sum of the previous four numbers.\n\n### Approach\nThe approach involves using an iterative method to efficiently compute the nth number in the sequence. Here's a step-by-step breakdown:\n\n1. **Base Cases**: Directly return the known values for n = 0, 1, 2, and 3.\n2. **Iterative Calculation**: For n >= 4, use a loop starting from 4 up to n. In each iteration, compute the next number as the sum of the previous four numbers and update the variables accordingly.\n\nThis method ensures that we only use a constant amount of space (O(1)) and compute the result in linear time (O(n)), making it efficient for large values of n.\n\n### Solution Code\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float a = l[(n / 2) - 1];\n        float b = l[n / 2];\n        return (a + b) / 2.0f;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int len = text.length();\n    if (len <= 1) {\n        return true;\n    }\n    for (int i = 0; i < len / 2; ++i) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "To solve this problem, we need to compute the result of raising a base number to an exponent and then taking the modulus with another number. This is a common operation in various fields such as cryptography, where efficiency is crucial due to potentially very large numbers involved.\n\n### Approach\nThe approach used here is called modular exponentiation by squaring. This method efficiently computes large powers modulo a number by breaking down the exponentiation process into smaller steps, reducing both the number of multiplications and the size of intermediate results through modulus operations at each step.\n\n1. **Initialization**: Start with a result initialized to 1.\n2. **Modulus Check**: If the modulus is 1, return 0 immediately since any number modulo 1 is 0.\n3. **Iterative Process**:\n   - Convert the base to its modulus form initially.\n   - While there are bits left in the exponent (processed bit by bit):\n     - Square the current result and take modulus.\n     - If the current bit of the exponent is 1, multiply the result by the base and take modulus.\n     - Right shift the exponent to process the next bit.\n4. **Return Result**: After processing all bits of the exponent, return the result.\n\nThis method ensures that we handle very large exponents efficiently without causing overflow issues or excessive computation time.\n\n### Solution Code\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <cctype> // for tolower function\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        char lower_c = tolower(c);\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "int add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> set0(s0.begin(), s0.end());\n    set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stack>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n\nusing namespace std;\n\nbool isMonotonic(vector<float> l) {\n    if (l.size() <= 1) return true;\n    \n    bool increasing = false;\n    bool decreasing = false;\n    \n    for (int i = 0; i < l.size() - 1; ++i) {\n        if (l[i] < l[i + 1]) {\n            increasing = true;\n            break;\n        } else if (l[i] > l[i + 1]) {\n            decreasing = true;\n            break;\n        }\n    }\n    \n    if (!increasing && !decreasing) return true; // All elements are equal\n    \n    if (increasing) {\n        for (int i = 0; i < l.size() - 1; ++i) {\n            if (l[i] > l[i + 1]) {\n                return false;\n            }\n        }\n    } else { // decreasing\n        for (int i = 0; i < l.size() - 1; ++i) {\n            if (l[i] < l[i + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n    vector<int> res;\n    \n    for (int num : s1) {\n        if (s2.find(num) != s2.end()) {\n            res.push_back(num);\n        }\n    }\n    \n    return res;\n}\n"}
{"task_id": "CPP/59", "generation": "int largest_prime_factor(int n) {\n    if (n <= 1) {\n        return -1; // Assuming n should be >1 as per problem constraints.\n    }\n    \n    int max_factor = -1;\n    \n    // Check divisibility by 2\n    if (n % 2 == 0) {\n        max_factor = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n    }\n    \n    // Check odd factors from 3 upwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            max_factor = i;\n            n /= i;\n        }\n    }\n    \n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        max_factor = n;\n    }\n    \n    return max_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> res;\n    for (size_t j = 1; j < xs.size(); ++j) {\n        res.push_back(j * xs[j]);\n    }\n    return res;\n}\n"}
{"task_id": "CPP/63", "generation": "int fibfib(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Represents fib(i-3), fib(i-2), fib(i-1)\n    for (int i = 3; i <= n; ++i) {\n        int current = a + b + c;\n        a = b;\n        b = c;\n        c = current;\n    }\n    return c;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <cctype>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        char lower_c = tolower(c);\n        if (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u') {\n            count++;\n        }\n    }\n    if (!s.empty()) {\n        char last_char = tolower(s.back());\n        if (last_char == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\nusing namespace std;\n\nint circularShift(int x, int shift) {\n    string s = to_string(x);\n    bool is_negative = (s[0] == '-');\n    string digits;\n    \n    if (is_negative) {\n        digits = s.substr(1); // Extract all characters except the first one\n    } else {\n        digits = s;          // Use the entire string as digits\n    }\n    \n    int len = digits.length();\n    if (len == 0) return x; // Handle edge case, though unlikely\n    \n    // Calculate effective shift to handle cases where shift is larger than length\n    int effective_shift = (shift % len + len) % len;\n    \n    if (effective_shift == 0) {\n        string result_str = is_negative ? \"-\" + digits : digits;\n        return stoi(result_str);\n    }\n    \n    // Perform the circular shift\n    string shifted_part = digits.substr(len - effective_shift, effective_shift);\n    string remaining = digits.substr(0, len - effective_shift);\n    string new_digits = shifted_part + remaining;\n    \n    string result_str = is_negative ? \"-\" + new_digits : new_digits;\n    return stoi(result_str);\n}\n"}
{"task_id": "CPP/66", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<string> tokens;\n    istringstream iss(s);\n    string token;\n    \n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n    \n    int apples = stoi(tokens[0]);\n    int oranges = stoi(tokens[3]);\n    \n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <climits>\n\nusing namespace std;\n\nvector<int> findMinEvenIndex(const vector<int>& arr) {\n    int n = arr.size();\n    if (n == 0) return {}; // Handle empty input\n\n    int min_val = INT_MAX;\n    int min_index = -1;\n\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (min_index == -1 || arr[i] < min_val) {\n                min_val = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {}; // No even numbers found\n    } else {\n        return {min_val, min_index};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (auto& pair : freq) {\n        if (pair.second >= pair.first && pair.first > max_num) {\n            max_num = pair.first;\n        }\n    }\n    \n    return max_num;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> rearrange(vector<int>& v) {\n    sort(v.begin(), v.end());\n    int n = v.size();\n    vector<int> res;\n    int left = 0, right = n - 1;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            res.push_back(v[left]);\n            left++;\n        } else {\n            res.push_back(v[right]);\n            right--;\n        }\n    }\n    return res;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <cmath>\n\nfloat calculateTriangleArea(float a, float b, float c) {\n    // Check if the sides form a valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1.0f;\n    }\n    \n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2.0f;\n    \n    // Compute area squared using Heron's formula\n    float area_sq = s * (s - a) * (s - b) * (s - c);\n    \n    if (area_sq < 0.0f) {\n        // Due to floating point precision errors, treat as zero\n        return 0.0f;\n    } else {\n        float area = sqrtf(area_sq);\n        // Round the area to two decimal places\n        return std::round(area * 100.0f) / 100.0f;\n    }\n}\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    bool is_palindrome = true;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    return is_palindrome && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0;\n    for (string s : lst1) {\n        sum1 += s.length();\n    }\n    \n    int sum2 = 0;\n    for (string s : lst2) {\n        sum2 += s.length();\n    }\n    \n    if (sum1 < sum2) {\n        return lst1;\n    } else if (sum2 < sum1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <math.h>\n\nint sum_of_exponents(int n) {\n    if (n == 0) return 0; // Handle the case where n is zero\n\n    int sum = 0;\n    for (int i = 2; i <= sqrt(n); ++i) { // Check up to square root of n\n        while (n % i == 0) {\n            sum++;\n            n /= i;\n        }\n    }\n\n    if (n > 1) {\n        sum++; // If remaining n is a prime number greater than 1\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/76", "generation": "To solve this problem, we need to determine whether a given number (target) can be obtained by raising a base number to a specified exponent. The function should return True if the result of the base raised to the exponent equals the target, and False otherwise.\n\n### Approach\nThe approach involves computing the result of raising the base to the given exponent and then comparing this result with the target value. Here are the key steps:\n\n1. **Handle Special Cases**: \n   - If the exponent is 0, any non-zero base raised to this exponent equals 1. Thus, we check if the target is 1.\n   - If the base is 0, raising it to a positive exponent results in 0. For non-positive exponents, the result is undefined or not allowed, so we return False.\n\n2. **Compute Result**: \n   - Calculate the result of raising the base to the given exponent using Python's built-in power operator (`**`).\n\n3. **Comparison**: \n   - Compare the computed result with the target value and return True if they are equal; otherwise, return False.\n\n### Solution Code\n"}
{"task_id": "CPP/77", "generation": "To determine if a given integer is a perfect cube, we can use a binary search approach to efficiently check for the existence of an integer whose cube equals the target value. Here\u2019s how we can implement this:\n\n### Approach\n1. **Handle Special Case for Zero**: If the input number `a` is zero, it is trivially a perfect cube (since 0^3 = 0), so we return true immediately.\n2. **Compute Absolute Value**: Since both positive and negative numbers can be perfect cubes, we convert the given number to its absolute value to simplify our search for the cube root.\n3. **Binary Search Setup**: We initialize two pointers, `low` set to 1 and `high` set to the absolute value of `a`. This range is suitable because any integer cube root must lie between these bounds.\n4. **Binary Search Execution**: Using binary search within the range [low, high], we repeatedly narrow down the middle point (`mid`) and compute its cube:\n   - If the cube of `mid` equals the target value, return true.\n   - If the cube is less than the target, adjust the lower bound to search in the higher half.\n   - If the cube is greater than the target, adjust the upper bound to search in the lower half.\n5. **Termination**: If the loop completes without finding a perfect cube, return false.\n\nThis approach ensures that we efficiently check for a perfect cube with a time complexity of O(log n), where n is the absolute value of the input number.\n\n### Solution Code\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    unordered_set<int> primes = {2, 3, 5, 7, 11, 13};\n    for (char c : num) {\n        int val;\n        if (isdigit(c)) {\n            val = c - '0';\n        } else {\n            val = (c - 'A') + 10;\n        }\n        if (primes.count(val)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "To solve this problem, we need to convert a given non-negative integer into its binary string representation. The binary representation of an integer is a sequence of digits consisting only of 0s and 1s, where each digit represents a power of 2, starting from the rightmost digit.\n\n### Approach\nThe approach to convert an integer to its binary representation involves the following steps:\n\n1. **Handle Zero Case**: If the input integer is zero, directly return \"0\" as its binary representation.\n2. **Collect Remainders**: For non-zero integers, repeatedly divide the number by 2 and collect the remainders. These remainders represent the bits of the binary number but in reverse order (from least significant bit to most significant bit).\n3. **Reverse the Order**: Since the collected remainders are in reverse order, we need to reverse them to get the correct binary string.\n4. **Convert to String**: Convert each digit from the reversed list to a string and concatenate them to form the final binary string.\n\n### Solution Code\n"}
{"task_id": "CPP/80", "generation": "#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i <= s.size() - 3; ++i) {\n        char c1 = s[i];\n        char c2 = s[i + 1];\n        char c3 = s[i + 2];\n        if (c1 == c2 || c1 == c3 || c2 == c3) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "To solve this problem, we need to determine the letter grade corresponding to a given GPA based on specific thresholds. The grading scale is defined such that each letter grade corresponds to a range of GPA values. \n\n### Approach\n1. **Understand the Grading Scale**: The GPA ranges and their corresponding letter grades are as follows:\n   - A+: 4.0 or above\n   - A: Greater than 3.7 but less than 4.0\n   - A-: Greater than 3.3 but less than or equal to 3.7\n   - B+: Greater than 3.0 but less than or equal to 3.3\n   - B: Greater than 2.7 but less than or equal to 3.0\n   - B-: Greater than 2.3 but less than or equal to 2.7\n   - C+: Greater than 2.0 but less than or equal to 2.3\n   - C: Greater than 1.7 but less than or equal to 2.0\n   - C-: Greater than 1.3 but less than or equal to 1.7\n   - D+: Greater than 1.0 but less than or equal to 1.3\n   - D: Greater than 0.7 but less than or equal to 1.0\n   - F: Less than or equal to 0.7\n\n2. **Read Input**: The input is a single floating-point number representing the GPA.\n\n3. **Determine Letter Grade**: Using a series of conditional checks, we determine which range the GPA falls into and print the corresponding letter grade.\n\n### Solution Code\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n\nusing namespace std;\n\nbool isPrimeLength(const string &str) {\n    int len = str.size();\n    if (len < 2)\n        return false;\n    \n    for (int i = 2; i * i <= len; ++i) {\n        if (len % i == 0)\n            return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "The number of positive integers with exactly \\( n \\) digits that start with 1 or end with 1 (or both) can be determined as follows:\n\nFor \\( n = 1 \\):\n- The only number is 1, so the count is 1.\n\nFor \\( n \\geq 2 \\):\n- Numbers starting with 1: There are \\( 10^{n-1} \\) such numbers.\n- Numbers ending with 1: There are \\( 9 \\times 10^{n-2} \\) such numbers.\n- Numbers both starting and ending with 1: There are \\( 10^{n-2} \\) such numbers.\n\nUsing the principle of inclusion-exclusion, the total count is:\n\\[ 10^{n-1} + 9 \\times 10^{n-2} - 10^{n-2} = 10^{n-1} + 8 \\times 10^{n-2} \\]\nFactoring out \\( 10^{n-2} \\):\n\\[ (10 + 8) \\times 10^{n-2} = 18 \\times 10^{n-2} \\]\n\nThus, the final answers are:\n- For \\( n = 1 \\): \\(\\boxed{1}\\)\n- For \\( n \\geq 2 \\): \\(\\boxed{18 \\times 10^{n-2}}\\)"}
{"task_id": "CPP/84", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    if (N == 0) {\n        sum = 0;\n    } else {\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n    }\n    \n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    vector<int> bits;\n    int s = sum;\n    while (s > 0) {\n        int rem = s % 2;\n        bits.push_back(rem);\n        s /= 2;\n    }\n    \n    reverse(bits.begin(), bits.end());\n    \n    string result;\n    for (int bit : bits) {\n        result += to_string(bit);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "To solve this problem, we need to write a function that takes a string as input and returns a new string where each word from the input is sorted based on the ASCII values of its characters. The words in the output should be joined together with spaces separating them.\n\n### Approach\n1. **Splitting the Input String**: First, we split the input string into individual words using the `split()` method. This method handles multiple spaces between words by treating them as a single separator and returns a list of words.\n2. **Sorting Each Word**: For each word in the list obtained from splitting the input string, we convert the word into a list of its characters. We then sort this list based on the ASCII values of the characters using Python's built-in `sorted()` function, which sorts strings lexicographically (i.e., by comparing their ASCII values).\n3. **Reconstructing Words**: After sorting the characters of each word, we join them back into a single string.\n4. **Joining Sorted Words**: Finally, we join all the sorted words back into a single string with spaces separating them.\n\n### Solution Code\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        for (int j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        } else {\n            return a[1] > b[1];\n        }\n    });\n    \n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    vector<int> result = array;\n    if (result.size() <= 1) return result;\n\n    int first = result[0];\n    int last = result.back();\n    int sum = first + last;\n\n    sort(result.begin(), result.end());\n\n    if (sum % 2 == 0) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            int shifted = (s[i] - 'a' + 4) % 26;\n            s[i] = 'a' + shifted;\n        }\n    }\n    return s;\n}\n"}
{"task_id": "CPP/90", "generation": "To solve this problem, we need to find the second smallest element in a given array of integers. The solution involves sorting the array and then accessing the second element in the sorted list. \n\n### Approach\n1. **Check Array Length**: First, we check if the length of the array is less than 2. If it is, we return `None` because there can't be a second smallest element.\n2. **Sort the Array**: If the array has at least two elements, we sort it in ascending order.\n3. **Return Second Element**: After sorting, the second smallest element will be at index 1 of the sorted array.\n\nThis approach ensures that we efficiently find the second smallest element by leveraging the built-in sorting functionality, which simplifies the process and makes the solution straightforward.\n\n### Solution Code\n"}
{"task_id": "CPP/91", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring trim(const string &s) {\n    size_t start = s.find_first_not_of(\" \\t\");\n    if (start == string::npos) {\n        return \"\";\n    }\n    size_t end = s.find_last_not_of(\" \\t\");\n    return s.substr(start, end - start + 1);\n}\n\nint countSentencesStartingWithI(const string &s) {\n    vector<string> sentences;\n    string current_sentence;\n\n    for (char c : s) {\n        if (c == '.' || c == '?' || c == '!') {\n            current_sentence = trim(current_sentence);\n            if (!current_sentence.empty()) {\n                sentences.push_back(current_sentence);\n            }\n            current_sentence.clear();\n        } else {\n            current_sentence += c;\n        }\n    }\n\n    // Add the last sentence\n    current_sentence = trim(current_sentence);\n    if (!current_sentence.empty()) {\n        sentences.push_back(current_sentence);\n    }\n\n    int count = 0;\n    for (const string &sentence : sentences) {\n        if (!sentence.empty() && sentence[0] == 'I') {\n            ++count;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "To solve this problem, we need to determine if three given numbers can form a valid triangle. A valid triangle is defined by two main conditions: all sides must be positive, and the sum of any two sides must be greater than the third side.\n\n### Approach\n1. **Check for Positive Values**: Each side length of a triangle must be a positive number. If any of the given numbers are zero or negative, it is immediately clear that they cannot form a valid triangle.\n2. **Triangle Inequality Theorem**: For three sides to form a valid triangle, the sum of any two sides must be greater than the third side. This theorem ensures that the sides can form a non-degenerate triangle.\n\nThe solution involves:\n1. Checking if all three numbers are positive.\n2. Verifying that each pair of sides satisfies the triangle inequality condition.\n\n### Solution Code\n"}
{"task_id": "CPP/93", "generation": "To solve this problem, we need to transform a given string by first converting each character to its opposite case (uppercase to lowercase and vice versa) and then shifting each vowel character by two positions in the ASCII table. Non-vowel characters remain unchanged after the case conversion.\n\n### Approach\n1. **Case Conversion**: Convert each character in the input string to its opposite case using Python's `swapcase()` method.\n2. **Vowel Check and Shift**: For each character in the transformed string, check if it is a vowel (A, E, I, O, U regardless of case). If it is a vowel, shift its ASCII value by two positions forward. Non-vowel characters remain unchanged.\n\n### Solution Code\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint sumDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/95", "generation": "To solve this problem, we need to determine if all strings in a given list are either entirely lowercase or entirely uppercase. Each string must be checked individually, and then we must ensure that all strings follow the same case convention (either all lowercase or all uppercase).\n\n### Approach\n1. **Check Each String**: For each string in the list, verify if it is entirely composed of lowercase letters or entirely composed of uppercase letters.\n2. **Collect Cases**: If a string passes either of the checks (all lowercase or all uppercase), record its case type ('lower' or 'upper').\n3. **Uniform Case Check**: After processing all strings, check if all recorded cases are the same. If they are, return true; otherwise, return false.\n\n### Solution Code\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <cstdlib> // For abs function\n\nint multiply(int a, int b) {\n    int unitA = abs(a) % 10;\n    int unitB = abs(b) % 10;\n    return unitA * unitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0) { // Check if index is even\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "To solve this problem, we need to create a function that rounds a given number to the nearest integer, with special handling for numbers that are exactly halfway between two integers. Specifically, if the number is positive and halfway, it should round up; if negative and halfway, it should round down.\n\n### Approach\n1. **Identify Halfway Cases**: Determine if the number is exactly halfway between two integers by checking if the fractional part of the number is 0.5.\n2. **Handle Positive and Negative Differently**:\n   - For positive numbers that are halfway, round up to the next integer.\n   - For negative numbers that are halfway, round down to the previous integer (which is more negative).\n3. **Standard Rounding for Other Cases**: For numbers that are not exactly halfway, use standard rounding by adding 0.5 and then taking the floor of the result.\n\n### Solution Code\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        current += 2;\n    }\n    return pile;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces\n    string modified_s;\n    for (char c : s) {\n        if (c == ',') {\n            modified_s += ' ';\n        } else {\n            modified_s += c;\n        }\n    }\n\n    // Split the modified string into words using istringstream\n    vector<string> result;\n    istringstream iss(modified_s);\n    string word;\n    while (iss >> word) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "To solve this problem, we need to find the largest even number within a given range [x, y]. If no such even number exists, we should return -1. \n\n### Approach\nThe approach to solve this problem involves the following steps:\n1. **Check if x is greater than y**: If x is greater than y, it means there are no numbers in the range, so we immediately return -1.\n2. **Determine the candidate even number**:\n   - If y is even, then y itself is a potential candidate for the largest even number.\n   - If y is odd, then the largest even number less than y is y-1.\n3. **Check if the candidate is within the range**: After determining the candidate, we check if it is greater than or equal to x. If it is, this candidate is our answer. Otherwise, there are no even numbers in the range, and we return -1.\n\nThis approach efficiently narrows down the possible candidates for the largest even number by leveraging the properties of even and odd numbers, ensuring that we only check a few potential values rather than iterating through the entire range.\n\n### Solution Code\n"}
{"task_id": "CPP/103", "generation": "To solve this problem, we need to compute the average of two integers provided as input. The key insight is that the average of two consecutive integers can be directly calculated by summing them and dividing by 2. Depending on whether the sum is even or odd, the result will either be an integer or a float.\n\n### Approach\n1. **Read Input**: Read two integers from the input.\n2. **Compute Sum**: Calculate the sum of these two integers.\n3. **Check Even/Odd**: Determine if the sum is even or odd.\n4. **Output Result**: If the sum is even, print the result as an integer. If the sum is odd, print the result as a float.\n\nThis approach ensures that we handle both cases correctly and efficiently.\n\n### Solution Code\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_all_odd_digits(int num) {\n    if (num == 0) return false;\n    while (num > 0) {\n        int d = num % 10;\n        if (d % 2 == 0) {\n            return false;\n        }\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> res;\n    for (int num : x) {\n        if (has_all_odd_digits(num)) {\n            res.push_back(num);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n\n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \n                            \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // even index, compute factorial\n            int fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n            }\n            result.push_back(fact);\n        } else { // odd index, compute sum of 1 to i\n            int sum = i * (i + 1) / 2;\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        int original = i;\n        int reversed = 0;\n        int temp = original;\n        while (temp > 0) {\n            reversed = reversed * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (reversed == original) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "To solve this problem, we need to determine how many numbers in a given list have digit sums greater than zero. The digit sum of a number is calculated by summing its individual digits. For negative numbers, we consider their absolute values before summing the digits.\n\n### Approach\n1. **Iterate through each number**: For each number in the input list, process it to determine if its digit sum is positive.\n2. **Handle zero case**: If a number is zero, its digit sum is zero, which does not count as positive.\n3. **Extract digits**: Convert each number into its absolute value and extract its individual digits.\n4. **Sum the digits**: Calculate the sum of these digits. For negative numbers, adjust the sum by subtracting the first digit (since we took the absolute value).\n5. **Check positivity**: If the resulting sum is positive, count that number.\n\n### Solution Code\n"}
{"task_id": "CPP/109", "generation": "To solve this problem, we need to determine if a given array can be rotated to form a non-decreasing (sorted) array. The key insight is that an array can be rotated into a sorted order if it meets specific conditions related to its structure.\n\n### Approach\nThe approach involves checking two main conditions:\n1. **Count of Decreasing Points**: Traverse the array and count how many times an element is greater than the next element (i.e., `arr[i] > arr[i+1]`). This count helps us understand if the array can be split into a non-decreasing sequence.\n2. **Check Last Element Condition**: If there is exactly one point where the sequence decreases, we also need to ensure that the last element of the array is less than or equal to the first element. This ensures that rotating the array at the decreasing point will result in a sorted array.\n\nThe solution can be broken down into the following steps:\n1. Traverse the array and count the number of times an element is greater than the next element.\n2. If there are no such points, the array is already sorted.\n3. If there is exactly one such point, check if the last element is less than or equal to the first element. If true, the array can be rotated to form a sorted array.\n\n### Solution Code\n"}
{"task_id": "CPP/110", "generation": "To solve this problem, we need to determine if we can make all elements in the first list (list1) even by swapping some of its odd elements with even elements from the second list (list2).\n\n### Approach\nThe key insight is that each swap operation allows us to replace an odd element from list1 with an even element from list2. Therefore, the number of such swaps we can perform is limited by the number of even elements available in list2.\n\nHere's the step-by-step approach:\n\n1. **Count Odd Elements in List1**: Calculate how many odd numbers are present in list1. This gives us the minimum number of swaps needed to make all elements in list1 even.\n2. **Count Even Elements in List2**: Determine how many even numbers are available in list2. These are the potential candidates for swapping with the odd elements in list1.\n3. **Compare Counts**: If the number of even elements in list2 is greater than or equal to the number of odd elements in list1, then it is possible to make all elements in list1 even through swaps. Otherwise, it is not possible.\n\n### Solution Code\n"}
{"task_id": "CPP/111", "generation": "#include <sstream>\n#include <map>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freq;\n    istringstream iss(test);\n    string token;\n    \n    // Count frequency of each character\n    while (iss >> token) {\n        if (!token.empty()) {\n            char c = token[0];\n            freq[c]++;\n        }\n    }\n    \n    // If no characters were found, return empty map\n    if (freq.empty()) {\n        return {};\n    }\n    \n    // Find the maximum frequency\n    int max_count = 0;\n    for (auto& pair : freq) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n    \n    // Collect all characters with maximum frequency\n    map<char, int> result;\n    for (auto& pair : freq) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> remove_chars(c.begin(), c.end());\n    string filtered;\n    \n    for (char ch : s) {\n        if (remove_chars.find(ch) == remove_chars.end()) {\n            filtered.push_back(ch);\n        }\n    }\n    \n    string reversed = filtered;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = (filtered == reversed);\n    \n    vector<string> result;\n    result.push_back(filtered);\n    result.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    const string template_str = \"the number of odd elements i n the str i ng i of the i nput.\";\n    \n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                count++;\n            }\n        }\n        \n        string output;\n        for (char c : template_str) {\n            if (c == 'i') {\n                output += to_string(count);\n            } else {\n                output += c;\n            }\n        }\n        result.push_back(output);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "To solve this problem, we need to find the minimal sum of any contiguous subarray within a given array. This can be efficiently achieved using an approach similar to Kadane's algorithm, which is typically used for finding the maximum subarray sum but can be adapted for our purpose.\n\n### Approach\nThe approach involves iterating through each element of the array while maintaining two variables:\n1. `min_current`: This variable keeps track of the minimal sum of the subarray ending at the current position.\n2. `min_global`: This variable stores the overall minimal sum encountered so far.\n\nFor each element in the array, we update `min_current` to be the minimum between the current element itself and the sum of `min_current` plus the current element. This ensures that we consider both starting a new subarray at the current element or extending the previous subarray. We then update `min_global` if `min_current` is smaller than the current value of `min_global`.\n\n### Solution Code\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <numeric> // For accumulate\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    for (auto &row : grid) {\n        int sum = accumulate(row.begin(), row.end(), 0);\n        if (sum == 0) continue;\n        int ops = (sum + capacity - 1) / capacity;\n        total_operations += ops;\n    }\n    return total_operations;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint countSetBits(int x) {\n    unsigned int u = static_cast<unsigned int>(x);\n    return __builtin_popcount(u);\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result;\n    }\n    \n    istringstream iss(s);\n    string word;\n    \n    while (iss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            char lower_c = tolower(c);\n            if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "To solve this problem, we need to determine how many ways we can split a given string into two non-empty parts such that each part contains at least one consonant. \n\n### Approach\n1. **Identify Consonants**: First, identify which characters in the string are consonants. Vowels are 'a', 'e', 'i', 'o', 'u'. Any other character is considered a consonant.\n2. **Track Consonants from Left**: Create an array `left` where each element indicates whether there is at least one consonant up to that position in the string.\n3. **Track Consonants from Right**: Similarly, create an array `right` where each element indicates whether there is at least one consonant from that position to the end of the string.\n4. **Count Valid Splits**: Iterate through possible split points and count how many splits result in both parts having at least one consonant.\n\n### Solution Code\n"}
{"task_id": "CPP/119", "generation": "To solve this problem, we need to determine if either of two concatenated strings formed by combining two given strings results in a valid parentheses sequence. A valid parentheses sequence is defined as one where every opening parenthesis '(' has a corresponding closing parenthesis ')', and they are properly nested.\n\n### Approach\n1. **Problem Analysis**: We are given two strings `s1` and `s2`. We need to check if either the concatenation of `s1` followed by `s2` (i.e., `s1 + s2`) or the concatenation of `s2` followed by `s1` (i.e., `s2 + s1`) forms a valid parentheses sequence.\n\n2. **Intuition**: A valid parentheses sequence can be checked using a balance counter. We iterate through each character in the string, incrementing the balance for every '(' and decrementing it for every ')'. If at any point the balance becomes negative, the sequence is invalid. At the end, if the balance is zero, the sequence is valid.\n\n3. **Algorithm**:\n   - Concatenate `s1` and `s2` to form `concat1`.\n   - Check if `concat1` is a valid parentheses sequence.\n   - If not, concatenate `s2` and `s1` to form `concat2`.\n   - Check if `concat2` is a valid parentheses sequence.\n   - Return true if either concatenation is valid; otherwise, return false.\n\n4. **Complexity Analysis**: The algorithm involves checking two concatenated strings, each of which can be up to the combined length of `s1` and `s2`. Each check runs in linear time relative to the length of the string, making the overall complexity O(n), where n is the total number of characters in both strings.\n\n### Solution Code\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    if (k == 0) {\n        return {};\n    }\n    \n    sort(arr.begin(), arr.end());\n    \n    int n = arr.size();\n    return vector<int>(arr.begin() + (n - k), arr.end());\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\n\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "To solve this problem, we need to generate the Collatz sequence starting from a given number and collect all the odd numbers encountered in this sequence. Finally, we will sort these collected odd numbers and return them as a sorted list.\n\n### Approach\n1. **Generate the Collatz Sequence**: Starting from the given number, repeatedly apply the following operations until reaching 1:\n   - If the current number is even, divide it by two.\n   - If the current number is odd, multiply it by three and add one.\n2. **Collect Odd Numbers**: During the generation of the sequence, collect all the odd numbers encountered.\n3. **Sort the Collected Odds**: Once all odd numbers are collected, sort them in ascending order.\n4. **Return the Sorted List**: Return the sorted list of odd numbers.\n\n### Solution Code\n"}
{"task_id": "CPP/124", "generation": "#include <string>\nusing namespace std;\n\nbool isValidDate(const string& date) {\n    // Check if the length is exactly 10 characters\n    if (date.length() != 10) return false;\n\n    // Check positions of hyphens\n    if (date[2] != '-' || date[5] != '-') return false;\n\n    // Extract month, day, year strings\n    string mm_str = date.substr(0, 2);\n    string dd_str = date.substr(3, 2);\n    string yyyy_str = date.substr(6, 4);\n\n    // Check if all characters in each part are digits\n    for (char c : mm_str) {\n        if (!isdigit(c)) return false;\n    }\n    for (char c : dd_str) {\n        if (!isdigit(c)) return false;\n    }\n    for (char c : yyyy_str) {\n        if (!isdigit(c)) return false;\n    }\n\n    // Convert to integers\n    int mm = stoi(mm_str);\n    int dd = stoi(dd_str);\n    int yyyy = stoi(yyyy_str);\n\n    // Check month validity\n    if (mm < 1 || mm > 12) return false;\n\n    // Determine leap year\n    bool is_leap_year = ((yyyy % 4 == 0 && yyyy % 100 != 0) || (yyyy % 400 == 0));\n\n    // Check day based on month\n    if (mm == 2) {\n        int max_day = is_leap_year ? 29 : 28;\n        if (dd < 1 || dd > max_day) return false;\n    } else if (mm == 4 || mm == 6 || mm == 9 || mm == 11) {\n        if (dd < 1 || dd > 30) return false;\n    } else {\n        if (dd < 1 || dd > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split(const string &s, char delim) {\n    vector<string> result;\n    size_t start = 0;\n    size_t end = s.find(delim);\n    while (end != string::npos) {\n        result.push_back(s.substr(start, end - start));\n        start = end + 1;\n        end = s.find(delim, start);\n    }\n    result.push_back(s.substr(start)); // Add the remaining part of the string\n    return result;\n}\n\nvector<string> processString(const string &s) {\n    vector<string> parts;\n\n    size_t spacePos = s.find(' ');\n    size_t commaPos = s.find(',');\n\n    if (spacePos != string::npos || commaPos != string::npos) {\n        char delimiter = ' ';\n        if (commaPos < spacePos && commaPos != string::npos) {\n            delimiter = ',';\n        }\n        parts = split(s, delimiter);\n    } else {\n        int count = 0;\n        for (char c : s) {\n            if (islower(c)) {\n                int ord = c - 'a';\n                if (ord % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        parts.push_back(to_string(count));\n    }\n\n    return parts;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is non-decreasing\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1]) {\n            return false;\n        }\n    }\n\n    // Count occurrences of each number\n    unordered_map<int, int> countMap;\n    for (int num : lst) {\n        countMap[num]++;\n    }\n\n    // Check if any number appears more than twice\n    for (auto& pair : countMap) {\n        if (pair.second > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "To solve this problem, we need to determine if two given intervals overlap and if their overlapping segment has a length that is a prime number. \n\n### Approach\n1. **Identify Overlapping Interval**: First, we find the start and end points of the overlapping interval between the two given intervals. The start point is the maximum of the starting points of the two intervals, and the end point is the minimum of their ending points.\n2. **Check for Validity**: If the calculated start point is greater than the end point, it means there is no overlap, so we return `False`.\n3. **Calculate Length**: Compute the length of the overlapping interval. If this length is less than 2, return `False` since a prime number must be at least 2.\n4. **Prime Check**: Use a helper function to check if the length of the overlapping segment is a prime number.\n\n### Solution Code\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum = 0;\n    for (int num : arr) {\n        sum += abs(num);\n    }\n    \n    int product = 1;\n    for (int num : arr) {\n        if (num == 0) {\n            product = 0;\n            break;\n        } else if (num < 0) {\n            product *= -1;\n        }\n    }\n    \n    return sum * product;\n}\n"}
{"task_id": "CPP/129", "generation": "To solve this problem, we need to find the lexicographically smallest sequence of length `k` in a given grid. The sequence is formed by moving from cell to adjacent cell (up, down, left, right) and collecting values along the path.\n\n### Approach\n1. **Problem Analysis**: We are given a grid and an integer `k`. Our task is to find the smallest possible sequence of length `k` where each element in the sequence is a value from the grid, and consecutive elements come from adjacent cells.\n\n2. **Intuition**: The problem can be approached using Breadth-First Search (BFS) combined with a priority queue (min-heap). BFS ensures that we explore all possible paths level by level, while the min-heap helps us always expand the lexicographically smallest sequence first.\n\n3. **Algorithm Selection**: We use a priority queue to keep track of the current sequences in lex order. Each entry in the queue is a tuple containing the current sequence and the position (i, j) in the grid. We also maintain a dictionary to keep track of the smallest sequence encountered for each cell at each step to avoid redundant processing.\n\n4. **Optimization**: By using a dictionary to store the smallest sequence for each cell at each step, we ensure that once we have found the smallest sequence for a particular cell and step count, we do not process any larger sequences for the same cell and step count again.\n\n### Solution Code\n"}
{"task_id": "CPP/130", "generation": "To solve this problem, we need to compute a sequence where each term is defined based on its position. The challenge is to efficiently determine the value of the sequence at a given position, especially since the position can be very large (up to 1e18).\n\n### Approach\nThe sequence alternates between two different formulas depending on whether the index is even or odd:\n1. For even indices: The value is computed as `(index // 2) + 1`.\n2. For odd indices: The value is computed as `((index + 3) // 2)^2 - 1`.\n\nThis approach allows us to compute the value in constant time, O(1), without using recursion or loops, making it highly efficient even for very large indices.\n\n### Solution Code\n"}
{"task_id": "CPP/131", "generation": "int digits(int n) {\n    int product = 1;\n    bool has_odd = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10; // Move to the next digit\n    }\n\n    return has_odd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "To solve this problem, we need to determine whether a given string of parentheses is validly nested. A string is considered validly nested if every opening parenthesis '(' has a corresponding closing parenthesis ')', and they are correctly ordered such that no closing parenthesis appears before its matching opening parenthesis.\n\n### Approach\nThe approach to solve this problem involves using a stack data structure. The stack helps keep track of the opening parentheses as we iterate through the string. Here's a step-by-step breakdown of the approach:\n\n1. **Initialize an empty stack**: This will be used to store opening parentheses '('.\n2. **Iterate through each character in the string**:\n   - If the character is an opening parenthesis '(', push it onto the stack.\n   - If the character is a closing parenthesis ')':\n     - Check if the stack is empty. If it is, this means there's no corresponding opening parenthesis for the current closing parenthesis, so return false.\n     - Pop the top element from the stack and check if it is an opening parenthesis '('. If not, return false (though in our case, since we only have parentheses, this might not be necessary unless other characters are allowed).\n3. **After processing all characters**, check if the stack is empty. If it is, all opening parentheses have been matched with closing ones, so return true. Otherwise, return false.\n\nThis approach ensures that each closing parenthesis correctly matches the most recent unmatched opening parenthesis, thus checking for proper nesting.\n\n### Solution Code\n"}
{"task_id": "CPP/133", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiled = ceil(num);\n        sum += ceiled * ceiled;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "To solve this problem, we need to create a function that determines if a given string ends with exactly one alphabetical letter. The function should return `true` if the string ends with such a letter and `false` otherwise.\n\n### Approach\nThe approach to solving this problem involves checking the last character of the string to see if it is an alphabetical letter (either uppercase or lowercase). Here are the key steps:\n\n1. **Check String Length**: First, we check if the string is non-empty. If the string is empty, it cannot end with a letter, so we return `false`.\n2. **Extract Last Character**: We then extract the last character of the string.\n3. **Check Alphabetical Character**: Using a regular expression, we test whether this last character is an alphabetical letter.\n\nThis approach ensures that we efficiently determine if the string ends with a single letter by focusing only on the last character and its type.\n\n### Solution Code\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = n - 1; i >= 1; --i) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(const vector<int>& nums) {\n    bool has_negative = false;\n    int max_neg = INT_MIN; \n\n    bool has_positive = false;\n    int min_pos = INT_MAX; \n\n    for (int num : nums) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n\n    int a = has_negative ? max_neg : 0;\n    int b = has_positive ? min_pos : 0;\n\n    return {a, b};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n#include <typeinfo>\n#include <algorithm>\n\nusing namespace std;\n\npair<type_info, double> parseValue(const boost::any& value) {\n    if (value.type() == typeid(int)) {\n        return make_pair(typeid(int), static_cast<double>(boost::any_cast<int>(value)));\n    } else if (value.type() == typeid(double)) {\n        return make_pair(typeid(double), boost::any_cast<double>(value));\n    } else if (value.type() == typeid(float)) {\n        return make_pair(typeid(float), static_cast<double>(boost::any_cast<float>(value)));\n    } else if (value.type() == typeid(string)) {\n        string s = boost::any_cast<string>(value);\n        // Replace all commas with dots\n        replace(s.begin(), s.end(), ',', '.');\n        double d = stod(s);\n        return make_pair(typeid(string), d);\n    }\n    throw invalid_argument(\"Invalid type\");\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    return (n >= 8 && n % 2 == 0);\n}\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\nusing namespace std;\n\n"}
{"task_id": "CPP/140", "generation": "To solve this problem, we need to write a function that takes a string and replaces each sequence of one or more spaces with a single underscore. This transformation should be applied consistently across the entire string, ensuring that multiple consecutive spaces are reduced to a single underscore.\n\n### Approach\nThe approach involves using regular expressions to identify sequences of one or more spaces and replace them with a single underscore. Here's a step-by-step breakdown:\n\n1. **Identify Sequences**: Use a regular expression pattern `r' +'` to match any sequence of one or more spaces.\n2. **Replace with Underscore**: Replace each identified sequence with a single underscore.\n\nThis approach ensures that all sequences of spaces, regardless of their length, are replaced efficiently and correctly.\n\n### Solution Code\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring validateFilename(string filename) {\n    // Check for exactly one dot\n    int dotCount = 0;\n    for (char c : filename) {\n        if (c == '.') {\n            dotCount++;\n        }\n    }\n    if (dotCount != 1) {\n        return \"No\";\n    }\n\n    size_t dotPos = filename.find('.');\n    string namePart = filename.substr(0, dotPos);\n    string extensionPart = filename.substr(dotPos + 1);\n\n    // Check name part is not empty\n    if (namePart.empty()) {\n        return \"No\";\n    }\n\n    // Check first character of name part is a letter\n    char firstChar = namePart[0];\n    if (!isalpha(firstChar)) {\n        return \"No\";\n    }\n\n    // Check extension is allowed\n    if (extensionPart != \"txt\" && extensionPart != \"exe\" && extensionPart != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the entire filename\n    int digitCount = 0;\n    for (char c : filename) {\n        if (isdigit(c)) {\n            digitCount++;\n        }\n    }\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    // All checks passed\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nusing namespace std;\n\nint processVector(const vector<int>& lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        int num = lst[i];\n        if (i % 3 == 0) {\n            sum += num * num;\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += num * num * num;\n        } else {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> selected_words;\n    stringstream ss(sentence);\n    string word;\n    \n    while (ss >> word) {\n        int len = word.length();\n        if (is_prime(len)) {\n            selected_words.push_back(word);\n        }\n    }\n    \n    if (selected_words.empty()) return \"\";\n    \n    string result;\n    for (size_t i = 0; i < selected_words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += selected_words[i];\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "To solve this problem, we need to determine if the product of two fractions results in an integer. The solution involves simplifying each fraction and then checking specific divisibility conditions to ensure the product is an integer.\n\n### Approach\n1. **Simplify Each Fraction**: Simplify both fractions by dividing the numerator and denominator by their greatest common divisor (GCD). This step reduces the fractions to their lowest terms.\n2. **Check Divisibility Conditions**: After simplifying, check if the simplified numerator of one fraction is divisible by the simplified denominator of the other fraction. Specifically:\n   - Check if the simplified numerator of the second fraction (`c_prime`) is divisible by the simplified denominator of the first fraction (`d_prime`).\n   - Check if the simplified numerator of the first fraction (`a_prime`) is divisible by the simplified denominator of the second fraction (`b_prime`).\n\nIf both conditions are satisfied, the product of the two fractions will be an integer.\n\n### Solution Code\n"}
{"task_id": "CPP/145", "generation": "To solve this problem, we need to sort a list of integers based on the sum of their digits while maintaining the relative order of elements with the same digit sum. \n\n### Approach\n1. **Calculate Digit Sum**: For each number in the list, compute the sum of its absolute value's digits. This helps in determining the sorting key.\n2. **Sort Based on Digit Sum**: Use the computed digit sums as keys to sort the list. If two numbers have the same digit sum, their relative order from the original list is preserved.\n\n### Solution Code\n"}
{"task_id": "CPP/146", "generation": "To solve this problem, we need to determine how many numbers in a given list are greater than 10 and have both their first and last digits as odd numbers. \n\n### Approach\n1. **Reading Input**: The input is read from standard input, which is then split into individual integers.\n2. **Filtering Numbers**: For each number, we check if it is greater than 10. If it is not, we skip further processing for that number.\n3. **Extracting Digits**: For numbers greater than 10, convert the number to a string to easily access the first and last digits.\n4. **Checking Odd Digits**: Convert the first and last characters of the string back to integers and check if both are odd.\n5. **Counting Valid Numbers**: Maintain a count of numbers that meet the criteria (both first and last digits are odd).\n\n### Solution Code\n"}
{"task_id": "CPP/147", "generation": "To solve this problem, we need to determine the number of valid triples in an array where each element is either 0 or 1. A valid triple is defined as a set of three elements whose sum is divisible by 3.\n\n### Approach\nThe key insight is that for the sum of three numbers to be divisible by 3, all three numbers must be the same. This means we need to count how many triples consist entirely of 0s or entirely of 1s.\n\n1. **Count the Zeros and Ones**: First, we count the number of zeros (`c0`) and ones (`c1`) in the array.\n2. **Calculate Valid Triples**: Using combinatorial mathematics, we calculate the number of ways to choose 3 elements from `c0` (for zeros) and from `c1` (for ones). This is done using the combination formula \\( C(n, k) \\), which gives the number of ways to choose `k` elements from a set of `n` elements.\n\nThe combination formula \\( C(n, 3) \\) can be computed as \\( n \\times (n-1) \\times (n-2) / 6 \\). If `n` is less than 3, the result is 0 because it's impossible to form a triple.\n\n### Solution Code\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> getPlanetsBetween(string planet1, string planet2) {\n    vector<string> solarSystem = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    unordered_map<string, size_t> planetIndices;\n    \n    for (size_t i = 0; i < solarSystem.size(); ++i) {\n        planetIndices[solarSystem[i]] = i;\n    }\n    \n    if (planetIndices.find(planet1) == planetIndices.end() || \n        planetIndices.find(planet2) == planetIndices.end()) {\n        return {};\n    }\n    \n    size_t idx1 = planetIndices[planet1];\n    size_t idx2 = planetIndices[planet2];\n    \n    size_t i = min(idx1, idx2);\n    size_t j = max(idx1, idx2);\n    \n    size_t start = i + 1;\n    size_t end = j - 1;\n    \n    if (start > end) {\n        return {};\n    }\n    \n    vector<string> result;\n    for (size_t k = start; k <= end; ++k) {\n        result.push_back(solarSystem[k]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered.push_back(s);\n        }\n    }\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.size() != b.size()) {\n            return a.size() < b.size();\n        } else {\n            return a < b;\n        }\n    });\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "To solve this problem, we need to compute the sum of the squares of all odd integers in a given list. This involves iterating through each number in the list, checking if it is odd, and then including its square in the total sum.\n\n### Approach\n1. **Read Input**: First, we read the input values which are provided as space-separated integers.\n2. **Initialize Sum**: We initialize a variable to keep track of the cumulative sum starting from zero.\n3. **Iterate Through List**: For each number in the list, we check if it is odd using the modulus operator (`%`). If the number modulo 2 equals 1, it is odd.\n4. **Sum Squares of Odd Numbers**: For each odd number found, we compute its square and add this value to our cumulative sum.\n5. **Output Result**: Finally, we print the computed sum.\n\nThis approach ensures that we efficiently process each element in the list exactly once, resulting in a time complexity of O(n), where n is the number of elements in the list.\n\n### Solution Code\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (int i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <climits> // For INT_MIN\n\nusing namespace std;\n\nstring StrongestExtension(string class_name, vector<string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    int max_strength = INT_MIN;\n    string strongest_ext;\n\n    for (const string& ext : extensions) {\n        int cap_count = 0;\n        int sm_count = 0;\n        for (char c : ext) {\n            if (isupper(c)) {\n                cap_count++;\n            } else if (islower(c)) {\n                sm_count++;\n            }\n        }\n        int strength = cap_count - sm_count;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_ext;\n}\n"}
{"task_id": "CPP/154", "generation": "To solve this problem, we need to determine if any rotation of a given string `b` is a substring of another string `a`. A rotation of `b` means that the string is shifted such that some characters are moved from the beginning to the end. For example, rotating \"abcd\" once would result in \"bcda\".\n\n### Approach\n1. **Understand Rotations**: A rotation of a string `b` can be generated by moving characters from the start to the end repeatedly. For instance, if `b` is \"abcd\", its rotations are \"abcd\", \"bcda\", \"cdab\", and \"dabc\".\n2. **Generate All Rotations**: For each possible rotation of `b`, we need to check if it exists as a substring in `a`.\n3. **Check Substring Presence**: For each generated rotation, check if it is present in `a`. If any rotation is found, return true; otherwise, return false after checking all rotations.\n\n### Solution Code\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> even_odd_digits(int num) {\n    vector<int> result;\n    if (num == 0) {\n        result.push_back(1);\n        result.push_back(0);\n        return result;\n    }\n    int n = abs(num);\n    int even = 0, odd = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0)\n            even++;\n        else\n            odd++;\n        n /= 10;\n    }\n    result.push_back(even);\n    result.push_back(odd);\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"},\n        {400, \"cd\"}, {100, \"c\"}, {90, \"xc\"},\n        {50, \"l\"}, {40, \"xl\"}, {10, \"x\"},\n        {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result;\n\n    for (const auto& value_pair : roman_numerals) {\n        while (number >= value_pair.first) {\n            result += value_pair.second;\n            number -= value_pair.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n    \n    if ((a + b) <= c || (a + c) <= b || (b + c) <= a) {\n        return false;\n    }\n    \n    float sides[3] = {a, b, c};\n    sort(sides.begin(), sides.end());\n    float x = sides[0];\n    float y = sides[1];\n    float z = sides[2];\n    \n    float square_x = x * x;\n    float square_y = y * y;\n    float square_z = z * z;\n    \n    // Using a small epsilon to account for floating point precision issues\n    const float epsilon = 1e-6f;\n    return fabs(square_x + square_y - square_z) <= epsilon;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nstring findMax(vector<string> words) {\n    int max_count = 0;\n    string best_word;\n\n    for (auto &s : words) {\n        unordered_set<char> chars(s.begin(), s.end());\n        int count = chars.size();\n\n        if (count > max_count) {\n            max_count = count;\n            best_word = s;\n        } else if (count == max_count) {\n            if (s < best_word) {\n                best_word = s;\n            }\n        }\n    }\n\n    return best_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\n#include <algorithm> // For std::min\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    int amount = std::min(need, remaining);\n    int total_eaten = number + amount;\n    int rem_after = remaining - amount;\n    return {total_eaten, rem_after};\n}\n"}
{"task_id": "CPP/160", "generation": "int multiply(int a, int b) {\n    return a * b;\n}\n\nint integer_division(int a, int b) {\n    return a / b;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    string result;\n    for (char c : s) {\n        if (isalpha(static_cast<unsigned char>(c))) { \n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n            hasLetters = true;\n        } else {\n            result += c;\n        }\n    }\n    if (!hasLetters) {\n        reverse(result.begin(), result.end());\n    }\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <openssl/md5.h>\n#include <string>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    MD5_CTX ctx;\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    static const char hex_digits[] = \"0123456789abcdef\";\n    char hex_digest[2 * MD5_DIGEST_LENGTH + 1];\n\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.data(), text.length());\n    MD5_Final(digest, &ctx);\n\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        unsigned char c = digest[i];\n        hex_digest[2 * i] = hex_digits[(c >> 4) & 0x0f];\n        hex_digest[2 * i + 1] = hex_digits[c & 0x0f];\n    }\n    hex_digest[2 * MD5_DIGEST_LENGTH] = '\\0';\n\n    return string(hex_digest);\n}\n"}
{"task_id": "CPP/163", "generation": "To solve this problem, we need to extract all even digits from each number in a given range [a, b]. The goal is to collect these even digits and return them as a list.\n\n### Approach\n1. **Problem Analysis**: We are given two integers, `a` and `b`, which define the range of numbers to consider. For each number in this range, we need to check each digit to see if it is even. If it is, we add it to our result list.\n2. **Intuition**: By iterating through each number from `a` to `b` inclusive, and then converting each number to a string to examine its digits individually, we can efficiently collect all even digits.\n3. **Algorithm**:\n   - Initialize an empty list to store the even digits.\n   - Loop through each number in the range [a, b].\n   - For each number, convert it to a string to process each digit.\n   - Check if each digit is even. If it is, add it to the result list.\n4. **Complexity**: The time complexity of this approach is O((b-a+1) * d), where `d` is the average number of digits per number in the range. This is efficient given the constraints.\n\n### Solution Code\n"}
