{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    sort(numbers.begin(), numbers.end());\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i+1] - numbers[i] <= threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    string cleaned;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned += c;\n        }\n    }\n    \n    vector<string> result;\n    string current_group;\n    int balance = 0;\n    \n    for (char c : cleaned) {\n        current_group += c;\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <math.h>\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    return number - integer_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f; // Handle empty vector case\n    }\n    \n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    float mad = mad_sum / numbers.size();\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<string> groups;\n    stringstream ss(paren_string);\n    string group;\n    while (getline(ss, group, ' ')) {\n        groups.push_back(group);\n    }\n    \n    vector<int> result;\n    for (auto &g : groups) {\n        int current_depth = 0;\n        int max_depth = 0;\n        for (char c : g) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (string s : strings) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    int current_max = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) return str;\n    int n = str.size();\n    for (int l = n; l >= 1; --l) {\n        string suffix = str.substr(n - l, l);\n        if (is_palindrome(suffix)) {\n            string prefix = str.substr(0, n - l);\n            string rev_prefix(prefix.rbegin(), prefix.rend());\n            return str + rev_prefix;\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <algorithm> // For max function\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    int max_len = max(a.size(), b.size());\n    \n    // Pad 'a' with leading zeros if necessary\n    string padded_a = a;\n    if (padded_a.size() < max_len) {\n        padded_a = string(max_len - padded_a.size(), '0') + padded_a;\n    }\n    \n    // Pad 'b' with leading zeros if necessary\n    string padded_b = b;\n    if (padded_b.size() < max_len) {\n        padded_b = string(max_len - padded_b.size(), '0') + padded_b;\n    }\n    \n    string result;\n    for (int i = 0; i < max_len; ++i) {\n        char a_char = padded_a[i];\n        char b_char = padded_b[i];\n        \n        int a_int = a_char - '0';\n        int b_int = b_char - '0';\n        \n        int xor_result = a_int ^ b_int;\n        result += (xor_result ? '1' : '0');\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    string max_str = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > max_str.length()) {\n            max_str = strings[i];\n        }\n    }\n    return max_str;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <cstdlib> // For abs function\n\nint greatest_common_divisor(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    for (int i = 1; i <= str.size(); ++i) {\n        string prefix = str.substr(0, i);\n        result.push_back(prefix);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <sstream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    bool first = true;\n    for (int i = 0; i <= n; ++i) {\n        if (!first) {\n            ss << \" \";\n        }\n        ss << i;\n        first = false;\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> seen;\n    for (char c : str) {\n        char lower_c = tolower(static_cast<unsigned char>(c));\n        seen.insert(lower_c);\n    }\n    return seen.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    stringstream ss(music_string);\n    string note;\n    while (ss >> note) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int m = substring.length();\n    int n = str.length();\n    \n    if (m == 0 || m > n) {\n        return 0;\n    }\n    \n    for (int i = 0; i <= n - m; ++i) {\n        if (str.substr(i, m) == substring) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    vector<string> words;\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    map<string, int> word_to_num;\n    word_to_num[\"zero\"] = 0;\n    word_to_num[\"one\"] = 1;\n    word_to_num[\"two\"] = 2;\n    word_to_num[\"three\"] = 3;\n    word_to_num[\"four\"] = 4;\n    word_to_num[\"five\"] = 5;\n    word_to_num[\"six\"] = 6;\n    word_to_num[\"seven\"] = 7;\n    word_to_num[\"eight\"] = 8;\n    word_to_num[\"nine\"] = 9;\n\n    vector<pair<int, string>> num_word;\n    for (auto &w : words) {\n        num_word.push_back(make_pair(word_to_num[w], w));\n    }\n\n    sort(num_word.begin(), num_word.end());\n\n    vector<string> sorted_words;\n    for (auto &p : num_word) {\n        sorted_words.push_back(p.second);\n    }\n\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        if (i != 0) {\n            result += \" \";\n        }\n        result += sorted_words[i];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = numbers[1] - numbers[0];\n    vector<float> result = {numbers[0], numbers[1]};\n    \n    for (int i = 1; i < numbers.size() - 1; ++i) {\n        float current_diff = numbers[i+1] - numbers[i];\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i+1];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // For std::min_element and std::max_element if needed\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.empty()) {\n        return {}; // Though the problem states at least two elements, handle empty case safely.\n    }\n    \n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    for (float num : numbers) {\n        if (num < min_val) {\n            min_val = num;\n        }\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    \n    if (min_val == max_val) {\n        vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n    \n    float range = max_val - min_val;\n    vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / range);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\nusing namespace std;\n\ntypedef list<boost::any> list_any;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (auto& elem : values) {\n        if (!elem.empty() && elem.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(elem));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    if (n <= 1) {\n        return 0;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Handle the factor 2 separately\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Now n must be odd, start from 3 and increment by 2\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If remaining n is a prime\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> freq;\n    for (int num : numbers) {\n        freq[num]++;\n    }\n    vector<int> result;\n    for (int num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <cctype>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (int i = 0; i < str.size(); ++i) {\n        if (islower(str[i])) {\n            str[i] = toupper(str[i]);\n        } else if (isupper(str[i])) {\n            str[i] = tolower(str[i]);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (string s : strings) {\n        result += s;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    if (prefix.empty()) {\n        return strings;\n    }\n    for (string s : strings) {\n        if (s.length() >= prefix.length()) {\n            string sub = s.substr(0, prefix.length());\n            if (sub == prefix) {\n                result.push_back(s);\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (long long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    auto f = [&](double x) { return poly(xs, x); };\n\n    // Check for roots at common points\n    if (f(0.0) == 0.0) return 0.0;\n    if (f(1.0) == 0.0) return 1.0;\n    if (f(-1.0) == 0.0) return -1.0;\n\n    // Find a bracket [a, b] where f(a) and f(b) have opposite signs\n    double a, b;\n    bool found = false;\n\n    // Try positive direction\n    double x = 1.0;\n    while (true) {\n        double fx = f(x);\n        if (fx == 0.0) return x;\n        if (f(0.0) * fx < 0) {\n            a = 0.0;\n            b = x;\n            found = true;\n            break;\n        }\n        if (x > 1e10) break; // Prevent infinite loop\n        x *= 2;\n    }\n\n    if (!found) {\n        // Try negative direction\n        x = -1.0;\n        while (true) {\n            double fx = f(x);\n            if (fx == 0.0) return x;\n            if (f(0.0) * fx < 0) {\n                a = x;\n                b = 0.0;\n                found = true;\n                break;\n            }\n            if (x < -1e10) break; // Prevent infinite loop\n            x *= 2;\n        }\n    }\n\n    // Apply the secant method\n    double tolerance = 1e-8;\n    int max_iter = 100;\n    double x_prev = a;\n    double x_curr = b;\n    double f_prev = f(x_prev);\n    double f_curr = f(x_curr);\n\n    for (int i = 0; i < max_iter; ++i) {\n        if (f_curr == 0.0) return x_curr;\n\n        double denominator = f_curr - f_prev;\n        if (denominator == 0) break; // Avoid division by zero\n\n        double x_next = x_curr - f_curr * (x_curr - x_prev) / denominator;\n\n        // Ensure the next point is within the bracket\n        if (x_next < a || x_next > b) {\n            x_next = (a + b) / 2;\n        }\n\n        double f_next = f(x_next);\n        if (fabs(x_next - x_curr) < tolerance) {\n            return x_next;\n        }\n\n        x_prev = x_curr;\n        x_curr = x_next;\n        f_prev = f_curr;\n        f_curr = f_next;\n    }\n\n    return x_curr;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> temp;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            temp.push_back(l[i]);\n        }\n    }\n    sort(temp.begin(), temp.end());\n    vector<int> result;\n    int j = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result.push_back(temp[j]);\n            j++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    sort(l.begin(), l.end());\n    auto last = unique(l.begin(), l.end());\n    l.erase(last, l.end());\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return 0; // Assuming 0 is an appropriate return value for an empty vector\n    }\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "int fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num != 0) {\n                int digit = num % 10;\n                if (digit == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> evens;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            evens.push_back(l[i]);\n        }\n    }\n    sort(evens.begin(), evens.end());\n    \n    vector<float> result;\n    int even_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(evens[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i < num; i++) {\n        string group = s.substr(i * 3, 3);\n        if (group.length() == 3) {\n            group = group[2] + group.substr(0, 2);\n        }\n        output += group;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int a = 1;\n    int b = 1;\n    int count = 0;\n    while (true) {\n        int next = a + b;\n        if (is_prime(next)) {\n            count++;\n            if (count == n) {\n                return next;\n            }\n        }\n        a = b;\n        b = next;\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n    sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "int car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_map<int, int> freq;\n    for (int num : l) {\n        freq[num]++;\n    }\n    for (int num : l) {\n        if (num == 0) {\n            if (freq[num] >= 2) {\n                return true;\n            }\n        } else {\n            if (freq.find(-num) != freq.end()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    string s;\n    while (x > 0) {\n        int rem = x % base;\n        s += (rem + '0');\n        x = x / base;\n    }\n    reverse(s.begin(), s.end());\n    return s;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2.0f;\n}\n"}
{"task_id": "CPP/46", "generation": "int fib4(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n    \n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        return (l[(n / 2) - 1] + l[n / 2]) / 2.0f;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <algorithm>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    string reversed_text = text;\n    reverse(reversed_text.begin(), reversed_text.end());\n    return reversed_text == text;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1) {\n        return 0;\n    }\n    int result = 1;\n    int base = 2 % p;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = n / 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <string>\nusing namespace std;\n\nstring decode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        int offset = (c - 'a' - 5 + 26) % 26;\n        out += (char)('a' + offset);\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result;\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <set>\n#include <string>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> set0(s0.begin(), s0.end());\n    set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}\n"}
{"task_id": "CPP/55", "generation": "int fib(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stack>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n    \n    int direction = 0; // 0: unknown, 1: increasing, -1: decreasing\n    \n    for (int i = 0; i < l.size() - 1; ++i) {\n        float current = l[i];\n        float next = l[i + 1];\n        \n        if (direction == 0) {\n            if (next > current) {\n                direction = 1;\n            } else if (next < current) {\n                direction = -1;\n            }\n        } else {\n            if (direction == 1) {\n                if (next < current) {\n                    return false;\n                }\n            } else {\n                if (next > current) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n    \n    vector<int> temp;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(temp));\n    \n    vector<int> result;\n    if (!temp.empty()) {\n        result.push_back(temp[0]);\n        for (size_t i = 1; i < temp.size(); ++i) {\n            if (temp[i] != result.back()) {\n                result.push_back(temp[i]);\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n\nint largest_prime_factor(int n) {\n    int largest = 1;\n\n    // Handle the case of 2 separately\n    while (n % 2 == 0) {\n        largest = 2;\n        n = n / 2;\n    }\n\n    // Now n must be odd, start from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n = n / i;\n        }\n    }\n\n    // If remaining n is a prime\n    if (n > 1) {\n        largest = n;\n    }\n\n    return largest;\n}\n"}
{"task_id": "CPP/60", "generation": "int sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stack>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "int fibfib(int n) {\n    if (n == 0 || n == 1) {\n        return 0;\n    } else if (n == 2) {\n        return 1;\n    }\n    int a = 0, b = 0, c = 1;\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n    return c;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        char lower_c = tolower(c);\n        if (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u') {\n            count++;\n        }\n    }\n    if (!s.empty()) {\n        char last = tolower(s.back());\n        if (last == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    string sign = \"\";\n    string digits;\n\n    if (s[0] == '-') {\n        sign = \"-\";\n        digits = s.substr(1);\n    } else {\n        digits = s;\n    }\n\n    int n = digits.length();\n    if (n == 0) {\n        return sign + digits;\n    }\n\n    if (shift > n) {\n        reverse(digits.begin(), digits.end());\n    } else {\n        int effective_shift = shift % n;\n        if (effective_shift != 0) {\n            string part1 = digits.substr(n - effective_shift);\n            string part2 = digits.substr(0, n - effective_shift);\n            digits = part1 + part2;\n        }\n    }\n\n    return sign + digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<string> tokens;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        tokens.push_back(word);\n    }\n    int apples = stoi(tokens[0]);\n    int oranges = stoi(tokens[3]);\n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1) {\n                smallest_even = arr[i];\n                index = i;\n            } else {\n                if (arr[i] < smallest_even) {\n                    smallest_even = arr[i];\n                    index = i;\n                } else if (arr[i] == smallest_even) {\n                    if (i < index) {\n                        index = i;\n                    }\n                }\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    } else {\n        return {smallest_even, index};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int max_candidate = -1;\n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        if (count >= num && num > max_candidate) {\n            max_candidate = num;\n        }\n    }\n    return max_candidate != -1 ? max_candidate : -1;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    if (lst.empty()) {\n        return {};\n    }\n    \n    sort(lst.begin(), lst.end());\n    \n    vector<int> res;\n    int i = 0;\n    int j = lst.size() - 1;\n    bool take_min = true;\n    \n    while (i <= j) {\n        if (take_min) {\n            res.push_back(lst[i]);\n            i++;\n        } else {\n            res.push_back(lst[j]);\n            j--;\n        }\n        take_min = !take_min;\n    }\n    \n    return res;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return -1;\n    }\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    float s = (a + b + c) / 2.0f;\n    float area_sq = s * (s - a) * (s - b) * (s - c);\n    float area = sqrt(area_sq);\n    area = round(area * 100.0f) / 100.0f;\n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    // Check if sum is within the weight limit\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0;\n    for (const string& s : lst1) {\n        sum1 += s.size();\n    }\n    \n    int sum2 = 0;\n    for (const string& s : lst2) {\n        sum2 += s.size();\n    }\n    \n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    if (a < 8) {\n        return false;\n    }\n    int count = 0;\n    int i = 2;\n    while (i * i <= a) {\n        if (a % i == 0) {\n            while (a % i == 0) {\n                count++;\n                a /= i;\n                if (count > 3) {\n                    return false;\n                }\n            }\n        } else {\n            i++;\n        }\n    }\n    if (a > 1) {\n        count++;\n    }\n    return count == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == -1) {\n        return (x == 1 || x == -1);\n    }\n    if (x == 0) {\n        return false;\n    }\n\n    if (n > 0) {\n        if (x < 0) {\n            return false;\n        }\n\n        double log_val = log(x) / log(n);\n        int k = round(log_val);\n\n        long long result = 1;\n        for (int i = 0; i < abs(k); ++i) {\n            result *= n;\n            if (result > x) {\n                return false;\n            }\n        }\n\n        return result == x;\n    } else {\n        int abs_n = abs(n);\n        int abs_x = abs(x);\n\n        double log_val = log(abs_x) / log(abs_n);\n        int k = round(log_val);\n\n        long long result = 1;\n        for (int i = 0; i < abs(k); ++i) {\n            result *= abs_n;\n            if (result > abs_x) {\n                return false;\n            }\n        }\n\n        if (result != abs_x) {\n            return false;\n        }\n\n        if (x < 0) {\n            return (k % 2 != 0);\n        } else {\n            return (k % 2 == 0);\n        }\n    }\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    double cube_root = (a < 0) ? -pow(-a, 1.0/3.0) : pow(a, 1.0/3.0);\n    int n = round(cube_root);\n    return (n *"}
{"task_id": "CPP/78", "generation": "#include <string>\n\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    string primes = \"2357BD\";\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary;\n    if (decimal == 0) {\n        binary = \"0\";\n    } else {\n        while (decimal > 0) {\n            int rem = decimal % 2;\n            binary += (rem == 0) ? '0' : '1';\n            decimal /= 2;\n        }\n        reverse(binary.begin(), binary.end());\n    }\n    string result = \"db\";\n    result += binary;\n    result += \"db\";\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i < s.size() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            result.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            result.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            result.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            result.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            result.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            result.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            result.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            result.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            result.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            result.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            result.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\nusing namespace std;\n\nbool prime_length(string str) {\n    int n = str.size();\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    } else {\n        int power = 1;\n        for (int i = 0; i < n - 2; ++i) {\n            power *= 10;\n        }\n        return 18 * power;\n    }\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N = N / 10;\n    }\n    if (sum == 0) {\n        return \"0\";\n    }\n    string binary;\n    while (sum > 0) {\n        binary += (sum % 2) + '0';\n        sum = sum / 2;\n    }\n    reverse(binary.begin(), binary.end());\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 1) { // Check if index is odd\n            if (lst[i] % 2 == 0) { // Check if element is even\n                sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    int i = 0;\n    while (i < s.size()) {\n        if (s[i] == ' ') {\n            result += ' ';\n            i++;\n        } else {\n            string word;\n            while (i < s.size() && s[i] != ' ') {\n                word += s[i];\n                i++;\n            }\n            sort(word.begin(), word.end());\n            result += word;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        const vector<int>& row = lst[i];\n        for (int j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0];\n        } else {\n            return a[1] > b[1];\n        }\n    });\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) {\n        return array;\n    }\n    int sum = array[0] + array.back();\n    if (sum % 2 != 0) {\n        sort(array.begin(), array.end());\n    } else {\n        sort(array.begin(), array.end(), greater<int>());\n    }\n    return array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result;\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            int shifted = (c - 'a' + 4) % 26;\n            result += 'a' + shifted;\n        } else if (c >= 'A' && c <= 'Z') {\n            int shifted = (c - 'A' + 4) % 26;\n            result += 'A' + shifted;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1;\n    }\n    sort(lst.begin(), lst.end());\n    int min_val = lst[0];\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] > min_val) {\n            return lst[i];\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <vector>\n#include <cctype>\n#include <string>\n\nusing namespace std;\n\nvector<string> split_into_sentences(const string &S) {\n    vector<string> sentences;\n    size_t start = 0;\n    for (size_t i = 0; i < S.size(); ++i) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            string sentence = S.substr(start, i - start);\n            sentences.push_back(sentence);\n            start = i + 1;\n        }\n    }\n    if (start < S.size()) {\n        sentences.push_back(S.substr(start));\n    }\n    return sentences;\n}\n\nbool starts_with_I(const string &sentence) {\n    size_t start = 0;\n    while (start < sentence.size() && isspace(sentence[start])) {\n        start++;\n    }\n    if (start >= sentence.size()) {\n        return false;\n    }\n    if (sentence[start] != 'I') {\n        return false;\n    }\n    size_t next = start + 1;\n    if (next >= sentence.size()) {\n        return true;\n    }\n    char c = sentence[next];\n    return (isspace(c) || c == '.' || c == '!' || c == '?');\n}\n\nint is_bored(string S) {\n    vector<string> sentences = split_into_sentences(S);\n    int count = 0;\n    for (const string &sentence : sentences) {\n        if (starts_with_I(sentence)) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    const float epsilon = 1e-6;\n    \n    // Check if all numbers are integers\n    if (fabs(a - round(a)) > epsilon ||\n        fabs(b - round(b)) > epsilon ||\n        fabs(c - round(c)) > epsilon) {\n        return false;\n    }\n    \n    // Check the three possible sum conditions\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nstring encode(string message) {\n    string result;\n    for (char c : message) {\n        // Swap the case of the character\n        if (islower(c)) {\n            c = toupper(c);\n        } else {\n            c = tolower(c);\n        }\n        \n        // Check if the character is a vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            \n            // Replace the vowel with the next two letters, maintaining case\n            if (isupper(c)) {\n                c = (c - 'A' + 2) % 26 + 'A';\n            } else {\n                c = (c - 'a' + 2) % 26 + 'a';\n            }\n        }\n        \n        result += c;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n    if (max_prime == -1) {\n        return 0;\n    }\n    int sum = 0;\n    int temp = max_prime;\n    while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool expected_lower = false;\n    bool expected_upper = false;\n\n    for (auto& pair : dict) {\n        string key = pair.first;\n        if (key.empty()) {\n            return false;\n        }\n\n        bool is_lower = true;\n        bool is_upper = true;\n\n        for (char c : key) {\n            if (c < 'a' || c > 'z') {\n                is_lower = false;\n            }\n            if (c < 'A' || c > 'Z') {\n                is_upper = false;\n            }\n        }\n\n        if (!is_lower && !is_upper) {\n            return false;\n        }\n\n        if (expected_lower || expected_upper) {\n            if (expected_lower) {\n                if (!is_lower) {\n                    return false;\n                }\n            } else {\n                if (!is_upper) {\n                    return false;\n                }\n            }\n        } else {\n            if (is_lower) {\n                expected_lower = true;\n                expected_upper = false;\n            } else {\n                expected_lower = false;\n                expected_upper = true;\n            }\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> result;\n    if (n <= 2) {\n        return result;\n    }\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <cstdlib> // For abs function\n\nint multiply(int a, int b) {\n    int unit_a = abs(a) % 10;\n    int unit_b = abs(b) % 10;\n    return unit_a * unit_b;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0) { // Check if the index is even\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    double x = stod(value);\n    double lower = floor(x);\n    double upper = lower + 1.0;\n    double distance_lower = x - lower;\n    double distance_upper = upper - x;\n\n    if (distance_lower < distance_upper) {\n        return (int)lower;\n    } else if (distance_upper < distance_lower) {\n        return (int)upper;\n    } else {\n        if (x >= 0) {\n            return (int)upper;\n        } else {\n            return (int)lower;\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(n + 2 * i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string current;\n\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!current.empty()) {\n                result.push_back(current);\n                current.clear();\n            }\n        } else {\n            current += c;\n        }\n    }\n\n    if (!current.empty()) {\n        result.push_back(current);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "int choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int avg = (n + m) / 2;\n    string binary;\n    while (avg > 0) {\n        int rem = avg % 2;\n        binary += rem ? '1' : '0';\n        avg /= 2;\n    }\n    reverse(binary.begin(), binary.end());\n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return false;\n        }\n        num = num / 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n    \n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n    \n    string names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = i * (i + 1) / 2;\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        string s = to_string(i);\n        string rev = s;\n        reverse(rev.begin(), rev.end());\n        if (s == rev) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) {\n            continue;\n        }\n        int sign = num < 0 ? -1 : 1;\n        int number = abs(num);\n        vector<int> digits;\n        int temp = number;\n        while (temp > 0) {\n            digits.insert(digits.begin(), temp % 10);\n            temp /= 10;\n        }\n        if (digits.empty()) {\n            continue;\n        }\n        int sum = sign * digits[0];\n        for (size_t i = 1; i < digits.size(); ++i) {\n            sum += digits[i];\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    int count = 0;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        int next = (i + 1) % n;\n        if (arr[i] > arr[next]) {\n            count++;\n        }\n    }\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int e1 = 0, e2 = 0;\n    for (int num : lst1) {\n        if (num % 2 == 0) {\n            e1++;\n        }\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            e2++;\n        }\n    }\n    if (e1 + e2 >= lst1.size()) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <map>\n#include <string>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> counts;\n    for (char c : test) {\n        if (c != ' ') {\n            counts[c]++;\n        }\n    }\n    int max_count = 0;\n    for (auto& pair : counts) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n    map<char, int> result;\n    if (max_count > 0) {\n        for (auto& pair : counts) {\n            if (pair.second == max_count) {\n                result[pair.first] = pair.second;\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> c_chars(c.begin(), c.end());\n    string filtered;\n    for (char ch : s) {\n        if (c_chars.find(ch) == c_chars.end()) {\n            filtered += ch;\n        }\n    }\n    string reversed = filtered;\n    reverse(reversed.begin(), reversed.end());\n    bool is_pal = (filtered == reversed);\n    return {filtered, is_pal ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result_vec;\n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (isdigit(c)) {\n                int digit = c - '0';\n                if (digit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        string result = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result += \".\";\n        result_vec.push_back(result);\n    }\n    return result_vec;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm> // For std::min\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) {\n        return 0; // Assuming 0 is returned for an empty vector, though the problem states it's non-empty.\n    }\n    long long current_min = nums[0];\n    long long overall_min = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = min(nums[i], current_min + nums[i]);\n        overall_min = min(overall_min, current_min);\n    }\n    return overall_min;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total = 0;\n    for (auto &row : grid) {\n        int sum = 0;\n        for (int val : row) {\n            sum += val;\n        }\n        int buckets = (sum + capacity - 1) / capacity;\n        total += buckets;\n    }\n    return total;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint count_ones(int num) {\n    num = abs(num);\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n        if (count_a != count_b) {\n            return count_a < count_b;\n        } else {\n            return a < b;\n        }\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            char lower_c = tolower(c);\n            if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"AEIOUaeiou\";\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (i == 0 || i == word.size() - 1) {\n                continue;\n            }\n            bool prevIsConsonant = (vowels.find(word[i-1]) == string::npos);\n            bool nextIsConsonant = (vowels.find(word[i+1]) == string::npos);\n            if (prevIsConsonant && nextIsConsonant) {\n                return string(1, word[i]);\n            }\n        }\n    }\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string a = lst[0];\n    string b = lst[1];\n    \n    int a_open = count(a.begin(), a.end(), '(');\n    int a_close = a.size() - a_open;\n    \n    int b_open = count(b.begin(), b.end(), '(');\n    int b_close = b.size() - b_open;\n    \n    int total_open = a_open + b_open;\n    int total_close = a_close + b_close;\n    \n    if (total_open != total_close) {\n        return \"No\";\n    }\n    \n    string ab = a + b;\n    string ba = b + a;\n    \n    if (is_balanced(ab) || is_balanced(ba)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    if (k == 0) {\n        return {};\n    }\n    sort(arr.begin(), arr.end());\n    vector<int> result;\n    int n = arr.size();\n    for (int i = n - k; i < n; ++i) {\n        result.push_back(arr[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\n\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0) { // Check if index is even\n            if (lst[i] % 2 != 0) { // Check if element is odd\n                sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (abs(num) < 100) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> sequence;\n    sequence.push_back(n);\n    int current = n;\n    while (current != 1) {\n        if (current % 2 == 0) {\n            current = current / 2;\n        } else {\n            current = 3 * current + 1;\n        }\n        sequence.push_back(current);\n    }\n    \n    vector<int> odds;\n    for (int num : sequence) {\n        if (num % 2 != 0) {\n            odds.push_back(num);\n        }\n    }\n    \n    sort(odds.begin(), odds.end());\n    return odds;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    if (date.empty()) return false;\n\n    if (date.size() != 10) return false;\n\n    for (int i = 0; i < 10; ++i) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return false;\n        } else {\n            if (!isdigit(date[i])) {\n                return false;\n            }\n        }\n    }\n\n    string mm = date.substr(0, 2);\n    string dd = date.substr(3, 2);\n    string yyyy = date.substr(6, 4);\n\n    int month = stoi(mm);\n    int day = stoi(dd);\n    int year = stoi(yyyy);\n\n    if (month < 1 || month > 12) return false;\n\n    if (month == 2) {\n        if (day < 1 || day > 29) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) return false;\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\nusing namespace std;\n\nvector<string> split_whitespace(const string& s) {\n    vector<string> tokens;\n    string current_token;\n    for (char c : s) {\n        if (isspace(c)) {\n            if (!current_token.empty()) {\n                tokens.push_back(current_token);\n                current_token.clear();\n            }\n        } else {\n            current_token += c;\n        }\n    }\n    if (!current_token.empty()) {\n        tokens.push_back(current_token);\n    }\n    return tokens;\n}\n\nvector<string> split_commas(const string& s) {\n    vector<string> tokens;\n    size_t start = 0;\n    size_t end = s.find(',');\n    while (end != string::npos) {\n        tokens.push_back(s.substr(start, end - start));\n        start = end + 1;\n        end = s.find(',', start);\n    }\n    tokens.push_back(s.substr(start));\n    return tokens;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> words = split_whitespace(txt);\n    if (words.size() > 1) {\n        return words;\n    } else {\n        vector<string> comma_words = split_commas(txt);\n        if (comma_words.size() > 1) {\n            return comma_words;\n        } else {\n            int count = 0;\n            for (char c : txt) {\n                if (islower(c)) {\n                    int pos = c - 'a';\n                    if (pos % 2 == 1) {\n                        count++;\n                    }\n                }\n            }\n            return vector<string>{to_string(count)};\n        }\n    }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in ascending order\n    for (int i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n    \n    // Check the frequency of each number\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n        if (freq[num] > 2) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int a1 = interval1[0], b1 = interval1[1];\n    int a2 = interval2[0], b2 = interval2[1];\n    \n    int start = max(a1, a2);\n    int end = min(b1, b2);\n    \n    if (start > end) {\n        return \"NO\";\n    }\n    \n    int length = end - start;\n    \n    if (length < 2) {\n        return \"NO\";\n    }\n    \n    return is_prime(length) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n    }\n    int product_sign = 1;\n    for (int num : arr) {\n        if (num < 0) {\n            product_sign *= -1;\n        }\n    }\n    int sum = 0;\n    for (int num : arr) {\n        sum += abs(num);\n    }\n    return sum * product_sign;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    int start_i = 0, start_j = 0;\n    int min_val = grid[0][0];\n    \n    // Find the starting cell with the minimum value\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                start_i = i;\n                start_j = j;\n            }\n        }\n    }\n    \n    vector<int> result;\n    result.reserve(k);\n    result.push_back(min_val);\n    \n    int current_i = start_i;\n    int current_j = start_j;\n    \n    // Directions: up, down, left, right\n    vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    for (int step = 1; step < k; ++step) {\n        int min_neighbor = INT_MAX;\n        int ni, nj;\n        \n        for (auto& dir : dirs) {\n            int new_i = current_i + dir.first;\n            int new_j = current_j + dir.second;\n            \n            if (new_i >= 0 && new_i < n && new_j >= 0 && new_j < n) {\n                if (grid[new_i][new_j] < min_neighbor) {\n                    min_neighbor = grid[new_i][new_j];\n                    ni = new_i;\n                    nj = new_j;\n                }\n            }\n        }\n        \n        current_i = ni;\n        current_j = nj;\n        result.push_back(grid[current_i][current_j]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> res;\n    if (n < 0) return res;\n    res.push_back(1); // tri(0)\n    if (n >= 1) {\n        res.push_back(3); // tri(1)\n        for (int m = 2; m <= n; ++m) {\n            if (m % 2 == 0) {\n                res.push_back(1 + m / 2);\n            } else {\n                int val = 1 + (m + 1) / 2 + res[m - 1] + res[m - 2];\n                res.push_back(val);\n            }\n        }\n    }\n    return res;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n = n / 10;\n    }\n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <map>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    map<int, int> current_map;\n    current_map[0] = 0;\n\n    for (char c : str) {\n        map<int, int> temp_map;\n\n        for (auto& entry : current_map) {\n            int balance = entry.first;\n            int depth = entry.second;\n\n            if (c == '[') {\n                int new_balance = balance + 1;\n                int new_depth = max(depth, new_balance);\n                if (temp_map.find(new_balance) != temp_map.end()) {\n                    if (new_depth > temp_map[new_balance]) {\n                        temp_map[new_balance] = new_depth;\n                    }\n                } else {\n                    temp_map[new_balance] = new_depth;\n                }\n            } else {\n                if (balance > 0) {\n                    int new_balance = balance - 1;\n                    int new_depth = depth;\n                    if (temp_map.find(new_balance) != temp_map.end()) {\n                        if (new_depth > temp_map[new_balance]) {\n                            temp_map[new_balance] = new_depth;\n                        }\n                    } else {\n                        temp_map[new_balance] = new_depth;\n                    }\n                }\n            }\n        }\n\n        for (auto& entry : temp_map) {\n            int balance = entry.first;\n            int depth = entry.second;\n            if (current_map.find(balance) != current_map.end()) {\n                if (depth > current_map[balance]) {\n                    current_map[balance] = depth;\n                }\n            } else {\n                current_map[balance] = depth;\n            }\n        }\n    }\n\n    if (current_map.find(0) != current_map.end() && current_map[0] >= 2) {\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiled = static_cast<int>(ceil(num));\n        sum += ceiled * ceiled;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n    char last = txt.back();\n    if (!isalpha(last)) {\n        return false;\n    }\n    if (txt.size() == 1) {\n        return true;\n    }\n    if (txt[txt.size() - 2] == ' ') {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int max_index = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> negatives;\n    vector<int> positives;\n\n    for (int num : lst) {\n        if (num < 0) {\n            negatives.push_back(num);\n        } else if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n\n    int a = 0;\n    if (!negatives.empty()) {\n        a = *max_element(negatives.begin(), negatives.end());\n    }\n\n    int b = 0;\n    if (!positives.empty()) {\n        b = *min_element(positives.begin(), positives.end());\n    }\n\n    return {a, b};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble getValue(const boost::any& arg) {\n    if (arg.type() == typeid(int)) {\n        return boost::any_cast<int>(arg);\n    } else if (arg.type() == typeid(float)) {\n        return boost::any_cast<float>(arg);\n    } else if (arg.type() == typeid(double)) {\n        return boost::any_cast<double>(arg);\n    } else if (arg.type() == typeid(string)) {\n        string s = boost::any_cast<string>(arg);\n        string num_str;\n        for (char c : s) {\n            if (c == ',') {\n                num_str += '.';\n            } else {\n                num_str += c;\n            }\n        }\n        return stod(num_str);\n    } else {\n        throw invalid_argument(\"Unsupported type\");\n    }\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double a_val = getValue(a);\n    double b_val = getValue(b);\n    \n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    long long current_factorial = 1;\n    for (int i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        result *= current_factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    bool in_space = false;\n    int current_space_count = 0;\n    string result;\n\n    for (char c : text) {\n        if (c == ' ') {\n            if (!in_space) {\n                in_space = true;\n                current_space_count = 1;\n            } else {\n                current_space_count++;\n            }\n        } else {\n            if (in_space) {\n                if (current_space_count <= 2) {\n                    result.append(current_space_count, '_');\n                } else {\n                    result += '-';\n                }\n                in_space = false;\n            }\n            result += c;\n        }\n    }\n\n    if (in_space) {\n        if (current_space_count <= 2) {\n            result.append(current_space_count, '_');\n        } else {\n            result += '-';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (c >= '0' && c <= '9') {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Count the number of dots\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    size_t dot_pos = file_name.find('.');\n    string name = file_name.substr(0, dot_pos);\n    string extension = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is valid\n    if (name.empty()) {\n        return \"No\";\n    }\n    char first_char = name[0];\n    if (!((first_char >= 'a' && first_char <= 'z') || (first_char >= 'A' && first_char <= 'Z'))) {\n        return \"No\";\n    }\n\n    // Check if the extension is valid\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    // All conditions are satisfied\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    vector<string> result;\n    for (auto &w : words) {\n        if (is_prime(w.length())) {\n            result.push_back(w);\n        }\n    }\n    \n    string output;\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i != 0) {\n            output += \" \";\n        }\n        output += result[i];\n    }\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <string>\nusing namespace std;\n\nint gcd(int num1, int num2) {\n    while (num2 != 0) {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\nbool simplify(string x, string n) {\n    int a, b, c, d;\n    sscanf(x.c_str(), \"%d/%d\", &a, &b);\n    sscanf(n.c_str(), \"%d/%d\", &c, &d);\n    \n    int product_num = a * c;\n    int product_den = b * d;\n    \n    if (product_num == 0) {\n        return true;\n    }\n    \n    int gcd_value = gcd(product_num, product_den);\n    int simplified_den = product_den / gcd_value;\n    \n    return simplified_den == 1;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint calculateSum(int num) {\n    string s = to_string(num);\n    int sum = 0;\n    if (s[0] == '-') {\n        sum += -(s[1] - '0');\n        for (int i = 2; i < s.size(); ++i) {\n            sum += (s[i] - '0');\n        }\n    } else {\n        for (int i = 0; i < s.size(); ++i) {\n            sum += (s[i] - '0');\n        }\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<tuple<int, int, int>> elements;\n    for (int i = 0; i < nums.size(); ++i) {\n        int sum = calculateSum(nums[i]);\n        elements.emplace_back(sum, i, nums[i]);\n    }\n    sort(elements.begin(), elements.end(), [](const tuple<int, int, int>& a, const tuple<int, int, int>& b) {\n        if (get<0>(a) != get<0>(b)) {\n            return get<0>(a) < get<0>(b);\n        } else {\n            return get<1>(a) < get<1>(b);\n        }\n    });\n    vector<int> result;\n    for (const auto& elem : elements) {\n        result.push_back(get<2>(elem));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) {\n            continue;\n        }\n        int last = num % 10;\n        if (last % 2 == 0) {\n            continue;\n        }\n        int first = num;\n        while (first >= 10) {\n            first /= 10;\n        }\n        if (first % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n\nint get_max_triples(int n) {\n    if (n < 3) {\n        return 0;\n    }\n    \n    int count_0 = 0;\n    if (n >= 2) {\n        count_0 = (n - 2) / 3 + 1;\n    }\n    int count_1 = n - count_0;\n    \n    int c0 = (count_0 >= 3) ? (count_0 * (count_0 - 1) * (count_0 - 2)) / 6 : 0;\n    int c1 = (count_1 >= 3) ? (count_1 * (count_1 - 1) * (count_1 - 2)) / 6 : 0;\n    \n    return c0 + c1;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    map<string, int> planet_to_index;\n\n    for (int i = 0; i < planets.size(); ++i) {\n        planet_to_index[planets[i]] = i;\n    }\n\n    if (planet_to_index.find(planet1) == planet_to_index.end() || \n        planet_to_index.find(planet2) == planet_to_index.end()) {\n        return {};\n    }\n\n    int index1 = planet_to_index[planet1];\n    int index2 = planet_to_index[planet2];\n\n    int lower = min(index1, index2);\n    int higher = max(index1, index2);\n\n    if (lower == higher) {\n        return {};\n    }\n\n    vector<string> result;\n    for (int i = lower + 1; i < higher; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter strings with even lengths\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            result.push_back(s);\n        }\n    }\n\n    // Sort the result by length and then lexicographically\n    sort(result.begin(), result.end(), [](const string& a, const string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        } else {\n            return a < b;\n        }\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath>\n\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    int limit = static_cast<int>(sqrt(n));\n    for (int i = 2; i <= limit; ++i) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num == static_cast<int>(num)) { // Check if the number is an integer\n            int integer_num = static_cast<int>(num);\n            if (integer_num >= 0) { // Check if the number is non-negative\n                if (integer_num % 2 == 1) { // Check if the number is odd\n                    sum += (integer_num * integer_num);\n                }\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> res;\n    for (int i = 0; i < game.size(); ++i) {\n        res.push_back(abs(game[i] - guess[i]));\n    }\n    return res;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    if (extensions.empty()) {\n        return class_name + \".\";\n    }\n\n    string best_ext = extensions[0];\n    int max_strength = 0;\n    int cap = 0, sm = 0;\n\n    // Calculate strength for the first extension\n    for (char c : best_ext) {\n        if (c >= 'A' && c <= 'Z') {\n            cap++;\n        } else if (c >= 'a' && c <= 'z') {\n            sm++;\n        }\n    }\n    max_strength = cap - sm;\n\n    // Iterate through the rest of the extensions\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        const string &ext = extensions[i];\n        int current_cap = 0, current_sm = 0;\n        for (char c : ext) {\n            if (c >= 'A' && c <= 'Z') {\n                current_cap++;\n            } else if (c >= 'a' && c <= 'z') {\n                current_sm++;\n            }\n        }\n        int current_strength = current_cap - current_sm;\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            best_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + best_ext;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    \n    if (len_b == 0) return true;\n    if (len_b > len_a) return false;\n    \n    for (int i = 0; i < len_b; ++i) {\n        string rotated = b.substr(i) + b.substr(0, i);\n        if (a.find(rotated) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    int even_count = 0, odd_count = 0;\n\n    if (num == 0) {\n        even_count = 1;\n        odd_count = 0;\n    } else {\n        num = abs(num);\n        while (num != 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n            num /= 10;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<string> hundreds = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n    vector<string> tens = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    vector<string> units = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n    int thousands = number / 1000;\n    int hundreds_digit = (number % 1000) / 100;\n    int tens_digit = (number % 100) / 10;\n    int units_digit = number % 10;\n\n    string roman;\n\n    if (thousands == 1) {\n        roman += 'm';\n    }\n\n    roman += hundreds[hundreds_digit];\n    roman += tens[tens_digit];\n    roman += units[units_digit];\n\n    return roman;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <cmath>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    float a_sq = a * a;\n    float b_sq = b * b;\n    float c_sq = c * c;\n    \n    float epsilon = 1e-6;\n    \n    return (fabs(a_sq + b_sq - c_sq) < epsilon) ||\n           (fabs(a_sq + c_sq - b_sq) < epsilon) ||\n           (fabs(b_sq + c_sq - a_sq) < epsilon);\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n    \n    string max_word = words[0];\n    int max_count = set<char>(max_word.begin(), max_word.end()).size();\n    \n    for (size_t i = 1; i < words.size(); ++i) {\n        string word = words[i];\n        set<char> unique_chars(word.begin(), word.end());\n        int current_count = unique_chars.size();\n        \n        if (current_count > max_count) {\n            max_count = current_count;\n            max_word = word;\n        } else if (current_count == max_count) {\n            if (word < max_word) {\n                max_word = word;\n            }\n        }\n    }\n    \n    return max_word;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int eat_amount = (need < remaining) ? need : remaining;\n    int total = number + eat_amount;\n    int left = remaining - eat_amount;\n    return {total, left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nint get_precedence(string op) {\n    if (op == \"**\") return 4;\n    if (op == \"*\" || op == \"//\") return 3;\n    if (op == \"+\" || op == \"-\") return 2;\n    return 0;\n}\n\nbool is_right_associative(string op) {\n    if (op == \"**\") return true;\n    return false;\n}\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Create tokens\n    vector<string> tokens;\n    for (int i = 0; i < operand.size(); ++i) {\n        tokens.push_back(to_string(operand[i]));\n        if (i < operato.size()) {\n            tokens.push_back(operato[i]);\n        }\n    }\n\n    // Step 2: Shunting-yard algorithm to get postfix notation\n    vector<string> output;\n    stack<string> op_stack;\n\n    for (string token : tokens) {\n        if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"//\" || token == \"**\") {\n            // Operator\n            while (!op_stack.empty() && op_stack.top() != \"(\" &&\n                   (get_precedence(op_stack.top()) > get_precedence(token) ||\n                    (get_precedence(op_stack.top()) == get_precedence(token) && !is_right_associative(token)))) {\n                output.push_back(op_stack.top());\n                op_stack.pop();\n            }\n            op_stack.push(token);\n        } else {\n            // Operand\n            output.push_back(token);\n        }\n    }\n\n    // Pop remaining operators\n    while (!op_stack.empty()) {\n        output.push_back(op_stack.top());\n        op_stack.pop();\n    }\n\n    // Step 3: Evaluate postfix notation\n    stack<int> eval_stack;\n\n    for (string token : output) {\n        if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"//\" || token == \"**\") {\n            // Operator\n            int right = eval_stack.top();\n            eval_stack.pop();\n            int left = eval_stack.top();\n            eval_stack.pop();\n            int result;\n\n            if (token == \"+\") {\n                result = left + right;\n            } else if (token == \"-\") {\n                result = left - right;\n            } else if (token == \"*\") {\n                result = left * right;\n            } else if (token == \"//\") {\n                result = left / right;\n            } else if (token == \"**\") {\n                result = static_cast<int>(pow(left, right));\n            }\n\n            eval_stack.push(result);\n        } else {\n            // Operand\n            eval_stack.push(stoi(token));\n        }\n    }\n\n    return eval_stack.top();\n}\n"}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    for (char &c : s) {\n        if (isalpha(c)) {\n            c = islower(c) ? toupper(c) : tolower(c);\n            hasLetters = true;\n        }\n    }\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5_CTX ctx;\n\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.c_str(), text.size());\n    MD5_Final(digest, &ctx);\n\n    string hexdigest;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        unsigned char byte = digest[i];\n        hexdigest += ( (byte >> 4) < 10 ) ? ( (byte >> 4) + '0' ) : ( (byte >> 4) - 10 + 'a' );\n        hexdigest += ( byte < 10 ) ? ( byte + '0' ) : ( byte - 10 + 'a' );\n    }\n\n    return hexdigest;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evens = {0, 2, 4, 6, 8};\n    int lower = (a < b) ? a : b;\n    int upper = (a > b) ? a : b;\n    vector<int> result;\n    for (int digit : evens) {\n        if (digit >= lower && digit <= upper) {\n            result.push_back(digit);\n        }\n    }\n    return result;\n}\n"}
