{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    sort(numbers.begin(), numbers.end());\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i+1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    string processed;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            processed.push_back(c);\n        }\n    }\n    \n    vector<string> result;\n    string current_group;\n    int depth = 0;\n    \n    for (char c : processed) {\n        if (c == '(') {\n            if (depth == 0) {\n                current_group.clear();\n            }\n            current_group += c;\n            depth++;\n        } else if (c == ')') {\n            current_group += c;\n            depth--;\n            if (depth == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <math.h>\n\nfloat truncate_number(float number) {\n    float integer_part = floorf(number);\n    return number - integer_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f;\n    }\n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n    float absolute_sum = 0.0f;\n    for (float num : numbers) {\n        absolute_sum += fabs(num - mean);\n    }\n    return absolute_sum / numbers.size();\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    vector<string> groups;\n    stringstream ss(paren_string);\n    string group;\n    \n    // Split the input string into groups separated by spaces, ignoring empty groups\n    while (getline(ss, group, ' ')) {\n        if (!group.empty()) {\n            groups.push_back(group);\n        }\n    }\n    \n    // Process each group to find the maximum depth\n    for (const auto& g : groups) {\n        int current_depth = 0;\n        int max_depth = 0;\n        for (char c : g) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (string s : strings) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n    int n = str.size();\n    for (int l = n; l >= 1; --l) {\n        string suffix = str.substr(n - l, l);\n        if (is_palindrome(suffix)) {\n            string prefix = str.substr(0, n - l);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    return str; // This line is theoretically unreachable\n}\n"}
{"task_id": "CPP/11", "generation": "#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    int max_len = max(a.size(), b.size());\n    if (a.size() < max_len) {\n        a = string(max_len - a.size(), '0') + a;\n    }\n    if (b.size() < max_len) {\n        b = string(max_len - b.size(), '0') + b;\n    }\n    string result;\n    for (int i = 0; i < max_len; ++i) {\n        if (a[i] != b[i]) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    string result = strings[0];\n    int max_len = result.size();\n    for (size_t i = 1; i < strings.size(); ++i) {\n        const string& current = strings[i];\n        int current_len = current.size();\n        if (current_len > max_len) {\n            max_len = current_len;\n            result = current;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <cstdlib> // For abs function\n\nint greatest_common_divisor(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    for (int i = 1; i <= str.size(); ++i) {\n        result.push_back(str.substr(0, i));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) {\n        return \"\";\n    }\n    string result;\n    if (n >= 0) {\n        result = to_string(0);\n        for (int i = 1; i <= n; ++i) {\n            result += \" \";\n            result += to_string(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <unordered_set>\n#include <cctype>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    unordered_set<char> distinct_chars;\n    for (char c : str) {\n        distinct_chars.insert(static_cast<char>(tolower(static_cast<unsigned char>(c))));\n    }\n    return distinct_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    stringstream ss(music_string);\n    string token;\n    while (ss >> token) {\n        if (token == \"o\") {\n            result.push_back(4);\n        } else if (token == \"o|\") {\n            result.push_back(2);\n        } else if (token == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/18", "generation": "<think>\nOkay, I need to solve this problem where I have to find how many times a substring appears in a given string, including overlapping cases. Let's think about how to approach this.\n\nFirst, let's understand the examples. For \"aaa\" and substring \"a\", the answer is 3, which makes sense because each character is a match. For \"aaaa\" and \"aa\", the answer is 3. Let's see why. The substrings would be positions 0-1, 1-2, 2-3. So even though the first match starts at 0, the next starts at 1, overlapping. So the approach needs to check every possible starting position and count each occurrence, even if they overlap.\n\nSo the steps I need to take are:\n\n1. Iterate through each possible starting index in the original string where the substring could begin.\n2. For each starting index, check if the substring matches starting at that position.\n3. If it does, increment the count.\n4. Return the total count.\n\nBut wait, how do I determine the possible starting indices? Well, the substring can't start at a position where there's not enough characters left. For example, if the substring is length 3, the starting index in the original string can't be more than (length of string - length of substring). So the loop should run from 0 to (str.length() - substring.length()), inclusive.\n\nBut wait, what if the substring is empty? The first test case has substring \"a\" and the original string is empty, which returns 0. So we need to handle cases where either the original string or the substring is empty. Wait, the problem says \"given substring can be found in the original string\". So if the substring is empty, how to handle that? But according to the first example, when the original string is empty and substring is \"a\", the answer is 0. So perhaps the problem assumes that the substring is non-empty. But the code should handle cases where the substring is empty? Let's check the problem statement again.\n\nThe problem's first example is how_many_times(\"\", \"a\") returns 0. So the substring is \"a\", which is not empty. So perhaps the function should return 0 if the substring is empty. Because in standard definitions, an empty substring can be considered to occur once between each character, but maybe the problem expects that. But the problem's examples don't cover that. However, the code needs to handle that. But according to the problem statement, maybe the function should return 0 if the substring is empty. Let's see: the problem says \"given substring can be found\". So perhaps if the substring is empty, the answer is 0. So in the code, first check if the substring is empty. If it is, return 0. Similarly, if the original string is empty, return 0.\n\nSo first, handle edge cases:\n\n- If substring is empty, return 0.\n- If original string is shorter than substring, return 0.\n\nOtherwise, loop through each possible starting index in the original string. For each index i from 0 to (str.length() - substring.length()), check if the substring starts at i. If yes, increment count.\n\nSo the code structure would be:\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0;\n    int count = 0;\n    int sub_len = substring.length();\n    int str_len = str.length();\n    if (sub_len > str_len) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        bool match = true;\n        for (int j = 0; j < sub_len; j++) {\n            if (str[i + j] != substring[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            count++;\n        }\n    }\n    return count;\n}\n\nWait, but in the example \"aaaa\" and \"aa\", the code would check starting at 0: \"aa\" matches. Then i increments by 1, next check starts at 1: \"aa\" matches. Then i increments to 2: \"aa\" matches. Then i increments to 3: but 3 + 2 is 5, which is beyond the string length (4). So the loop runs from i=0 to i=2 (since 4-2=2). So i can be 0,1,2. So three times. Which is correct. So the code works for that case.\n\nAnother example: \"aaa\" and \"a\". The substring length is 1. So the loop runs from 0 to 2 (3-1=2). For each i, check str[i] == 'a'. All do, so count is 3. Correct.\n\nWhat about overlapping cases? Like \"ababa\" and \"aba\". The substring \"aba\" occurs at 0 and 2. So the code would check i=0: matches. Then i=1: check 'bab' vs 'aba'? No. i=2: 'aba' matches. So count is 2. Which is correct.\n\nSo the code seems to handle overlapping cases correctly.\n\nNow, what about when the substring is longer than the original string? Then return 0.\n\nWhat about when the original string is empty? Then return 0, which is handled by the code.\n\nSo this code should work. Let's test the examples.\n\nFirst example: how_many_times(\"\", \"a\") returns 0. Correct.\n\nSecond"}
{"task_id": "CPP/19", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    vector<string> words;\n    stringstream ss(numbers);\n    string s;\n    while (ss >> s) {\n        words.push_back(s);\n    }\n    \n    map<string, int> word_to_num = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    sort(words.begin(), words.end(), [&](const string &a, const string &b) {\n        return word_to_num[a] < word_to_num[b];\n    });\n    \n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    sort(numbers.begin(), numbers.end());\n    \n    if (numbers.size() < 2) {\n        return {}; // Though the problem states the input has at least two elements\n    }\n    \n    int min_index = 0;\n    float min_diff = numbers[1] - numbers[0];\n    \n    for (int i = 1; i < numbers.size() - 1; ++i) {\n        float current_diff = numbers[i+1] - numbers[i];\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            min_index = i;\n        }\n    }\n    \n    return {numbers[min_index], numbers[min_index + 1]};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) { \n    if (numbers.empty()) return numbers; // Handle empty input, though problem states at least two elements.\n    \n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    for (float num : numbers) {\n        if (num < min_val) min_val = num;\n        if (num > max_val) max_val = num;\n    }\n    \n    float range = max_val - min_val;\n    vector<float> result;\n    \n    for (float num : numbers) {\n        result.push_back(range == 0 ? 0.0f : (num - min_val) / range);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(val));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <cmath>\n\nint largest_divisor(int n) {\n    if (n <= 1) {\n        return 0; // Handle edge case where n is 1 or less, though problem likely assumes n >= 2\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1; // n is prime\n}\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    if (n == 1) {\n        return factors; // Returns empty vector for n=1\n    }\n    // Handle the factor 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> counts;\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    vector<int> result;\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result;\n    for (char c : str) {\n        if (c >= 'A' && c <= 'Z') {\n            result += c + 32;\n        } else if (c >= 'a' && c <= 'z') {\n            result += c - 32;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result;\n    for (const string& s : strings) {\n        result += s;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& s : strings) {\n        if (s.size() >= prefix.size() && s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0.0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    double a = -1.0;\n    double b = 1.0;\n    double fa = poly(xs, a);\n    double fb = poly(xs, b);\n\n    if (fa == 0.0) return a;\n    if (fb == 0.0) return b;\n\n    while (fa * fb > 0) {\n        a *= 2.0;\n        b *= 2.0;\n        fa = poly(xs, a);\n        fb = poly(xs, b);\n        if (fa == 0.0) return a;\n        if (fb == 0.0) return b;\n    }\n\n    double low, high;\n    if (fa < 0.0) {\n        low = a;\n        high = b;\n    } else {\n        low = b;\n        high = a;\n    }\n\n    const double epsilon = 1e-12;\n    for (int i = 0; i < 100; ++i) {\n        double mid = (low + high) / 2.0;\n        double fmid = poly(xs, mid);\n        if (fmid == 0.0) {\n            return mid;\n        }\n        if (fmid < 0.0) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n        if (high - low < epsilon) {\n            break;\n        }\n    }\n\n    return (low + high) / 2.0;\n}\n\n// Example usage (as mentioned in the problem statement)\n// "}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> res = l;\n    vector<int> to_sort;\n    \n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < res.size(); ++i) {\n        if (i % 3 == 0) {\n            to_sort.push_back(res[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace the elements in the result vector\n    int sorted_index = 0;\n    for (int i = 0; i < res.size(); ++i) {\n        if (i % 3 == 0) {\n            if (sorted_index < to_sort.size()) {\n                res[i] = to_sort[sorted_index++];\n            }\n        }\n    }\n    \n    return res;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    sort(l.begin(), l.end());\n    auto last = unique(l.begin(), l.end());\n    l.erase(last, l.end());\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return 0.0f;\n    }\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int count = 0;\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n            total += count;\n        }\n    }\n    return total;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> evens;\n    for (int i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n    sort(evens.begin(), evens.end());\n    vector<float> result = l;\n    for (int i = 0; i < evens.size(); ++i) {\n        result[i * 2] = evens[i];\n    }\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string group = s.substr(i * 3, 3);\n        if (group.length() == 3) {\n            group = group.substr(2, 1) + group.substr(0, 2);\n        }\n        output += group;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_prime(long long num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int count = 0;\n    long long a = 0, b = 1;\n    while (true) {\n        if (is_prime(a)) {\n            count++;\n            if (count == n) {\n                return a;\n            }\n        }\n        long long next = a + b;\n        a = b;\n        b = next;\n    }\n}\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "int car_race_collision(int n) {\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    string s;\n    while (x > 0) {\n        int rem = x % base;\n        s += '0' + rem;\n        x = x / base;\n    }\n    reverse(s.begin(), s.end());\n    return s;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2.0f;\n}\n"}
{"task_id": "CPP/46", "generation": "int fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) {\n        return 0;\n    } else if (n == 2) {\n        return 2;\n    }\n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 4; i <= n; ++i) {\n        int current = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = current;\n    }\n    return d;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n/2 - 1] + l[n/2]) / 2.0f;\n    } else {\n        return l[n/2];\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int n = text.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    if (p == 1) {\n        return 0;\n    }\n    int result = 1;\n    int base = 2 % p;\n    int exponent = n;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % p;\n        }\n        exponent = exponent >> 1;\n        base = (base * base) % p;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decode_shift(string s){\n    string out;\n    for(int i=0; i<s.length(); i++){\n        int w = ( (s[i] - 'a' + 21) % 26 ) + 'a';   \n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    string vowels = \"aeiouAEIOU\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <string>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    bool chars0[256] = {false};\n    bool chars1[256] = {false};\n    \n    for (int i = 0; i < s0.size(); ++i) {\n        chars0[(unsigned char)s0[i]] = true;\n    }\n    for (int i = 0; i < s1.size(); ++i) {\n        chars1[(unsigned char)s1[i]] = true;\n    }\n    \n    for (int i = 0; i < 256; ++i) {\n        if (chars0[i] != chars1[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/55", "generation": "int fib(int n) {\n    if (n <= 0) return 0; // Handles cases where n is non-positive, though per problem statement n is positive.\n    if (n == 1 || n == 2) return 1;\n    int a = 1, b = 1;\n    for (int i = 3; i <= n; ++i) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) return true;\n    bool inc = true, dec = true;\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        float current = l[i];\n        float next = l[i+1];\n        if (next > current) {\n            dec = false;\n        } else if (next < current) {\n            inc = false;\n        }\n        if (!inc && !dec) {\n            return false;\n        }\n    }\n    return inc || dec;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort and deduplicate the first list\n    sort(l1.begin(), l1.end());\n    auto last = unique(l1.begin(), l1.end());\n    l1.erase(last, l1.end());\n\n    // Sort and deduplicate the second list\n    sort(l2.begin(), l2.end());\n    last = unique(l2.begin(), l2.end());\n    l2.erase(last, l2.end());\n\n    vector<int> res;\n    int i = 0, j = 0;\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            res.push_back(l1[i]);\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return res;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n\nint largest_prime_factor(int n) {\n    int largest = 1;\n    int i = 2;\n    while (i * i <= n) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n        i++;\n    }\n    if (n > 1) {\n        largest = n;\n    }\n    return largest;\n}\n\n// Example usage:\n// "}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            counter++;\n        } else {\n            counter--;\n        }\n        if (counter < 0) {\n            return false;\n        }\n    }\n    return counter == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> res;\n    for (int i = 1; i < xs.size(); ++i) {\n        res.push_back(xs[i] * i);\n    }\n    return res;\n}\n"}
{"task_id": "CPP/63", "generation": "int fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n    int a = 0, b = 0, c = 1;\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n    return c;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int count = 0;\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (!s.empty() && s.back() == 'y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int len = s.size();\n    \n    if (shift > len) {\n        reverse(s.begin(), s.end());\n        return s;\n    } else {\n        int k = shift;\n        string part1 = s.substr(len - k, k);\n        string part2 = s.substr(0, len - k);\n        return part1 + part2;\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    size_t and_pos = s.find(\" and \");\n    string first_part = s.substr(0, and_pos);\n    string second_part = s.substr(and_pos + 5);\n    \n    size_t space1 = first_part.find(' ');\n    int apples = stoi(first_part.substr(0, space1));\n    \n    size_t space2 = second_part.find(' ');\n    int oranges = stoi(second_part.substr(0, space2));\n    \n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int min_val = -1;\n    int index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        int num = arr[i];\n        if (num % 2 == 0) {\n            if (min_val == -1) {\n                min_val = num;\n                index = i;\n            } else if (num < min_val) {\n                min_val = num;\n                index = i;\n            }\n        }\n    }\n    \n    if (min_val == -1) {\n        return {};\n    } else {\n        return {min_val, index};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int max_val = -1;\n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        if (count >= num && num > max_val) {\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    sort(lst.begin(), lst.end());\n    vector<int> res;\n    int left = 0;\n    int right = lst.size() - 1;\n    bool take_left = true;\n    \n    while (left <= right) {\n        if (take_left) {\n            res.push_back(lst[left]);\n            left++;\n        } else {\n            res.push_back(lst[right]);\n            right--;\n        }\n        take_left = !take_left;\n    }\n    \n    return res;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1.0f;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0f;\n    \n    // Calculate the area using Heron's formula\n    float area = sqrtf(s * (s - a) * (s - b) * (s - c));\n    \n    // Round to two decimal places\n    area = roundf(area * 100.0f) / 100.0f;\n    \n    return area;\n}\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    // Check sum against maximum weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        int j = n - 1 - i;\n        if (arr[i] != arr[j]) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0;\n    for (string s : lst1) {\n        sum1 += s.size();\n    }\n    int sum2 = 0;\n    for (string s : lst2) {\n        sum2 += s.size();\n    }\n    return (sum1 <= sum2) ? lst1 : lst2;\n}\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    if (a < 8) return false; // The smallest product of three primes is 2*2*2=8\n\n    // Generate all primes under 100 using Sieve of Eratosthenes\n    vector<int> primes;\n    bool is_prime[101];\n    fill_n(is_prime, 101, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= 100; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= 100; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    for (int i = 2; i <= 100; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    int sum = 0;\n    int original_a = a; // To check if any factors remain after processing all primes\n    for (int p : primes) {\n        while (a % p == 0) {\n            sum++;\n            a /= p;\n            if (sum > 3) {\n                return false;\n            }\n        }\n        if (a == 1) {\n            break;\n        }\n    }\n\n    if (a != 1) { // There's a prime factor greater than 100\n        return false;\n    }\n\n    return sum == 3;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <cstdlib> // For abs function\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (x == 0) {\n        return (n == 0);\n    } else if (x == 1) {\n        return (n != 0);\n    }\n    \n    if (n == 0) {\n        return false;\n    }\n    \n    if (n == 1) {\n        return false;\n    }\n    \n    long long product = 1;\n    while (true) {\n        product *= n;\n        if (product == x) {\n            return true;\n        }\n        if (abs(product) > abs(x)) {\n            break;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    double root = cbrt(a);\n    int n = round(root);\n    return n * n * n == a;\n}\n"}
{"task_id": "CPP/78", "generation": "#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    string binary;\n    int num = decimal;\n    while (num > 0) {\n        int remainder = num % 2;\n        binary.push_back(remainder ? '1' : '0');\n        num = num / 2;\n    }\n    reverse(binary.begin(), binary.end());\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i < s.size() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            result.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            result.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            result.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            result.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            result.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            result.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            result.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            result.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            result.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            result.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            result.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <string>\nusing namespace std;\n\nbool prime_length(string str) {\n    int len = str.size();\n    if (len <= 1) {\n        return false;\n    }\n    if (len == 2) {\n        return true;\n    }\n    if (len % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    int ans = 18;\n    for (int i = 0; i < n - 2; i++) {\n        ans *= 10;\n    }\n    return ans;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    int temp = N;\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n    \n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    string binary;\n    while (sum > 0) {\n        binary.push_back((sum % 2) + '0');\n        sum /= 2;\n    }\n    reverse(binary.begin(), binary.end());\n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    vector<string> tokens;\n    if (s.empty()) {\n        return s;\n    }\n    \n    string current_token;\n    current_token += s[0];\n    bool current_is_space = (s[0] == ' ');\n    \n    for (size_t i = 1; i < s.size(); ++i) {\n        char c = s[i];\n        bool c_is_space = (c == ' ');\n        if (c_is_space == current_is_space) {\n            current_token += c;\n        } else {\n            tokens.push_back(current_token);\n            current_token = string(1, c);\n            current_is_space = c_is_space;\n        }\n    }\n    tokens.push_back(current_token);\n    \n    for (auto& token : tokens) {\n        if (!token.empty() && token[0] != ' ') {\n            sort(token.begin(), token.end());\n        }\n    }\n    \n    string result;\n    for (const auto& token : tokens) {\n        result += token;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    for (int i = 0; i < lst.size(); ++i) {\n        vector<int> cols;\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                cols.push_back(j);\n            }\n        }\n        sort(cols.begin(), cols.end(), greater<int>());\n        for (int col : cols) {\n            result.push_back({i, col});\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    vector<int> result = array;\n    if (array.size() <= 1) {\n        return result;\n    }\n    int first = array[0];\n    int last = array.back();\n    int sum = first + last;\n    if (sum % 2 == 1) {\n        sort(result.begin(), result.end());\n    } else {\n        sort(result.begin(), result.end());\n        reverse(result.begin(), result.end());\n    }\n    return result;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            int shifted = (c - 'a' + 4) % 26;\n            result += 'a' + shifted;\n        } else if (c >= 'A' && c <= 'Z') {\n            int shifted = (c - 'A' + 4) % 26;\n            result += 'A' + shifted;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Represents None in C++ context\n    }\n    sort(lst.begin(), lst.end());\n    int smallest = lst[0];\n    for (int num : lst) {\n        if (num > smallest) {\n            return num;\n        }\n    }\n    return -1; // All elements are the same or only one element\n}\n"}
{"task_id": "CPP/91", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    vector<string> sentences;\n    int start = 0;\n    for (int i = 0; i < S.size(); ++i) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            string sentence = S.substr(start, i - start);\n            sentences.push_back(sentence);\n            start = i + 1;\n        }\n    }\n    if (start < S.size()) {\n        sentences.push_back(S.substr(start));\n    }\n    \n    int count = 0;\n    for (string sentence : sentences) {\n        size_t first = sentence.find_first_not_of(\" \\t\\n\\r\");\n        if (first == string::npos) {\n            continue;\n        }\n        string trimmed = sentence.substr(first);\n        \n        vector<string> words;\n        size_t pos = 0;\n        while (pos < trimmed.size()) {\n            size_t next = trimmed.find_first_of(\" \\t\\n\\r\", pos);\n            if (next == string::npos) {\n                words.push_back(trimmed.substr(pos));\n                break;\n            }\n            if (next != pos) {\n                words.push_back(trimmed.substr(pos, next - pos));\n            }\n            pos = next + 1;\n        }\n        \n        if (!words.empty() && words[0] == \"I\") {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    if (a != static_cast<int>(a) || b != static_cast<int>(b) || c != static_cast<int>(c)) {\n        return false;\n    }\n    \n    // Check if any one of the numbers is the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nstring encode(string message) {\n    string result;\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap the case of the character\n            char swapped = isupper(c) ? tolower(c) : toupper(c);\n            // Check if the swapped character is a vowel (case-insensitive)\n            char lower = tolower(swapped);\n            if (lower == 'a' || lower == 'e' || lower == 'i' || lower == 'o' || lower == 'u') {\n                swapped += 2; // Replace vowel with the next two letters\n            }\n            result += swapped;\n        } else {\n            result += c; // Non-alphabetic characters are added as-is\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > max_prime) {\n            max_prime = num;\n        }\n    }\n    if (max_prime == -1) {\n        return 0;\n    }\n    int sum = 0;\n    int n = max_prime;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <cctype>\n#include <string>\n#include <map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool is_first = true;\n    bool required_case;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        if (key.empty()) return false;\n\n        bool all_lower = true;\n        bool all_upper = true;\n\n        for (char c : key) {\n            if (!isalpha((unsigned char)c)) return false;\n            if (islower((unsigned char)c)) {\n                all_upper = false;\n            } else {\n                all_lower = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) return false;\n\n        if (is_first) {\n            required_case = all_lower;\n            is_first = false;\n        } else {\n            if (required_case != all_lower) return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    if (n <= 2) return primes;\n    \n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <cstdlib> // For abs function\n\nint multiply(int a, int b) {\n    int lastA = abs(a) % 10;\n    int lastB = abs(b) % 10;\n    return lastA * lastB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0) { // Check if index is even\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value);\n    return static_cast<int>(round(num));\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> res;\n    for (int i = 0; i < n; ++i) {\n        res.push_back(n + 2 * i);\n    }\n    return res;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string current;\n    for (int i = 0; i < s.size(); i++) {\n        char c = s[i];\n        if (c == ',' || c == ' ') {\n            if (!current.empty()) {\n                result.push_back(current);\n                current.clear();\n            }\n            // Skip all consecutive separators\n            while (i + 1 < s.size() && (s[i+1] == ',' || s[i+1] == ' ')) {\n                i++;\n            }\n        } else {\n            current += c;\n        }\n    }\n    // Add the last word if any\n    if (!current.empty()) {\n        result.push_back(current);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    int candidate = (y % 2 == 0) ? y : y - 1;\n    return (candidate >= x) ? candidate : -1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int avg = (n + m) / 2;\n    string binary;\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        int rem = avg % 2;\n        binary = (rem ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasNoEvenDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return false;\n        }\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> res;\n    for (int num : x) {\n        if (hasNoEvenDigits(num)) {\n            res.push_back(num);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n    \n    sort(filtered.begin(), filtered.end());\n    reverse(filtered.begin(), filtered.end());\n    \n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    vector<string> result;\n    \n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result;\n    if (n <= 0) return result;\n    int fact = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            fact *= i;\n            result.push_back(fact);\n        } else {\n            int sum = i * (i + 1) / 2;\n            result.push_back(sum);\n            fact *= i;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        string s = to_string(i);\n        string rev(s.rbegin(), s.rend());\n        if (s == rev) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <algorithm> // for reverse\n\nusing namespace std;\n\nint sum_digits(int num) {\n    if (num == 0) {\n        return 0;\n    }\n    bool is_negative = num < 0;\n    int abs_num = abs(num);\n    vector<int> digits;\n    while (abs_num > 0) {\n        digits.push_back(abs_num % 10);\n        abs_num /= 10;\n    }\n    reverse(digits.begin(), digits.end());\n    if (is_negative) {\n        digits[0] *= -1;\n    }\n    int sum = 0;\n    for (int d : digits) {\n        sum += d;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int s = sum_digits(num);\n        if (s > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int E1 = 0, E2 = 0;\n    for (int num : lst1) {\n        if (num % 2 == 0) E1++;\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) E2++;\n    }\n    int total_evens = E1 + E2;\n    if (total_evens < lst1.size()) {\n        return \"NO\";\n    }\n    int O1 = lst1.size() - E1;\n    if (E2 >= O1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freq;\n    for (char c : test) {\n        if (c != ' ') {\n            freq[c]++;\n        }\n    }\n    map<char, int> result;\n    if (freq.empty()) {\n        return result;\n    }\n    int max_count = 0;\n    for (auto &pair : freq) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n    for (auto &pair : freq) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a boolean array to mark characters to delete\n    bool delete_chars[256] = {false};\n    for (char ch : c) {\n        delete_chars[static_cast<unsigned char>(ch)] = true;\n    }\n    \n    // Build the filtered string by including characters not marked for deletion\n    string filtered;\n    for (char ch : s) {\n        if (!delete_chars[static_cast<unsigned char>(ch)]) {\n            filtered += ch;\n        }\n    }\n    \n    // Check if the filtered string is a palindrome by comparing it to its reverse\n    string reversed = filtered;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = (filtered == reversed);\n    \n    // Return the result as a vector of strings\n    return {filtered, is_palindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    const string template_str = \"the number of odd elements in the string i of the input.\";\n    for (const string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                count++;\n            }\n        }\n        string output;\n        for (char ch : template_str) {\n            if (ch == 'i') {\n                output += to_string(count);\n            } else {\n                output += ch;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Assuming the input is non-empty as per problem examples\n    \n    long long current_min = nums[0];\n    long long global_min = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = min(nums[i], current_min + nums[i]);\n        global_min = min(global_min, current_min);\n    }\n    \n    return global_min;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total = 0;\n    for (auto &row : grid) {\n        int sum = 0;\n        for (int num : row) {\n            sum += num;\n        }\n        if (sum > 0) {\n            total += (sum + capacity - 1) / capacity;\n        }\n    }\n    return total;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <cstdlib> // For abs()\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = __builtin_popcount(abs(a));\n        int count_b = __builtin_popcount(abs(b));\n        if (count_a != count_b) {\n            return count_a < count_b;\n        } else {\n            return a < b;\n        }\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split(const string& s) {\n    vector<string> words;\n    string current;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!current.empty()) {\n                words.push_back(current);\n                current.clear();\n            }\n        } else {\n            current += c;\n        }\n    }\n    if (!current.empty()) {\n        words.push_back(current);\n    }\n    return words;\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        char lower_c = tolower(c);\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    vector<string> words = split(s);\n    for (const string& word : words) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    const string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n    for (int i = len - 2; i >= 1; --i) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (vowels.find(word[i-1]) == string::npos && vowels.find(word[i+1]) == string::npos) {\n                return string(1, word[i]);\n            }\n        }\n    }\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_balanced(const string &s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    int sum_open = 0, sum_close = 0;\n    for (string s : lst) {\n        for (char c : s) {\n            if (c == '(') sum_open++;\n            else sum_close++;\n        }\n    }\n    if (sum_open != sum_close) {\n        return \"No\";\n    }\n    string s1 = lst[0];\n    string s2 = lst[1];\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    if (k == 0) return {};\n    sort(arr.begin(), arr.end());\n    int n = arr.size();\n    vector<int> res;\n    res.reserve(k); // Reserve space for efficiency\n    for (int i = n - k; i < n; ++i) {\n        res.push_back(arr[i]);\n    }\n    return res;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <cstdlib> // for abs function\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (abs(num) < 100) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> sequence;\n    int current = n;\n    sequence.push_back(current);\n    while (current != 1) {\n        if (current % 2 == 0) {\n            current /= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n        sequence.push_back(current);\n    }\n    \n    vector<int> odds;\n    for (int num : sequence) {\n        if (num % 2 != 0) {\n            odds.push_back(num);\n        }\n    }\n    \n    sort(odds.begin(), odds.end());\n    return odds;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    if (date.empty()) {\n        return false;\n    }\n    if (date.size() != 10) {\n        return false;\n    }\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    \n    string mm_str = date.substr(0, 2);\n    string dd_str = date.substr(3, 2);\n    string yyyy_str = date.substr(6, 4);\n    \n    auto isDigits = [](const string &s) {\n        for (char c : s) {\n            if (!isdigit(c)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    \n    if (!isDigits(mm_str) || !isDigits(dd_str) || !isDigits(yyyy_str)) {\n        return false;\n    }\n    \n    int month = stoi(mm_str);\n    int day = stoi(dd_str);\n    int year = stoi(yyyy_str);\n    \n    if (month < 1 || month > 12) {\n        return false;\n    }\n    \n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for any whitespace characters\n    bool has_whitespace = false;\n    for (char c : txt) {\n        if (isspace(c)) {\n            has_whitespace = true;\n            break;\n        }\n    }\n    if (has_whitespace) {\n        vector<string> result;\n        istringstream iss(txt);\n        string token;\n        while (iss >> token) {\n            result.push_back(token);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        vector<string> result;\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start));\n        return result;\n    }\n    \n    // Calculate the count of lowercase letters with odd ordinals\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int ord = c - 'a';\n            if (ord % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is sorted in non-decreasing order\n    for (int i = 0; i < (int)lst.size() - 1; ++i) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n    }\n    \n    // Check if any number appears more than twice\n    unordered_map<int, int> counts;\n    for (int num : lst) {\n        counts[num]++;\n    }\n    \n    for (auto& pair : counts) {\n        if (pair.second >= 3) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int s1 = interval1[0], e1 = interval1[1];\n    int s2 = interval2[0], e2 = interval2[1];\n    \n    int inter_start = max(s1, s2);\n    int inter_end = min(e1, e2);\n    \n    if (inter_start > inter_end) {\n        return \"NO\";\n    }\n    \n    int len = inter_end - inter_start;\n    \n    if (len <= 0) {\n        return \"NO\";\n    }\n    \n    // Check if len is a prime number\n    if (len <= 1) {\n        return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n    if (len % 2 == 0) {\n        return \"NO\";\n    }\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cstdlib> // For abs function\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum_mag = 0;\n    int product_sign = 1;\n    \n    for (int num : arr) {\n        sum_mag += abs(num);\n        if (num == 0) {\n            product_sign = 0;\n            break;\n        } else if (num < 0) {\n            product_sign *= -1;\n        }\n    }\n    \n    return sum_mag * product_sign;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    int x = 0, y = 0;\n    int min_val = grid[0][0];\n    \n    // Find the starting cell with the minimum value\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                x = i;\n                y = j;\n            }\n        }\n    }\n    \n    vector<int> path;\n    path.push_back(min_val);\n    if (k == 1) return path;\n    \n    // Directions: up, down, left, right\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    \n    for (int step = 1; step < k; ++step) {\n        int next_x = x, next_y = y;\n        int min_next = INT_MAX;\n        \n        // Check all four possible directions\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                int val = grid[nx][ny];\n                if (val < min_next) {\n                    min_next = val;\n                    next_x = nx;\n                    next_y = ny;\n                }\n            }\n        }\n        \n        path.push_back(min_next);\n        x = next_x;\n        y = next_y;\n    }\n    \n    return path;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n < 0) return {};\n    \n    int max_even = (n % 2 == 0) ? n : n + 1;\n    int size = max_even + 1;\n    vector<int> res(size, 0);\n    \n    // Compute even terms\n    for (int i = 0; i <= max_even; i += 2) {\n        res[i] = 1 + i / 2;\n    }\n    \n    // Set tri(1) = 3 if within bounds\n    if (1 <= max_even) {\n        res[1] = 3;\n    }\n    \n    // Compute odd terms from 3 up to max_odd\n    int max_odd = (n % 2 == 1) ? n : n - 1;\n    for (int i = 3; i <= max_odd; i += 2) {\n        if (i + 1 <= max_even) { // Ensure i+1 is within bounds\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    \n    // Return the first n+1 elements\n    return vector<int>(res.begin(), res.begin() + n + 1);\n}\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd = false;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int n = str.size();\n    if (n < 4) return false;\n\n    int first_open = -1;\n    for (int i = 0; i < n; ++i) {\n        if (str[i] == '[') {\n            first_open = i;\n            break;\n        }\n    }\n    if (first_open == -1) return false;\n\n    int second_open = -1;\n    for (int i = first_open + 1; i < n; ++i) {\n        if (str[i] == '[') {\n            second_open = i;\n            break;\n        }\n    }\n    if (second_open == -1) return false;\n\n    int first_close = -1;\n    for (int i = second_open + 1; i < n; ++i) {\n        if (str[i] == ']') {\n            first_close = i;\n            break;\n        }\n    }\n    if (first_close == -1) return false;\n\n    int second_close = -1;\n    for (int i = first_close + 1; i < n; ++i) {\n        if (str[i] == ']') {\n            second_close = i;\n            break;\n        }\n    }\n    if (second_close == -1) return false;\n\n    return true;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        double ceiled = ceil(num);\n        int ceiled_int = static_cast<int>(ceiled);\n        sum += ceiled_int * ceiled_int;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <cctype>\n#include <string>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n    \n    char last_char = txt.back();\n    if (!isalpha(last_char)) {\n        return false;\n    }\n    \n    int last = txt.size() - 1;\n    int start = last;\n    \n    while (start > 0 && txt[start - 1] != ' ') {\n        start--;\n    }\n    \n    int length = last - start + 1;\n    return length == 1;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int max_index = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] <= arr[i-1]) {\n            if (i > max_index) {\n                max_index = i;\n            }\n        }\n    }\n    return max_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int a = 0;\n    int b = 0;\n    for (int num : lst) {\n        if (num < 0) {\n            if (a == 0 || num > a) {\n                a = num;\n            }\n        } else if (num > 0) {\n            if (b == 0 || num < b) {\n                b = num;\n            }\n        }\n    }\n    return {a, b};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ndouble get_value(const boost::any &var) {\n    if (var.type() == typeid(int)) {\n        return static_cast<double>(boost::any_cast<int>(var));\n    } else if (var.type() == typeid(double)) {\n        return boost::any_cast<double>(var);\n    } else if (var.type() == typeid(string)) {\n        string s = boost::any_cast<string>(var);\n        replace(s.begin(), s.end(), ',', '.');\n        return stod(s);\n    } else {\n        return 0.0;\n    }\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double a_val = get_value(a);\n    double b_val = get_value(b);\n    \n    if (a_val == b_val) {\n        return string(\"None\");\n    } else if (a_val > b_val) {\n        return a;\n    } else {\n        return b;\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    return (n >= 8) && (n % 2 == 0);\n}\n"}
{"task_id": "CPP/139", "generation": "long long special_factorial(int n) {\n    if (n <= 0) return 0;\n    long long result = 1;\n    long long current_fact = 1;\n    for (int k = 1; k <= n; ++k) {\n        current_fact *= k;\n        result *= current_fact;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int i = 0;\n    int n = text.length();\n    while (i < n) {\n        if (text[i] != ' ') {\n            result += text[i];\n            i++;\n        } else {\n            int count = 0;\n            while (i < n && text[i] == ' ') {\n                count++;\n                i++;\n            }\n            if (count <= 2) {\n                result += string(count, '_');\n            } else {\n                result += '-';\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t first_dot = file_name.find('.');\n    if (first_dot == string::npos) {\n        return \"No\";\n    }\n    size_t next_dot = file_name.find('.', first_dot + 1);\n    if (next_dot != string::npos) {\n        return \"No\";\n    }\n    \n    // Split into name and extension parts\n    string name_part = file_name.substr(0, first_dot);\n    string ext_part = file_name.substr(first_dot + 1);\n    \n    // Check name part is not empty and starts with a letter\n    if (name_part.empty()) {\n        return \"No\";\n    }\n    char first_char = name_part[0];\n    if (!((first_char >= 'A' && first_char <= 'Z') || (first_char >= 'a' && first_char <= 'z'))) {\n        return \"No\";\n    }\n    \n    // Check extension is valid\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n    \n    // Check digit count does not exceed three\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (c >= '0' && c <= '9') {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n    while (getline(ss, word, ' ')) {\n        words.push_back(word);\n    }\n    \n    vector<string> result;\n    for (auto& w : words) {\n        if (is_prime(w.length())) {\n            result.push_back(w);\n        }\n    }\n    \n    string output;\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i == 0) {\n            output = result[i];\n        } else {\n            output += \" \" + result[i];\n        }\n    }\n    \n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <algorithm> // for std::__gcd (GNU extension)\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse x into a/b\n    size_t slash_pos = x.find('/');\n    long long a = stoll(x.substr(0, slash_pos));\n    long long b = stoll(x.substr(slash_pos + 1));\n    \n    // Parse n into c/d\n    slash_pos = n.find('/');\n    long long c = stoll(n.substr(0, slash_pos));\n    long long d = stoll(n.substr(slash_pos + 1));\n    \n    // Simplify by cancelling common factors between a and d\n    long long g1 = __gcd(a, d);\n    a /= g1;\n    d /= g1;\n    \n    // Simplify by cancelling common factors between c and b\n    long long g2 = __gcd(c, b);\n    c /= g2;\n    b /= g2;\n    \n    // Check if the resulting denominator is 1\n    return (b * d) == 1;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint sumDigits(int n) {\n    if (n == 0) return 0;\n    bool isNegative = n < 0;\n    string s = to_string(abs(n));\n    int sum = 0;\n    if (isNegative) {\n        sum += -(s[0] - '0');\n        for (int i = 1; i < s.size(); ++i) {\n            sum += s[i] - '0';\n        }\n    } else {\n        for (char c : s) {\n            sum += c - '0';\n        }\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<tuple<int, int, int>> elements;\n    for (int i = 0; i < nums.size(); ++i) {\n        int sum = sumDigits(nums[i]);\n        elements.emplace_back(sum, i, nums[i]);\n    }\n    sort(elements.begin(), elements.end(), [](const tuple<int, int, int>& a, const tuple<int, int, int>& b) {\n        if (get<0>(a) != get<0>(b)) {\n            return get<0>(a) < get<0>(b);\n        } else {\n            return get<1>(a) < get<1>(b);\n        }\n    });\n    vector<int> result;\n    for (const auto& elem : elements) {\n        result.push_back(get<2>(elem));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) {\n            continue;\n        }\n        int last = num % 10;\n        int first = num;\n        while (first >= 10) {\n            first /= 10;\n        }\n        if (first % 2 != 0 && last % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n\nint get_max_triples(int n) {\n    int count0 = 0;\n    if (n >= 2) {\n        count0 = (n - 2) / 3 + 1;\n    }\n    int count1 = n - count0;\n    \n    long long triples0 = (count0 >= 3) ? (long long)count0 * (count0 - 1) * (count0 - 2) / 6 : 0;\n    long long triples1 = (count1 >= 3) ? (long long)count1 * (count1 - 1) * (count1 - 2) / 6 : 0;\n    \n    return triples0 + triples1;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> ordered = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int index1 = -1, index2 = -1;\n    \n    for (int i = 0; i < ordered.size(); ++i) {\n        if (ordered[i] == planet1) index1 = i;\n        if (ordered[i] == planet2) index2 = i;\n    }\n    \n    if (index1 == -1 || index2 == -1) {\n        return vector<string>();\n    }\n    \n    int lower = min(index1, index2);\n    int higher = max(index1, index2);\n    \n    if (higher - lower <= 1) {\n        return vector<string>();\n    }\n    \n    vector<string> result;\n    for (int i = lower + 1; i <= higher - 1; ++i) {\n        result.push_back(ordered[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n    for (auto &s : lst) {\n        if (s.size() % 2 == 0) {\n            result.push_back(s);\n        }\n    }\n    sort(result.begin(), result.end(), [](const string &a, const string &b) {\n        if (a.size() == b.size()) {\n            return a < b;\n        }\n        return a.size() < b.size();\n    });\n    return result;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num < 0) {\n            continue;\n        }\n        if (num != static_cast<float>(static_cast<int>(num))) {\n            continue;\n        }\n        int val = static_cast<int>(num);\n        if (val % 2 != 0) {\n            sum += static_cast<long long>(val) * val;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> res;\n    for (int i = 0; i < game.size(); ++i) {\n        res.push_back(abs(game[i] - guess[i]));\n    }\n    return res;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <ctype.h>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1e9;\n    int best_index = 0;\n    for (int i = 0; i < extensions.size(); ++i) {\n        const string& ext = extensions[i];\n        int cap = 0, sm = 0;\n        for (char c : ext) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            best_index = i;\n        }\n    }\n    return class_name + \".\" + extensions[best_index];\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.empty()) {\n        return true; // Assuming empty string is considered a substring\n    }\n    int len = b.size();\n    for (int i = 0; i < len; ++i) {\n        string rotation = b.substr(i) + b.substr(0, i);\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <cstdlib> // For abs()\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    int even = 0, odd = 0;\n    num = abs(num); // Handle negative numbers\n    \n    if (num == 0) {\n        even = 1;\n    } else {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n            num /= 10;\n        }\n    }\n    \n    return {even, odd};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n    string result = \"\";\n    for (auto &pair : roman) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <cmath>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    float a_sq = a * a;\n    float b_sq = b * b;\n    float c_sq = c * c;\n\n    float max_sq = a_sq;\n    if (b_sq > max_sq) max_sq = b_sq;\n    if (c_sq > max_sq) max_sq = c_sq;\n\n    float sum_other = (a_sq + b_sq + c_sq) - max_sq;\n\n    return fabs(sum_other - max_sq) < 1e-5f;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    if (words.empty()) return \"\";\n    \n    string result = words[0];\n    set<char> first_unique(words[0].begin(), words[0].end());\n    int max_count = first_unique.size();\n    \n    for (size_t i = 1; i < words.size(); ++i) {\n        const string& word = words[i];\n        set<char> current_unique(word.begin(), word.end());\n        int current_count = current_unique.size();\n        \n        if (current_count > max_count) {\n            max_count = current_count;\n            result = word;\n        } else if (current_count == max_count) {\n            if (word < result) {\n                result = word;\n            }\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int eat_amount = (need < remaining) ? need : remaining;\n    vector<int> res;\n    res.push_back(number + eat_amount);\n    res.push_back(remaining - eat_amount);\n    return res;\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint getPrecedence(const string& op) {\n    if (op == \"**\") return 4;\n    if (op == \"*\" || op == \"//\") return 3;\n    if (op == \"+\" || op == \"-\") return 2;\n    return -1; // Invalid operator\n}\n\nbool isRightAssociative(const string& op) {\n    return op == \"**\";\n}\n\nvector<string> shuntingYard(const vector<string>& tokens) {\n    vector<string> output;\n    vector<string> stack;\n\n    for (const string& token : tokens) {\n        if (isdigit(token[0])) {\n            output.push_back(token);\n        } else {\n            while (!stack.empty()) {\n                const string& top_op = stack.back();\n                int curr_prec = getPrecedence(token);\n                int top_prec = getPrecedence(top_op);\n\n                if (curr_prec == -1 || top_prec == -1) break;\n\n                bool curr_assoc = isRightAssociative(token);\n                bool condition = false;\n\n                if (curr_assoc) {\n                    condition = (curr_prec < top_prec);\n                } else {\n                    condition = (curr_prec <= top_prec);\n                }\n\n                if (condition) {\n                    output.push_back(top_op);\n                    stack.pop_back();\n                } else {\n                    break;\n                }\n            }\n            stack.push_back(token);\n        }\n    }\n\n    while (!stack.empty()) {\n        output.push_back(stack.back());\n        stack.pop_back();\n    }\n\n    return output;\n}\n\nint evaluateRPN(const vector<string>& rpn) {\n    vector<int> stack;\n\n    for (const string& token : rpn) {\n        if (isdigit(token[0])) {\n            stack.push_back(stoi(token));\n        } else {\n            if (stack.size() < 2) {\n                return -1; // Invalid expression\n            }\n            int b = stack.back(); stack.pop_back();\n            int a = stack.back(); stack.pop_back();\n            int result;\n\n            if (token == \"+\") {\n                result = a + b;\n            } else if (token == \"-\") {\n                result = a - b;\n            } else if (token == \"*\") {\n                result = a * b;\n            } else if (token == \"//\") {\n                if (b == 0) return -1; // Division by zero\n                result = a / b;\n            } else if (token == \"**\") {\n                if (a == 0 && b == 0) return -1; // Undefined 0^0\n                result = 1;\n                for (int i = 0; i < b; ++i) {\n                    result *= a;\n                }\n            } else {\n                return -1; // Invalid operator\n            }\n            stack.push_back(result);\n        }\n    }\n\n    if (stack.size() != 1) return -1; // Invalid expression\n    return stack.back();\n}\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operand.size() < 2) return -1; // Invalid input per problem statement\n\n    vector<string> tokens;\n    tokens.push_back(to_string(operand[0]));\n\n    for (int i = 0; i < operato.size(); ++i) {\n        tokens.push_back(operato[i]);\n        tokens.push_back(to_string(operand[i + 1]));\n    }\n\n    vector<string> rpn = shuntingYard(tokens);\n    return evaluateRPN(rpn);\n}\n"}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n    if (!has_letters) {\n        reverse(s.begin(), s.end());\n    } else {\n        for (char &c : s) {\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((const unsigned char*)text.c_str(), text.size(), digest);\n    string hex_str;\n    hex_str.reserve(2 * MD5_DIGEST_LENGTH);\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        const char hex_chars[] = \"0123456789abcdef\";\n        unsigned char byte = digest[i];\n        hex_str.push_back(hex_chars[(byte >> 4) & 0x0F]);\n        hex_str.push_back(hex_chars[byte & 0x0F]);\n    }\n    return hex_str;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Check each even digit (2, 4, 6, 8)\n    if (2 >= start && 2 <= end) {\n        result.push_back(2);\n    }\n    if (4 >= start && 4 <= end) {\n        result.push_back(4);\n    }\n    if (6 >= start && 6 <= end) {\n        result.push_back(6);\n    }\n    if (8 >= start && 8 <= end) {\n        result.push_back(8);\n    }\n    \n    return result;\n}\n"}
