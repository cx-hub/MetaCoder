{"task_id": "CPP/0", "generation": "bool has_close_elements(vector<float> numbers, float threshold) {\n  // Sort the vector of numbers\n  sort(numbers.begin(), numbers.end());\n\n  // Iterate through the sorted vector\n  for (int i = 1; i < numbers.size(); i++) {\n    // Check if the difference between the current element and the previous one is less than the threshold\n    if (abs(numbers[i] - numbers[i-1]) < threshold) {\n      return true; // Found two numbers closer than the threshold\n    }\n  }\n\n  return false; // No two numbers closer than the threshold\n}\n"}
{"task_id": "CPP/1", "generation": "vector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            balance++;\n            current_group += c;\n        } else if (c == ')') {\n            balance--;\n            current_group += c;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns the decimal part of a given positive floating point number.\n *\n * @param number A positive floating point number.\n * @return The decimal part of the number.\n */\nfloat truncate_number(float number) {\n    // Calculate the integer part of the number\n    int integer_part = (int) number;\n    \n    // Subtract the integer part from the original number to get the decimal part\n    float decimal_part = number - integer_part;\n    \n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Detects if the balance of a bank account falls below zero at any point.\n *\n * @param operations A vector of deposit and withdrawal operations.\n * @return True if the balance falls below zero, false otherwise.\n */\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\n/**\n * Calculate the Mean Absolute Deviation (MAD) of a dataset.\n *\n * MAD is the average absolute difference between each element and the mean of the dataset.\n *\n * @param numbers The input dataset.\n * @return The Mean Absolute Deviation of the dataset.\n */\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the dataset\n    float sum = std::accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n\n    // Calculate the sum of absolute differences from the mean\n    float sum_abs_diff = 0.0f;\n    for (float num : numbers) {\n        sum_abs_diff += std::abs(num - mean);\n    }\n\n    // Calculate the Mean Absolute Deviation\n    float mad = sum_abs_diff / numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Inserts a number \"delimiter\" between every two consecutive elements of input vector `numbers`.\n *\n * @param numbers Input vector of integers.\n * @param delimiter Number to be inserted between consecutive elements.\n * @return A new vector with the delimiter inserted between consecutive elements.\n */\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <stack>\n#include <vector>\n#include <string>\n\n// Function declaration\nint process_group(std::string group);\n\n// Function to parse nested parentheses\nstd::vector<int> parse_nested_parens(std::string paren_string) {\n  std::vector<int> results;\n  std::string group;\n  for (char c : paren_string) {\n    if (c == ' ') {\n      // Process the current group\n      results.push_back(process_group(group));\n      group.clear();\n    } else {\n      group += c;\n    }\n  }\n  // Process the last group\n  results.push_back(process_group(group));\n  return results;\n}\n\n// Function to process a group of parentheses\nint process_group(std::string group) {\n  int max_depth = 0;\n  int current_depth = 0;\n  std::stack<char> s;\n  for (char c : group) {\n    if (c == '(') {\n      s.push(c);\n      current_depth++;\n      max_depth = std::max(max_depth, current_depth);\n    } else if (c == ')') {\n      s.pop();\n      current_depth--;\n    }\n  }\n  return max_depth;\n}\n"}
{"task_id": "CPP/7", "generation": "/**\n * Filters an input vector of strings to only include those that contain a given substring.\n *\n * @param strings The input vector of strings to filter.\n * @param substring The substring to search for in each string.\n * @return A new vector containing only the strings that contain the given substring.\n */\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a vector containing the sum and product of all integers in the input vector.\n * Empty sum is 0 and empty product is 1.\n *\n * @param numbers Input vector of integers\n * @return Vector containing sum and product of integers\n */\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate over each number in the input vector\n    for (int num : numbers) {\n        sum += num;  // Add number to sum\n        product *= num;  // Multiply number with product\n    }\n\n    // Create a new vector containing sum and product\n    std::vector<int> result = {sum, product};\n    return result;\n}\n\n"}
{"task_id": "CPP/9", "generation": "/**\n * Generates a vector of rolling maximum elements found until a given moment in the sequence.\n *\n * @param numbers The input vector of integers.\n * @return A vector of rolling maximum elements.\n */\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int max_so_far = numbers[0];\n    result.push_back(max_so_far);\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n        }\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a given string is a palindrome.\n *\n * @param str The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(const string& str) {\n    // Create a reversed copy of the input string\n    string s(str.rbegin(), str.rend());\n    // Compare the reversed string with the original string\n    return s == str;\n}\n\n/**\n * Finds the shortest palindrome that begins with a supplied string.\n *\n * Algorithm idea:\n * 1. Find the longest postfix of the supplied string that is a palindrome.\n * 2. Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n *\n * @param str The input string to make a palindrome.\n * @return The shortest palindrome that begins with the input string.\n */\nstring make_palindrome(const string& str) {\n    // Handle the edge case where the input string is empty\n    if (str.empty()) {\n        return \"\";\n    }\n\n    // Find the longest palindromic suffix\n    string suffix;\n    for (int i = str.length() - 1; i >= 0; --i) {\n        suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            break;\n        }\n    }\n\n    // Find the prefix that comes before the palindromic suffix\n    string prefix = str.substr(0, str.length() - suffix.length());\n\n    // Append the reverse of the prefix to the end of the string\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Performs binary XOR on two input strings consisting only of 1s and 0s.\n * \n * @param a First input string\n * @param b Second input string\n * @return Result of binary XOR as a string\n */\nstring string_xor(string a, string b) {\n    // Check if input strings have the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must have the same length\");\n    }\n\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        // Perform XOR on corresponding characters\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the longest string in a vector of strings.\n * If multiple strings have the same maximum length, returns the first one.\n * Returns an empty string if the input vector is empty.\n */\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n\n    return longest_str;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\n// Function to calculate the greatest common divisor (GCD) of two integers\nint greatest_common_divisor(int a, int b) {\n    // Use the Euclidean algorithm to find the GCD\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a vector of all prefixes from shortest to longest of the input string.\n *\n * @param str The input string.\n * @return A vector of all prefixes of the input string.\n */\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a string containing space-delimited numbers starting from 0 upto n inclusive.\n *\n * @param n The upper limit of the sequence.\n * @return A string containing the sequence of numbers.\n */\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Create a set to store unique characters\n    set<char> unique_chars(str.begin(), str.end());\n    \n    // Return the size of the set, which represents the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n/**\n * Parse a string representing musical notes in a special ASCII format\n * and return a vector of integers corresponding to how many beats each note lasts.\n *\n * @param music_string Input string representing musical notes\n * @return Vector of integers representing the duration of each note in beats\n */\nvector<int> parse_music(string music_string) {\n    vector<int> note_durations;\n    int i = 0;\n\n    // Iterate through the input string\n    while (i < music_string.length()) {\n        // Check for whole note (\"o\")\n        if (music_string[i] == 'o' && (i + 1 == music_string.length() || music_string[i + 1] != '|')) {\n            note_durations.push_back(4); // Whole note lasts 4 beats\n            i++;\n        }\n        // Check for half note (\"o|\")\n        else if (music_string[i] == 'o' && music_string[i + 1] == '|') {\n            note_durations.push_back(2); // Half note lasts 2 beats\n            i += 2;\n        }\n        // Check for quarter note (\".|\")\n        else if (music_string[i] == '.' && music_string[i + 1] == '|') {\n            note_durations.push_back(1); // Quarter note lasts 1 beat\n            i += 2;\n        }\n        // Skip spaces\n        else if (music_string[i] == ' ') {\n            i++;\n        }\n        // Invalid input\n        else {\n            printf(\"Invalid input: '%c'\\n\", music_string[i]);\n            return vector<int>(); // Return empty vector on error\n        }\n    }\n\n    return note_durations;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Counts the number of occurrences of a substring in a given string.\n * Overlapping cases are included in the count.\n *\n * @param str The original string to search in.\n * @param substring The substring to search for.\n * @return The number of times the substring is found in the original string.\n */\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the string until we've searched the entire string\n    while (pos < str.length()) {\n        // Find the next occurrence of the substring\n        pos = str.find(substring, pos);\n\n        // If the substring is not found, exit the loop\n        if (pos == string::npos) {\n            break;\n        }\n\n        // Increment the count and move the search position forward\n        count++;\n        pos += 1; // Move forward by 1 character to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers in a string\nstring sort_numbers(string numbers) {\n    // Map to store the numerical values of the number words\n    map<string, int> numMap = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into a vector of words\n    stringstream ss(numbers);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Sort the vector of words based on their numerical values\n    sort(words.begin(), words.end(), [&numMap](const string& a, const string& b) {\n        return numMap[a] < numMap[b];\n    });\n\n    // Join the sorted words back into a string\n    string sortedNumbers;\n    for (const auto& word : words) {\n        sortedNumbers += word + \" \";\n    }\n\n    // Remove the trailing space\n    sortedNumbers.pop_back();\n\n    return sortedNumbers;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Find the two closest elements in a vector of numbers.\n *\n * @param numbers A vector of numbers (of length at least two).\n * @return A vector containing the two closest numbers in order (smaller number, larger number).\n */\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize the minimum difference and the closest pair\n    float min_diff = INFINITY;\n    vector<float> closest_pair;\n\n    // Iterate through the sorted vector to find the closest pair\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "vector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Check if all values are the same (to avoid division by zero)\n    if (min_val == max_val) {\n        // If all values are the same, return a vector of zeros\n        vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    // Apply the linear transformation\n    vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <boost/any.hpp>\n#include <list>\n#include <vector>\n#include <string>\n\ntypedef std::list<boost::any> list_any;\n\n/**\n * Filters a list of any values and returns a vector of integers.\n *\n * @param values A list of any values.\n * @return A vector of integers.\n */\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the length of the given string.\n *\n * @param str The input string.\n * @return The length of the input string.\n */\nint strlen(string str) {\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\n// Function to find the largest number that divides n evenly, smaller than n\nint largest_divisor(int n) {\n    // Start from n-1 and decrement by 1 until we find a divisor\n    for (int i = n - 1; i > 0; i--) {\n        // Check if i is a divisor of n\n        if (n % i == 0) {\n            return i; // Return the largest divisor\n        }\n    }\n    return 1; // If no divisor is found, return 1 (since 1 is a divisor of every number)\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a vector of prime factors of the given integer in the order from smallest to largest.\n * Each factor is included in the vector a number of times corresponding to its multiplicity in the factorization.\n * The input number should be equal to the product of all factors.\n *\n * @param n The input integer to be factorized.\n * @return A vector of prime factors.\n */\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "vector<int> remove_duplicates(vector<int> numbers) {\n    vector<int> result;\n    for (int num : numbers) {\n        if (count(numbers.begin(), numbers.end(), num) == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Flips the case of all characters in a given string.\n * \n * @param str The input string.\n * @return The string with all characters' case flipped.\n */\nstring flip_case(string str) {\n    for (char& c : str) {\n        if (c >= 'a' && c <= 'z') {\n            // Convert lowercase to uppercase\n            c -= 'a' - 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            // Convert uppercase to lowercase\n            c += 'a' - 'A';\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Concatenates a vector of strings into a single string.\n *\n * @param strings Vector of strings to concatenate.\n * @return A single string containing all input strings concatenated together.\n */\nstring concatenate(vector<string> strings) {\n    string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Filter an input vector of strings only for ones that start with a given prefix.\n *\n * @param strings Input vector of strings\n * @param prefix Prefix to filter by\n * @return Filtered vector of strings\n */\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(prefix) == 0) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a new vector containing only the positive numbers from the input vector.\n *\n * @param l The input vector of numbers.\n * @return A new vector containing only the positive numbers from the input vector.\n */\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n\n/**\n * Returns true if a given number is prime, and false otherwise.\n *\n * @param n The number to check for primality.\n * @return True if n is prime, false otherwise.\n */\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n <= 1) {\n        return false; // Numbers less than or equal to 1 are not prime\n    }\n\n    // Check if n is divisible by any number up to its square root\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false; // If n is divisible by i, it's not prime\n        }\n    }\n\n    // If we reach this point, n is prime\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <stdexcept>\n\n// Define the poly function to evaluate a polynomial at a given point\ndouble poly(const std::vector<double>& coeffs, double x) {\n    double result = 0;\n    for (int i = 0; i < coeffs.size(); ++i) {\n        result += coeffs[i] * pow(x, i);\n    }\n    return result;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Check if the number of coefficients is even\n    if (xs.size() % 2 != 0) {\n        throw std::invalid_argument(\"Number of coefficients must be even\");\n    }\n\n    // Check if the largest non-zero coefficient is at the end\n    int max_non_zero_idx = -1;\n    for (int i = xs.size() - 1; i >= 0; --i) {\n        if (xs[i] != 0) {\n            max_non_zero_idx = i;\n            break;\n        }\n    }\n    if (max_non_zero_idx != xs.size() - 1) {\n        throw std::invalid_argument(\"Largest non-zero coefficient must be at the end\");\n    }\n\n    // Use the Newton-Raphson method to find a zero\n    double x = 1.0; // initial guess\n    double tol = 1e-6; // tolerance\n    double max_iter = 100; // maximum number of iterations\n\n    for (int i = 0; i < max_iter; ++i) {\n        double f_x = poly(xs, x);\n        double f_prime_x = 0;\n        for (int j = 1; j < xs.size(); ++j) {\n            f_prime_x += j * xs[j] * pow(x, j - 1);\n        }\n        double x_new = x - f_x / f_prime_x;\n        if (abs(x_new - x) < tol) {\n            return x_new;\n        }\n        x = x_new;\n    }\n\n    throw std::runtime_error(\"Failed to converge\");\n}\n"}
{"task_id": "CPP/33", "generation": "vector<int> sort_third(vector<int> l) {\n    // Create a vector to store the values at indices divisible by 3\n    vector<int> third_values;\n    \n    // Iterate over the input vector and extract values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the extracted values in ascending order\n    sort(third_values.begin(), third_values.end());\n    \n    // Create a new vector to store the result\n    vector<int> result;\n    \n    // Iterate over the input vector and construct the result\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            // Use the sorted values at indices divisible by 3\n            result.push_back(third_values[i / 3]);\n        } else {\n            // Use the original values at indices not divisible by 3\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Returns a sorted vector of unique elements from the input vector.\n *\n * @param l The input vector.\n * @return A sorted vector of unique elements.\n */\nvector<int> unique(vector<int> l) {\n    // Sort the vector in ascending order\n    sort(l.begin(), l.end());\n\n    // Use the erase-remove idiom to remove duplicates\n    l.erase(unique(l.begin(), l.end()), l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // for std::max_element\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    return *max_element(l.begin(), l.end());\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "vector<float> sort_even(vector<float> l) {\n    // Separate even-indexed elements into a new vector\n    vector<float> even_elements;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector with the sorted even-indexed elements\n    vector<float> result;\n    int even_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even_elements[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encodes a string by cycling groups of three characters.\n * \n * @param s The input string to be encoded.\n * @return The encoded string.\n */\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // Cycle elements in each group, unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n/**\n * Decodes a string that was encoded with the encode_cyclic function.\n * \n * @param s The input string to be decoded.\n * @return The decoded string.\n */\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // Reverse the cycling of elements in each group.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate Fibonacci numbers\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; i++) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0;\n    int fib_num = 0;\n    while (count < n) {\n        fib_num = fibonacci(fib_num + 1);\n        if (is_prime(fib_num)) {\n            count++;\n        }\n    }\n    return fib_num;\n}\n\n"}
{"task_id": "CPP/40", "generation": "bool triples_sum_to_zero(vector<int> l) {\n  // Sort the vector to make it easier to find triples\n  sort(l.begin(), l.end());\n\n  // Iterate over the vector\n  for (int i = 0; i < l.size() - 2; i++) {\n    // Skip duplicates to ensure distinct elements\n    if (i > 0 && l[i] == l[i - 1]) continue;\n\n    // Initialize two pointers, one at the next element and one at the end\n    int j = i + 1;\n    int k = l.size() - 1;\n\n    // Move the pointers towards each other until they meet\n    while (j < k) {\n      int sum = l[i] + l[j] + l[k];\n\n      // If the sum is zero, return true\n      if (sum == 0) return true;\n\n      // If the sum is negative, move the left pointer to the right\n      if (sum < 0) j++;\n\n      // If the sum is positive, move the right pointer to the left\n      else k--;\n    }\n  }\n\n  // If no triple is found, return false\n  return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\n/**\n * Calculates the number of collisions between two sets of cars moving in opposite directions.\n *\n * @param n The number of cars in each set.\n * @return The total number of collisions.\n */\nint car_race_collision(int n) {\n    // Since all cars move at the same speed, each car in one set will collide with every car in the other set.\n    // Therefore, the total number of collisions is the product of the number of cars in each set.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a new vector with each element incremented by 1.\n *\n * @param l The input vector to increment.\n * @return A new vector with each element incremented by 1.\n */\nstd::vector<int> incr_vector(const std::vector<int>& l) {\n    std::vector<int> result;\n    for (int i : l) {\n        result.push_back(i + 1);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\n/**\n * Returns true if there are two distinct elements in the vector that sum to zero, and false otherwise.\n */\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Changes the numerical base of input number x to base.\n * Returns string representation after the conversion.\n * Base numbers are less than 10.\n *\n * @param x The input number to convert.\n * @param base The target base.\n * @return String representation of x in the target base.\n */\nstring change_base(int x, int base) {\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x = x / base;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "/**\n * Calculates the area of a triangle given the length of a side and the height.\n *\n * @param a The length of a side of the triangle.\n * @param h The height of the triangle.\n * @return The area of the triangle.\n */\nfloat triangle_area(float a, float h) {\n    // The formula for the area of a triangle is (base * height) / 2.\n    // In this case, we're using the given side as the base.\n    return (a * h) / 2;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\n\n/**\n * Compute the n-th element of the Fib4 number sequence.\n *\n * The Fib4 sequence is defined as:\n *   fib4(0) -> 0\n *   fib4(1) -> 0\n *   fib4(2) -> 2\n *   fib4(3) -> 0\n *   fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n *\n * This implementation uses dynamic programming to efficiently compute the n-th element.\n *\n * @param n The index of the element to compute.\n * @return The n-th element of the Fib4 sequence.\n */\nint fib4(int n) {\n  if (n <= 1) return 0; // base cases\n  if (n == 2) return 2;\n  if (n == 3) return 0;\n\n  int fib4_prev = 0; // fib4(n-4)\n  int fib4_prev_prev = 0; // fib4(n-3)\n  int fib4_prev_prev_prev = 2; // fib4(n-2)\n  int fib4_prev_prev_prev_prev = 0; // fib4(n-1)\n\n  for (int i = 4; i <= n; i++) {\n    int fib4_curr = fib4_prev + fib4_prev_prev + fib4_prev_prev_prev + fib4_prev_prev_prev_prev;\n    fib4_prev = fib4_prev_prev;\n    fib4_prev_prev = fib4_prev_prev_prev;\n    fib4_prev_prev_prev = fib4_prev_prev_prev_prev;\n    fib4_prev_prev_prev_prev = fib4_curr;\n  }\n\n  return fib4_prev_prev_prev_prev;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns the median of elements in the vector l.\n *\n * @param l A vector of float numbers.\n * @return The median of the elements in the vector.\n */\nfloat median(vector<float> l) {\n    // First, sort the vector in ascending order\n    sort(l.begin(), l.end());\n\n    // Get the size of the vector\n    int n = l.size();\n\n    // If the size of the vector is even, the median is the average of the two middle numbers\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n    // If the size of the vector is odd, the median is the middle number\n    else {\n        return l[n / 2];\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a given string is a palindrome.\n *\n * A palindrome is a string that reads the same backward as forward.\n *\n * @param text The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\n/**\n * Returns 2^n modulo p.\n *\n * @param n The exponent.\n * @param p The modulus.\n * @return 2^n modulo p.\n */\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encodes a string by shifting every character by 5 positions in the alphabet.\n *\n * @param s The input string to encode.\n * @return The encoded string.\n */\nstring encode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n\n/**\n * Decodes a string that was previously encoded with the encode_shift function.\n *\n * @param s The input string to decode.\n * @return The decoded string.\n */\nstring decode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "string remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    text.erase(std::remove_if(text.begin(), text.end(), \n        [&vowels](char c) { return vowels.find(c) != std::string::npos; }), \n        text.end());\n    return text;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns true if all numbers in the vector l are below threshold t.\n *\n * @param l The vector of integers to check.\n * @param t The threshold value.\n * @return True if all numbers in l are below t, false otherwise.\n */\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Checks if two words have the same kind of characters.\n *\n * @param s0 First string\n * @param s1 Second string\n * @return True if both strings have the same kind of characters, false otherwise\n */\nbool same_chars(string s0, string s1) {\n    // Sort both strings to compare character sets\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Compare character sets\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\n// Function to calculate the nth Fibonacci number\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n-1) + fib(n-2);\n    }\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if every opening bracket has a corresponding closing bracket.\n *\n * @param brackets A string of '<' and '>' characters.\n * @return True if the bracketing is correct, false otherwise.\n */\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced closing bracket\n            }\n        }\n    }\n    return balance == 0; // All opening brackets have corresponding closing brackets\n}\n"}
{"task_id": "CPP/57", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns true if the elements of the vector are monotonically increasing or decreasing.\n *\n * @param l The input vector of floats.\n * @return True if the vector is monotonically increasing or decreasing, false otherwise.\n */\nbool monotonic(vector<float> l) {\n    // Check if the vector is empty or has only one element\n    if (l.size() <= 1) {\n        return true; // A single element or empty vector is considered monotonic\n    }\n\n    // Check if the vector is monotonically increasing\n    bool increasing = true;\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n            break;\n        }\n    }\n\n    // Check if the vector is monotonically decreasing\n    bool decreasing = true;\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n            break;\n        }\n    }\n\n    // Return true if the vector is either monotonically increasing or decreasing\n    return increasing || decreasing;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Returns a sorted vector of unique common elements between two input vectors.\n *\n * @param l1 The first input vector.\n * @param l2 The second input vector.\n * @return A sorted vector of unique common elements.\n */\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Find the intersection of the two vectors\n    vector<int> intersection;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n                     back_inserter(intersection));\n\n    // Remove duplicates by converting to a set and back to a vector\n    set<int> unique_elements(intersection.begin(), intersection.end());\n    intersection.assign(unique_elements.begin(), unique_elements.end());\n\n    // Sort the resulting vector\n    sort(intersection.begin(), intersection.end());\n\n    return intersection;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n\n// Function to check if a number is prime\nint is_prime(int num) {\n    if (num <= 1) return 0;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Function to find the largest prime factor of a number\nint largest_prime_factor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n                int largest = i;\n                while (n % i == 0) {\n                    n /= i;\n                }\n                if (is_prime(n)) {\n                    return (n > largest) ? n : largest;\n                } else {\n                    return largest;\n                }\n            }\n        }\n        i++;\n    }\n    return n;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\n// Function to calculate the sum of numbers from 1 to n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if every opening bracket in the input string has a corresponding closing bracket.\n *\n * @param brackets A string consisting only of '(' and ')'.\n * @return True if every opening bracket has a corresponding closing bracket, false otherwise.\n */\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unmatched closing bracket\n            }\n        }\n    }\n    return balance == 0; // All brackets matched\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the derivative of a polynomial represented by its coefficients.\n *\n * The input vector `xs` represents the coefficients of a polynomial:\n * xs[0] + xs[1] * x + xs[2] * x^2 + ...\n *\n * The output vector represents the coefficients of the derivative of this polynomial.\n *\n * @param xs Coefficients of the polynomial\n * @return Coefficients of the derivative of the polynomial\n */\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\n\n/**\n * Compute the n-th element of the FibFib number sequence.\n *\n * The FibFib sequence is defined as:\n *   fibfib(0) == 0\n *   fibfib(1) == 0\n *   fibfib(2) == 1\n *   fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n *\n * @param n The index of the element to compute.\n * @return The n-th element of the FibFib sequence.\n */\nint fibfib(int n) {\n  if (n <= 1) return 0; // base cases\n  if (n == 2) return 1; // base case\n\n  // Initialize a table to store the first n+1 elements of the sequence\n  int fibfib_table[n + 1];\n  fibfib_table[0] = 0;\n  fibfib_table[1] = 0;\n  fibfib_table[2] = 1;\n\n  // Compute the rest of the sequence using dynamic programming\n  for (int i = 3; i <= n; i++) {\n    fibfib_table[i] = fibfib_table[i - 1] + fibfib_table[i - 2] + fibfib_table[i - 3];\n  }\n\n  return fibfib_table[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "int vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        switch (c) {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n                count++;\n                break;\n            case 'y':\n                if (c == s.back()) {\n                    count++;\n                }\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n * If shift > number of digits, return digits reversed.\n *\n * @param x The integer to be shifted\n * @param shift The number of positions to shift\n * @return The shifted integer as a string\n */\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str = to_string(x);\n    \n    // Calculate the effective shift (in case shift > number of digits)\n    int effective_shift = shift % str.length();\n    \n    // If effective shift is 0, return the original string\n    if (effective_shift == 0) {\n        return str;\n    }\n    \n    // Perform the circular shift\n    string result = str.substr(str.length() - effective_shift) + str.substr(0, str.length() - effective_shift);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\n\n/**\n * Returns the sum of the ASCII codes of the upper case characters in the input string.\n *\n * @param s The input string.\n * @return The sum of the ASCII codes of the upper case characters.\n */\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += (int)c;\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Split the string into two parts: apples and oranges\n    size_t pos = s.find(\" and \");\n    string apples_str = s.substr(0, pos);\n    string oranges_str = s.substr(pos + 5);\n\n    // Extract the numbers from the strings\n    int apples, oranges;\n    stringstream(apples_str) >> apples;\n    stringstream(oranges_str) >> oranges;\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits.h>\n\nvector<int> pluck(vector<int> arr) {\n    int smallestEven = INT_MAX; // Initialize with max integer value\n    int smallestEvenIndex = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallestEven) {\n            smallestEven = arr[i];\n            smallestEvenIndex = i;\n        }\n    }\n\n    if (smallestEvenIndex == -1) {\n        return {}; // Return empty vector if no even values found\n    }\n\n    return {smallestEven, smallestEvenIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint search(vector<int> lst) {\n    // Create a frequency map to store the count of each integer\n    unordered_map<int, int> freqMap;\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n\n    // Iterate through the frequency map to find the greatest integer\n    // that has a frequency greater than or equal to its value\n    int maxVal = -1;\n    for (auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > maxVal) {\n            maxVal = pair.first;\n        }\n    }\n\n    return maxVal;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector of integers in strange order.\n * Strange sorting is when you start with the minimum value,\n * then maximum of the remaining integers, then minimum and so on.\n *\n * @param lst Input vector of integers\n * @return Vector of integers in strange order\n */\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    bool is_min = true;\n\n    while (!lst.empty()) {\n        if (is_min) {\n            // Find and remove the minimum element\n            auto min_it = min_element(lst.begin(), lst.end());\n            result.push_back(*min_it);\n            lst.erase(min_it);\n        } else {\n            // Find and remove the maximum element\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n        is_min = !is_min;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Calculates the area of a triangle given the lengths of its three sides.\n * Returns the area rounded to 2 decimal points if the sides form a valid triangle.\n * Otherwise returns -1.\n *\n * @param a Length of side a\n * @param b Length of side b\n * @param c Length of side c\n * @return Area of the triangle or -1 if invalid\n */\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1; // Invalid triangle\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    return area;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns true if the object q will fly, and false otherwise.\n * The object q will fly if it's balanced (it is a palindromic vector) and \n * the sum of its elements is less than or equal the maximum possible weight w.\n */\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    bool is_palindromic = true;\n    for (int i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of the vector elements\n    int sum = 0;\n    for (int i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n\n    // Return true if the vector is palindromic and the sum is less than or equal to w\n    return is_palindromic && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Returns the minimum number of elements that need to be changed to make the vector palindromic.\n *\n * @param arr The input vector of integers.\n * @return The minimum number of changes required.\n */\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end of the vector, moving towards the center.\n    for (int i = 0; i < n / 2; i++) {\n        // If the elements at the current positions are different, increment the changes counter.\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint totalChars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\n// Function to compare two vectors of strings based on total number of characters\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = totalChars(lst1);\n    int total2 = totalChars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if a number is the product of 3 prime numbers\nbool is_multiply_prime(int a) {\n    // Iterate over all possible combinations of 3 prime numbers less than 100\n    for (int p1 = 2; p1 < 100; p1++) {\n        if (!is_prime(p1)) continue;\n        for (int p2 = p1; p2 < 100; p2++) {\n            if (!is_prime(p2)) continue;\n            for (int p3 = p2; p3 < 100; p3++) {\n                if (!is_prime(p3)) continue;\n                if (p1 * p2 * p3 == a) return true;\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (x <= 0 || n <= 0) {\n        return false;\n    }\n\n    // Calculate the logarithm of x with base n\n    double log_result = log(x) / log(n);\n\n    // Check if the logarithm is an integer\n    return log_result == (int)log_result;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Checks if an integer is a cube of some integer number.\n *\n * @param a The input integer to check.\n * @return True if the integer is a cube, false otherwise.\n */\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    double cubeRoot = pow(abs(a), 1.0 / 3.0);\n    \n    // Check if the cube root is an integer\n    return cubeRoot == (int)cubeRoot;\n}\n\n"}
{"task_id": "CPP/78", "generation": "int hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        switch (c) {\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Converts a decimal number to binary format as a string.\n * The string is prefixed and suffixed with \"db\" for formatting.\n *\n * @param decimal The decimal number to convert.\n * @return A string representing the binary number.\n */\nstring decimal_to_binary(int decimal) {\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = (decimal % 2 == 0 ? \"0\" : \"1\") + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a string is happy.\n * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n *\n * @param s The input string.\n * @return True if the string is happy, false otherwise.\n */\nbool is_happy(string s) {\n    // Check if the string length is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate over the string with a sliding window of size 3\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the current 3 consecutive letters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no consecutive duplicates are found, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float grade : grades) {\n        if (grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if the length of a given string is a prime number.\n *\n * @param str The input string.\n * @return True if the string length is a prime number, false otherwise.\n */\nbool prime_length(string str) {\n    int length = str.length();\n    if (length <= 1) return false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) return false; // if length is divisible by any number, it's not prime\n    }\n\n    return true; // if no divisors found, length is prime\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n\n/**\n * Returns the count of n-digit positive integers that start or end with 1.\n *\n * @param n The number of digits in the integers.\n * @return The count of n-digit positive integers that start or end with 1.\n */\nint starts_one_ends(int n) {\n    // Calculate the total number of n-digit positive integers\n    int total = 9 * (int)pow(10, n - 1);\n\n    // Calculate the number of n-digit positive integers that start with 1\n    int starts_with_one = (int)pow(10, n - 1);\n\n    // Calculate the number of n-digit positive integers that end with 1\n    int ends_with_one = 9 * (int)pow(10, n - 2);\n\n    // Subtract the overlap (numbers that start and end with 1)\n    int overlap = (int)pow(10, n - 2);\n\n    // Return the total count\n    return starts_with_one + ends_with_one - overlap;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the binary representation of the sum of digits of a given positive integer N.\n *\n * @param N a positive integer\n * @return a string of binary number\n */\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return bitset<32>(sum).to_string();\n}\n"}
{"task_id": "CPP/85", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Adds the even elements at odd indices in the given vector.\n *\n * @param lst A non-empty vector of integers.\n * @return The sum of even elements at odd indices.\n */\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n\n    // Iterate through each character in the input string\n    for (char c : s) {\n        // If the character is a space, add the sorted word to the result and reset the word\n        if (c == ' ') {\n            sort(word.begin(), word.end());\n            result += word + \" \";\n            word = \"\";\n        } else {\n            // Add the character to the current word\n            word += c;\n        }\n    }\n\n    // Sort the last word and add it to the result\n    sort(word.begin(), word.end());\n    result += word;\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate over each row in the list\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate over each element in the row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the element is equal to x\n            if (lst[i][j] == x) {\n                // Add the coordinates to the result vector\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the coordinates by row in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // Sort the coordinates of each row by column in descending order\n    for (int i = 0; i < coordinates.size(); i++) {\n        int row = coordinates[i][0];\n        int start = i;\n        while (i < coordinates.size() && coordinates[i][0] == row) {\n            i++;\n        }\n        sort(coordinates.begin() + start, coordinates.begin() + i, [](const vector<int>& a, const vector<int>& b) {\n            return a[1] > b[1];\n        });\n        i--;\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a copy of the given vector after sorting.\n * The sorting order is determined by the sum of the first and last index values.\n * If the sum is odd, the vector is sorted in ascending order.\n * If the sum is even, the vector is sorted in descending order.\n *\n * @param array The input vector to be sorted.\n * @return A copy of the sorted vector.\n */\nvector<int> sort_array(vector<int> array) {\n    // Calculate the sum of the first and last index values\n    int sum = array.empty() ? 0 : array[0] + array.back();\n\n    // Sort the vector in ascending or descending order based on the sum\n    if (sum % 2 == 0) {\n        // Sort in descending order if the sum is even\n        sort(array.rbegin(), array.rend());\n    } else {\n        // Sort in ascending order if the sum is odd\n        sort(array.begin(), array.end());\n    }\n\n    return array;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encrypts a string by rotating the alphabet down by 2 * 2 places.\n *\n * @param s The input string to be encrypted.\n * @return The encrypted string.\n */\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Rotate lowercase letters\n            result += 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            // Rotate uppercase letters\n            result += 'A' + (c - 'A' + 4) % 26;\n        } else {\n            // Non-alphabet characters remain unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "int next_smallest(vector<int> lst) {\n    if (lst.empty() || lst.size() < 2) {\n        return -1; // equivalent to None in Python\n    }\n\n    sort(lst.begin(), lst.end());\n    if (lst[0] == lst[1]) {\n        return -1; // no second smallest element if first two elements are equal\n    }\n\n    return lst[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Counts the number of boredoms in a given string of words.\n * A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n *\n * @param S The input string of words.\n * @return The number of boredoms in the input string.\n */\nint is_bored(string S) {\n    int boredom_count = 0;\n    bool in_sentence = false;\n    bool is_I = false;\n\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            in_sentence = false;\n            is_I = false;\n        } else if (!in_sentence) {\n            in_sentence = true;\n            if (c == 'I' || c == 'i') {\n                is_I = true;\n            }\n        } else if (is_I && (c == ' ' || c == '.' || c == '?' || c == '!')) {\n            boredom_count++;\n            is_I = false;\n        }\n    }\n\n    return boredom_count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != (int)a || b != (int)b || c != (int)c) {\n        return false;\n    }\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/93", "generation": "string encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\n    for (char c : message) {\n        // Swap case of all letters\n        if (isalpha(c)) {\n            c = isupper(c) ? tolower(c) : toupper(c);\n        }\n\n        // Replace vowels with the letter 2 places ahead\n        size_t pos = vowels.find(c);\n        if (pos != string::npos) {\n            char newChar = 'a' + (pos % 5 + 2) % 5;\n            if (isupper(c)) {\n                newChar = toupper(newChar);\n            }\n            result += newChar;\n        } else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = 0;\n    for (int num : lst) {\n        if (isPrime(num) && num > maxPrime) {\n            maxPrime = num;\n        }\n    }\n    return sumOfDigits(maxPrime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\n/**\n * Checks if all keys in a map are strings and are either all in lower case or all in upper case.\n * Returns false if the map is empty.\n *\n * @param dict The input map to check.\n * @return True if all keys are strings and are either all in lower case or all in upper case, false otherwise.\n */\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Initialize a flag to track if all keys are in lower case or upper case\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Iterate over the map\n    for (const auto& pair : dict) {\n        // Check if the key is not a string (should not happen, but just in case)\n        if (!pair.first.empty()) {\n            // Check if the key is not in lower case\n            if (!islower(pair.first[0])) {\n                allLower = false;\n            }\n            // Check if the key is not in upper case\n            if (!isupper(pair.first[0])) {\n                allUpper = false;\n            }\n        }\n    }\n\n    // Return true if all keys are in lower case or all keys are in upper case\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n/**\n * Returns a vector of the first n prime numbers less than n.\n *\n * @param n The upper bound for the prime numbers.\n * @return A vector of prime numbers less than n.\n */\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n\n/**\n * Returns the product of the unit digits of two integers.\n *\n * @param a The first integer.\n * @param b The second integer.\n * @return The product of the unit digits of a and b.\n */\nint multiply(int a, int b) {\n    // Get the unit digits of a and b using the modulus operator\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Counts the number of uppercase vowels in even indices of a given string.\n *\n * @param s The input string.\n * @return The number of uppercase vowels in even indices.\n */\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "int closest_integer(string value) {\n    double num = stod(value); // convert string to double\n    double decimal_part = num - floor(num); // get decimal part\n\n    if (decimal_part < 0.5) {\n        return floor(num); // round down\n    } else if (decimal_part > 0.5) {\n        return ceil(num); // round up\n    } else {\n        // equidistant from two integers, round away from zero\n        if (num > 0) {\n            return ceil(num);\n        } else {\n            return floor(num);\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a vector representing the number of stones in each level of a pile.\n * The first level has n stones. The number of stones in the next level is:\n *   - the next odd number if n is odd.\n *   - the next even number if n is even.\n *\n * @param n The number of levels in the pile.\n * @return A vector where element at index i represents the number of stones in level (i+1).\n */\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i);\n    }\n    return stones;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Splits a string of words separated by commas or spaces into a vector of words.\n *\n * @param s The input string of words.\n * @return A vector of words.\n */\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    // Check if x is greater than y, if so, return -1\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from y and decrement by 1 until we find an even number\n    for (int i = y; i >= x; i--) {\n        // Check if the current number is even\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m, return \"-1\" if true\n    if (n > m) return \"-1\";\n\n    // Calculate the average of the integers from n through m\n    double avg = (n + m) / 2.0;\n\n    // Round the average to the nearest integer (smaller one)\n    int rounded_avg = floor(avg);\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    while (rounded_avg > 0) {\n        binary = (rounded_avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a sorted vector of all elements that haven't any even digit.\n *\n * @param x A vector of positive integers.\n * @return A sorted vector of integers without even digits.\n */\nvector<int> unique_digits(vector<int> x) {\n    // Filter out numbers with even digits\n    vector<int> result;\n    for (int num : x) {\n        bool hasEvenDigit = false;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                hasEvenDigit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort and reverse the vector, then replace digits with their corresponding names\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9 inclusive\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted vector\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map of digit to its corresponding name\n    map<int, string> digit_to_name = {\n        {1, \"One\"},\n        {2, \"Two\"},\n        {3, \"Three\"},\n        {4, \"Four\"},\n        {5, \"Five\"},\n        {6, \"Six\"},\n        {7, \"Seven\"},\n        {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n\n    // Replace digits with their corresponding names\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n#include <numeric>\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // calculate factorial\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // calculate sum of numbers from 1 to i\n            result[i - 1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a vector containing the number of even and odd integer palindromes\n * within the range (1, n), inclusive.\n *\n * @param n A positive integer.\n * @return A vector of two integers, where the first element is the number of even\n *         palindromes and the second element is the number of odd palindromes.\n */\nvector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; i++) {\n        string str = to_string(i);\n        string rev = str;\n        reverse(rev.begin(), rev.end());\n        if (str == rev) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n\n"}
{"task_id": "CPP/108", "generation": "int count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int sign = (num < 0) ? -1 : 1;\n        num = abs(num);\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum * sign > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Checks if it's possible to get a sorted vector by performing right shift operations.\n *\n * @param arr The input vector of unique integers.\n * @return True if it's possible to get a sorted vector, false otherwise.\n */\nbool canSortByRightShift(vector<int> arr) {\n    // If the vector is empty, it's already sorted\n    if (arr.empty()) {\n        return true;\n    }\n\n    // Find the minimum element in the vector\n    int min_val = *min_element(arr.begin(), arr.end());\n\n    // Find the index of the minimum element\n    int min_index = distance(arr.begin(), find(arr.begin(), arr.end(), min_val));\n\n    // Check if the vector is sorted starting from the minimum element\n    for (int i = min_index; i < arr.size() - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n\n    // If the vector is not sorted, check if it's sorted starting from the last element\n    for (int i = arr.size() - 1; i > min_index; i--) {\n        if (arr[i] < arr[i - 1]) { // Changed from '>' to '<'\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks if it's possible to get a sorted vector by performing right shift operations.\n *\n * @param arr The input vector of unique integers.\n * @return True if it's possible to get a sorted vector, false otherwise.\n */\nbool move_one_ball(vector<int> arr) {\n    return canSortByRightShift(arr);\n}\n\n"}
{"task_id": "CPP/110", "generation": "string exchange(vector<int> lst1, vector<int> lst2) {\n    int evenCountInLst2 = 0;\n    int oddCountInLst1 = 0;\n\n    // Count the number of even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Count the number of odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountInLst1++;\n        }\n    }\n\n    // If the number of even numbers in lst2 is greater than or equal to\n    // the number of odd numbers in lst1, we can exchange elements to make\n    // all elements in lst1 even\n    if (evenCountInLst2 >= oddCountInLst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to calculate the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Initialize an empty map to store the frequency of each character\n    map<char, int> frequencyMap;\n\n    // Iterate over each character in the string\n    for (char c : test) {\n        // If the character is not a space (assuming spaces are ignored)\n        if (c != ' ') {\n            // If the character is already in the map, increment its count\n            if (frequencyMap.find(c) != frequencyMap.end()) {\n                frequencyMap[c]++;\n            } \n            // If the character is not in the map, add it with a count of 1\n            else {\n                frequencyMap[c] = 1;\n            }\n        }\n    }\n\n    // Find the maximum frequency\n    int maxFrequency = 0;\n    for (auto& pair : frequencyMap) {\n        if (pair.second > maxFrequency) {\n            maxFrequency = pair.second;\n        }\n    }\n\n    // Create a new map to store the characters with the maximum frequency\n    map<char, int> result;\n    for (auto& pair : frequencyMap) {\n        if (pair.second == maxFrequency) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are equal to any character in c\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversed = result;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = result == reversed;\n\n    // Return the result string and the palindrome check as a vector\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    return output;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\n/**\n * Returns a vector of strings, where each string is a modified version of the input string.\n * Each element i of the output string contains the number of odd digits in the i'th string of the input.\n *\n * @param lst A vector of strings, where each string consists of only digits.\n * @return A vector of strings, where each string is a modified version of the input string.\n */\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(odd_count) + \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) + \" of the \" + to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Finds the minimum sum of any non-empty sub-vector of nums.\n *\n * @param nums A vector of integers.\n * @return The minimum sum of any non-empty sub-vector of nums.\n */\nlong long minSubArraySum(vector<long long> nums) {\n    // Initialize the minimum sum to the first element of the vector\n    long long min_sum = nums[0];\n\n    // Initialize the current sum to the first element of the vector\n    long long current_sum = nums[0];\n\n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < nums.size(); i++) {\n        // Update the current sum by adding the current element\n        current_sum = min(nums[i], current_sum + nums[i]);\n\n        // Update the minimum sum if the current sum is smaller\n        min_sum = min(min_sum, current_sum);\n    }\n\n    // Return the minimum sum\n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Calculate the number of times the buckets need to be lowered to empty the wells.\n *\n * @param grid A 2D vector representing the wells, where 1 indicates a unit of water.\n * @param capacity The capacity of each bucket.\n * @return The number of times the buckets need to be lowered.\n */\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_water = 0;\n    for (const auto& well : grid) {\n        for (int water : well) {\n            total_water += water;\n        }\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n\n"}
{"task_id": "CPP/116", "generation": "vector<int> sort_array(vector<int> arr) {\n    // Use a lambda function as the comparison function for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Count the number of ones in the binary representation of a and b\n        int ones_a = __builtin_popcount(abs(a));\n        int ones_b = __builtin_popcount(abs(b));\n\n        // If the number of ones is the same, sort based on decimal value\n        if (ones_a == ones_b) {\n            return a < b;\n        }\n\n        // Otherwise, sort based on the number of ones\n        return ones_a < ones_b;\n    });\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "vector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                int consonants = 0;\n                for (char w : word) {\n                    w = tolower(w);\n                    if (w != 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u') {\n                        consonants++;\n                    }\n                }\n                if (consonants == n) {\n                    result.push_back(word);\n                }\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    // Handle the last word\n    if (!word.empty()) {\n        int consonants = 0;\n        for (char w : word) {\n            w = tolower(w);\n            if (w != 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "string get_closest_vowel(string word) {\n    // Define vowels\n    string vowels = \"AEIOUaeiou\";\n\n    // Iterate from the right side of the word\n    for (int i = word.size() - 1; i > 0; --i) {\n        // Check if current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if previous character is a consonant\n            if (vowels.find(word[i - 1]) == string::npos) {\n                // Check if next character is a consonant\n                if (i + 1 < word.size() && vowels.find(word[i + 1]) == string::npos) {\n                    // Return the vowel\n                    return string(1, word[i]);\n                }\n            }\n        }\n    }\n\n    // If no vowel is found, return empty string\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n/**\n * Checks if it's possible to concatenate two strings of parentheses\n * in some order to form a balanced string.\n *\n * @param lst A vector of two strings, each consisting of '(' or ')'\n * @return \"Yes\" if a balanced string can be formed, \"No\" otherwise\n */\nstring match_parens(vector<string> lst) {\n  int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n  // Count the number of open and close parentheses in each string\n  for (char c : lst[0]) {\n    if (c == '(') open1++;\n    else close1++;\n  }\n  for (char c : lst[1]) {\n    if (c == '(') open2++;\n    else close2++;\n  }\n\n  // Check if the total number of open and close parentheses is balanced\n  if (open1 + open2 == close1 + close2) {\n    // If the total is balanced, check if each string can be concatenated\n    // in some order to form a balanced string\n    if (open1 <= close2 || open2 <= close1) {\n      return \"Yes\";\n    }\n  }\n  return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a sorted vector of length k with the maximum k numbers in arr, in ascending order.\n *\n * @param arr  The input vector of integers.\n * @param k    The number of maximum elements to return.\n * @return     A sorted vector of length k with the maximum k numbers in arr.\n */\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the vector in descending order to get the maximum elements first\n    sort(arr.rbegin(), arr.rend());\n    \n    // Return a new vector with the first k elements of the sorted vector\n    return vector<int>(arr.begin(), arr.begin() + k);\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <stdio.h>\n#include <vector>\n\nint solution(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the sum of elements with at most two digits from the first k elements of arr.\n *\n * @param arr A non-empty vector of integers.\n * @param k An integer representing the number of elements to consider.\n * @return The sum of elements with at most two digits.\n */\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "vector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_numbers.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    odd_numbers.push_back(1); // add 1 to the end of the sequence\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <stdexcept>\n\nbool valid_date(const std::string& date) {\n  // Check if date string is not empty\n  if (date.empty()) {\n    return false;\n  }\n\n  // Check if date is in the correct format (mm-dd-yyyy)\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n\n  int month, day, year;\n  try {\n    // Extract month, day, and year from date string\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    // If any of the extractions fail, return false\n    return false;\n  }\n\n  // Check if month is valid (1-12)\n  if (month < 1 || month > 12) {\n    return false;\n  }\n\n  // Check if day is valid based on month\n  if (month == 2) {\n    // February has 29 days\n    if (day < 1 || day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    // April, June, September, and November have 30 days\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  } else {\n    // All other months have 31 days\n    if (day < 1 || day > 31) {\n      return false;\n    }\n  }\n\n  // If all checks pass, return true\n  return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "vector<string> split_words(string txt) {\n  // Check if the string contains whitespace\n  if (txt.find(' ') != string::npos) {\n    // Split on whitespace\n    vector<string> words;\n    size_t pos = 0;\n    while ((pos = txt.find(' ')) != string::npos) {\n      words.push_back(txt.substr(0, pos));\n      txt.erase(0, pos + 1);\n    }\n    words.push_back(txt);\n    return words;\n  } else if (txt.find(',') != string::npos) {\n    // Split on commas\n    vector<string> words;\n    size_t pos = 0;\n    while ((pos = txt.find(',')) != string::npos) {\n      words.push_back(txt.substr(0, pos));\n      txt.erase(0, pos + 1);\n    }\n    words.push_back(txt);\n    return words;\n  } else {\n    // Count lower-case letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n      if (c >= 'a' && c <= 'z' && (c - 'a') % 2 != 0) {\n        count++;\n      }\n    }\n    return {to_string(count)};\n  }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if any number appears more than twice\n    for (int num : lst) {\n        int count = 0;\n        for (int other_num : lst) {\n            if (num == other_num) count++;\n        }\n        if (count > 2) return false;\n    }\n\n    // Check if the list is sorted in ascending order\n    for (int i = 0; i < lst.size() - 1; i++) {\n        if (lst[i] > lst[i + 1]) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the intersection of the two intervals\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if the intervals intersect\n    if (start > end) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length)) return \"YES\";\n    else return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "int prod_signs(vector<int> arr) {\n    if (arr.empty()) return -32768; // return -32768 for empty arr\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (int num : arr) {\n        sum_of_magnitudes += abs(num); // sum of magnitudes\n        product_of_signs *= (num >= 0) ? 1 : -1; // product of signs\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Define the directions for moving in the grid\nconst int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    vector<int> res;\n    queue<pair<int, vector<int>>> q;\n\n    // Find the minimum value in the grid and start BFS from it\n    int minVal = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < minVal) {\n                minVal = grid[i][j];\n                q.push({i * n + j, {minVal}});\n            }\n        }\n    }\n\n    while (!q.empty()) {\n        auto front = q.front();\n        q.pop();\n\n        int pos = front.first;\n        vector<int> path = front.second;\n\n        // If the path length is equal to k, update the result if necessary\n        if (path.size() == k) {\n            if (res.empty() || path < res) {\n                res = path;\n            }\n            continue;\n        }\n\n        // Explore the neighbors of the current cell\n        int x = pos / n, y = pos % n;\n        for (auto& dir : directions) {\n            int nx = x + dir[0], ny = y + dir[1];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                q.push({nx * n + ny, path});\n                q.back().second.push_back(grid[nx][ny]);\n            }\n        }\n    }\n\n    return res;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the first n+1 numbers of the Tribonacci sequence.\n *\n * @param n A non-negative integer.\n * @return A vector of integers representing the Tribonacci sequence.\n */\nvector<int> tri(int n) {\n    vector<int> sequence(n + 1);\n    sequence[0] = 1;\n    sequence[1] = 3;\n\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            sequence[i] = 1 + i / 2;\n        } else {\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1];\n        }\n    }\n\n    // Handle the case where n is 0 or 1\n    if (n == 0) {\n        sequence.resize(1);\n    } else if (n == 1) {\n        sequence.resize(2);\n    }\n\n    return sequence;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\n/**\n * Returns the product of the odd digits of a given positive integer.\n * Returns 0 if all digits are even.\n *\n * @param n A positive integer.\n * @return The product of the odd digits, or 0 if all digits are even.\n */\nint digits(int n) {\n    int product = 1;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product == 1 ? 0 : product;\n}\n"}
{"task_id": "CPP/132", "generation": "bool is_nested(string str) {\n    int stack = 0;\n    for (char c : str) {\n        if (c == '[') {\n            stack++;\n        } else if (c == ']') {\n            if (stack > 1) {\n                return true; // found a nested bracket\n            }\n            stack--;\n        }\n    }\n    return false; // no nested brackets found\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the sum of squared numbers in the given vector.\n * Each element in the vector is rounded to the upper int (Ceiling) first.\n *\n * @param lst A vector of numbers.\n * @return The sum of squared numbers.\n */\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        // Round each element to the upper int (Ceiling)\n        int rounded_num = ceil(num);\n        // Square the rounded number and add to the sum\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "bool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Remove trailing whitespace\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the last character is alphabetical\n    if (!isalpha(txt.back())) {\n        return false;\n    }\n\n    // Split the string into words\n    size_t pos = txt.find_last_of(' ');\n    if (pos == string::npos) {\n        return false; // No spaces found, last character is part of a word\n    }\n\n    // Check if the last character is not part of a word\n    return txt.size() - pos == 1;\n}\n"}
{"task_id": "CPP/135", "generation": "int can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int max_index = -1;\n    \n    // Iterate through the array from the second element to the last element\n    for (int i = 1; i < n; i++) {\n        // If the current element is not greater than or equal to the previous element\n        if (arr[i] < arr[i-1]) {\n            // Update the max_index\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector (a, b) where \"a\" is the largest of negative integers,\n * and \"b\" is the smallest of positive integers in the input vector.\n * If there is no negative or positive integers, return them as 0.\n */\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    // Find the largest negative integer\n    for (int num : lst) {\n        if (num < 0 && (largest_negative == 0 || num > largest_negative)) {\n            largest_negative = num;\n        }\n    }\n\n    // Find the smallest positive integer\n    for (int num : lst) {\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert string inputs to float\n    if (a.type() == typeid(string)) {\n        string strA = boost::any_cast<string>(a);\n        replace(strA.begin(), strA.end(), ',', '.');\n        a = stof(strA);\n    }\n    if (b.type() == typeid(string)) {\n        string strB = boost::any_cast<string>(b);\n        replace(strB.begin(), strB.end(), ',', '.');\n        b = stof(strB);\n    }\n\n    // Compare values\n    if (a.type() == typeid(float) || a.type() == typeid(int)) {\n        float fA = boost::any_cast<float>(a);\n        float fB = boost::any_cast<float>(b);\n        if (fA > fB) return a;\n        else if (fA < fB) return b;\n        else return \"None\";\n    } else {\n        // If inputs are not numbers, return \"None\"\n        return \"None\";\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "bool is_equal_to_sum_even(int n) {\n    // Check if n is even\n    if (n % 2 != 0) {\n        return false;\n    }\n\n    // Try to find 4 even numbers that sum up to n\n    for (int a = 2; a <= n / 4; a += 2) {\n        for (int b = a; b <= (n - a) / 3; b += 2) {\n            for (int c = b; c <= (n - a - b) / 2; c += 2) {\n                int d = n - a - b - c;\n                if (d >= c && d % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\n\n/**\n * Calculates the Brazilian factorial of a given integer n.\n *\n * The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *\n * @param n The input integer (n > 0)\n * @return The Brazilian factorial of n\n */\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "string fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces > 2) {\n                result += '-';\n            } else if (consecutive_spaces == 1) {\n                result += '_';\n            }\n        } else {\n            consecutive_spaces = 0;\n            result += c;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <algorithm>\n\nstring file_name_check(string file_name) {\n    // Check if the file name contains exactly one dot\n    if (count(file_name.begin(), file_name.end(), '.') != 1) {\n        return \"No\";\n    }\n\n    // Split the file name into two parts: before and after the dot\n    size_t dot_pos = file_name.find('.');\n    string before_dot = file_name.substr(0, dot_pos);\n    string after_dot = file_name.substr(dot_pos + 1);\n\n    // Check if the substring before the dot is not empty and starts with a latin alphabet letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of the allowed extensions\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there are more than three digits in the file name\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all checks pass, return \"Yes\"\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * This function takes a vector of integers, squares the entries at indices that are multiples of 3,\n * cubes the entries at indices that are multiples of 4 but not 3, and returns the sum of all entries.\n *\n * @param lst A vector of integers.\n * @return The sum of all entries in the vector after applying the transformation.\n */\nint sum_squares(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Iterate over the vector\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the entry and add to sum\n        } else if (i % 4 == 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the entry and add to sum\n        } else { // If index is not a multiple of 3 or 4\n            sum += lst[i]; // Add the entry to sum as is\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to get words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            result += word + \" \";\n        }\n    }\n    // Remove trailing space\n    if (!result.empty()) result.pop_back();\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nbool simplify(string x, string n) {\n    // Split the input strings into numerator and denominator\n    int x_num, x_den, n_num, n_den;\n    char slash;\n    stringstream(x) >> x_num >> slash >> x_den;\n    stringstream(n) >> n_num >> slash >> n_den;\n\n    // Calculate the product of the numerators and denominators\n    long long product_num = (long long)x_num * n_num;\n    long long product_den = (long long)x_den * n_den;\n\n    // Check if the product is a whole number\n    return product_num % product_den == 0;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum += abs(n % 10);\n        n /= 10;\n    }\n    return sum;\n}\n\n// Custom comparator function for sorting\nbool compare(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (sumOfDigits(a.first) == sumOfDigits(b.first)) {\n        return a.second < b.second;\n    }\n    return sumOfDigits(a.first) < sumOfDigits(b.first);\n}\n\n// Function to sort the vector based on the sum of digits\nstd::vector<int> orderByPoints(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexedNums;\n    for (int i = 0; i < nums.size(); i++) {\n        indexedNums.push_back(std::make_pair(nums[i], i));\n    }\n\n    std::sort(indexedNums.begin(), indexedNums.end(), compare);\n\n    std::vector<int> sortedNums;\n    for (const auto& pair : indexedNums) {\n        sortedNums.push_back(pair.first);\n    }\n\n    return sortedNums;\n}\n\n"}
{"task_id": "CPP/146", "generation": "int specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (abs(num) > 10) {\n            // Convert the number to a string to easily access the first and last digits\n            string strNum = to_string(abs(num));\n            // Check if the first and last digits are odd\n            if ((strNum[0] - '0') % 2 != 0 && (strNum[strNum.size() - 1] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n *\n * @param n The length of the vector a.\n * @return The number of valid triples.\n */\nint get_max_triples(int n) {\n    // Create a vector to store the values of a{i}\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Initialize a counter for the number of valid triples\n    int count = 0;\n\n    // Iterate over all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                // Check if the sum of a{i}, a{j}, and a{k} is a multiple of 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Define the order of planets in our solar system\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nvector<string> bf(string planet1, string planet2) {\n    // Check if both planet names are valid\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() ||\n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n\n    // Find the indices of planet1 and planet2 in the planets vector\n    int idx1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int idx2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n    // Swap indices if planet1 is farther from the Sun than planet2\n    if (idx1 > idx2) {\n        swap(idx1, idx2);\n    }\n\n    // Return the planets between planet1 and planet2, excluding planet1 and planet2\n    return vector<string>(planets.begin() + idx1 + 1, planets.begin() + idx2);\n}\n\n"}
{"task_id": "CPP/149", "generation": "vector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    lst.erase(std::remove_if(lst.begin(), lst.end(),\n        [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    std::sort(lst.begin(), lst.end(),\n        [](const string& a, const string& b) {\n            if (a.length() == b.length()) {\n                return a < b;\n            }\n            return a.length() < b.length();\n        });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\n// Function to check if a number is prime\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Function to return x if n is prime, y otherwise\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Returns the sum of squares of the odd numbers in the input vector.\n * Ignores negative numbers and non-integers.\n *\n * @param lst Input vector of numbers\n * @return Sum of squares of odd numbers\n */\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && fmod(num, 1) == 0 && fmod(num, 2) != 0) {\n            sum += (long long)pow(num, 2);\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Compare the guessed scores with the actual scores and return a vector of differences.\n *\n * @param game  A vector of actual scores.\n * @param guess A vector of guessed scores.\n * @return A vector of differences between the guessed and actual scores.\n */\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Initialize an empty vector to store the differences.\n    vector<int> differences;\n\n    // Iterate over the game and guess vectors simultaneously.\n    for (int i = 0; i < game.size(); i++) {\n        // Calculate the absolute difference between the guessed and actual scores.\n        int difference = abs(game[i] - guess[i]);\n\n        // Append the difference to the differences vector.\n        differences.push_back(difference);\n    }\n\n    // Return the vector of differences.\n    return differences;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    // Initialize the strongest extension and its strength\n    string strongest_extension = extensions[0];\n    double strongest_strength = 0.0;\n\n    // Iterate through each extension\n    for (const auto& extension : extensions) {\n        // Calculate the strength of the current extension\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) cap++;\n            if (islower(c)) sm++;\n        }\n        double strength = (double)cap - sm;\n\n        // Update the strongest extension if the current one is stronger\n        if (strength > strongest_strength) {\n            strongest_extension = extension;\n            strongest_strength = strength;\n        }\n    }\n\n    // Return the class name with the strongest extension\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if the second word or any of its rotations is a substring in the first word.\n *\n * @param a The first word.\n * @param b The second word.\n * @return True if the second word or any of its rotations is a substring in the first word, false otherwise.\n */\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself to handle rotations\n    string double_a = a + a;\n\n    // Check if the second word or any of its rotations is a substring in the concatenated string\n    for (int i = 0; i < b.length(); i++) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (double_a.find(rotated_b) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a vector containing the count of even and odd digits in the given integer.\n *\n * @param num The input integer.\n * @return A vector of size 2, where the first element is the count of even digits and the second element is the count of odd digits.\n */\nvector<int> even_odd_count(int num) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Convert the integer to its absolute value to handle negative numbers\n    num = abs(num);\n\n    // Iterate through each digit of the number\n    while (num > 0) {\n        int digit = num % 10;\n\n        // Check if the digit is even or odd\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n\n        // Move to the next digit\n        num /= 10;\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/156", "generation": "string int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result;\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns true if the three sides form a right-angled triangle, false otherwise.\n *\n * A right-angled triangle is a triangle in which one angle is a right angle (90 degrees).\n *\n * @param a The length of the first side.\n * @param b The length of the second side.\n * @param c The length of the third side.\n * @return True if the three sides form a right-angled triangle, false otherwise.\n */\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides in ascending order\n    if (a > b) {\n        float temp = a;\n        a = b;\n        b = temp;\n    }\n    if (b > c) {\n        float temp = b;\n        b = c;\n        c = temp;\n    }\n\n    // Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return (a * a + b * b == c * c);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <algorithm>\n#include <string>\n#include <vector>\n\nstring find_max(vector<string> words) {\n    // Use std::max_element with a custom comparator\n    return *max_element(words.begin(), words.end(),\n        [](string a, string b) {  // Take strings by value instead of const reference\n            // Count unique characters in each string\n            int unique_a = unique(a.begin(), a.end()) - a.begin();\n            int unique_b = unique(b.begin(), b.end()) - b.begin();\n\n            // If unique counts are equal, compare lexicographically\n            if (unique_a == unique_b) {\n                return a > b;\n            }\n            return unique_a < unique_b;\n        });\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Calculate the total number of eaten carrots and the number of carrots left after meals.\n *\n * @param number The number of carrots already eaten.\n * @param need The number of carrots needed to eat.\n * @param remaining The number of remaining carrots in stock.\n * @return A vector containing the total number of eaten carrots and the number of carrots left.\n */\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots needed to eat\n    int total_needed = number + need;\n    \n    // Calculate the total number of carrots eaten\n    int total_eaten = min(total_needed, number + remaining);\n    \n    // Calculate the number of carrots left\n    int carrots_left = remaining - (total_eaten - number);\n    \n    // Return the result as a vector\n    return {total_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n/**\n * Evaluates an algebraic expression built from two vectors: operator and operand.\n * \n * @param operato Vector of basic algebra operations (+, -, *, //, **)\n * @param operand Vector of non-negative integers\n * @return The result of the evaluated expression\n */\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize the result with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands\n    for (int i = 0; i < operato.size(); i++) {\n        string op = operato[i];\n        int num = operand[i + 1];\n\n        // Perform the corresponding operation\n        if (op == \"+\") {\n            result += num;\n        } else if (op == \"-\") {\n            result -= num;\n        } else if (op == \"*\") {\n            result *= num;\n        } else if (op == \"//\") {\n            result /= num;\n        } else if (op == \"**\") {\n            result = pow(result, num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "string solve(string s) {\n    // Check if the string contains any letters\n    bool hasLetter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    // If the string contains no letters, reverse the string\n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, reverse the case of each letter\n    for (char& c : s) {\n        if (isalpha(c)) {\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), hash);\n\n    string md5_hash;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        char hex[3];\n        sprintf(hex, \"%02x\", hash[i]);\n        md5_hash += hex;\n    }\n\n    return md5_hash;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector of even digits between a and b (inclusive) in ascending order.\n * \n * @param a The lower bound (inclusive).\n * @param b The upper bound (inclusive).\n * @return A vector of even digits between a and b.\n */\nvector<int> generate_integers(int a, int b) {\n    // Swap a and b if a is greater than b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> result;\n\n    // Iterate from a to b\n    for (int i = a; i <= b; i++) {\n        // Check if the number is even and less than 10\n        if (i % 2 == 0 && i < 10) {\n            result.push_back(i);\n        }\n    }\n\n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
