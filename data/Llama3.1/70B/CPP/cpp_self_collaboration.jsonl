{"task_id": "CPP/0", "generation": "#include <algorithm>\n#include <vector>\n\nbool has_close_elements(const std::vector<float>& numbers, float threshold) {\n    if (numbers.empty() || threshold < 0.0f) {\n        return false;\n    }\n\n    std::vector<float> sortedNumbers = numbers;\n    std::sort(sortedNumbers.begin(), sortedNumbers.end());\n\n    for (size_t i = 1; i < sortedNumbers.size(); ++i) {\n        if (sortedNumbers[i] - sortedNumbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to remove spaces from the input string\nstring remove_spaces(string input_string) {\n    string space_free_string = \"\";\n    for (char c : input_string) {\n        if (c != ' ') {\n            space_free_string += c;\n        }\n    }\n    return space_free_string;\n}\n\n// Function to identify individual parenthesis groups\nvector<string> identify_paren_groups(string space_free_string) {\n    vector<string> paren_groups;\n    string current_group = \"\";\n    int balance = 0;\n    for (char c : space_free_string) {\n        current_group += c;\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance == 0) {\n            paren_groups.push_back(current_group);\n            current_group = \"\";\n        }\n    }\n    return paren_groups;\n}\n\n// Function to extract and separate parenthesis groups\nvector<string> extract_paren_groups(vector<string> paren_groups) {\n    return paren_groups;\n}\n\n// Main function to separate parenthesis groups\nvector<string> separate_paren_groups(string paren_string) {\n    string space_free_string = remove_spaces(paren_string);\n    vector<string> paren_groups = identify_paren_groups(space_free_string);\n    vector<string> extracted_groups = extract_paren_groups(paren_groups);\n    return extracted_groups;\n}\n"}
{"task_id": "CPP/2", "generation": "/*\nGiven a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n    if (number <= 0) {\n        // Handle invalid input (non-positive number)\n        printf(\"Error: Input must be a positive floating-point number.\\n\");\n        return -1.0f; // Return an error value\n    }\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nbool below_zero(const std::vector<int>& operations) {\n    int balance = 0;\n    for (const auto& operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        throw invalid_argument(\"Input vector is empty\");\n    }\n\n    float sum = 0.0f;\n    for (float num : numbers) {\n        sum += num;\n    }\n\n    float mean = sum / numbers.size();\n\n    float sum_abs_diff = 0.0f;\n    for (float num : numbers) {\n        sum_abs_diff += abs(num - mean);\n    }\n\n    float mad = sum_abs_diff / numbers.size();\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    if (numbers.size() == 1) {\n        return numbers;\n    }\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimiter);\n    }\n    result.push_back(numbers.back());\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <stack>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    istringstream iss(paren_string);\n    string group;\n\n    while (iss >> group) {\n        int max_level = 0;\n        int current_level = 0;\n        stack<char> s;\n\n        for (char c : group) {\n            if (c == '(') {\n                s.push(c);\n                current_level++;\n                max_level = max(max_level, current_level);\n            } else if (c == ')') {\n                if (s.empty()) {\n                    // Invalid input: closing parenthesis without matching opening parenthesis\n                    throw invalid_argument(\"Invalid input string\");\n                }\n                s.pop();\n                current_level--;\n            }\n        }\n\n        if (!s.empty()) {\n            // Invalid input: opening parentheses without matching closing parentheses\n            throw invalid_argument(\"Invalid input string\");\n        }\n\n        result.push_back(max_level);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n#include <numeric>\n\nstd::pair<int, int> sum_product(const std::vector<int>& numbers) {\n    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int product = 1;\n    for (const auto& num : numbers) {\n        product *= num;\n    }\n    return std::make_pair(sum, product);\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm>\n\nvector<int> rolling_max(vector<int> numbers) {\n  vector<int> output_vector;\n  int max_so_far = numbers[0];\n  output_vector.push_back(max_so_far);\n  \n  for (int i = 1; i < numbers.size(); i++) {\n    if (numbers[i] > max_so_far) {\n      max_so_far = numbers[i];\n    }\n    output_vector.push_back(max_so_far);\n  }\n  \n  return output_vector;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (is_palindrome(str)) {\n        return str;\n    }\n\n    string longest_palindromic_suffix = \"\";\n    for (int i = str.length() - 1; i >= 0; --i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            longest_palindromic_suffix = suffix;\n            break;\n        }\n    }\n\n    string non_palindromic_prefix = str.substr(0, str.length() - longest_palindromic_suffix.length());\n    string reversed_prefix(non_palindromic_prefix.rbegin(), non_palindromic_prefix.rend());\n\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Input Validation\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Input strings must have the same length.\");\n    }\n\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input strings must consist only of 1s and 0s.\");\n        }\n    }\n\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            throw invalid_argument(\"Input strings must consist only of 1s and 0s.\");\n        }\n    }\n\n    // Binary XOR Operation\n    string result;\n    for (int i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n#include <stdexcept>\n\nstring longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        throw std::invalid_argument(\"Input vector is empty\");\n    }\n\n    size_t max_length = 0;\n    std::string longest_string;\n\n    for (const auto& str : strings) {\n        if (str.size() > max_length) {\n            max_length = str.size();\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "/*\nReturn a greatest common divisor of two integers a and b\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n*/\n#include<iostream>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n  if (a < 0 || b < 0) {\n    throw invalid_argument(\"Input integers must be non-negative.\");\n  }\n\n  while (b != 0) {\n    int temp = b;\n    b = a % b;\n    a = temp;\n  }\n\n  return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\n\nvector<string> all_prefixes(const string& str) {\n    if (str.empty()) {\n        return {};\n    }\n\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <sstream>\n#include <stdexcept>\n#include <string>\n\nstring string_sequence(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str){\n  // Normalize case\n  std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n  // Extract characters and store unique characters\n  std::set<char> unique_chars;\n  for (char c : str) {\n    unique_chars.insert(c);\n  }\n\n  // Count distinct characters\n  return unique_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beat_durations;\n    string note;\n    for (char c : music_string) {\n        if (c == ' ') {\n            if (note == \"o\") beat_durations.push_back(4);\n            else if (note == \"o|\") beat_durations.push_back(2);\n            else if (note == \".|\") beat_durations.push_back(1);\n            note.clear();\n        } else {\n            note += c;\n        }\n    }\n    // Handle the last note\n    if (note == \"o\") beat_durations.push_back(4);\n    else if (note == \"o|\") beat_durations.push_back(2);\n    else if (note == \".|\") beat_durations.push_back(1);\n    return beat_durations;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n\n    int match_count = 0;\n    int window_size = substring.length();\n\n    for (int i = 0; i <= str.length() - window_size; i++) {\n        if (str.substr(i, window_size) == substring) {\n            match_count++;\n        }\n    }\n\n    return match_count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    map<string, int> numeral_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    vector<string> tokenized_numbers;\n    string temp = \"\";\n    for (char c : numbers) {\n        if (c == ' ') {\n            tokenized_numbers.push_back(temp);\n            temp = \"\";\n        } else {\n            temp += c;\n        }\n    }\n    tokenized_numbers.push_back(temp);\n\n    vector<int> numerical_values;\n    for (string numeral : tokenized_numbers) {\n        numerical_values.push_back(numeral_map[numeral]);\n    }\n\n    sort(numerical_values.begin(), numerical_values.end());\n\n    vector<string> sorted_numerals;\n    for (int value : numerical_values) {\n        for (auto& pair : numeral_map) {\n            if (pair.second == value) {\n                sorted_numerals.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    string result = \"\";\n    for (string numeral : sorted_numerals) {\n        result += numeral + \" \";\n    }\n    result.pop_back(); // remove the trailing space\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <algorithm>\n#include <vector>\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the input vector\n    std::sort(numbers.begin(), numbers.end());\n\n    // Initialize minimum difference and closest elements\n    float min_diff = FLT_MAX;\n    float closest_smaller, closest_larger;\n\n    // Iterate through the sorted vector\n    for (int i = 1; i < numbers.size(); i++) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_smaller = numbers[i - 1];\n            closest_larger = numbers[i];\n        }\n    }\n\n    // Return the closest elements\n    return {closest_smaller, closest_larger};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <algorithm>\n#include <vector>\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must have at least two elements\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_value - min_value;\n\n    vector<float> transformed_numbers;\n    for (float num : numbers) {\n        transformed_numbers.push_back((num - min_value) / range);\n    }\n\n    return transformed_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values){\n  vector<int> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(int)) {\n      result.push_back(boost::any_cast<int>(value));\n    }\n  }\n  return result;\n}\n"}
{"task_id": "CPP/23", "generation": "/*\nReturn length of given string\n>>> strlen(\"\")\n0\n>>> strlen(\"abc\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    if (str.empty() || str == \"\") {\n        return 0;\n    }\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n#include <cmath>\n\nint largest_divisor(int n) {\n    if (n <= 0) {\n        std::cerr << \"Error: Input must be a positive integer.\" << std::endl;\n        return -1; // or throw an exception\n    }\n\n    int largest = 1;\n    for (int i = 2; i <= std::sqrt(n); i++) {\n        if (n % i == 0) {\n            largest = (n / i > i) ? n / i : i;\n        }\n    }\n\n    return largest;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    if (n <= 0) {\n        throw invalid_argument(\"Input must be a positive integer.\");\n    }\n\n    vector<int> primeFactors;\n    map<int, int> multiplicity;\n\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            primeFactors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 1) {\n        primeFactors.push_back(n);\n    }\n\n    for (const auto& factor : primeFactors) {\n        ++multiplicity[factor];\n    }\n\n    vector<int> result;\n    for (const auto& pair : multiplicity) {\n        for (int i = 0; i < pair.second; ++i) {\n            result.push_back(pair.first);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    std::unordered_map<int, int> count_map;\n    for (const auto& num : numbers) {\n        ++count_map[num];\n    }\n\n    vector<int> result;\n    for (const auto& num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str){\n  string result = \"\";\n  for (char c : str) {\n    if (isupper(c)) {\n      result += tolower(c);\n    } else {\n      result += toupper(c);\n    }\n  }\n  return result;\n}\n"}
{"task_id": "CPP/28", "generation": "/*\nConcatenate vector of strings into a single string\n>>> concatenate({})\n\"\"\n>>> concatenate({\"a\", \"b\", \"c\"})\n\"abc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  string result = \"\";\n  for (string str : strings) {\n    result += str;\n  }\n  return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(prefix) == 0) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n  vector<float> positive_numbers;\n  for (float num : l) {\n    if (num > 0) {\n      positive_numbers.push_back(num);\n    }\n  }\n  return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_prime(long long n) {\n    // Input Validation\n    if (n <= 0) {\n        return false;\n    }\n\n    // Handle Edge Cases\n    if (n == 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n\n    // Primality Test\n    for (long long i = 2; i <= std::sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    // Return Result\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0.0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    if (xs.size() % 2 != 0) {\n        throw std::invalid_argument(\"Number of coefficients must be even.\");\n    }\n\n    double max_coeff = 0.0;\n    for (double coeff : xs) {\n        if (std::abs(coeff) > std::abs(max_coeff)) {\n            max_coeff = coeff;\n        }\n    }\n\n    if (max_coeff == 0.0) {\n        throw std::invalid_argument(\"Largest coefficient must be non-zero.\");\n    }\n\n    double x = 1.0; // initial guess\n    double tolerance = 1e-6;\n    double max_iterations = 1000;\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double f_x = poly(xs, x);\n        double f_prime_x = 0.0;\n        for (size_t j = 1; j < xs.size(); ++j) {\n            f_prime_x += j * xs[j] * pow(x, j - 1);\n        }\n\n        if (std::abs(f_prime_x) < tolerance) {\n            throw std::runtime_error(\"Derivative is zero.\");\n        }\n\n        double x_new = x - f_x / f_prime_x;\n        if (std::abs(x_new - x) < tolerance) {\n            return x_new;\n        }\n\n        x = x_new;\n    }\n\n    throw std::runtime_error(\"Failed to converge.\");\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_values;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_values.push_back(l[i]);\n        }\n    }\n    sort(sorted_values.begin(), sorted_values.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted_values[j++];\n        }\n    }\n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    vector<int> unique_elements;\n    for (int element : l) {\n        if (find(unique_elements.begin(), unique_elements.end(), element) == unique_elements.end()) {\n            unique_elements.push_back(element);\n        }\n    }\n    sort(unique_elements.begin(), unique_elements.end());\n    return unique_elements;\n}\n"}
{"task_id": "CPP/35", "generation": "/*\nReturn maximum element in the vector.\n>>> max_element({1, 2, 3})\n3\n>>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n    if(l.empty()) {\n        // Return NaN (Not a Number) for empty vector\n        return NAN;\n    }\n\n    float max_val = l[0];\n    for(int i = 1; i < l.size(); i++) {\n        if(l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nint fizz_buzz(int n) {\n    if (n <= 0) {\n        return 0;\n    }\n\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string str = std::to_string(i);\n            for (char c : str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "vector<float> sort_even(vector<float> l){\n    if (l.empty()) {\n        return l;\n    }\n\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    sort(even_elements.begin(), even_elements.end());\n\n    vector<float> result;\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even_elements[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    // takes as input string encoded with encode_cyclic function. Returns decoded string.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //decycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x[1]+x.substr(2)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int count = 0;\n    int a = 0, b = 1;\n    while (true) {\n        int fib = a;\n        a = b;\n        b = fib + b;\n        if (is_prime(fib) && ++count == n) return fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Input Validation\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Sort the Input Vector\n    sort(l.begin(), l.end());\n\n    // Iterate Through the Vector\n    for (int i = 0; i < l.size() - 2; i++) {\n        // Skip duplicates for i\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n\n        int j = i + 1;\n        int k = l.size() - 1;\n\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n\n            if (sum < 0) {\n                j++;\n            } else if (sum > 0) {\n                k--;\n            } else {\n                return true;\n            }\n        }\n    }\n\n    // Return False\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n  // Calculate the number of pairs of cars\n  int num_pairs = n * n;\n  \n  // Since each pair collides exactly once, return the number of pairs\n  return num_pairs;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n\nvector<int> incr_vector(const std::vector<int>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Input vector is empty\");\n    }\n\n    std::vector<int> result;\n    result.reserve(l.size());\n\n    for (const auto& element : l) {\n        result.push_back(element + 1);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Input Validation\n    if (l.size() <= 1) {\n        return false;\n    }\n\n    // Element Pair Generation and Pair Sum Calculation\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n\n    // If no zero sum is found after iterating through all pairs, return false\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x < 0 || base < 2 || base > 9) {\n        throw invalid_argument(\"Invalid input: x must be non-negative and base must be between 2 and 9\");\n    }\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder;\n        result = digit + result;\n        x /= base;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "/*\nGiven length of a side and high return area for a triangle.\n>>> triangle_area(5, 3)\n7.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // Input Validation\n    if (a < 0 || h < 0) {\n        // Handle invalid input (e.g., return an error or throw an exception)\n        // For simplicity, we'll just return -1.0 to indicate an error\n        return -1.0;\n    }\n\n    // Calculate Area\n    float area = 0.5 * a * h;\n\n    // Return Result\n    return area;\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\n\nint fib4(int n) {\n    if (n < 0) {\n        printf(\"Error: n must be a non-negative integer.\\n\");\n        return -1; // Return an error value\n    }\n\n    if (n <= 3) {\n        // Handle base cases\n        if (n == 0 || n == 1 || n == 3) {\n            return 0;\n        } else if (n == 2) {\n            return 2;\n        }\n    }\n\n    int fib4_values[4] = {0, 0, 2, 0}; // Initialize the first four elements\n    int i;\n    for (i = 4; i <= n; i++) {\n        // Calculate the next element as the sum of the previous four elements\n        int next_fib4 = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        // Shift the array to make room for the new element\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = next_fib4;\n    }\n\n    // Return the calculated n-th element\n    return fib4_values[3];\n}\n"}
{"task_id": "CPP/47", "generation": "/*\nReturn median of elements in the vector l.\n>>> median({3, 1, 2, 4, 5})\n3\n>>> median({-10, 4, 6, 1000, 10, 20})\n8.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    if (l.empty()) {\n        // Handle empty input vector\n        return NAN;\n    }\n\n    // Sort the vector in ascending order\n    std::sort(l.begin(), l.end());\n\n    size_t n = l.size();\n    if (n % 2 == 1) {\n        // If the vector has an odd number of elements, return the middle element\n        return l[n / 2];\n    } else {\n        // If the vector has an even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <cctype> // for std::tolower and std::isalnum\n#include <string>\n\nbool is_palindrome(const std::string& text) {\n    if (text.empty()) {\n        return true; // empty string is a palindrome\n    }\n\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (!std::isalnum(text[left])) {\n            left++;\n        } else if (!std::isalnum(text[right])) {\n            right--;\n        } else if (std::tolower(text[left]) != std::tolower(text[right])) {\n            return false; // not a palindrome\n        } else {\n            left++;\n            right--;\n        }\n    }\n\n    return true; // palindrome\n}\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p <= 1) {\n        throw invalid_argument(\"p must be greater than 1\");\n    }\n\n    if (n < 0) {\n        n = n % (p - 1);\n        if (n < 0) {\n            n += p - 1;\n        }\n    }\n\n    unsigned long long result = 1;\n    unsigned long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <limits>\n\nbool below_threshold(const std::vector<int>& l, int t) {\n  if (l.empty()) return true; // input validation\n  if (t != t || t == std::numeric_limits<int>::infinity() || t == -std::numeric_limits<int>::infinity()) {\n    throw std::invalid_argument(\"Threshold is not a valid integer\");\n  }\n  for (const int& x : l) { // vector iteration\n    if (x >= t) { // comparison\n      return false;\n    }\n  }\n  return true;\n}\n"}
{"task_id": "CPP/53", "generation": "/*\nAdd two numbers x and y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include<iostream>\nusing namespace std;\nint add(int x, int y) {\n    // Input validation\n    if (!cin) {\n        cerr << \"Error: Invalid input.\" << endl;\n        exit(1);\n    }\n    // Addition logic\n    int result = x + y;\n    // Result output\n    return result;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Preprocessing: Convert both input strings to lowercase\n    transform(s0.begin(), s0.end(), s0.begin(), ::tolower);\n    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n\n    // Character Set Extraction: Use a set to store unique characters from each input string\n    set<char> set0(s0.begin(), s0.end());\n    set<char> set1(s1.begin(), s1.end());\n\n    // Character Set Comparison: Compare the two extracted character sets for equality\n    return set0 == set1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n <= 0) {\n        printf(\"Error: Input should be a positive integer.\\n\");\n        return -1; // Return an error code\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    int prev = 1;\n    int curr = 1;\n    int result = 0;\n\n    for (int i = 2; i <= n; i++) {\n        result = prev + curr;\n        prev = curr;\n        curr = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <stack>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> opening_brackets;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            opening_brackets.push(bracket);\n        } else if (bracket == '>') {\n            if (opening_brackets.empty()) {\n                return false;\n            }\n            opening_brackets.pop();\n        } else {\n            // Invalid character in input string\n            return false;\n        }\n    }\n    return opening_brackets.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n  bool is_increasing = true;\n  bool is_decreasing = true;\n\n  if (l.size() <= 1) {\n    return true;\n  }\n\n  for (int i = 0; i < l.size() - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      is_increasing = false;\n    }\n    if (l[i] < l[i + 1]) {\n      is_decreasing = false;\n    }\n  }\n\n  return is_increasing || is_decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Input Validation\n    if (l1.empty() || l2.empty()) {\n        return {};\n    }\n\n    // Find Common Elements\n    set<int> commonElements;\n    for (int element : l1) {\n        if (find(l2.begin(), l2.end(), element) != l2.end()) {\n            commonElements.insert(element);\n        }\n    }\n\n    // Convert set to vector and sort\n    vector<int> result(commonElements.begin(), commonElements.end());\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            if (is_prime(i)) {\n                largest_factor = i;\n            }\n            n /= i;\n        }\n    }\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdexcept>\n\nint sum_to_n(int n) {\n    if (n <= 0) {\n        throw std::invalid_argument(\"Input must be a positive integer.\");\n    }\n\n    int sum = n * (n + 1) / 2;\n    return sum;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stack>\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    std::stack<char> opening_brackets;\n    for (char c : brackets) {\n        if (c == '(') {\n            opening_brackets.push(c);\n        } else if (c == ')') {\n            if (opening_brackets.empty()) {\n                return false;\n            }\n            opening_brackets.pop();\n        } else {\n            return false; // invalid character\n        }\n    }\n    return opening_brackets.empty();\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\n#include <stdexcept>\n\nvector<float> derivative(const vector<float>& xs) {\n    if (xs.empty()) {\n        throw std::invalid_argument(\"Input vector is empty\");\n    }\n\n    vector<float> derivativeCoefficients;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        derivativeCoefficients.push_back(xs[i] * i);\n    }\n\n    return derivativeCoefficients;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    if (n <= 2) {\n        if (n == 0 || n == 1) return 0;\n        else return 1;\n    }\n\n    std::vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    for (int i = 3; i <= n; i++) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "int vowels_count(string s) {\n    int vowel_count = 0;\n    if (s.empty()) return vowel_count;\n\n    for (char& c : s) {\n        c = tolower(c);\n        switch (c) {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n                vowel_count++;\n                break;\n        }\n    }\n\n    if (!s.empty() && s.back() == 'y') vowel_count++;\n\n    return vowel_count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <stdexcept>\n\nstring circular_shift(int x, int shift) {\n    // Input validation\n    if (x < 0 || shift < 0) {\n        throw std::invalid_argument(\"Input values must be non-negative.\");\n    }\n\n    // Convert integer to string\n    std::string str_x = std::to_string(x);\n\n    // Calculate effective shift\n    int num_digits = str_x.length();\n    int effective_shift = shift % num_digits;\n\n    // Handle reverse case\n    if (effective_shift == 0 && shift > num_digits) {\n        // Reverse the string\n        std::string reversed_str_x(str_x.rbegin(), str_x.rend());\n        return reversed_str_x;\n    }\n\n    // Perform circular shift\n    std::string shifted_str_x = str_x.substr(num_digits - effective_shift) + str_x.substr(0, num_digits - effective_shift);\n    return shifted_str_x;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <cctype> // for isupper function\n\nint digitSum(string s) {\n  int sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (int)c;\n    }\n  }\n  return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples, oranges;\n    string temp;\n\n    // Parse the input string to extract the numbers of apples and oranges\n    istringstream iss(s);\n    iss >> apples >> temp >> oranges >> temp;\n\n    // Calculate the total number of apples and oranges\n    int total_apples_oranges = apples + oranges;\n\n    // Calculate the number of mango fruits\n    int mango_fruits = n - total_apples_oranges;\n\n    return mango_fruits;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <climits> // for INT_MAX\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n  if (arr.empty()) return {};\n\n  int smallest_even = INT_MAX;\n  int index = -1;\n\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n      smallest_even = arr[i];\n      index = i;\n    }\n  }\n\n  if (index == -1) return {}; // no even values found\n\n  return {smallest_even, index};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Input Validation\n    if (lst.empty()) {\n        return -1;\n    }\n\n    // Count Frequency\n    map<int, int> frequency;\n    for (int num : lst) {\n        frequency[num]++;\n    }\n\n    // Filter Integers\n    vector<int> filtered;\n    for (auto& pair : frequency) {\n        if (pair.second >= pair.first) {\n            filtered.push_back(pair.first);\n        }\n    }\n\n    // Find Greatest Integer\n    if (filtered.empty()) {\n        return -1;\n    }\n    return *max_element(filtered.begin(), filtered.end());\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    vector<int> copy = lst;\n\n    while (!copy.empty()) {\n        auto min_iter = min_element(copy.begin(), copy.end());\n        result.push_back(*min_iter);\n        copy.erase(min_iter);\n\n        if (!copy.empty()) {\n            auto max_iter = max_element(copy.begin(), copy.end());\n            result.push_back(*max_iter);\n            copy.erase(max_iter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Input Validation\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return -1;\n    }\n\n    // Validate Triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate Semi-Perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate Area\n    float A = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round Area\n    A = round(A * 100) / 100;\n\n    // Return Result\n    return A;\n}\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n  // Input validation\n  if (q.empty() || w < 0) {\n    return false;\n  }\n\n  // Check palindromic property\n  vector<int> reversed_q = q;\n  reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n\n  // Calculate sum of vector elements\n  int sum = 0;\n  for (int elem : q) {\n    sum += elem;\n  }\n\n  // Compare sum with maximum weight\n  if (sum > w) {\n    return false;\n  }\n\n  // Return result\n  return true;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    \n    // Check if the input vector is empty or has an odd length\n    if (n == 0 || (n % 2 != 0)) {\n        return -1; // Return an error code\n    }\n\n    int changes = 0;\n    int left = 0;\n    int right = n - 1;\n\n    // Compare the input vector with its reverse\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n  int total_chars_lst1 = 0;\n  int total_chars_lst2 = 0;\n\n  // Calculate total number of characters in lst1\n  for (const auto& str : lst1) {\n    total_chars_lst1 += str.length();\n  }\n\n  // Calculate total number of characters in lst2\n  for (const auto& str : lst2) {\n    total_chars_lst2 += str.length();\n  }\n\n  // Compare total number of characters\n  if (total_chars_lst1 <= total_chars_lst2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Function to generate all prime numbers less than 100\nstd::vector<int> generatePrimes() {\n    std::vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        bool isPrime = true;\n        for (int j = 2; j <= std::sqrt(i); ++j) {\n            if (i % j == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    std::vector<int> primes = generatePrimes();\n    for (int i = 0; i < primes.size(); ++i) {\n        for (int j = i; j < primes.size(); ++j) {\n            for (int k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_simple_power(int x, int n) {\n  if (x < 0 || n < 0) { // edge case: negative inputs\n    return false;\n  }\n  if (x == 0 || n == 0) { // edge case: zero inputs\n    return false;\n  }\n  if (x == 1) { // edge case: x is 1\n    return true;\n  }\n  double p = std::log(x) / std::log(n); // calculate the power\n  if (std::floor(p) == p) { // check if the power is an integer\n    return true;\n  }\n  return false;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool iscube(int a) {\n    double cube_root = round(pow(abs(a), 1.0 / 3.0));\n    return pow(cube_root, 3) == abs(a);\n}\n"}
{"task_id": "CPP/78", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int decimal_value) {\n    if (decimal_value <= 1) return false;\n    for (int i = 2; i * i <= decimal_value; i++) {\n        if (decimal_value % i == 0) return false;\n    }\n    return true;\n}\n\nint hex_key(string num) {\n    int prime_count = 0;\n    for (char c : num) {\n        int decimal_value;\n        if (c >= '0' && c <= '9') {\n            decimal_value = c - '0';\n        } else {\n            decimal_value = c - 'A' + 10;\n        }\n        if (is_prime(decimal_value)) prime_count++;\n    }\n    return prime_count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal < 0) {\n        return \"Error: Input must be a non-negative integer.\";\n    }\n\n    string binary = \"db\";\n    while (decimal > 0) {\n        binary += (decimal % 2 == 0) ? '0' : '1';\n        decimal /= 2;\n    }\n    binary += \"db\";\n\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Input Validation\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // Return result\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float grade : grades) {\n        if (grade < 0.0 || grade > 4.0) {\n            letter_grades.push_back(\"Invalid GPA\");\n        } else if (grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade >= 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade >= 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade >= 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade >= 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade >= 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade >= 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade >= 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade >= 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade >= 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade >= 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade >= 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num < 2) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is a prime number\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n <= 0) {\n        throw std::invalid_argument(\"Input n must be a positive integer.\");\n    }\n\n    long long countStartWithOne = 9 * (long long)pow(10, n - 2);\n    long long countEndWithOne = 9 * (long long)pow(10, n - 2);\n    long long overlapCount = (long long)pow(10, n - 2);\n\n    long long totalCount = countStartWithOne + countEndWithOne - overlapCount;\n\n    return totalCount;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    string binary = \"\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\n\nint add(const std::vector<int>& lst) {\n  int sum = 0;\n  for (size_t i = 0; i < lst.size(); ++i) {\n    if (i % 2 != 0 && lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    istringstream iss(s);\n    string word;\n    string result = \"\";\n\n    while (iss >> word) {\n        string sorted_word = word;\n        sort(sorted_word.begin(), sorted_word.end());\n        result += sorted_word + \" \";\n    }\n\n    // Remove the trailing space\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom sorting function to sort coordinates first by row in ascending order, then by column in descending order\nbool compareCoordinates(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) {\n        return a[1] > b[1];\n    }\n    return a[0] < b[0];\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through the 2D vector using nested loops\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element matches the input x\n            if (lst[i][j] == x) {\n                // Store the coordinates (row, column) in the coordinates vector\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the coordinates vector using the custom sorting function\n    sort(coordinates.begin(), coordinates.end(), compareCoordinates);\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n  if (array.empty()) {\n    return array;\n  }\n\n  int sum = array[0] + array[array.size() - 1];\n  bool is_odd = sum % 2 != 0;\n\n  vector<int> sorted_array = array;\n  if (is_odd) {\n    sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n  }\n\n  return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s){\n    string result = \"\";\n    int shift = 2 * 2; // calculate the shift value\n\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n\n        // check if the character is an alphabet letter\n        if (c >= 'a' && c <= 'z') {\n            // calculate the new character by shifting down by shift places\n            char new_c = 'a' + (c - 'a' + shift) % 26;\n            result += new_c;\n        } else if (c >= 'A' && c <= 'Z') {\n            // handle uppercase letters\n            char new_c = 'A' + (c - 'A' + shift) % 26;\n            result += new_c;\n        } else {\n            // if the character is not a letter, add it to the result as is\n            result += c;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst){\n    // Input Validation\n    if (lst.empty()) {\n        return -1; // Return -1 instead of None, since C++ doesn't have None\n    }\n\n    // Remove Duplicates\n    set<int> s(lst.begin(), lst.end());\n    vector<int> unique_lst(s.begin(), s.end());\n\n    // Find Smallest Element\n    int smallest = *min_element(unique_lst.begin(), unique_lst.end());\n\n    // Find 2nd Smallest Element\n    unique_lst.erase(remove(unique_lst.begin(), unique_lst.end(), smallest), unique_lst.end());\n    if (unique_lst.empty()) {\n        return -1; // Return -1 instead of None\n    }\n    int second_smallest = *min_element(unique_lst.begin(), unique_lst.end());\n\n    return second_smallest;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    string sentence;\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            if (!sentence.empty() && sentence[0] == 'I') {\n                boredomCount++;\n            }\n            sentence.clear();\n        } else {\n            sentence += c;\n        }\n    }\n    // Check the last sentence\n    if (!sentence.empty() && sentence[0] == 'I') {\n        boredomCount++;\n    }\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n  // Input Validation\n  if (a != floor(a) || b != floor(b) || c != floor(c)) {\n    return false;\n  }\n\n  // Calculate Sums\n  float sum_ab = a + b;\n  float sum_ac = a + c;\n  float sum_bc = b + c;\n\n  // Comparison\n  if (sum_ab == c || sum_ac == b || sum_bc == a) {\n    return true;\n  }\n\n  // Return Result\n  return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message){\n  string output = \"\";\n  for (char c : message) {\n    if (isalpha(c)) {\n      c = isupper(c) ? tolower(c) : toupper(c); // swap case of the letter\n      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n          c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n        // replace vowel with letter 2 places ahead\n        if (c == 'a' || c == 'A') c = c == 'a' ? 'c' : 'C';\n        else if (c == 'e' || c == 'E') c = c == 'e' ? 'g' : 'G';\n        else if (c == 'i' || c == 'I') c = c == 'i' ? 'k' : 'K';\n        else if (c == 'o' || c == 'O') c = c == 'o' ? 'q' : 'Q';\n        else if (c == 'u' || c == 'U') c = c == 'u' ? 'w' : 'W';\n      }\n    }\n    output += c;\n  }\n  return output;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPrime(int num) {\n  if (num <= 1) return false;\n  for (int i = 2; i * i <= num; i++) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n  int largestPrime = 0;\n  for (int num : lst) {\n    if (isPrime(num) && num > largestPrime) {\n      largestPrime = num;\n    }\n  }\n  int digitSum = 0;\n  while (largestPrime > 0) {\n    digitSum += largestPrime % 10;\n    largestPrime /= 10;\n  }\n  return digitSum;\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nbool check_dict_case(map<string,string> dict){\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Iterate through each key in the map\n    for (auto& pair : dict) {\n        // Check if the key is a string (always true since map<string, string>)\n        // Check if the key is either in lower case or upper case\n        bool allLower = true;\n        bool allUpper = true;\n        for (char c : pair.first) {\n            if (!islower(c)) {\n                allLower = false;\n            }\n            if (!isupper(c)) {\n                allUpper = false;\n            }\n        }\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // If all keys pass the above checks, return true\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate prime numbers less than n\nvector<int> generate_primes(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) primes.push_back(i);\n    }\n    return primes;\n}\n\n// Main function to count up to n prime numbers\nvector<int> count_up_to(int n) {\n    return generate_primes(n);\n}\n\n"}
{"task_id": "CPP/97", "generation": "int multiply(int a, int b) {\n  int unit_digit_a = abs(a) % 10;\n  int unit_digit_b = abs(b) % 10;\n  int product = unit_digit_a * unit_digit_b;\n  return product;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool is_even_index(int index) {\n  return index % 2 == 0;\n}\n\nbool is_uppercase_vowel(char c) {\n  return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nint count_upper(string s){\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    if (is_even_index(i) && is_uppercase_vowel(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    try {\n        double num = stod(value);\n        double fractional_part = num - floor(num);\n        if (fractional_part == 0.5) {\n            if (num > 0) {\n                return floor(num) + 1;\n            } else {\n                return floor(num) - 1;\n            }\n        } else if (fractional_part > 0.5) {\n            return floor(num) + 1;\n        } else if (fractional_part < 0.5) {\n            return floor(num);\n        } else {\n            return num;\n        }\n    } catch (const std::invalid_argument& e) {\n        throw std::invalid_argument(\"Invalid input string\");\n    } catch (const std::out_of_range& e) {\n        throw std::out_of_range(\"Input value is out of range\");\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    int increment = (n % 2 == 0) ? 2 : 2;\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(current_stones);\n        current_stones += increment;\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Remove leading and trailing whitespace\n    s.erase(0, s.find_first_not_of(\" ,\"));\n    s.erase(s.find_last_not_of(\" ,\") + 1);\n\n    // Replace commas with spaces\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == ',') {\n            s[i] = ' ';\n        }\n    }\n\n    // Split the string into words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "/*\nThis function takes two positive numbers x and y and returns the\nbiggest even integer number that is in the range [x, y] inclusive. If \nthere's no such number, then the function should return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n#include<stdio.h>\nusing namespace std;\nint choose_num(int x,int y){\n    // Validate Input\n    if (x <= 0 || y <= 0) {\n        return -1; // or throw an error\n    }\n\n    // Determine Range\n    if (x > y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n\n    // Find Largest Even Number\n    int largestEven = -1;\n    for (int i = y; i >= x; i--) {\n        if (i % 2 == 0) {\n            largestEven = i;\n            break;\n        }\n    }\n\n    return largestEven;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    double avg = (n + m) / 2.0;\n    int rounded_avg = floor(avg);\n\n    string binary = \"\";\n    while (rounded_avg > 0) {\n        binary = (rounded_avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if an integer has any even digits\nbool hasEvenDigit(int num) {\n    string str = to_string(num);\n    for (char c : str) {\n        if ((c - '0') % 2 == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    // Input validation: if input vector is empty, return an empty vector\n    if (x.empty()) {\n        return {};\n    }\n\n    // Filtering step: iterate through each integer and check for even digits\n    vector<int> filteredVector;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            filteredVector.push_back(num);\n        }\n    }\n\n    // Sorting step: sort the filtered vector in increasing order\n    sort(filteredVector.begin(), filteredVector.end());\n\n    // Return the sorted vector\n    return filteredVector;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Input Validation\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Filtering\n    vector<int> filtered_arr;\n    copy_if(arr.begin(), arr.end(), back_inserter(filtered_arr), [](int x) { return x >= 1 && x <= 9; });\n\n    // Sorting\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reversing\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Mapping\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n    for (int digit : filtered_arr) {\n        result.push_back(digit_to_name[digit]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            result[i - 1] = i * (i + 1) / 2;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    string rev_str = str;\n    reverse(rev_str.begin(), rev_str.end());\n    return str == rev_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint calculate_digit_sum(int num) {\n    int digit_sum = 0;\n    int sign = (num < 0) ? -1 : 1;\n    num = abs(num);\n    while (num > 0) {\n        digit_sum += sign * (num % 10);\n        num /= 10;\n    }\n    return digit_sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int element : n) {\n        int digit_sum = calculate_digit_sum(element);\n        if (digit_sum > 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <algorithm>\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n  if (arr.empty()) return true;\n\n  int min_idx = std::distance(arr.begin(), std::min_element(arr.begin(), arr.end()));\n\n  for (int i = min_idx; i < arr.size() - 1; i++) {\n    if (arr[i] > arr[i + 1]) {\n      for (int j = 0; j < min_idx; j++) {\n        if (arr[j] > arr[(j + 1) % arr.size()]) return false;\n      }\n      return true;\n    }\n  }\n  return true;\n}\n"}
{"task_id": "CPP/110", "generation": "string exchange(vector<int> lst1, vector<int> lst2) {\n    int evenCountLst1 = 0, oddCountLst1 = 0, evenCountLst2 = 0;\n\n    // Count even and odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 == 0) {\n            evenCountLst1++;\n        } else {\n            oddCountLst1++;\n        }\n    }\n\n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    // Check if exchange is possible\n    if (evenCountLst2 >= oddCountLst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> result;\n\n    // Split the input string into individual letters and count the occurrence of each letter\n    for (char c : test) {\n        if (c != ' ') {\n            letterCount[c]++;\n        }\n    }\n\n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (auto& pair : letterCount) {\n        maxCount = max(maxCount, pair.second);\n    }\n\n    // Identify letters with the maximum occurrence and create the output map\n    for (auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Input Validation\n    if (s.empty() || c.empty()) {\n        return {\"\", \"False\"};\n    }\n\n    // Character Deletion\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Palindrome Check\n    string reversed = result;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = result == reversed;\n\n    // Result Formatting\n    vector<string> res;\n    res.push_back(result);\n    res.push_back(is_palindrome ? \"True\" : \"False\");\n    return res;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> output;\n    string template_str = \"the number of odd elements %dn the str%dng %d of the %dnput.\";\n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        string output_str = template_str;\n        output_str.replace(output_str.find(\"%d\"), 2, to_string(odd_count));\n        output_str.replace(output_str.find(\"%d\"), 2, to_string(odd_count));\n        output_str.replace(output_str.find(\"%d\"), 2, to_string(odd_count));\n        output_str.replace(output_str.find(\"%d\"), 2, to_string(odd_count));\n        output.push_back(output_str);\n    }\n    return output;\n}\n"}
{"task_id": "CPP/114", "generation": "long long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX;\n    long long current_sum = 0;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n    \n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint count_ones_in_row(vector<int> row) {\n  int count = 0;\n  for (int element : row) {\n    if (element == 1) {\n      count++;\n    }\n  }\n  return count;\n}\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n  int total_buckets = 0;\n  for (vector<int> row : grid) {\n    int water_in_well = count_ones_in_row(row);\n    int buckets_needed = ceil((double)water_in_well / capacity);\n    total_buckets += buckets_needed;\n  }\n  return total_buckets;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n// Custom comparison function for sorting\nbool compare(int a, int b) {\n    int onesA = countOnes(abs(a));\n    int onesB = countOnes(abs(b));\n    if (onesA == onesB) {\n        return a < b;\n    }\n    return onesA < onesB;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Check for empty input vector\n    if (arr.empty()) {\n        return arr;\n    }\n\n    // Sort the vector using the custom comparison function\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        char lower_c = tolower(c);\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    istringstream iss(s);\n    string word;\n\n    while (iss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool isVowel(char c) {\n  return (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n          c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool isConsonant(char c) {\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) && !isVowel(c);\n}\n\nstring get_closest_vowel(string word){\n  if (word.empty() || word.length() < 3) return \"\";\n\n  for (int i = word.length() - 1; i >= 1; i--) {\n    if (isVowel(word[i])) {\n      if (isConsonant(word[i-1]) && (i + 1 < word.length() ? isConsonant(word[i+1]) : true)) {\n        return string(1, word[i]);\n      }\n    }\n  }\n\n  return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst){\n  int open_count1 = 0, close_count1 = 0, open_count2 = 0, close_count2 = 0;\n\n  // Count Open and Close Parentheses\n  for (char c : lst[0]) {\n    if (c == '(') open_count1++;\n    else close_count1++;\n  }\n  for (char c : lst[1]) {\n    if (c == '(') open_count2++;\n    else close_count2++;\n  }\n\n  // Determine Balance\n  if (open_count1 + open_count2 != close_count1 + close_count2) {\n    return \"No\";\n  }\n\n  // Check Concatenation Order\n  if (open_count1 + close_count2 == open_count2 + close_count1) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n"}
{"task_id": "CPP/120", "generation": "vector<int> maximum(vector<int> arr, int k) {\n  if (k == 0 || arr.empty()) {\n    return {};\n  }\n  \n  std::sort(arr.begin(), arr.end());\n  \n  if (k > arr.size()) {\n    k = arr.size();\n  }\n  \n  return vector<int>(arr.end() - k, arr.end());\n}\n"}
{"task_id": "CPP/121", "generation": "int solution(vector<int> lst){\n  int sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 2 == 0 && lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Input Validation\n    if (arr.empty() || k < 1 || k > arr.size()) {\n        throw invalid_argument(\"Invalid input\");\n    }\n\n    int sum = 0;\n    // Filter Elements and Calculate Sum\n    for (int i = 0; i < k; i++) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate Collatz Sequence\n    collatz_sequence.push_back(n);\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        collatz_sequence.push_back(n);\n    }\n\n    // Filter Odd Numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the Odd Numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Input Validation: Check if the input date string is not empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Date String Format Validation: Check if the input date string matches the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Month Extraction and Validation\n    int month = stoi(date.substr(0, 2));\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Day Extraction and Validation\n    int day = stoi(date.substr(3, 2));\n    int maxDays;\n    if (month == 2) {\n        maxDays = 29;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        maxDays = 30;\n    } else {\n        maxDays = 31;\n    }\n    if (day < 1 || day > maxDays) {\n        return false;\n    }\n\n    // Year Extraction (not validated in this implementation)\n    int year = stoi(date.substr(6, 4));\n\n    // Return Result: If all validations pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    if (txt.empty()) {\n        return {};\n    }\n\n    if (txt.find(' ') != string::npos) {\n        vector<string> result;\n        size_t pos = 0;\n        while ((pos = txt.find(' ')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt);\n        return result;\n    }\n\n    if (txt.find(',') != string::npos) {\n        vector<string> result;\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt);\n        return result;\n    }\n\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z' && (c - 'a') % 2 != 0) {\n            count++;\n        }\n    }\n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n  // Input validation\n  if (lst.empty()) {\n    return false;\n  }\n\n  // Count occurrences\n  unordered_map<int, int> counts;\n  for (int num : lst) {\n    counts[num]++;\n  }\n\n  // Check for duplicates\n  for (auto& pair : counts) {\n    if (pair.second > 2) {\n      return false;\n    }\n  }\n\n  // Check for sorting\n  for (int i = 0; i < lst.size() - 1; i++) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n\n  // Return result\n  return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Validate input intervals\n    if (interval1.size() != 2 || interval2.size() != 2) return \"NO\";\n    if (interval1[0] > interval1[1] || interval2[0] > interval2[1]) return \"NO\";\n\n    // Find interval intersection\n    int intersectionStart = max(interval1[0], interval2[0]);\n    int intersectionEnd = min(interval1[1], interval2[1]);\n    if (intersectionStart > intersectionEnd) return \"NO\";\n\n    // Calculate intersection length\n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n\n    // Primality check\n    if (isPrime(intersectionLength)) return \"YES\";\n    else return \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr){\n    if(arr.empty()) return -32768;\n    \n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n    \n    for(int num : arr){\n        sum_of_magnitudes += abs(num);\n        if(num > 0) product_of_signs *= 1;\n        else if(num < 0) product_of_signs *= -1;\n        else product_of_signs *= 0;\n    }\n    \n    return sum_of_magnitudes * product_of_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <queue>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Path {\n    vector<int> values;\n    int x, y;\n    bool operator<(const Path& other) const {\n        for (int i = 0; i < min(values.size(), other.values.size()); i++) {\n            if (values[i] < other.values[i]) return true;\n            if (values[i] > other.values[i]) return false;\n        }\n        return values.size() < other.values.size();\n    }\n};\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    priority_queue<Path> pq;\n    set<pair<int, int>> visited;\n\n    // Find the cell with the minimum value in the grid\n    int minX = 0, minY = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < grid[minX][minY]) {\n                minX = i;\n                minY = j;\n            }\n        }\n    }\n\n    // Construct an initial path of length k starting from the minimum value cell\n    Path initialPath;\n    initialPath.values.push_back(grid[minX][minY]);\n    initialPath.x = minX;\n    initialPath.y = minY;\n    pq.push(initialPath);\n\n    while (!pq.empty()) {\n        Path currentPath = pq.top();\n        pq.pop();\n\n        if (currentPath.values.size() == k) {\n            return currentPath.values;\n        }\n\n        // Explore neighbor cells\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n        for (int i = 0; i < 4; i++) {\n            int newX = currentPath.x + dx[i];\n            int newY = currentPath.y + dy[i];\n\n            // Check if the neighbor cell is within the grid boundaries\n            if (newX >= 0 && newX < n && newY >= 0 && newY < n) {\n                // Check if the neighbor cell has not been visited before\n                if (visited.find({newX, newY}) == visited.end()) {\n                    Path newPath = currentPath;\n                    newPath.values.push_back(grid[newX][newY]);\n                    newPath.x = newX;\n                    newPath.y = newY;\n                    pq.push(newPath);\n                    visited.insert({newX, newY});\n                }\n            }\n        }\n    }\n\n    return {};\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> trib(n + 2, 0);\n    trib[1] = 3;\n    trib[2] = 2;\n    for (int i = 3; i <= n + 1; i++) {\n        if (i % 2 == 0) {\n            trib[i] = 1 + i / 2;\n        } else {\n            trib[i] = trib[i - 1] + trib[i - 2] + trib[i + 1];\n        }\n    }\n    // Handle the case where n is 0 or 1\n    if (n == 0) {\n        return vector<int>(1, 1);\n    } else if (n == 1) {\n        return vector<int>({1, 3});\n    }\n    // Return the constructed trib vector\n    return vector<int>(trib.begin(), trib.begin() + n + 1);\n}\n"}
{"task_id": "CPP/131", "generation": "/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    if (n <= 0) {\n        throw invalid_argument(\"Input must be a positive integer.\");\n    }\n\n    int product = 1;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n\n    return product == 1 ? 0 : product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    // Validate input string\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            throw invalid_argument(\"Input string must only contain square brackets\");\n        }\n    }\n\n    // Initialize variables\n    int nesting_level = 0;\n    bool is_nested = false;\n\n    // Iterate through the string\n    for (char c : str) {\n        if (c == '[') {\n            nesting_level++;\n            if (nesting_level > 1) {\n                is_nested = true;\n            }\n        } else if (c == ']') {\n            nesting_level--;\n            if (nesting_level < 0) {\n                return false; // Invalid bracket sequence\n            }\n        }\n    }\n\n    // Check validity of bracket sequence\n    if (nesting_level != 0) {\n        return false;\n    }\n\n    return is_nested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    if(lst.empty()) {\n        throw invalid_argument(\"Input vector is empty\");\n    }\n\n    int sum = 0;\n    for(float num : lst) {\n        sum += pow(ceil(num), 2);\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <cctype> // for isalpha function\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n  if (txt.empty()) return false; // Input Validation\n  char last_char = txt[txt.length() - 1]; // Get Last Character\n  if (!isalpha(last_char)) return false; // Check Alphabetical\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') return false; // Check Word Boundary\n  return true; // Return Result\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.empty()) {\n        return -1;\n    }\n\n    int max_index = -1;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <algorithm>\n#include <vector>\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n  if (lst.empty()) {\n    return {0, 0};\n  }\n\n  int largest_negative = 0;\n  int smallest_positive = 0;\n\n  for (int num : lst) {\n    if (num < 0) {\n      largest_negative = (largest_negative == 0) ? num : max(largest_negative, num);\n    } else if (num > 0) {\n      smallest_positive = (smallest_positive == 0) ? num : min(smallest_positive, num);\n    }\n  }\n\n  return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\nusing namespace std;\n\n// Helper function to check if a boost::any object is a valid number\nbool isValidNumber(const boost::any& a) {\n  return a.type() == typeid(int) || a.type() == typeid(float) || a.type() == typeid(std::string);\n}\n\n// Helper function to format a string with a comma as a decimal separator\nboost::any formatString(const boost::any& a) {\n  std::string str = boost::any_cast<std::string>(a);\n  std::replace(str.begin(), str.end(), ',', '.');\n  return str;\n}\n\n// Helper function to convert a string to a number\nboost::any convertStringToNumber(const boost::any& a) {\n  std::string str = boost::any_cast<std::string>(a);\n  try {\n    return std::stof(str);\n  } catch (const std::invalid_argument& e) {\n    throw std::invalid_argument(\"Invalid string input\");\n  }\n}\n\n// Helper function to compare two boost::any objects\nbool compare(const boost::any& a, const boost::any& b) {\n  if (a.type() == typeid(int) && b.type() == typeid(int)) {\n    return boost::any_cast<int>(a) > boost::any_cast<int>(b);\n  } else if (a.type() == typeid(float) && b.type() == typeid(float)) {\n    return boost::any_cast<float>(a) > boost::any_cast<float>(b);\n  } else if (a.type() == typeid(std::string) && b.type() == typeid(std::string)) {\n    return boost::any_cast<std::string>(a) > boost::any_cast<std::string>(b);\n  } else {\n    throw std::invalid_argument(\"Invalid input types\");\n  }\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n  // Input Validation\n  if (!isValidNumber(a) || !isValidNumber(b)) {\n    throw std::invalid_argument(\"Invalid input\");\n  }\n\n  // String Formatting\n  if (a.type() == typeid(std::string)) {\n    a = formatString(a);\n  }\n  if (b.type() == typeid(std::string)) {\n    b = formatString(b);\n  }\n\n  // Type Conversion\n  if (a.type() == typeid(std::string)) {\n    a = convertStringToNumber(a);\n  }\n  if (b.type() == typeid(std::string)) {\n    b = convertStringToNumber(b);\n  }\n\n  // Comparison\n  if (compare(a, b)) {\n    return a;\n  } else if (compare(b, a)) {\n    return b;\n  } else {\n    return \"None\";\n  }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n\nbool is_equal_to_sum_even(int n) {\n    if (n <= 0) return false; // Validate input\n\n    bool found = false;\n    for (int a = 2; a <= n / 4; a += 2) {\n        for (int b = a; b <= n / 3; b += 2) {\n            for (int c = b; c <= n / 2; c += 2) {\n                int d = n - a - b - c;\n                if (d >= c && d % 2 == 0) {\n                    if (found) return false; // More than one combination found\n                    found = true;\n                }\n            }\n        }\n    }\n    return found;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\nlong long factorial(int k) {\n    long long result = 1;\n    for (int i = 2; i <= k; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long product(long long* factorials, int size) {\n    long long result = 1;\n    for (int i = 0; i < size; i++) {\n        result *= factorials[i];\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long* factorials = new long long[n];\n    for (int i = 0; i < n; i++) {\n        factorials[i] = factorial(n - i);\n    }\n    long long result = product(factorials, n);\n    delete[] factorials;\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n            if (space_count == 1 || space_count == 2) {\n                result += '_';\n            } else if (space_count > 2) {\n                result += '-';\n                space_count = 0;\n            }\n        } else {\n            if (space_count > 2) {\n                result += '-';\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n// Function to count the number of digits in the file name\nint count_digits(string file_name) {\n  int count = 0;\n  for (char c : file_name) {\n    if (c >= '0' && c <= '9') {\n      count++;\n    }\n  }\n  return count;\n}\n\n// Function to verify that the file name contains exactly one dot\nbool has_exactly_one_dot(string file_name) {\n  int count = 0;\n  for (char c : file_name) {\n    if (c == '.') {\n      count++;\n    }\n  }\n  return count == 1;\n}\n\n// Function to split the file name into two substrings: one before the dot and one after the dot\nvoid split_file_name(string file_name, string& before_dot, string& after_dot) {\n  size_t dot_pos = file_name.find('.');\n  before_dot = file_name.substr(0, dot_pos);\n  after_dot = file_name.substr(dot_pos + 1);\n}\n\n// Function to check that the substring before the dot is not empty and starts with a letter from the Latin alphabet\nbool is_valid_before_dot(string before_dot) {\n  return !before_dot.empty() && ((before_dot[0] >= 'a' && before_dot[0] <= 'z') || (before_dot[0] >= 'A' && before_dot[0] <= 'Z'));\n}\n\n// Function to check that the substring after the dot is one of the allowed extensions\nbool is_valid_after_dot(string after_dot) {\n  return after_dot == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\";\n}\n\n// Main function to check the file name\nstring file_name_check(string file_name) {\n  if (count_digits(file_name) > 3) return \"No\";\n  if (!has_exactly_one_dot(file_name)) return \"No\";\n  string before_dot, after_dot;\n  split_file_name(file_name, before_dot, after_dot);\n  if (!is_valid_before_dot(before_dot)) return \"No\";\n  if (!is_valid_after_dot(after_dot)) return \"No\";\n  return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result;\n\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <numeric>\n\nusing namespace std;\n\n// Function to calculate the greatest common divisor (GCD) using the Euclidean algorithm\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n// Function to parse a fraction string into numerator and denominator\nvoid parseFraction(const string& fraction, int& numerator, int& denominator) {\n    stringstream ss(fraction);\n    string token;\n    getline(ss, token, '/');\n    numerator = stoi(token);\n    getline(ss, token);\n    denominator = stoi(token);\n}\n\nbool simplify(string x, string n) {\n    int xNumerator, xDenominator, nNumerator, nDenominator;\n    parseFraction(x, xNumerator, xDenominator);\n    parseFraction(n, nNumerator, nDenominator);\n\n    // Multiply the fractions\n    int productNumerator = xNumerator * nNumerator;\n    int productDenominator = xDenominator * nDenominator;\n\n    // Simplify the fraction by dividing both numerator and denominator by the GCD\n    int gcdValue = gcd(productNumerator, productDenominator);\n    productNumerator /= gcdValue;\n    productDenominator /= gcdValue;\n\n    // Check if the simplified denominator is 1\n    return productDenominator == 1;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to calculate the sum of digits for a single integer\nint calculate_sum_of_digits(int num) {\n    int sum = 0;\n    int sign = (num < 0) ? -1 : 1;\n    num = abs(num);\n    while (num > 0) {\n        sum += sign * (num % 10);\n        num /= 10;\n    }\n    return sum;\n}\n\n// Custom comparison function for sorting\nbool compare_pairs(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (a.first == b.first) {\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store integers and their sum of digits\n    std::vector<std::pair<int, int>> num_pairs;\n    for (int i = 0; i < nums.size(); i++) {\n        int sum = calculate_sum_of_digits(nums[i]);\n        num_pairs.push_back(std::make_pair(sum, i));\n    }\n\n    // Sort the vector of pairs based on the sum of digits and original index\n    std::sort(num_pairs.begin(), num_pairs.end(), compare_pairs);\n\n    // Extract and return the sorted integers\n    vector<int> sorted_nums;\n    for (int i = 0; i < num_pairs.size(); i++) {\n        sorted_nums.push_back(nums[num_pairs[i].second]);\n    }\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string strNum = to_string(abs(num));\n            if ((strNum[0] - '0') % 2 != 0 && (strNum[strNum.size() - 1] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Validate Input Planets\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n    \n    // Determine Planet Order\n    int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n    \n    // Swap indices if necessary\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Generate Intermediate Planets\n    vector<string> intermediatePlanets(planets.begin() + index1 + 1, planets.begin() + index2);\n    \n    return intermediatePlanets;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort the vector\nbool compareStrings(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // Sort alphabetically if lengths are equal\n    }\n    return a.length() < b.length(); // Sort by length\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> even_length_strings;\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {\n            even_length_strings.push_back(str);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(even_length_strings.begin(), even_length_strings.end(), compareStrings);\n\n    return even_length_strings;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\n// Function to return x if n is prime, y otherwise\nint x_or_y(int n, int x, int y) {\n  if (is_prime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\n"}
{"task_id": "CPP/151", "generation": "long long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == (int)num) {\n            int integerPart = (int)num;\n            if (integerPart % 2 != 0) {\n                sum += (long long)integerPart * integerPart;\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n  // Check if input vectors have the same length\n  if (game.size() != guess.size()) {\n    throw invalid_argument(\"Input vectors must have the same length\");\n  }\n\n  // Initialize output vector\n  vector<int> result(game.size());\n\n  // Iterate over input vectors\n  for (int i = 0; i < game.size(); i++) {\n    // Compare elements and calculate absolute difference\n    int diff = abs(game[i] - guess[i]);\n\n    // Store result in output vector\n    result[i] = diff;\n  }\n\n  // Return output vector\n  return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) cap++;\n            else if (islower(c)) sm++;\n        }\n        int strength = cap - sm;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Helper function to generate all rotations of a string\nvector<string> generateRotations(string b) {\n  vector<string> rotations;\n  int n = b.length();\n  for (int i = 0; i < n; i++) {\n    string rotation = b.substr(i, n - i) + b.substr(0, i);\n    rotations.push_back(rotation);\n  }\n  return rotations;\n}\n\n// Helper function to check if a string is a substring of another string\nbool isSubstring(string a, string b) {\n  return a.find(b) != string::npos;\n}\n\n// Main function to check if the second word or any of its rotations is a substring in the first word\nbool cycpattern_check(string a, string b) {\n  // Input validation\n  if (a.empty() || b.empty()) {\n    return false;\n  }\n\n  // Generate rotations of b\n  vector<string> rotations = generateRotations(b);\n\n  // Iterate and check\n  for (const string& rotation : rotations) {\n    if (isSubstring(a, rotation)) {\n      return true;\n    }\n  }\n\n  // Return result\n  return false;\n}\n"}
{"task_id": "CPP/155", "generation": "vector<int> even_odd_count(int num){\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    if (number < 1 || number > 1000) {\n        throw invalid_argument(\"Input number is out of range (1-1000)\");\n    }\n\n    vector<pair<int, string>> romanMappings = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n\n    string result;\n    for (const auto& mapping : romanMappings) {\n        while (number >= mapping.first) {\n            result += mapping.second;\n            number -= mapping.first;\n        }\n    }\n\n    for (char& c : result) {\n        c = tolower(c);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Validate input\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n\n    // Sort side lengths\n    float sides[] = {a, b, c};\n    std::sort(sides, sides + 3);\n    a = sides[0];\n    b = sides[1];\n    c = sides[2];\n\n    // Check Pythagorean Theorem\n    return (a * a + b * b) == (c * c);\n}\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_string;\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_chars_count = unique_chars.size();\n\n        if (unique_chars_count > max_unique_chars) {\n            max_unique_chars = unique_chars_count;\n            max_string = word;\n        } else if (unique_chars_count == max_unique_chars) {\n            if (word < max_string) {\n                max_string = word;\n            }\n        }\n    }\n\n    return max_string;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n  int total_needed = number + need;\n  if (total_needed <= remaining) {\n    int total_eaten = number + need;\n    int carrots_left = remaining - total_needed;\n    return {total_eaten, carrots_left};\n  } else {\n    int total_eaten = number + remaining;\n    int carrots_left = 0;\n    return {total_eaten, carrots_left};\n  }\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n\n// Function to validate input vectors\nbool validate_input(vector<string> operato, vector<int> operand) {\n  if (operato.size() != operand.size() - 1) {\n    return false;\n  }\n  for (int i = 0; i < operand.size(); i++) {\n    if (operand[i] < 0) {\n      return false;\n    }\n  }\n  if (operato.size() < 1 || operand.size() < 2) {\n    return false;\n  }\n  return true;\n}\n\n// Function to build algebraic expression\nstring build_expression(vector<string> operato, vector<int> operand) {\n  string expression = \"\";\n  expression += to_string(operand[0]);\n  for (int i = 0; i < operato.size(); i++) {\n    expression += \" \" + operato[i] + \" \";\n    expression += to_string(operand[i + 1]);\n  }\n  return expression;\n}\n\n// Function to evaluate algebraic expression\nint evaluate_expression(string expression) {\n  FILE *fp = popen(\"bc\", \"w\");\n  if (fp == NULL) {\n    return -1;\n  }\n  fprintf(fp, \"%s\\n\", expression.c_str());\n  int result;\n  fscanf(fp, \"%d\", &result);\n  pclose(fp);\n  return result;\n}\n\n// Main function to perform algebraic operation\nint do_algebra(vector<string> operato, vector<int> operand) {\n  // Input Validation\n  if (!validate_input(operato, operand)) {\n    return -1;\n  }\n\n  // Build Algebraic Expression\n  string expression = build_expression(operato, operand);\n\n  // Evaluate Algebraic Expression\n  int result = evaluate_expression(expression);\n\n  return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <algorithm>\n#include <cctype>\n#include <string>\n\nstring solve(string s) {\n    bool hasLetter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            c = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text){\n  if (text.empty()) {\n    return \"None\";\n  }\n\n  // Initialize MD5 context\n  MD5_CTX md5_ctx;\n  MD5_Init(&md5_ctx);\n\n  // Update MD5 context with input string\n  MD5_Update(&md5_ctx, text.c_str(), text.size());\n\n  // Finalize MD5 hash\n  unsigned char md5_hash[MD5_DIGEST_LENGTH];\n  MD5_Final(md5_hash, &md5_ctx);\n\n  // Convert hash to string\n  string md5_string;\n  for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n    char hex[3];\n    sprintf(hex, \"%02x\", md5_hash[i]);\n    md5_string += hex;\n  }\n\n  return md5_string;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <algorithm>\n#include <vector>\n\nvector<int> generate_integers(int a, int b) {\n    // Validate Input\n    if (a <= 0 || b <= 0) {\n        return {};\n    }\n\n    // Determine Range\n    int min_val = std::min(a, b);\n    int max_val = std::max(a, b);\n\n    // Generate Even Digits\n    vector<int> even_digits;\n    for (int i = min_val; i <= max_val; ++i) {\n        if (i < 10 && i % 2 == 0) {\n            even_digits.push_back(i);\n        }\n    }\n\n    // Sort Even Digits\n    std::sort(even_digits.begin(), even_digits.end());\n\n    // Return Result\n    return even_digits;\n}\n"}
