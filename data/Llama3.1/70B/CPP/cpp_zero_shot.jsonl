{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n/**\n * Checks if any two numbers in the given vector are closer to each other than the given threshold.\n *\n * @param numbers The vector of numbers to check.\n * @param threshold The minimum distance between two numbers.\n * @return True if any two numbers are closer than the threshold, false otherwise.\n */\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector of numbers in ascending order\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted vector and check the distance between each pair of adjacent numbers\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        // Calculate the distance between the current number and the next number\n        float distance = numbers[i + 1] - numbers[i];\n\n        // If the distance is less than or equal to the threshold, return true\n        if (distance <= threshold) {\n            return true;\n        }\n    }\n\n    // If no pairs of numbers are closer than the threshold, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Separate groups of nested parentheses into separate strings.\n *\n * @param paren_string Input string containing multiple groups of nested parentheses.\n * @return Vector of strings, each representing a separate group of parentheses.\n */\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0; // Balance of open and close parentheses\n\n    // Iterate over each character in the input string\n    for (char c : paren_string) {\n        // Ignore spaces\n        if (c == ' ') continue;\n\n        // Update balance\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n\n        // Add character to current group\n        current_group += c;\n\n        // If balance is zero, we've found a complete group\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns the decimal part of a given floating point number.\n *\n * @param number A positive floating point number.\n * @return The decimal part of the number.\n */\nfloat truncate_number(float number) {\n    // Calculate the integer part of the number\n    int integer_part = (int) number;\n\n    // Subtract the integer part from the original number to get the decimal part\n    float decimal_part = number - integer_part;\n\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Detects if the balance of a bank account falls below zero at any point.\n *\n * @param operations A vector of deposit and withdrawal operations.\n * @return True if the balance falls below zero, false otherwise.\n */\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Calculate the Mean Absolute Deviation (MAD) of a dataset.\n *\n * MAD is the average absolute difference between each element and the mean of the dataset.\n *\n * @param numbers The input dataset.\n * @return The Mean Absolute Deviation of the dataset.\n */\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the absolute deviations from the mean\n    float sum_abs_dev = 0.0;\n    for (float num : numbers) {\n        sum_abs_dev += fabs(num - mean);\n    }\n\n    // Calculate the Mean Absolute Deviation\n    float mad = sum_abs_dev / numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Inserts a number \"delimiter\" between every two consecutive elements of input vector `numbers`.\n *\n * @param numbers Input vector of integers.\n * @param delimiter Number to be inserted between consecutive elements.\n * @return New vector with delimiter inserted between consecutive elements.\n */\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Parse a string of multiple groups of nested parentheses separated by spaces.\n * For each group, return the deepest level of nesting of parentheses.\n *\n * @param paren_string Input string containing multiple groups of nested parentheses.\n * @return A vector of integers representing the deepest level of nesting for each group.\n */\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    string group;\n    int max_depth = 0;\n    int current_depth = 0;\n\n    // Split the input string into individual groups\n    for (char c : paren_string) {\n        if (c == ' ') {\n            // Process the current group\n            result.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        } else {\n            group += c;\n        }\n    }\n\n    // Process the last group\n    result.push_back(max_depth);\n\n    // Iterate over each group\n    for (int i = 0; i < result.size(); i++) {\n        max_depth = 0;\n        current_depth = 0;\n\n        // Iterate over each character in the group\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        // Update the result vector\n        result[i] = max_depth;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Filters an input vector of strings to only include those that contain a given substring.\n *\n * @param strings The input vector of strings to filter.\n * @param substring The substring to search for in each string.\n * @return A new vector containing only the strings that contain the substring.\n */\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a vector containing the sum and product of all integers in the input vector.\n * Empty sum is 0 and empty product is 1.\n *\n * @param numbers Input vector of integers\n * @return Vector containing sum and product of integers\n */\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate over each number in the input vector\n    for (int num : numbers) {\n        sum += num;  // Add number to sum\n        product *= num;  // Multiply number with product\n    }\n\n    // Create a new vector with sum and product\n    std::vector<int> result = {sum, product};\n\n    return result;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Generates a vector of rolling maximum elements from a given vector of integers.\n *\n * @param numbers The input vector of integers.\n * @return A vector of rolling maximum elements.\n */\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int max_so_far = numbers[0];\n\n    // Iterate through the input vector\n    for (int num : numbers) {\n        // Update the maximum element found so far\n        max_so_far = std::max(max_so_far, num);\n        // Append the current maximum to the result vector\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a given string is a palindrome.\n *\n * @param str The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(string str) {\n    // Create a reversed copy of the input string\n    string s(str.rbegin(), str.rend());\n    // Compare the original string with its reversed copy\n    return s == str;\n}\n\n/**\n * Finds the shortest palindrome that begins with a supplied string.\n *\n * Algorithm idea:\n * 1. Find the longest postfix of the supplied string that is a palindrome.\n * 2. Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n *\n * @param str The input string to make a palindrome.\n * @return The shortest palindrome that begins with the input string.\n */\nstring make_palindrome(string str) {\n    // Handle the edge case where the input string is empty\n    if (str.empty()) {\n        return \"\";\n    }\n\n    // Initialize variables to store the longest palindromic postfix and its length\n    string longest_palindromic_postfix = \"\";\n    int longest_palindromic_postfix_length = 0;\n\n    // Iterate over the input string to find the longest palindromic postfix\n    for (int i = str.length() - 1; i >= 0; --i) {\n        // Extract the postfix from the input string\n        string postfix = str.substr(i);\n        // Check if the postfix is a palindrome\n        if (is_palindrome(postfix)) {\n            // Update the longest palindromic postfix if the current postfix is longer\n            if (postfix.length() > longest_palindromic_postfix_length) {\n                longest_palindromic_postfix = postfix;\n                longest_palindromic_postfix_length = postfix.length();\n            }\n        }\n    }\n\n    // Find the prefix that comes before the longest palindromic postfix\n    string prefix = str.substr(0, str.length() - longest_palindromic_postfix_length);\n\n    // Reverse the prefix\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n\n    // Append the reversed prefix to the end of the input string\n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Performs binary XOR on two input strings consisting only of 1s and 0s.\n * \n * @param a First input string\n * @param b Second input string\n * @return Result of binary XOR as a string\n */\nstring string_xor(string a, string b) {\n    // Check if both strings have the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Both strings must have the same length\");\n    }\n\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        // Perform XOR on corresponding characters\n        char xor_result = (a[i] == b[i]) ? '0' : '1';\n        result += xor_result;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the longest string from a vector of strings.\n * If multiple strings have the same maximum length, returns the first one.\n * Returns an empty string if the input vector is empty.\n */\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n\n    return longestStr;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\n// Function to calculate the greatest common divisor of two integers\nint greatest_common_divisor(int a, int b) {\n    // Base case: if b is 0, the GCD is a\n    if (b == 0) {\n        return a;\n    }\n    // Recursive case: call the function with b and the remainder of a/b\n    else {\n        return greatest_common_divisor(b, a % b);\n    }\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a vector of all prefixes from shortest to longest of the input string.\n *\n * @param str The input string.\n * @return A vector of all prefixes of the input string.\n */\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a string containing space-delimited numbers starting from 0 up to n inclusive.\n *\n * @param n The upper limit of the sequence (inclusive).\n * @return A string containing the sequence of numbers.\n */\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Counts the number of distinct characters in a given string, regardless of case.\n *\n * @param str The input string.\n * @return The number of distinct characters in the string.\n */\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case differences\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Create a set to store unique characters\n    vector<char> unique_chars;\n\n    // Iterate over each character in the string\n    for (char c : str) {\n        // If the character is not already in the set, add it\n        if (find(unique_chars.begin(), unique_chars.end(), c) == unique_chars.end()) {\n            unique_chars.push_back(c);\n        }\n    }\n\n    // Return the size of the set, which represents the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Parse a string of musical notes in a special ASCII format and return a vector of integers\n * representing the number of beats each note lasts.\n *\n * Legend:\n * \"o\" - whole note, lasts four beats\n * \"o|\" - half note, lasts two beats\n * \".|\" - quarter note, lasts one beat\n *\n * @param music_string The input string of musical notes\n * @return A vector of integers representing the number of beats each note lasts\n */\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int i = 0;\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                // Half note\n                beats.push_back(2);\n                i += 2;\n            } else {\n                // Whole note\n                beats.push_back(4);\n                i += 1;\n            }\n        } else if (music_string[i] == '.') {\n            // Quarter note\n            beats.push_back(1);\n            i += 2; // Skip the \"|\" character\n        } else {\n            // Skip whitespace characters\n            i += 1;\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Counts the number of occurrences of a substring in a given string.\n * Overlapping cases are included in the count.\n *\n * @param str The original string to search in.\n * @param substring The substring to search for.\n * @return The number of times the substring is found in the original string.\n */\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the string until we've checked all possible positions\n    while (pos < str.length()) {\n        // Find the next occurrence of the substring\n        pos = str.find(substring, pos);\n\n        // If the substring is not found, break out of the loop\n        if (pos == string::npos) {\n            break;\n        }\n\n        // Increment the count and move the position to the next character\n        count++;\n        pos++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers in a string\nstring sort_numbers(string numbers) {\n    // Map to store number words and their corresponding integer values\n    map<string, int> numMap = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into a vector of words\n    vector<string> words;\n    size_t pos = 0;\n    while ((pos = numbers.find(\" \")) != string::npos) {\n        words.push_back(numbers.substr(0, pos));\n        numbers.erase(0, pos + 1);\n    }\n    words.push_back(numbers);\n\n    // Sort the words based on their corresponding integer values\n    sort(words.begin(), words.end(), [&numMap](const string& a, const string& b) {\n        return numMap[a] < numMap[b];\n    });\n\n    // Join the sorted words back into a string\n    string sortedNumbers;\n    for (const auto& word : words) {\n        sortedNumbers += word + \" \";\n    }\n    sortedNumbers.pop_back(); // Remove the trailing space\n\n    return sortedNumbers;\n}\n\n"}
{"task_id": "CPP/20", "generation": "/**\n * Find the two closest elements in a vector of numbers.\n *\n * @param numbers A vector of numbers (length at least 2)\n * @return A vector containing the two closest numbers in order (smaller, larger)\n */\nvector<float> find_closest_elements(vector<float> numbers) {\n  // Sort the vector in ascending order\n  sort(numbers.begin(), numbers.end());\n\n  // Initialize the minimum difference and the closest pair\n  float min_diff = INFINITY;\n  vector<float> closest_pair;\n\n  // Iterate through the sorted vector to find the closest pair\n  for (size_t i = 0; i < numbers.size() - 1; ++i) {\n    float diff = numbers[i + 1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_pair = {numbers[i], numbers[i + 1]};\n    }\n  }\n\n  return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "vector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Check if all values are the same (to avoid division by zero)\n    if (min_val == max_val) {\n        // If all values are the same, return a vector of zeros\n        vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    // Apply the linear transformation to each element\n    vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "vector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the length of the given string.\n *\n * @param str The input string.\n * @return The length of the string.\n */\nint strlen(string str) {\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\n/**\n * Finds the largest number that divides n evenly, smaller than n.\n *\n * @param n The input number.\n * @return The largest divisor of n, smaller than n.\n */\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisors are found, return 1 (since 1 is a divisor of every number)\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a vector of prime factors of the given integer in the order from smallest to largest.\n * Each factor is repeated the number of times it appears in the factorization.\n * The input number is equal to the product of all factors.\n *\n * @param n The input integer to factorize.\n * @return A vector of prime factors.\n */\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "vector<int> remove_duplicates(vector<int> numbers) {\n    vector<int> result;\n    for (int num : numbers) {\n        if (count(numbers.begin(), numbers.end(), num) == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Flips the case of all characters in a given string.\n * \n * @param str The input string.\n * @return The string with all characters' cases flipped.\n */\nstring flip_case(string str) {\n    for (char& c : str) {\n        if (c >= 'a' && c <= 'z') {\n            // Convert lowercase to uppercase\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            // Convert uppercase to lowercase\n            c = c - 'A' + 'a';\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\n/**\n * Concatenates a vector of strings into a single string.\n *\n * @param strings Vector of strings to concatenate.\n * @return A single string containing all the input strings concatenated together.\n */\nstring concatenate(const vector<string>& strings) {\n    string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Filter an input vector of strings only for ones that start with a given prefix.\n *\n * @param strings Input vector of strings\n * @param prefix Prefix to filter by\n * @return Filtered vector of strings\n */\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(prefix) == 0) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a new vector containing only the positive numbers from the input vector.\n *\n * @param l The input vector of numbers.\n * @return A new vector containing only the positive numbers from the input vector.\n */\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n\n/**\n * Returns true if a given number is prime, and false otherwise.\n *\n * @param n The number to check for primality.\n * @return true if n is prime, false otherwise.\n */\nbool is_prime(long long n) {\n    if (n <= 1) {\n        // Numbers less than or equal to 1 are not prime.\n        return false;\n    }\n\n    // Check if n is divisible by any number up to its square root.\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            // If n is divisible by i, it's not prime.\n            return false;\n        }\n    }\n\n    // If we reach this point, n is prime.\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "double find_zero(vector<double> xs) {\n    // Check if the number of coefficients is even\n    if (xs.size() % 2 != 0) {\n        throw std::invalid_argument(\"Number of coefficients must be even\");\n    }\n\n    // Check if the largest non-zero coefficient is at the end\n    int largest_non_zero_idx = xs.size() - 1;\n    while (largest_non_zero_idx >= 0 && xs[largest_non_zero_idx] == 0) {\n        largest_non_zero_idx--;\n    }\n    if (largest_non_zero_idx != xs.size() - 1) {\n        throw std::invalid_argument(\"Largest non-zero coefficient must be at the end\");\n    }\n\n    // Use the Newton-Raphson method to find a zero\n    double x = 1.0; // initial guess\n    double tolerance = 1e-6; // tolerance for convergence\n    int max_iter = 100; // maximum number of iterations\n\n    for (int i = 0; i < max_iter; i++) {\n        double f_x = poly(xs, x);\n        double f_prime_x = 0;\n        for (int j = 1; j < xs.size(); j++) {\n            f_prime_x += j * xs[j] * pow(x, j - 1);\n        }\n        double x_new = x - f_x / f_prime_x;\n        if (abs(x_new - x) < tolerance) {\n            return x_new;\n        }\n        x = x_new;\n    }\n\n    throw std::runtime_error(\"Failed to converge\");\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * This function takes a vector l and returns a vector l' such that\n * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n * to the values of the corresponding indicies of l, but sorted in ascending order.\n */\nvector<int> sort_third(vector<int> l) {\n    // Create a new vector to store the values at indices divisible by 3\n    vector<int> third_values;\n    \n    // Iterate over the input vector and extract values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the extracted values in ascending order\n    sort(third_values.begin(), third_values.end());\n    \n    // Create a new vector to store the result\n    vector<int> result = l;\n    \n    // Iterate over the input vector and replace values at indices divisible by 3 with the sorted values\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = third_values[j++];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector of unique elements in sorted order.\n *\n * @param l The input vector.\n * @return A vector of unique elements in sorted order.\n */\nvector<int> unique(vector<int> l) {\n    // Remove duplicates by converting to a set\n    sort(l.begin(), l.end());\n    l.erase(unique(l.begin(), l.end()), l.end());\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // for std::max_element\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n    return *std::max_element(l.begin(), l.end());\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n\n/**\n * Returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n *\n * @param n The upper limit (exclusive) for the range of numbers to check.\n * @return The count of occurrences of the digit 7 in the specified range.\n */\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "vector<float> sort_even(vector<float> l) {\n    // Separate even-indexed elements into a new vector\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector with the sorted even-indexed elements\n    vector<float> result;\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even_elements[even_idx++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encodes a string by cycling groups of three characters.\n * \n * @param s The input string to be encoded.\n * @return The encoded string.\n */\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // Cycle elements in each group, unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\n/**\n * Decodes a string that was encoded with the encode_cyclic function.\n * \n * @param s The input string to be decoded.\n * @return The decoded string.\n */\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // Reverse the cycling of elements in each group.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate Fibonacci numbers\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; i++) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0;\n    int fib_num = 0;\n    while (count < n) {\n        fib_num = fibonacci(fib_num + 1);\n        if (is_prime(fib_num)) {\n            count++;\n        }\n    }\n    return fib_num;\n}\n\n"}
{"task_id": "CPP/40", "generation": "bool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to make it easier to find triples\n    sort(l.begin(), l.end());\n\n    // Iterate over the vector\n    for (int i = 0; i < l.size() - 2; i++) {\n        // Skip duplicates to ensure distinct elements\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        // Initialize two pointers, one at the next element and one at the end\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        // Move the pointers towards each other until they meet\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            // If the sum is zero, return true\n            if (sum == 0) return true;\n\n            // If the sum is less than zero, move the left pointer to the right\n            if (sum < 0) left++;\n\n            // If the sum is greater than zero, move the right pointer to the left\n            else right--;\n        }\n    }\n\n    // If no triples are found, return false\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\n/**\n * Calculate the number of collisions between two sets of cars moving in opposite directions.\n *\n * @param n The number of cars in each set.\n * @return The total number of collisions.\n */\nint car_race_collision(int n) {\n    // Since all cars move at the same speed, each car in one set will collide with each car in the other set.\n    // Therefore, the total number of collisions is the product of the number of cars in each set.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a new vector with each element incremented by 1.\n *\n * @param l The input vector to increment.\n * @return A new vector with each element incremented by 1.\n */\nvector<int> incr_vector(vector<int> l) {\n    // Create a new vector to store the incremented elements\n    vector<int> result;\n    \n    // Iterate over each element in the input vector\n    for (int elem : l) {\n        // Increment the element by 1 and add it to the result vector\n        result.push_back(elem + 1);\n    }\n    \n    // Return the result vector\n    return result;\n}\n\n"}
{"task_id": "CPP/43", "generation": "bool pairs_sum_to_zero(vector<int> l) {\n    // Create a set to store the elements we've seen so far\n    set<int> seen;\n\n    // Iterate over the vector\n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            // If it is, return true\n            return true;\n        }\n        // Otherwise, add the current number to the set\n        seen.insert(num);\n    }\n\n    // If we've iterated over the entire vector and haven't found a pair that sums to zero, return false\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "string change_base(int x, int base) {\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "/**\n * Calculates the area of a triangle given the length of a side and the height.\n *\n * @param a The length of a side of the triangle.\n * @param h The height of the triangle.\n * @return The area of the triangle.\n */\nfloat triangle_area(float a, float h) {\n    // The formula for the area of a triangle is (base * height) / 2.\n    // In this case, we're assuming 'a' is the base and 'h' is the height.\n    return (a * h) / 2;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n\n/**\n * Compute the n-th element of the Fib4 number sequence.\n *\n * The Fib4 sequence is defined as:\n *   fib4(0) -> 0\n *   fib4(1) -> 0\n *   fib4(2) -> 2\n *   fib4(3) -> 0\n *   fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n *\n * This implementation uses dynamic programming to efficiently compute the n-th element.\n *\n * @param n The index of the element to compute.\n * @return The n-th element of the Fib4 sequence.\n */\nint fib4(int n) {\n    if (n <= 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib4_prev = 0;  // fib4(n-4)\n    int fib4_prev2 = 2;  // fib4(n-3)\n    int fib4_prev3 = 0;  // fib4(n-2)\n    int fib4_prev4 = 0;  // fib4(n-1)\n\n    for (int i = 4; i <= n; i++) {\n        int fib4_curr = fib4_prev + fib4_prev2 + fib4_prev3 + fib4_prev4;\n        fib4_prev = fib4_prev2;\n        fib4_prev2 = fib4_prev3;\n        fib4_prev3 = fib4_prev4;\n        fib4_prev4 = fib4_curr;\n    }\n\n    return fib4_prev4;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns the median of elements in the vector l.\n *\n * @param l A vector of floating point numbers.\n * @return The median of the elements in the vector.\n */\nfloat median(vector<float> l) {\n    // First, we need to sort the vector in ascending order\n    sort(l.begin(), l.end());\n\n    // Get the size of the vector\n    int n = l.size();\n\n    // If the size of the vector is odd, the median is the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size of the vector is even, the median is the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a given string is a palindrome.\n *\n * A palindrome is a string that reads the same backward as forward.\n *\n * @param text The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\n/**\n * Returns 2^n modulo p.\n *\n * @param n The exponent.\n * @param p The modulus.\n * @return 2^n modulo p.\n */\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encodes a string by shifting every character by 5 positions in the alphabet.\n *\n * @param s The input string to be encoded.\n * @return The encoded string.\n */\nstring encode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n\n/**\n * Decodes a string that was previously encoded with the encode_shift function.\n *\n * @param s The input string to be decoded.\n * @return The decoded string.\n */\nstring decode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "string remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns true if all numbers in the vector l are below threshold t.\n *\n * @param l A vector of integers.\n * @param t The threshold value.\n * @return True if all numbers in l are below t, false otherwise.\n */\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "bool same_chars(string s0, string s1) {\n    // Create a set of unique characters from each string\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n\n    // Compare the two sets\n    return chars0 == chars1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    int a = 0, b = 1, result = 0;\n    for (int i = 2; i <= n; i++) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if every opening bracket has a corresponding closing bracket.\n *\n * @param brackets a string of '<' and '>'\n * @return true if brackets are correctly paired, false otherwise\n */\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false; // more closing brackets than opening\n            }\n        }\n    }\n    return balance == 0; // all opening brackets have a corresponding closing bracket\n}\n"}
{"task_id": "CPP/57", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Returns true if the vector elements are monotonically increasing or decreasing.\n *\n * @param l The input vector.\n * @return True if the vector is monotonically increasing or decreasing, false otherwise.\n */\nbool monotonic(const std::vector<float>& l) {\n    if (l.size() <= 1) {\n        return true; // A single element or empty vector is considered monotonic.\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Returns a sorted vector of unique common elements between two input vectors.\n *\n * @param l1 First input vector.\n * @param l2 Second input vector.\n * @return A sorted vector of unique common elements.\n */\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Find the intersection of the two vectors\n    vector<int> intersection;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n                     back_inserter(intersection));\n\n    // Remove duplicates by converting to a set and back to a vector\n    set<int> unique_elements(intersection.begin(), intersection.end());\n    intersection.assign(unique_elements.begin(), unique_elements.end());\n\n    // Sort the resulting vector\n    sort(intersection.begin(), intersection.end());\n\n    return intersection;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n\n// Function to check if a number is prime\nint is_prime(int num) {\n    if (num <= 1) return 0;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Function to find the largest prime factor of a number\nint largest_prime_factor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            if (is_prime(n / i)) return n / i;\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\n// Function to calculate the sum of numbers from 1 to n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if every opening bracket in the input string has a corresponding closing bracket.\n *\n * @param brackets A string of '(' and ')'.\n * @return True if the bracketing is correct, false otherwise.\n */\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Keep track of the balance of opening and closing brackets\n\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++; // Increment balance when we see an opening bracket\n        } else if (c == ')') {\n            balance--; // Decrement balance when we see a closing bracket\n            if (balance < 0) {\n                return false; // If balance goes negative, there's an extra closing bracket\n            }\n        }\n    }\n\n    return balance == 0; // Return true if balance is zero, meaning every opening bracket has a corresponding closing bracket\n}\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Returns the derivative of a polynomial represented by its coefficients.\n *\n * The input vector xs represents the coefficients of a polynomial:\n * xs[0] + xs[1] * x + xs[2] * x^2 + ...\n *\n * The output vector represents the coefficients of the derivative of this polynomial.\n *\n * @param xs Coefficients of the polynomial\n * @return Coefficients of the derivative of the polynomial\n */\nvector<float> derivative(vector<float> xs) {\n    vector<float> derivative_xs;\n    for (int i = 1; i < xs.size(); i++) {\n        derivative_xs.push_back(i * xs[i]);\n    }\n    return derivative_xs;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\n\n/**\n * Compute the n-th element of the FibFib number sequence.\n *\n * The FibFib sequence is defined as:\n *   fibfib(0) == 0\n *   fibfib(1) == 0\n *   fibfib(2) == 1\n *   fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n *\n * @param n The index of the element to compute.\n * @return The n-th element of the FibFib sequence.\n */\nint fibfib(int n) {\n  if (n <= 1) return 0; // base cases\n  if (n == 2) return 1; // base case\n\n  // Use dynamic programming to store previously computed values\n  int fibfib_values[n + 1];\n  fibfib_values[0] = 0;\n  fibfib_values[1] = 0;\n  fibfib_values[2] = 1;\n\n  // Compute the n-th element using the recurrence relation\n  for (int i = 3; i <= n; i++) {\n    fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n  }\n\n  return fibfib_values[n];\n}\n"}
{"task_id": "CPP/64", "generation": "int vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        switch (tolower(c)) {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n                count++;\n                break;\n            case 'y':\n                if (c == s.back()) {\n                    count++;\n                }\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n * If shift > number of digits, return digits reversed.\n *\n * @param x The integer to shift\n * @param shift The number of positions to shift\n * @return The shifted integer as a string\n */\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str = to_string(x);\n\n    // Calculate the effective shift, taking into account the length of the string\n    int effective_shift = shift % str.length();\n\n    // If the effective shift is 0, return the original string\n    if (effective_shift == 0) {\n        return str;\n    }\n\n    // Otherwise, perform the circular shift\n    string result = str.substr(str.length() - effective_shift) + str.substr(0, str.length() - effective_shift);\n\n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the sum of the ASCII codes of the upper case characters in the input string.\n *\n * @param s The input string.\n * @return The sum of the ASCII codes of the upper case characters.\n */\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Parse the string to extract the number of apples and oranges\n    int apples, oranges;\n    stringstream ss(s);\n    ss >> apples;\n    ss.ignore(7); // ignore \"apples and \"\n    ss >> oranges;\n    ss.ignore(8); // ignore \"oranges\"\n\n    // Calculate the number of mango fruits\n    int mangoes = n - apples - oranges;\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits>\n\n/**\n * Plucks the node with the smallest even value from the given tree branch.\n * If multiple nodes have the same smallest even value, returns the node with the smallest index.\n * If no even values are found or the input vector is empty, returns an empty vector.\n *\n * @param arr The input vector representing the tree branch.\n * @return A vector containing the smallest even value and its index, or an empty vector if no even values are found.\n */\nvector<int> pluck(vector<int> arr) {\n    int smallestEven = std::numeric_limits<int>::max(); // Initialize with max int value\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallestEven) {\n            smallestEven = arr[i];\n            smallestIndex = i;\n        }\n    }\n\n    if (smallestIndex == -1) {\n        return {}; // Return empty vector if no even values are found\n    }\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint search(std::vector<int> lst) {\n    // Create a frequency map to store the count of each integer\n    std::unordered_map<int, int> freqMap;\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n\n    // Iterate through the frequency map to find the greatest integer\n    // that has a frequency greater than or equal to its value\n    int maxNum = -1;\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > maxNum) {\n            maxNum = pair.first;\n        }\n    }\n\n    return maxNum;\n}\n\n"}
{"task_id": "CPP/70", "generation": "vector<int> strange_sort_list(vector<int> lst) {\n    if (lst.empty()) return lst; // edge case: empty list\n\n    vector<int> result;\n    bool is_min = true; // flag to alternate between min and max\n\n    while (!lst.empty()) {\n        if (is_min) {\n            auto min_it = min_element(lst.begin(), lst.end());\n            result.push_back(*min_it);\n            lst.erase(min_it);\n        } else {\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n        is_min = !is_min; // toggle flag\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Calculates the area of a triangle given the lengths of its three sides.\n * \n * @param a The length of the first side.\n * @param b The length of the second side.\n * @param c The length of the third side.\n * @return The area of the triangle rounded to 2 decimal points if the sides form a valid triangle, -1 otherwise.\n */\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return roundf(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    if (q != reversed_q) {\n        return false; // Not a palindrome, won't fly\n    }\n\n    // Check if the sum of elements is less than or equal to the maximum weight\n    int sum = 0;\n    for (int i : q) {\n        sum += i;\n    }\n    if (sum > w) {\n        return false; // Too heavy, won't fly\n    }\n\n    return true; // Balanced and not too heavy, will fly\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the minimum number of elements that need to be changed to make the vector palindromic.\n *\n * @param arr The input vector of integers.\n * @return The minimum number of changes required.\n */\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end of the vector, moving towards the center.\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0, sum2 = 0;\n    \n    // Calculate the total number of characters in lst1\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n    \n    // Calculate the total number of characters in lst2\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n    \n    // Return the list with fewer characters\n    return (sum1 <= sum2) ? lst1 : lst2;\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if a number is the product of 3 prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all prime numbers less than 100\n    std::vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) primes.push_back(i);\n    }\n\n    // Check all combinations of 3 prime numbers\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i; j < primes.size(); j++) {\n            for (int k = j; k < primes.size(); k++) {\n                if (a == primes[i] * primes[j] * primes[k]) return true;\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns true if x is a simple power of n, false otherwise.\n * A simple power of n is a number that can be expressed as n^int, where int is an integer.\n *\n * @param x The number to check.\n * @param n The base number.\n * @return True if x is a simple power of n, false otherwise.\n */\nbool is_simple_power(int x, int n) {\n    if (x <= 0 || n <= 0) {\n        return false; // Simple powers are positive numbers\n    }\n\n    double logResult = log(x) / log(n);\n    return logResult == (int)logResult; // Check if logResult is an integer\n}\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns true if the given integer is a cube of some integer number.\n *\n * @param a The input integer to check.\n * @return True if a is a cube, false otherwise.\n */\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    double cubeRoot = pow(abs(a), 1.0 / 3.0);\n    \n    // Check if the cube root is an integer\n    return cubeRoot == (int)cubeRoot;\n}\n"}
{"task_id": "CPP/78", "generation": "int hex_key(string num) {\n    int count = 0;\n    string prime_digits = \"2357BD\";\n    for (char c : num) {\n        if (prime_digits.find(c) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\n#include <bitset> // for std::bitset\n\nusing namespace std;\n\n/**\n * Converts a decimal number to binary format.\n *\n * @param decimal The decimal number to convert.\n * @return A string representing the binary number, with \"db\" at the beginning and end.\n */\nstring decimal_to_binary(int decimal) {\n    // Convert the decimal number to binary using std::bitset\n    bitset<32> binary(decimal); // 32 bits is enough for most integers\n\n    // Convert the binary bitset to a string\n    string binary_str = binary.to_string();\n\n    // Remove leading zeros\n    size_t pos = binary_str.find('1');\n    if (pos != string::npos) {\n        binary_str = binary_str.substr(pos);\n    }\n\n    // Add \"db\" at the beginning and end\n    return \"db\" + binary_str + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a string is happy.\n * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n *\n * @param s The input string.\n * @return True if the string is happy, false otherwise.\n */\nbool is_happy(string s) {\n    // Check if the string length is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate over the string with a sliding window of size 3\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the current 3 consecutive letters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If we reach this point, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Converts a vector of GPAs to a vector of letter grades.\n *\n * @param grades A vector of GPAs.\n * @return A vector of letter grades corresponding to the input GPAs.\n */\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa >= 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa >= 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa >= 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa >= 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa >= 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa >= 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa >= 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa >= 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa >= 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa >= 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if the length of the input string is a prime number, false otherwise.\n *\n * @param str The input string.\n * @return True if the length of the string is prime, false otherwise.\n */\nbool prime_length(string str) {\n    int length = str.length();\n    if (length <= 1) {\n        return false; // 0 and 1 are not prime numbers\n    }\n\n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) {\n            return false; // if length is divisible by any number, it's not prime\n        }\n    }\n\n    return true; // if no divisors found, length is prime\n}\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n\n/**\n * Returns the count of n-digit positive integers that start or end with 1.\n *\n * @param n The number of digits in the integers.\n * @return The count of n-digit positive integers that start or end with 1.\n */\nint starts_one_ends(int n) {\n    // Calculate the total number of n-digit positive integers\n    int total = 9 * pow(10, n - 1);\n\n    // Calculate the number of n-digit positive integers that start with 1\n    int starts_with_one = pow(10, n - 1);\n\n    // Calculate the number of n-digit positive integers that end with 1\n    int ends_with_one = 9 * pow(10, n - 2) * 9;\n\n    // Subtract the overlap (numbers that start and end with 1)\n    int overlap = pow(10, n - 2);\n\n    // Return the total count\n    return starts_with_one + ends_with_one - overlap;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the sum of digits of a given integer N as a binary string.\n *\n * @param N a positive integer\n * @return a string representing the sum of digits in binary\n */\nstring solve(int N) {\n    int sum = 0; // Initialize sum to 0\n    while (N > 0) { // Loop until N becomes 0\n        sum += N % 10; // Add the last digit to the sum\n        N /= 10; // Remove the last digit from N\n    }\n    // Convert the sum to binary and return as a string\n    return bitset<32>(sum).to_string();\n}\n"}
{"task_id": "CPP/85", "generation": "#include <stdio.h>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "string anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        // If the character is a space, add the sorted word to the result and reset the word\n        if (c == ' ') {\n            sort(word.begin(), word.end()); // Sort the characters in the word\n            result += word + \" \"; // Add the sorted word to the result\n            word = \"\"; // Reset the word\n        } else {\n            word += c; // Add the character to the current word\n        }\n    }\n    \n    // Sort and add the last word to the result\n    sort(word.begin(), word.end());\n    result += word;\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate over each row in the list\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate over each element in the row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the element is equal to x\n            if (lst[i][j] == x) {\n                // Add the coordinates to the result vector\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the coordinates by row in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // Sort the coordinates of each row by column in descending order\n    for (int i = 0; i < coordinates.size(); i++) {\n        int row = coordinates[i][0];\n        int start = i;\n        while (i < coordinates.size() && coordinates[i][0] == row) {\n            i++;\n        }\n        sort(coordinates.begin() + start, coordinates.begin() + i, [](const vector<int>& a, const vector<int>& b) {\n            return a[1] > b[1];\n        });\n        i--;\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a copy of the given vector after sorting.\n * The sorting order is determined by the sum of the first and last index values.\n * If the sum is odd, the vector is sorted in ascending order.\n * If the sum is even, the vector is sorted in descending order.\n *\n * @param array The input vector to be sorted.\n * @return A new sorted vector.\n */\nvector<int> sort_array(vector<int> array) {\n    // Calculate the sum of the first and last index values\n    int sum = array.empty() ? 0 : array[0] + array.back();\n\n    // Create a copy of the input vector\n    vector<int> sorted_array = array;\n\n    // Sort the copied vector based on the sum\n    if (sum % 2 == 0) {\n        // Sort in descending order if the sum is even\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Sort in ascending order if the sum is odd\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <string>\n\n/**\n * Encrypts a string by rotating the alphabet down by 2 places.\n *\n * @param s The input string to be encrypted.\n * @return The encrypted string.\n */\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Rotate lowercase letters down by 2 places\n            result += 'a' + (c - 'a' + 2) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            // Rotate uppercase letters down by 2 places\n            result += 'A' + (c - 'A' + 2) % 26;\n        } else {\n            // Non-alphabet characters remain unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "int next_smallest(vector<int> lst) {\n    // Check if the list is empty\n    if (lst.empty()) {\n        return -1; // Return -1 to indicate no 2nd smallest element\n    }\n\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n\n    // Check if there are at least two distinct elements\n    if (lst.size() < 2 || lst[0] == lst[1]) {\n        return -1; // Return -1 to indicate no 2nd smallest element\n    }\n\n    // Return the 2nd smallest element\n    return lst[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Counts the number of boredoms in a given string.\n * A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n *\n * @param S The input string.\n * @return The number of boredoms.\n */\nint is_bored(string S) {\n    int boredom_count = 0;\n    size_t pos = 0;\n    while ((pos = S.find_first_of(\".!?\")) != string::npos) {\n        string sentence = S.substr(0, pos);\n        if (sentence.find(\"I\") == 0) {\n            boredom_count++;\n        }\n        S.erase(0, pos + 1);\n    }\n    // Check the last sentence\n    if (S.find(\"I\") == 0) {\n        boredom_count++;\n    }\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != (int)a || b != (int)b || c != (int)c) {\n        return false;\n    }\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/93", "generation": "string encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n\n    for (char c : message) {\n        // Swap case of all letters\n        if (isupper(c)) {\n            c = tolower(c);\n        } else {\n            c = toupper(c);\n        }\n\n        // Replace vowels with the letter 2 places ahead\n        size_t pos = vowels.find(c);\n        if (pos != string::npos) {\n            int offset = (pos % 5) + 2; // 5 vowels in total\n            c = vowels[(pos + offset) % 10]; // wrap around to the beginning\n        }\n\n        result += c;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    // Find the largest prime number in the list\n    int maxPrime = 0;\n    for (int num : lst) {\n        if (isPrime(num) && num > maxPrime) {\n            maxPrime = num;\n        }\n    }\n\n    // If no prime number is found, return 0\n    if (maxPrime == 0) return 0;\n\n    // Return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\n/**\n * Checks if all keys in a map are strings and are either all in lower case or all in upper case.\n *\n * @param dict The input map to check.\n * @return True if all keys are strings and are either all in lower case or all in upper case, false otherwise.\n */\nbool check_dict_case(map<string, string> dict) {\n    // If the map is empty, return false\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Check if all keys are strings (this is always true in C++ since map keys are typed)\n    // Check if all keys are either all in lower case or all in upper case\n    bool allLower = true;\n    bool allUpper = true;\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        for (char c : key) {\n            if (isupper(c)) {\n                allLower = false;\n            } else if (islower(c)) {\n                allUpper = false;\n            } else {\n                // If the key contains a non-alphabetic character, return false\n                return false;\n            }\n        }\n    }\n\n    // If all keys are either all in lower case or all in upper case, return true\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n/**\n * Returns a vector of the first n prime numbers less than n.\n *\n * @param n A non-negative integer.\n * @return A vector of prime numbers less than n.\n */\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n\nint multiply(int a, int b) {\n    // Get the unit digits of a and b\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Counts the number of uppercase vowels in even indices of a given string.\n *\n * @param s The input string.\n * @return The number of uppercase vowels in even indices.\n */\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        // Check if the index is even\n        if (i % 2 == 0) {\n            // Check if the character is an uppercase vowel\n            if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "int closest_integer(string value) {\n    double num = stod(value); // convert string to double\n    double fractional_part = num - floor(num); // get fractional part\n\n    if (fractional_part < 0.5) {\n        return floor(num); // round down\n    } else if (fractional_part > 0.5) {\n        return ceil(num); // round up\n    } else {\n        // equidistant from two integers, round away from zero\n        if (num > 0) {\n            return ceil(num);\n        } else {\n            return floor(num);\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Creates a pile of n levels of stones, where the number of stones in each level\n * is determined by the parity of the initial number of stones.\n *\n * @param n The initial number of stones.\n * @return A vector of integers, where each element represents the number of stones\n *         in the corresponding level.\n */\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current = n;\n\n    // Loop until we have n levels\n    for (int i = 0; i < n; i++) {\n        // Add the current number of stones to the vector\n        stones.push_back(current);\n\n        // Determine the next number of stones based on the parity of the current number\n        if (current % 2 == 0) { // even\n            current += 2; // next even number\n        } else { // odd\n            current += 2; // next odd number\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Splits a string of words separated by commas or spaces into a vector of words.\n *\n * @param s The input string of words.\n * @return A vector of words.\n */\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "/**\n * Returns the biggest even integer number in the range [x, y] inclusive.\n * If no such number exists, returns -1.\n *\n * @param x The start of the range (inclusive).\n * @param y The end of the range (inclusive).\n * @return The biggest even integer number in the range, or -1 if none exists.\n */\nint choose_num(int x, int y) {\n    // Check if the range is valid (x <= y)\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and work backwards\n    for (int i = y; i >= x; i--) {\n        // Check if the current number is even\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "string rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    int sum = (n + m) * (m - n + 1) / 2;\n    int avg = floor((double)sum / (m - n + 1));\n\n    string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a sorted vector of all elements that haven't any even digit.\n *\n * @param x A vector of positive integers.\n * @return A sorted vector of integers without any even digit.\n */\nvector<int> unique_digits(vector<int> x) {\n    // Filter out numbers with even digits\n    vector<int> result;\n    for (int num : x) {\n        bool hasEvenDigit = false;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                hasEvenDigit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert numbers to their corresponding names\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map numbers to their corresponding names\n    map<int, string> num_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Convert numbers to their corresponding names\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_name[num]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a vector of size n, where the value at index i is the factorial of i if i is even,\n * or the sum of numbers from 1 to i otherwise.\n *\n * @param n The size of the vector to return.\n * @return A vector of size n with the calculated values.\n */\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) { // i is even\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else { // i is odd\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a vector containing the number of even and odd integer palindromes\n * within the range [1, n].\n *\n * @param n A positive integer.\n * @return A vector of two integers, where the first element is the number of even\n *         integer palindromes and the second element is the number of odd integer\n *         palindromes.\n */\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate over the range [1, n]\n    for (int i = 1; i <= n; i++) {\n        // Convert the integer to a string to check if it's a palindrome\n        string str = to_string(i);\n        string rev_str = str;\n        reverse(rev_str.begin(), rev_str.end());\n\n        // Check if the string is a palindrome\n        if (str == rev_str) {\n            // Check if the palindrome is even or odd\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "int count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int sign = (num < 0) ? -1 : 1;\n        num = abs(num);\n        while (num > 0) {\n            sum += sign * (num % 10);\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "bool move_one_ball(vector<int> arr) {\n    // Handle edge case: empty vector\n    if (arr.empty()) {\n        return true;\n    }\n\n    // Find the index of the smallest element\n    int min_idx = 0;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n\n    // Check if the vector is sorted in non-decreasing order starting from the smallest element\n    for (int i = min_idx; i < arr.size() - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n\n    // If we reach here, it means the vector can be sorted by performing right shift operations\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "string exchange(vector<int> lst1, vector<int> lst2) {\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountInLst1++;\n        }\n    }\n\n    return (evenCountInLst2 >= oddCountInLst1) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\n/**\n * Returns a map of the letter(s) with the most repetition and their corresponding count.\n * If several letters have the same occurrence, returns all of them.\n *\n * @param test a string representing a space separated lowercase letters\n * @return a map of char to int, where each key is a letter and its value is the count\n */\nmap<char, int> histogram(string test) {\n    map<char, int> letterCounts;\n    int maxCount = 0;\n\n    // Count the occurrences of each letter\n    for (char c : test) {\n        if (c != ' ') { // ignore spaces\n            letterCounts[c]++;\n            maxCount = max(maxCount, letterCounts[c]);\n        }\n    }\n\n    // Filter the map to only include letters with the maximum count\n    map<char, int> result;\n    for (auto& pair : letterCounts) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are present in c\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversed = result;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = result == reversed;\n\n    // Return the result string and the palindrome check result\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        string temp = \"the number of odd elements \";\n        temp += to_string(odd_count);\n        temp += \"n the str\";\n        temp += to_string(odd_count);\n        temp += \"ng \";\n        temp += to_string(odd_count);\n        temp += \" of the \";\n        temp += to_string(odd_count);\n        temp += \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Finds the minimum sum of any non-empty sub-vector of nums.\n *\n * @param nums A vector of integers.\n * @return The minimum sum of any non-empty sub-vector of nums.\n */\nlong long minSubArraySum(vector<long long> nums) {\n    // Initialize the minimum sum to the first element of the vector\n    long long min_sum = nums[0];\n    \n    // Initialize the current sum to the first element of the vector\n    long long current_sum = nums[0];\n    \n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < nums.size(); i++) {\n        // Update the current sum by adding the current element\n        current_sum = min(nums[i], current_sum + nums[i]);\n        \n        // Update the minimum sum if the current sum is smaller\n        min_sum = min(min_sum, current_sum);\n    }\n    \n    // Return the minimum sum\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n\n"}
{"task_id": "CPP/116", "generation": "vector<int> sort_array(vector<int> arr) {\n    // Use a lambda function as the comparison function for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Calculate the number of ones in the binary representation of a and b\n        int ones_a = __builtin_popcount(abs(a));\n        int ones_b = __builtin_popcount(abs(b));\n\n        // If the number of ones is the same, sort based on decimal value\n        if (ones_a == ones_b) {\n            return a < b;\n        }\n\n        // Otherwise, sort based on the number of ones\n        return ones_a < ones_b;\n    });\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "vector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                int consonants = 0;\n                for (char w : word) {\n                    if (w != 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u' &&\n                        w != 'A' && w != 'E' && w != 'I' && w != 'O' && w != 'U') {\n                        consonants++;\n                    }\n                }\n                if (consonants == n) {\n                    result.push_back(word);\n                }\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    // Handle the last word\n    if (!word.empty()) {\n        int consonants = 0;\n        for (char w : word) {\n            if (w != 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u' &&\n                w != 'A' && w != 'E' && w != 'I' && w != 'O' && w != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "string get_closest_vowel(string word) {\n  // Define the vowels\n  string vowels = \"AEIOUaeiou\";\n\n  // Iterate from the right side of the word\n  for (int i = word.length() - 1; i > 0; --i) {\n    // Check if the current character is a vowel\n    if (vowels.find(word[i]) != string::npos) {\n      // Check if the previous character is a consonant\n      if (vowels.find(word[i - 1]) == string::npos) {\n        // Check if the next character is a consonant\n        if (i + 1 < word.length() && vowels.find(word[i + 1]) == string::npos) {\n          // Return the vowel\n          return string(1, word[i]);\n        }\n      }\n    }\n  }\n\n  // If no vowel is found, return an empty string\n  return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "string match_parens(vector<string> lst) {\n    int count1 = 0, count2 = 0;\n    for (char c : lst[0]) {\n        if (c == '(') count1++;\n        else count1--;\n    }\n    for (char c : lst[1]) {\n        if (c == '(') count2++;\n        else count2--;\n    }\n    return (count1 + count2 == 0 || count1 == -count2) ? \"Yes\" : \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a sorted vector of length k with the maximum k numbers in arr, in ascending order.\n *\n * @param arr A vector of integers.\n * @param k A positive integer.\n * @return A sorted vector of length k with the maximum k numbers in arr.\n */\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the vector in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n\n    // Return the first k elements of the sorted vector\n    return vector<int>(arr.begin(), arr.begin() + k);\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <stdio.h>\n#include <vector>\n\nint solution(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns the sum of the elements with at most two digits from the first k elements of arr.\n *\n * @param arr A non-empty vector of integers.\n * @param k An integer representing the number of elements to consider.\n * @return The sum of the elements with at most two digits from the first k elements of arr.\n */\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < k; i++) { // Iterate over the first k elements of arr\n        if (arr[i] >= 10 && arr[i] <= 99) { // Check if the element has at most two digits\n            sum += arr[i]; // Add the element to the sum\n        }\n    }\n    return sum; // Return the sum\n}\n\n"}
{"task_id": "CPP/123", "generation": "vector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_numbers.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    odd_numbers.push_back(1); // 1 is always an odd number in the sequence\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if date string is not empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Split date string into month, day, and year\n    int month, day, year;\n    char delimiter;\n    stringstream ss(date);\n    ss >> month >> delimiter >> day >> delimiter >> year;\n\n    // Check if date is in the correct format (mm-dd-yyyy)\n    if (ss.fail() || delimiter != '-' || month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid for the given month\n    if (month == 2) {\n        // February has 29 days\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // April, June, September, and November have 30 days\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        // All other months have 31 days\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check if the string contains whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        vector<string> words;\n        size_t pos = 0;\n        while ((pos = txt.find(' ')) != string::npos) {\n            words.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        words.push_back(txt);\n        return words;\n    } else if (txt.find(',') != string::npos) {\n        // Split on commas\n        vector<string> words;\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            words.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        words.push_back(txt);\n        return words;\n    } else {\n        // Count the number of lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z' && (c - 'a') % 2 != 0) {\n                count++;\n            }\n        }\n        return {to_string(count)};\n    }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Returns whether the input vector is sorted in ascending order.\n * If a number appears more than twice, returns false.\n * Assumes no negative numbers and only integers.\n */\nbool is_sorted(vector<int> lst) {\n    // Check if the vector is sorted in ascending order\n    if (!is_sorted(lst.begin(), lst.end())) {\n        return false;\n    }\n\n    // Check if any number appears more than twice\n    for (int i = 0; i < lst.size() - 2; i++) {\n        if (lst[i] == lst[i + 1] && lst[i] == lst[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Find the intersection of the two intervals\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if the intervals intersect\n    if (start > end) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length)) return \"YES\";\n    else return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Returns the sum of magnitudes of integers multiplied by product of all signs\n * of each number in the vector.\n *\n * @param arr A vector of integers.\n * @return The product of signs multiplied by the sum of magnitudes.\n *         Returns -32768 for an empty vector.\n */\nint prod_signs(vector<int> arr) {\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    // Iterate over each element in the vector\n    for (int num : arr) {\n        // Calculate the magnitude of the number\n        int magnitude = abs(num);\n\n        // Update the sum of magnitudes\n        sum_magnitudes += magnitude;\n\n        // Update the product of signs\n        if (num > 0) {\n            product_signs *= 1;\n        } else if (num < 0) {\n            product_signs *= -1;\n        } else {\n            // If the number is 0, the product of signs is 0\n            product_signs = 0;\n        }\n    }\n\n    // If the vector is empty, return -32768\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Return the product of signs multiplied by the sum of magnitudes\n    return product_signs * sum_magnitudes;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Define the directions for moving in the grid\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\n// Function to check if a cell is valid\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\n// Function to find the minimum path\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    vector<int> res;\n\n    // Find the cell with the minimum value\n    int minX = 0, minY = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < grid[minX][minY]) {\n                minX = i;\n                minY = j;\n            }\n        }\n    }\n\n    // Perform BFS to find the minimum path\n    queue<pair<pair<int, int>, vector<int>>> q;\n    q.push({{minX, minY}, {grid[minX][minY]}});\n    while (!q.empty()) {\n        auto [pos, path] = q.front();\n        q.pop();\n        int x = pos.first, y = pos.second;\n        if (path.size() == k) {\n            res = path;\n            break;\n        }\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (isValid(nx, ny, n)) {\n                vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                q.push({{nx, ny}, newPath});\n            }\n        }\n    }\n\n    return res;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the first n+1 numbers of the Tribonacci sequence.\n *\n * @param n A non-negative integer.\n * @return A vector of integers representing the Tribonacci sequence.\n */\nvector<int> tri(int n) {\n    vector<int> sequence(n + 1);\n    sequence[0] = 1;\n    sequence[1] = 3;\n\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            sequence[i] = 1 + i / 2;\n        } else {\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1];\n        }\n    }\n\n    // Handle the case where n is 0 or 1\n    if (n == 0) {\n        sequence.resize(1);\n    } else if (n == 1) {\n        sequence.resize(2);\n    }\n\n    return sequence;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\n\n/**\n * Returns the product of the odd digits of a given positive integer.\n * Returns 0 if all digits are even.\n *\n * @param n A positive integer.\n * @return The product of the odd digits.\n */\nint digits(int n) {\n    int product = 1;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product == 1 ? 0 : product;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a string of square brackets contains a valid subsequence with at least one nested bracket.\n *\n * @param str The input string containing only square brackets.\n * @return True if a valid subsequence with nested brackets exists, false otherwise.\n */\nbool is_nested(string str) {\n    int stack = 0; // Initialize a stack counter\n    for (char c : str) {\n        if (c == '[') {\n            stack++; // Increment stack counter for each opening bracket\n        } else if (c == ']') {\n            if (stack > 1) { // If stack counter is greater than 1, it means we have a nested bracket\n                return true;\n            }\n            stack--; // Decrement stack counter for each closing bracket\n        }\n    }\n    return false; // If no nested brackets are found, return false\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num); // round to upper int\n        sum += rounded_num * rounded_num; // square and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if the last character of a given string is an alphabetical character\n * and is not a part of a word, and false otherwise.\n *\n * @param txt The input string to check.\n * @return true if the last character is a standalone alphabetical character, false otherwise.\n */\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character of the string\n    char last_char = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Check if the last character is part of a word\n    if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n        return false;\n    }\n\n    // If all checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the largest index of an element which is not greater than or equal to \n * the element immediately preceding it. If no such element exists then return -1.\n *\n * @param arr The input vector of integers.\n * @return The largest index of an element which is not greater than or equal to \n * the element immediately preceding it, or -1 if no such element exists.\n */\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int max_index = -1;\n    \n    // Iterate through the array from the second element to the end\n    for (int i = 1; i < n; i++) {\n        // Check if the current element is not greater than or equal to the previous element\n        if (arr[i] < arr[i - 1]) {\n            // Update the max_index if the current index is greater\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector (a, b), where \"a\" is the largest of negative integers,\n * and \"b\" is the smallest of positive integers in the input vector.\n * If there is no negative or positive integers, return them as 0.\n */\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    // Find the largest negative integer\n    for (int num : lst) {\n        if (num < 0 && (largest_negative == 0 || num > largest_negative)) {\n            largest_negative = num;\n        }\n    }\n\n    // Find the smallest positive integer\n    for (int num : lst) {\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert string representations to floats\n    if (a.type() == typeid(string)) {\n        string strA = boost::any_cast<string>(a);\n        replace(strA.begin(), strA.end(), ',', '.');\n        a = stof(strA);\n    }\n    if (b.type() == typeid(string)) {\n        string strB = boost::any_cast<string>(b);\n        replace(strB.begin(), strB.end(), ',', '.');\n        b = stof(strB);\n    }\n\n    // Compare values\n    if (a.type() == typeid(float) || a.type() == typeid(double)) {\n        float fA = boost::any_cast<float>(a);\n        float fB = boost::any_cast<float>(b);\n        if (fA > fB) return a;\n        else if (fA < fB) return b;\n        else return \"None\";\n    } else if (a.type() == typeid(int)) {\n        int iA = boost::any_cast<int>(a);\n        int iB = boost::any_cast<int>(b);\n        if (iA > iB) return a;\n        else if (iA < iB) return b;\n        else return \"None\";\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\n/**\n * Evaluates whether the given number n can be written as the sum of exactly 4 positive even numbers.\n *\n * @param n The number to check.\n * @return True if n can be written as the sum of exactly 4 positive even numbers, false otherwise.\n */\nbool is_equal_to_sum_even(int n) {\n    // We need to find 4 positive even numbers that sum up to n.\n    // The smallest possible even number is 2, so we start from there.\n    for (int a = 2; a <= n / 4; a += 2) {\n        for (int b = a; b <= (n - a) / 3; b += 2) {\n            for (int c = b; c <= (n - a - b) / 2; c += 2) {\n                int d = n - a - b - c;\n                // Check if d is a positive even number.\n                if (d > 0 && d % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/139", "generation": "long long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "string fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces > 2) {\n                result += '-';\n            } else {\n                result += '_';\n            }\n        } else {\n            consecutive_spaces = 0;\n            result += c;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype> // for std::isdigit and std::isalpha\n\nstring file_name_check(const string& file_name) {\n    // Check if the file name contains exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Check if the substring before the dot is not empty and starts with a letter\n    if (dot_pos == 0 || !std::isalpha(file_name[0])) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of the allowed extensions\n    string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (std::isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all checks pass, return \"Yes\"\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "int sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to get words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n\n    // Iterate over each word in the sentence\n    while (ss >> word) {\n        // Check if the length of the word is a prime number\n        if (isPrime(word.length())) {\n            // If it is, append it to the result string\n            result += word + \" \";\n        }\n    }\n\n    // Remove the trailing space from the result string\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nbool simplify(string x, string n) {\n    // Split the input strings into numerator and denominator\n    int x_num, x_den, n_num, n_den;\n    char slash;\n    stringstream(x) >> x_num >> slash >> x_den;\n    stringstream(n) >> n_num >> slash >> n_den;\n\n    // Calculate the product of the numerators and denominators\n    long long product_num = (long long)x_num * n_num;\n    long long product_den = (long long)x_den * n_den;\n\n    // Check if the product is a whole number\n    return product_num % product_den == 0;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <algorithm>\n#include <vector>\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += abs(num % 10);\n        num /= 10;\n    }\n    return sum;\n}\n\n// Custom comparator for sorting\nstruct Comparator {\n    bool operator()(const int& a, const int& b) {\n        int sumA = sumOfDigits(a);\n        int sumB = sumOfDigits(b);\n        if (sumA == sumB) {\n            // If sums are equal, sort based on original index\n            return a < b;\n        }\n        return sumA < sumB;\n    }\n};\n\nvector<int> order_by_points(vector<int> nums) {\n    // Sort the vector using the custom comparator\n    std::sort(nums.begin(), nums.end(), Comparator());\n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "int specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(abs(num)); // convert to string to access digits\n            if (numStr[0] == '1' || numStr[0] == '3' || numStr[0] == '5' || numStr[0] == '7' || numStr[0] == '9') {\n                if (numStr[numStr.size() - 1] == '1' || numStr[numStr.size() - 1] == '3' || numStr[numStr.size() - 1] == '5' || numStr[numStr.size() - 1] == '7' || numStr[numStr.size() - 1] == '9') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n *\n * @param n The length of the integer vector a.\n * @return The number of valid triples.\n */\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Define the order of the planets in our solar system\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nvector<string> bf(string planet1, string planet2) {\n    // Check if both planet names are valid\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() ||\n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {}; // Return an empty vector if either planet name is invalid\n    }\n\n    // Find the indices of the two planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n\n    // Determine the order of the planets\n    bool reverse = it1 > it2;\n\n    // Extract the range of planets between the two input planets\n    auto start = reverse ? it2 + 1 : it1 + 1;\n    auto end = reverse ? it1 : it2;\n\n    // Create a new vector with the extracted range of planets\n    vector<string> result(start, end);\n\n    // If the planets were in reverse order, reverse the result vector\n    if (reverse) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/149", "generation": "vector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\n// Function to check if a number is prime\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Function to return x if n is prime, y otherwise\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && fmod(num, 1) == 0 && fmod(num, 2) != 0) {\n            sum_of_squares += (long long)pow(num, 2);\n        }\n    }\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Compare the actual scores with the guessed scores and return a vector of differences.\n *\n * @param game  A vector of actual scores.\n * @param guess A vector of guessed scores.\n * @return A vector of differences between actual and guessed scores.\n */\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> differences;\n    for (int i = 0; i < game.size(); i++) {\n        int difference = abs(game[i] - guess[i]);\n        differences.push_back(difference);\n    }\n    return differences;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    // Initialize the strongest extension and its strength\n    string strongest_extension = extensions[0];\n    int max_strength = 0;\n\n    // Iterate over each extension\n    for (const auto& extension : extensions) {\n        // Count the number of uppercase and lowercase letters\n        int uppercase_count = 0;\n        int lowercase_count = 0;\n        for (char c : extension) {\n            if (c >= 'A' && c <= 'Z') {\n                uppercase_count++;\n            } else if (c >= 'a' && c <= 'z') {\n                lowercase_count++;\n            }\n        }\n\n        // Calculate the strength of the extension\n        int strength = uppercase_count - lowercase_count;\n\n        // Update the strongest extension if necessary\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the class name with the strongest extension\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if the second word or any of its rotations is a substring in the first word.\n *\n * @param a The first word.\n * @param b The second word.\n * @return True if the second word or any of its rotations is a substring in the first word, false otherwise.\n */\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself to handle rotations\n    string double_a = a + a;\n    \n    // Check if the second word or any of its rotations is a substring in the concatenated string\n    for (int i = 0; i < b.length(); i++) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (double_a.find(rotated_b) != string::npos) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a vector containing the count of even and odd digits in the given integer.\n *\n * @param num The input integer.\n * @return A vector of size 2, where the first element is the count of even digits and the second element is the count of odd digits.\n */\nvector<int> even_odd_count(int num) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Convert the integer to a string to easily iterate over each digit\n    string numStr = to_string(abs(num)); // Use abs to handle negative numbers\n\n    // Iterate over each digit in the string\n    for (char digit : numStr) {\n        int digitValue = digit - '0'; // Convert char to int\n\n        // Check if the digit is even or odd\n        if (digitValue % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return the counts as a vector\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/156", "generation": "string int_to_mini_roman(int number) {\n    // Define the mapping of integers to roman numerals\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result;\n    for (const auto& pair : roman_numerals) {\n        // Subtract the largest possible roman numeral value from the number\n        while (number >= pair.first) {\n            number -= pair.first;\n            result += pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns true if the three sides form a right-angled triangle, false otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or 90 degree.\n *\n * @param a The length of the first side.\n * @param b The length of the second side.\n * @param c The length of the third side.\n * @return True if the three sides form a right-angled triangle, false otherwise.\n */\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides in ascending order\n    if (a > b) {\n        float temp = a;\n        a = b;\n        b = temp;\n    }\n    if (b > c) {\n        float temp = b;\n        b = c;\n        c = temp;\n    }\n\n    // Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return (a * a + b * b == c * c);\n}\n\n"}
{"task_id": "CPP/158", "generation": "string find_max(vector<string> words) {\n    // Use the max_element function with a custom comparator\n    return *max_element(words.begin(), words.end(),\n        [](const string& a, const string& b) {\n            // Count unique characters in each string\n            int unique_a = unique(a.begin(), a.end()) - a.begin();\n            int unique_b = unique(b.begin(), b.end()) - b.begin();\n\n            // If unique character counts are equal, compare lexicographically\n            if (unique_a == unique_b) {\n                return a > b;\n            }\n            return unique_a < unique_b;\n        });\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots needed\n    int total_needed = number + need;\n    \n    // Calculate the total number of carrots eaten\n    int total_eaten = min(total_needed, number + remaining);\n    \n    // Calculate the number of carrots left\n    int carrots_left = remaining - (total_eaten - number);\n    \n    // Return the result as a vector\n    return {total_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nint do_algebra(const std::vector<std::string>& operators, const std::vector<int>& operands) {\n    if (operators.size() != operands.size() - 1) {\n        throw std::invalid_argument(\"Number of operators must be one less than number of operands\");\n    }\n\n    int result = operands[0];\n    for (size_t i = 0; i < operators.size(); ++i) {\n        const std::string& op = operators[i];\n        int operand = operands[i + 1];\n\n        if (op == \"+\") {\n            result += operand;\n        } else if (op == \"-\") {\n            result -= operand;\n        } else if (op == \"*\") {\n            result *= operand;\n        } else if (op == \"//\") {\n            result /= operand;\n        } else if (op == \"**\") {\n            result = pow(result, operand);\n        } else {\n            throw std::invalid_argument(\"Invalid operator: \" + op);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "string solve(string s) {\n    // Check if the string contains any letters\n    bool hasLetters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If the string contains letters, reverse their case\n    if (hasLetters) {\n        for (char& c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } \n    // If the string contains no letters, reverse the string\n    else {\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), hash);\n\n    string md5_hash;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        char hex[3];\n        sprintf(hex, \"%02x\", hash[i]);\n        md5_hash += hex;\n    }\n\n    return md5_hash;\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n/**\n * Returns a vector of even digits between a and b (inclusive) in ascending order.\n * \n * @param a The lower bound (inclusive).\n * @param b The upper bound (inclusive).\n * @return A vector of even digits between a and b.\n */\nvector<int> generate_integers(int a, int b) {\n    // Swap a and b if a is greater than b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> even_digits;\n\n    // Iterate from a to b\n    for (int i = a; i <= b; i++) {\n        // Check if the number is even and less than 10\n        if (i % 2 == 0 && i < 10) {\n            even_digits.push_back(i);\n        }\n    }\n\n    // Sort the vector in ascending order\n    sort(even_digits.begin(), even_digits.end());\n\n    return even_digits;\n}\n\n"}
