{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\n/**\n * Calculate the number of collisions between two sets of cars moving in opposite directions.\n *\n * @param n The number of cars in each set.\n * @return The total number of collisions.\n */\nint car_race_collision(int n) {\n    // Since all cars move at the same speed, each car in one set will collide with each car in the other set.\n    // Therefore, the total number of collisions is the product of the number of cars in each set.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/116", "generation": "vector<int> sort_array(vector<int> arr) {\n    // Use a lambda function as the comparison function for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Calculate the number of ones in the binary representation of a and b\n        int ones_a = __builtin_popcount(abs(a));\n        int ones_b = __builtin_popcount(abs(b));\n\n        // If the number of ones is the same, sort based on decimal value\n        if (ones_a == ones_b) {\n            return a < b;\n        }\n\n        // Otherwise, sort based on the number of ones\n        return ones_a < ones_b;\n    });\n\n    return arr;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if every opening bracket in the input string has a corresponding closing bracket.\n *\n * @param brackets A string of '(' and ')'.\n * @return True if the bracketing is correct, false otherwise.\n */\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Keep track of the balance of opening and closing brackets\n\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++; // Increment balance when we see an opening bracket\n        } else if (c == ')') {\n            balance--; // Decrement balance when we see a closing bracket\n            if (balance < 0) {\n                return false; // If balance goes negative, there's an extra closing bracket\n            }\n        }\n    }\n\n    return balance == 0; // Return true if balance is zero, meaning every opening bracket has a corresponding closing bracket\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a vector of prime factors of the given integer in the order from smallest to largest.\n * Each factor is repeated the number of times it appears in the factorization.\n * The input number is equal to the product of all factors.\n *\n * @param n The input integer to factorize.\n * @return A vector of prime factors.\n */\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/137", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert string inputs to float, handling both '.' and ',' as decimal separators\n    if (a.type() == typeid(string)) {\n        string strA = boost::any_cast<string>(a);\n        replace(strA.begin(), strA.end(), ',', '.');\n        a = stof(strA);\n    }\n    if (b.type() == typeid(string)) {\n        string strB = boost::any_cast<string>(b);\n        replace(strB.begin(), strB.end(), ',', '.');\n        b = stof(strB);\n    }\n\n    // Compare the values\n    if (a.type() == typeid(int) && b.type() == typeid(int)) {\n        int intA = boost::any_cast<int>(a);\n        int intB = boost::any_cast<int>(b);\n        return (intA > intB) ? a : ((intA < intB) ? b : \"None\");\n    } else if (a.type() == typeid(float) && b.type() == typeid(float)) {\n        float floatA = boost::any_cast<float>(a);\n        float floatB = boost::any_cast<float>(b);\n        return (floatA > floatB) ? a : ((floatA < floatB) ? b : \"None\");\n    } else {\n        float floatA = boost::any_cast<float>(a);\n        float floatB = boost::any_cast<float>(b);\n        return (floatA > floatB) ? a : ((floatA < floatB) ? b : \"None\");\n    }\n}\n"}
{"task_id": "CPP/102", "generation": "/**\n * Returns the biggest even integer number in the range [x, y] inclusive.\n * If no such number exists, returns -1.\n *\n * @param x The start of the range (inclusive).\n * @param y The end of the range (inclusive).\n * @return The biggest even integer number in the range, or -1 if none exists.\n */\nint choose_num(int x, int y) {\n    // Check if the range is valid (x <= y)\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and work backwards\n    for (int i = y; i >= x; i--) {\n        // Check if the current number is even\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a given string is a palindrome.\n *\n * @param str The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(string str) {\n    // Create a reversed copy of the input string\n    string s(str.rbegin(), str.rend());\n    // Compare the original string with its reversed copy\n    return s == str;\n}\n\n/**\n * Finds the shortest palindrome that begins with a supplied string.\n *\n * Algorithm idea:\n * 1. Find the longest postfix of the supplied string that is a palindrome.\n * 2. Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n *\n * @param str The input string to make a palindrome.\n * @return The shortest palindrome that begins with the input string.\n */\nstring make_palindrome(string str) {\n    // Handle the edge case where the input string is empty\n    if (str.empty()) {\n        return \"\";\n    }\n\n    // Initialize variables to store the longest palindromic postfix and its length\n    string longest_palindromic_postfix = \"\";\n    int longest_palindromic_postfix_length = 0;\n\n    // Iterate over the input string to find the longest palindromic postfix\n    for (int i = str.length() - 1; i >= 0; --i) {\n        // Extract the postfix from the input string\n        string postfix = str.substr(i);\n        // Check if the postfix is a palindrome\n        if (is_palindrome(postfix)) {\n            // Update the longest palindromic postfix if the current postfix is longer\n            if (postfix.length() > longest_palindromic_postfix_length) {\n                longest_palindromic_postfix = postfix;\n                longest_palindromic_postfix_length = postfix.length();\n            }\n        }\n    }\n\n    // Find the prefix that comes before the longest palindromic postfix\n    string prefix = str.substr(0, str.length() - longest_palindromic_postfix_length);\n\n    // Reverse the prefix\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n\n    // Append the reversed prefix to the end of the input string\n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/76", "generation": "bool is_simple_power(int x, int n) {\n    if (x <= 0 || n <= 0) {\n        return false;\n    }\n    int exp = 0;\n    while (pow(n, exp) <= x) {\n        if (pow(n, exp) == x) {\n            return true;\n        }\n        exp++;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    // Find the largest prime number in the list\n    int maxPrime = 0;\n    for (int num : lst) {\n        if (isPrime(num) && num > maxPrime) {\n            maxPrime = num;\n        }\n    }\n\n    // If no prime number is found, return 0\n    if (maxPrime == 0) return 0;\n\n    // Return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0.0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble polyDerivative(const std::vector<double>& xs, double x) {\n    double sum = 0.0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    if (xs.size() % 2 != 0) {\n        throw std::invalid_argument(\"The number of coefficients must be even\");\n    }\n    if (xs.back() == 0.0) {\n        throw std::invalid_argument(\"The largest non-zero coefficient must be at the end\");\n    }\n\n    double x = 1.0; // initial guess\n    while (true) {\n        double f_x = poly(xs, x);\n        double f_prime_x = polyDerivative(xs, x);\n        double x_next = x - f_x / f_prime_x;\n        if (std::abs(x_next - x) < 1e-6) { // convergence criterion\n            return x_next;\n        }\n        x = x_next;\n    }\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * This function takes a vector l and returns a vector l' such that\n * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n * to the values of the corresponding indicies of l, but sorted in ascending order.\n */\nvector<int> sort_third(vector<int> l) {\n    // Create a new vector to store the values at indices divisible by 3\n    vector<int> third_values;\n    \n    // Iterate over the input vector and extract values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the extracted values in ascending order\n    sort(third_values.begin(), third_values.end());\n    \n    // Create a new vector to store the result\n    vector<int> result = l;\n    \n    // Iterate over the input vector and replace values at indices divisible by 3 with the sorted values\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = third_values[j++];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a copy of the given vector after sorting.\n * The sorting order is determined by the sum of the first and last index values.\n * If the sum is odd, the vector is sorted in ascending order.\n * If the sum is even, the vector is sorted in descending order.\n *\n * @param array The input vector to be sorted.\n * @return A new sorted vector.\n */\nvector<int> sort_array(vector<int> array) {\n    // Calculate the sum of the first and last index values\n    int sum = array.empty() ? 0 : array[0] + array.back();\n\n    // Create a copy of the input vector\n    vector<int> sorted_array = array;\n\n    // Sort the copied vector based on the sum\n    if (sum % 2 == 0) {\n        // Sort in descending order if the sum is even\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Sort in ascending order if the sum is odd\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a string containing space-delimited numbers starting from 0 up to n inclusive.\n *\n * @param n The upper limit of the sequence (inclusive).\n * @return A string containing the sequence of numbers.\n */\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n/**\n * Returns a vector of even digits between a and b (inclusive) in ascending order.\n * \n * @param a The lower bound (inclusive).\n * @param b The upper bound (inclusive).\n * @return A vector of even digits between a and b.\n */\nvector<int> generate_integers(int a, int b) {\n    // Swap a and b if a is greater than b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> even_digits;\n\n    // Iterate from a to b\n    for (int i = a; i <= b; i++) {\n        // Check if the number is even and less than 10\n        if (i % 2 == 0 && i < 10) {\n            even_digits.push_back(i);\n        }\n    }\n\n    // Sort the vector in ascending order\n    sort(even_digits.begin(), even_digits.end());\n\n    return even_digits;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Separate groups of nested parentheses into separate strings.\n *\n * @param paren_string Input string containing multiple groups of nested parentheses.\n * @return Vector of strings, each representing a separate group of parentheses.\n */\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0; // Balance of open and close parentheses\n\n    // Iterate over each character in the input string\n    for (char c : paren_string) {\n        // Ignore spaces\n        if (c == ' ') continue;\n\n        // Update balance\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n\n        // Add character to current group\n        current_group += c;\n\n        // If balance is zero, we've found a complete group\n        if (balance == 0) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint search(std::vector<int> lst) {\n    // Create a frequency map to store the count of each integer\n    std::unordered_map<int, int> freqMap;\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n\n    // Iterate through the frequency map to find the greatest integer\n    // that has a frequency greater than or equal to its value\n    int maxNum = -1;\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > maxNum) {\n            maxNum = pair.first;\n        }\n    }\n\n    return maxNum;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n\n/**\n * Returns true if a given number is prime, and false otherwise.\n *\n * @param n The number to check for primality.\n * @return true if n is prime, false otherwise.\n */\nbool is_prime(long long n) {\n    if (n <= 1) {\n        // Numbers less than or equal to 1 are not prime.\n        return false;\n    }\n\n    // Check if n is divisible by any number up to its square root.\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            // If n is divisible by i, it's not prime.\n            return false;\n        }\n    }\n\n    // If we reach this point, n is prime.\n    return true;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert numbers to their corresponding names\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map numbers to their corresponding names\n    map<int, string> num_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Convert numbers to their corresponding names\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_name[num]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns true if all numbers in the vector l are below threshold t.\n *\n * @param l A vector of integers.\n * @param t The threshold value.\n * @return True if all numbers in l are below t, false otherwise.\n */\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // concatenate the first word with itself to handle rotations\n    string double_a = a + a;\n    \n    // check if the second word or any of its rotations is a substring in the concatenated string\n    for (int i = 0; i < b.length(); i++) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (double_a.find(rotated_b) != string::npos) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/115", "generation": "int max_fill(vector<vector<int>> grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n"}
{"task_id": "CPP/131", "generation": "int digits(int n) {\n    int product = 1;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product == 1 ? 0 : product;\n}\n"}
{"task_id": "CPP/37", "generation": "vector<float> sort_even(vector<float> l) {\n    // Separate even-indexed elements into a new vector\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector with the sorted even-indexed elements\n    vector<float> result;\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even_elements[even_idx++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != (int)a || b != (int)b || c != (int)c) {\n        return false;\n    }\n\n    // Check if one of the numbers is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/118", "generation": "string get_closest_vowel(string word) {\n  // Define the vowels\n  string vowels = \"AEIOUaeiou\";\n\n  // Iterate from the right side of the word\n  for (int i = word.length() - 1; i > 0; --i) {\n    // Check if the current character is a vowel\n    if (vowels.find(word[i]) != string::npos) {\n      // Check if the previous character is a consonant\n      if (vowels.find(word[i - 1]) == string::npos) {\n        // Check if the next character is a consonant\n        if (i + 1 < word.length() && vowels.find(word[i + 1]) == string::npos) {\n          // Return the vowel\n          return string(1, word[i]);\n        }\n      }\n    }\n  }\n\n  // If no vowel is found, return an empty string\n  return \"\";\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    while (start < paren_string.size()) {\n        size_t end = paren_string.find(' ', start);\n        if (end == string::npos) {\n            end = paren_string.size();\n        }\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0;\n        int current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n        start = end + 1;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate over each row in the list\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate over each element in the row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the element is equal to x\n            if (lst[i][j] == x) {\n                // Add the coordinates to the result vector\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the coordinates by row in ascending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // Sort the coordinates of each row by column in descending order\n    for (int i = 0; i < coordinates.size(); i++) {\n        int row = coordinates[i][0];\n        int start = i;\n        while (i < coordinates.size() && coordinates[i][0] == row) {\n            i++;\n        }\n        sort(coordinates.begin() + start, coordinates.begin() + i, [](const vector<int>& a, const vector<int>& b) {\n            return a[1] > b[1];\n        });\n        i--;\n    }\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns the decimal part of a given floating point number.\n *\n * @param number A positive floating point number.\n * @return The decimal part of the number.\n */\nfloat truncate_number(float number) {\n    // Calculate the integer part of the number\n    int integer_part = (int) number;\n\n    // Subtract the integer part from the original number to get the decimal part\n    float decimal_part = number - integer_part;\n\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Counts the number of distinct characters in a given string, regardless of case.\n *\n * @param str The input string.\n * @return The number of distinct characters in the string.\n */\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case differences\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Create a set to store unique characters\n    vector<char> unique_chars;\n\n    // Iterate over each character in the string\n    for (char c : str) {\n        // If the character is not already in the set, add it\n        if (find(unique_chars.begin(), unique_chars.end(), c) == unique_chars.end()) {\n            unique_chars.push_back(c);\n        }\n    }\n\n    // Return the size of the set, which represents the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the largest index of an element which is not greater than or equal to \n * the element immediately preceding it. If no such element exists then return -1.\n *\n * @param arr The input vector of integers.\n * @return The largest index of an element which is not greater than or equal to \n * the element immediately preceding it, or -1 if no such element exists.\n */\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int max_index = -1;\n    \n    // Iterate through the array from the second element to the end\n    for (int i = 1; i < n; i++) {\n        // Check if the current element is not greater than or equal to the previous element\n        if (arr[i] < arr[i - 1]) {\n            // Update the max_index if the current index is greater\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a vector of size n, where the value at index i is the factorial of i if i is even,\n * or the sum of numbers from 1 to i otherwise.\n *\n * @param n The size of the vector to return.\n * @return A vector of size n with the calculated values.\n */\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) { // i is even\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else { // i is odd\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char md5_hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), md5_hash);\n\n    string md5_string;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        char hex[3];\n        sprintf(hex, \"%02x\", md5_hash[i]);\n        md5_string += hex;\n    }\n\n    return md5_string;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Inserts a number \"delimiter\" between every two consecutive elements of input vector `numbers`.\n *\n * @param numbers Input vector of integers.\n * @param delimiter Number to be inserted between consecutive elements.\n * @return New vector with delimiter inserted between consecutive elements.\n */\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n\nint multiply(int a, int b) {\n    // Get the unit digits of a and b\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/44", "generation": "string change_base(int x, int base) {\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "string solve(string s) {\n    // Check if the string contains any letters\n    bool hasLetters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If the string contains letters, reverse their case\n    if (hasLetters) {\n        for (char& c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } \n    // If the string contains no letters, reverse the string\n    else {\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encodes a string by cycling groups of three characters.\n * \n * @param s The input string to be encoded.\n * @return The encoded string.\n */\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // Cycle elements in each group, unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\n/**\n * Decodes a string that was encoded with the encode_cyclic function.\n * \n * @param s The input string to be decoded.\n * @return The decoded string.\n */\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // Reverse the cycling of elements in each group.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/93", "generation": "string encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string encoded_message = \"\";\n    for (char c : message) {\n        if (vowels.find(c) != string::npos) {\n            if (isupper(c)) {\n                encoded_message += 'A' + (c - 'A' + 2) % 26;\n            } else {\n                encoded_message += 'a' + (c - 'a' + 2) % 26;\n            }\n        } else {\n            if (isupper(c)) {\n                encoded_message += tolower(c);\n            } else {\n                encoded_message += toupper(c);\n            }\n        }\n    }\n    return encoded_message;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Compare the actual scores with the guessed scores and return a vector of differences.\n *\n * @param game  A vector of actual scores.\n * @param guess A vector of guessed scores.\n * @return A vector of differences between actual and guessed scores.\n */\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> differences;\n    for (int i = 0; i < game.size(); i++) {\n        int difference = abs(game[i] - guess[i]);\n        differences.push_back(difference);\n    }\n    return differences;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Returns the derivative of a polynomial represented by its coefficients.\n *\n * The input vector xs represents the coefficients of a polynomial:\n * xs[0] + xs[1] * x + xs[2] * x^2 + ...\n *\n * The output vector represents the coefficients of the derivative of this polynomial.\n *\n * @param xs Coefficients of the polynomial\n * @return Coefficients of the derivative of the polynomial\n */\nvector<float> derivative(vector<float> xs) {\n    vector<float> derivative_xs;\n    for (int i = 1; i < xs.size(); i++) {\n        derivative_xs.push_back(i * xs[i]);\n    }\n    return derivative_xs;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Filters an input vector of strings to only include those that contain a given substring.\n *\n * @param strings The input vector of strings to filter.\n * @param substring The substring to search for in each string.\n * @return A new vector containing only the strings that contain the substring.\n */\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\n/**\n * Finds the largest number that divides n evenly, smaller than n.\n *\n * @param n The input number.\n * @return The largest divisor of n, smaller than n.\n */\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisors are found, return 1 (since 1 is a divisor of every number)\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\n#include<bitset>\nusing namespace std;\n\nstring decimal_to_binary(int decimal){\n    string binary = bitset<32>(decimal).to_string();  // convert decimal to binary\n    size_t pos = binary.find('1');  // find the first '1' in the binary string\n    if (pos != string::npos) {\n        binary = binary.substr(pos);  // remove leading zeros\n    } else {\n        binary = \"0\";  // handle the case where decimal is 0\n    }\n    return \"db\" + binary + \"db\";  // add \"db\" prefix and suffix\n}\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a vector containing the count of even and odd digits in the given integer.\n *\n * @param num The input integer.\n * @return A vector of size 2, where the first element is the count of even digits and the second element is the count of odd digits.\n */\nvector<int> even_odd_count(int num) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Convert the integer to a string to easily iterate over each digit\n    string numStr = to_string(abs(num)); // Use abs to handle negative numbers\n\n    // Iterate over each digit in the string\n    for (char digit : numStr) {\n        int digitValue = digit - '0'; // Convert char to int\n\n        // Check if the digit is even or odd\n        if (digitValue % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return the counts as a vector\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Calculate the Mean Absolute Deviation (MAD) of a dataset.\n *\n * MAD is the average absolute difference between each element and the mean of the dataset.\n *\n * @param numbers The input dataset.\n * @return The Mean Absolute Deviation of the dataset.\n */\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the absolute deviations from the mean\n    float sum_abs_dev = 0.0;\n    for (float num : numbers) {\n        sum_abs_dev += fabs(num - mean);\n    }\n\n    // Calculate the Mean Absolute Deviation\n    float mad = sum_abs_dev / numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if every opening bracket has a corresponding closing bracket.\n *\n * @param brackets a string of '<' and '>'\n * @return true if brackets are correctly paired, false otherwise\n */\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false; // more closing brackets than opening\n            }\n        }\n    }\n    return balance == 0; // all opening brackets have a corresponding closing bracket\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots needed\n    int total_needed = number + need;\n    \n    // Calculate the total number of carrots eaten\n    int total_eaten = min(total_needed, number + remaining);\n    \n    // Calculate the number of carrots left\n    int carrots_left = remaining - (total_eaten - number);\n    \n    // Return the result as a vector\n    return {total_eaten, carrots_left};\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\nint starts_one_ends(int n){\n    // Calculate the total number of n-digit positive integers\n    int total = 9 * (int)pow(10, n - 1);\n    \n    // Calculate the number of n-digit positive integers that start with 1\n    int starts_with_one = (int)pow(10, n - 1);\n    \n    // Calculate the number of n-digit positive integers that end with 1\n    int ends_with_one = 9 * (int)pow(10, n - 2) * 9;\n    \n    // Subtract the number of n-digit positive integers that start and end with 1\n    // to avoid double counting\n    int starts_and_ends_with_one = (int)pow(9, n - 2) * 9;\n    \n    // Return the total count of n-digit positive integers that start or end with 1\n    return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Flips the case of all characters in a given string.\n * \n * @param str The input string.\n * @return The string with all characters' cases flipped.\n */\nstring flip_case(string str) {\n    for (char& c : str) {\n        if (c >= 'a' && c <= 'z') {\n            // Convert lowercase to uppercase\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            // Convert uppercase to lowercase\n            c = c - 'A' + 'a';\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/146", "generation": "int specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(abs(num)); // convert to string to access digits\n            if (numStr[0] == '1' || numStr[0] == '3' || numStr[0] == '5' || numStr[0] == '7' || numStr[0] == '9') {\n                if (numStr[numStr.size() - 1] == '1' || numStr[numStr.size() - 1] == '3' || numStr[numStr.size() - 1] == '5' || numStr[numStr.size() - 1] == '7' || numStr[numStr.size() - 1] == '9') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float grade : grades) {\n        if (grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector (a, b), where \"a\" is the largest of negative integers,\n * and \"b\" is the smallest of positive integers in the input vector.\n * If there is no negative or positive integers, return them as 0.\n */\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    // Find the largest negative integer\n    for (int num : lst) {\n        if (num < 0 && (largest_negative == 0 || num > largest_negative)) {\n            largest_negative = num;\n        }\n    }\n\n    // Find the smallest positive integer\n    for (int num : lst) {\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/67", "generation": "#include <sstream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    istringstream iss(s);\n    string word;\n    int apples, oranges;\n\n    iss >> apples >> word >> oranges >> word;\n\n    int mangoes = n - apples - oranges;\n\n    return mangoes;\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a given string is a palindrome.\n *\n * A palindrome is a string that reads the same backward as forward.\n *\n * @param text The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check if the string contains whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        vector<string> words;\n        size_t pos = 0;\n        while ((pos = txt.find(' ')) != string::npos) {\n            words.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        words.push_back(txt);\n        return words;\n    } else if (txt.find(',') != string::npos) {\n        // Split on commas\n        vector<string> words;\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            words.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        words.push_back(txt);\n        return words;\n    } else {\n        // Count the number of lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z' && (c - 'a') % 2 != 0) {\n                count++;\n            }\n        }\n        return {to_string(count)};\n    }\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nint do_algebra(const std::vector<std::string>& operato, const std::vector<int>& operand) {\n    if (operato.size() != operand.size() - 1) {\n        throw std::invalid_argument(\"Invalid input: operator and operand vectors must have compatible sizes\");\n    }\n\n    int result = operand[0];\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            if (operand[i + 1] == 0) {\n                throw std::runtime_error(\"Division by zero\");\n            }\n            result /= operand[i + 1];\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        } else {\n            throw std::invalid_argument(\"Invalid operator: \" + operato[i]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && fmod(num, 1) == 0 && fmod(num, 2) != 0) {\n            sum_of_squares += (long long)pow(num, 2);\n        }\n    }\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/117", "generation": "vector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                int consonants = 0;\n                for (char w : word) {\n                    if (w != 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u' &&\n                        w != 'A' && w != 'E' && w != 'I' && w != 'O' && w != 'U') {\n                        consonants++;\n                    }\n                }\n                if (consonants == n) {\n                    result.push_back(word);\n                }\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    // Handle the last word\n    if (!word.empty()) {\n        int consonants = 0;\n        for (char w : word) {\n            if (w != 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u' &&\n                w != 'A' && w != 'E' && w != 'I' && w != 'O' && w != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/78", "generation": "int hex_key(string num) {\n    int count = 0;\n    string prime_digits = \"2357BD\";\n    for (char c : num) {\n        if (prime_digits.find(c) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int sum1 = 0, sum2 = 0;\n    \n    // Calculate the total number of characters in lst1\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n    \n    // Calculate the total number of characters in lst2\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n    \n    // Return the list with fewer characters\n    return (sum1 <= sum2) ? lst1 : lst2;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n/**\n * Counts the number of uppercase vowels in even indices of a given string.\n *\n * @param s The input string.\n * @return The number of uppercase vowels in even indices.\n */\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        // Check if the index is even\n        if (i % 2 == 0) {\n            // Check if the character is an uppercase vowel\n            if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result += \"_\";\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result += \"_\";\n    }\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns a vector of unique elements in sorted order.\n *\n * @param l The input vector.\n * @return A vector of unique elements in sorted order.\n */\nvector<int> unique(vector<int> l) {\n    // Remove duplicates by converting to a set\n    sort(l.begin(), l.end());\n    l.erase(unique(l.begin(), l.end()), l.end());\n    return l;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the sum of the ASCII codes of the upper case characters in the input string.\n *\n * @param s The input string.\n * @return The sum of the ASCII codes of the upper case characters.\n */\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n    sort(arr.rbegin(), arr.rend()); // sort in descending order\n    vector<int> result(arr.begin(), arr.begin() + k); // take the first k elements\n    sort(result.begin(), result.end()); // sort in ascending order\n    return result;\n}\n"}
{"task_id": "CPP/139", "generation": "long long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the longest string from a vector of strings.\n * If multiple strings have the same maximum length, returns the first one.\n * Returns an empty string if the input vector is empty.\n */\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n\n    return longestStr;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <stdio.h>\n#include <vector>\n\nint solution(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // for std::max_element\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n    return *std::max_element(l.begin(), l.end());\n}\n"}
{"task_id": "CPP/20", "generation": "/**\n * Find the two closest elements in a vector of numbers.\n *\n * @param numbers A vector of numbers (length at least 2)\n * @return A vector containing the two closest numbers in order (smaller, larger)\n */\nvector<float> find_closest_elements(vector<float> numbers) {\n  // Sort the vector in ascending order\n  sort(numbers.begin(), numbers.end());\n\n  // Initialize the minimum difference and the closest pair\n  float min_diff = INFINITY;\n  vector<float> closest_pair;\n\n  // Iterate through the sorted vector to find the closest pair\n  for (size_t i = 0; i < numbers.size() - 1; ++i) {\n    float diff = numbers[i + 1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_pair = {numbers[i], numbers[i + 1]};\n    }\n  }\n\n  return closest_pair;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers in a string\nstring sort_numbers(string numbers) {\n    // Map to store number words and their corresponding integer values\n    map<string, int> numMap = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into a vector of words\n    vector<string> words;\n    size_t pos = 0;\n    while ((pos = numbers.find(\" \")) != string::npos) {\n        words.push_back(numbers.substr(0, pos));\n        numbers.erase(0, pos + 1);\n    }\n    words.push_back(numbers);\n\n    // Sort the words based on their corresponding integer values\n    sort(words.begin(), words.end(), [&numMap](const string& a, const string& b) {\n        return numMap[a] < numMap[b];\n    });\n\n    // Join the sorted words back into a string\n    string sortedNumbers;\n    for (const auto& word : words) {\n        sortedNumbers += word + \" \";\n    }\n    sortedNumbers.pop_back(); // Remove the trailing space\n\n    return sortedNumbers;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <stdio.h>\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/21", "generation": "vector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Check if all values are the same (to avoid division by zero)\n    if (min_val == max_val) {\n        // If all values are the same, return a vector of zeros\n        vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    // Apply the linear transformation to each element\n    vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Move the function definition outside of match_parens\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    return (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) ? \"Yes\" : \"No\";\n}\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns a new vector containing only the positive numbers from the input vector.\n *\n * @param l The input vector of numbers.\n * @return A new vector containing only the positive numbers from the input vector.\n */\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n\n"}
{"task_id": "CPP/64", "generation": "int vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        switch (tolower(c)) {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n                count++;\n                break;\n            case 'y':\n                if (c == s.back()) {\n                    count++;\n                }\n                break;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Returns the sum of magnitudes of integers multiplied by product of all signs\n * of each number in the vector.\n *\n * @param arr A vector of integers.\n * @return The product of signs multiplied by the sum of magnitudes.\n *         Returns -32768 for an empty vector.\n */\nint prod_signs(vector<int> arr) {\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    // Iterate over each element in the vector\n    for (int num : arr) {\n        // Calculate the magnitude of the number\n        int magnitude = abs(num);\n\n        // Update the sum of magnitudes\n        sum_magnitudes += magnitude;\n\n        // Update the product of signs\n        if (num > 0) {\n            product_signs *= 1;\n        } else if (num < 0) {\n            product_signs *= -1;\n        } else {\n            // If the number is 0, the product of signs is 0\n            product_signs = 0;\n        }\n    }\n\n    // If the vector is empty, return -32768\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Return the product of signs multiplied by the sum of magnitudes\n    return product_signs * sum_magnitudes;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the intersection of the two intervals\n    int intersection_start = max(interval1[0], interval2[0]);\n    int intersection_end = min(interval1[1], interval2[1]);\n\n    // Check if the intervals intersect\n    if (intersection_start <= intersection_end) {\n        // Calculate the length of the intersection\n        int intersection_length = intersection_end - intersection_start + 1;\n\n        // Check if the length of the intersection is a prime number\n        if (intersection_length > 1) {\n            bool is_prime = true;\n            for (int i = 2; i * i <= intersection_length; i++) {\n                if (intersection_length % i == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            return is_prime ? \"YES\" : \"NO\";\n        } else {\n            return \"NO\";\n        }\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/122", "generation": "int add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        int num = arr[i];\n        int digits = 0;\n        if (num == 0) digits = 1;\n        else if (num < 0) num = -num;\n        while (num > 0) {\n            num /= 10;\n            digits++;\n        }\n        if (digits <= 2) sum += arr[i];\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n\n// Function to check if a number is prime\nint is_prime(int num) {\n    if (num <= 1) return 0;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Function to find the largest prime factor of a number\nint largest_prime_factor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            if (is_prime(n / i)) return n / i;\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if the last character of a given string is an alphabetical character\n * and is not a part of a word, and false otherwise.\n *\n * @param txt The input string to check.\n * @return true if the last character is a standalone alphabetical character, false otherwise.\n */\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character of the string\n    char last_char = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Check if the last character is part of a word\n    if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n        return false;\n    }\n\n    // If all checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n    vector<int> result(l.size());\n    std::transform(l.begin(), l.end(), result.begin(), [](int x) { return x + 1; });\n    return result;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Performs binary XOR on two input strings consisting only of 1s and 0s.\n * \n * @param a First input string\n * @param b Second input string\n * @return Result of binary XOR as a string\n */\nstring string_xor(string a, string b) {\n    // Check if both strings have the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Both strings must have the same length\");\n    }\n\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        // Perform XOR on corresponding characters\n        char xor_result = (a[i] == b[i]) ? '0' : '1';\n        result += xor_result;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <algorithm>\n#include <vector>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        if (i > 0 && l[i] == l[i-1]) {\n            continue;\n        }\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total < 0) {\n                left += 1;\n            } else if (total > 0) {\n                right -= 1;\n            } else {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\n// Function to calculate the greatest common divisor of two integers\nint greatest_common_divisor(int a, int b) {\n    // Base case: if b is 0, the GCD is a\n    if (b == 0) {\n        return a;\n    }\n    // Recursive case: call the function with b and the remainder of a/b\n    else {\n        return greatest_common_divisor(b, a % b);\n    }\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci_sequence(n + 1);\n    tribonacci_sequence[1] = 3;\n    tribonacci_sequence[2] = 1 + 2 / 2;\n    tribonacci_sequence[3] = tribonacci_sequence[2] + tribonacci_sequence[1] + (1 + 4 / 2);\n    for (int i = 4; i <= n; i++) {\n        if (i % 2 == 0) {\n            tribonacci_sequence[i] = 1 + i / 2;\n        } else {\n            tribonacci_sequence[i] = tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i - 3];\n        }\n    }\n    return tribonacci_sequence;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\n// Function to calculate the sum of numbers from 1 to n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns the length of the given string.\n *\n * @param str The input string.\n * @return The length of the string.\n */\nint strlen(string str) {\n    return str.length();\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n <= 1) {\n        return 0;\n    } else if (n == 2) {\n        return 2;\n    } else if (n == 3) {\n        return 0;\n    }\n\n    int fib4_values[4] = {0, 0, 2, 0};\n    for (int i = 4; i <= n; i++) {\n        int next_fib4 = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];\n        fib4_values[0] = fib4_values[1];\n        fib4_values[1] = fib4_values[2];\n        fib4_values[2] = fib4_values[3];\n        fib4_values[3] = next_fib4;\n    }\n\n    return fib4_values[3];\n}\n"}
{"task_id": "CPP/51", "generation": "string remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Counts the number of occurrences of a substring in a given string.\n * Overlapping cases are included in the count.\n *\n * @param str The original string to search in.\n * @param substring The substring to search for.\n * @return The number of times the substring is found in the original string.\n */\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the string until we've checked all possible positions\n    while (pos < str.length()) {\n        // Find the next occurrence of the substring\n        pos = str.find(substring, pos);\n\n        // If the substring is not found, break out of the loop\n        if (pos == string::npos) {\n            break;\n        }\n\n        // Increment the count and move the position to the next character\n        count++;\n        pos++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to get words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n\n    // Iterate over each word in the sentence\n    while (ss >> word) {\n        // Check if the length of the word is a prime number\n        if (isPrime(word.length())) {\n            // If it is, append it to the result string\n            result += word + \" \";\n        }\n    }\n\n    // Remove the trailing space from the result string\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "int count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            digit_sum += temp % 10;\n            temp /= 10;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/43", "generation": "bool pairs_sum_to_zero(vector<int> l) {\n    // Create a set to store the elements we've seen so far\n    set<int> seen;\n\n    // Iterate over the vector\n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            // If it is, return true\n            return true;\n        }\n        // Otherwise, add the current number to the set\n        seen.insert(num);\n    }\n\n    // If we've iterated over the entire vector and haven't found a pair that sums to zero, return false\n    return false;\n}\n"}
{"task_id": "CPP/70", "generation": "vector<int> strange_sort_list(vector<int> lst) {\n    if (lst.empty()) return lst; // edge case: empty list\n\n    vector<int> result;\n    bool is_min = true; // flag to alternate between min and max\n\n    while (!lst.empty()) {\n        if (is_min) {\n            auto min_it = min_element(lst.begin(), lst.end());\n            result.push_back(*min_it);\n            lst.erase(min_it);\n        } else {\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n        is_min = !is_min; // toggle flag\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\n\n/**\n * Compute the n-th element of the FibFib number sequence.\n *\n * The FibFib sequence is defined as:\n *   fibfib(0) == 0\n *   fibfib(1) == 0\n *   fibfib(2) == 1\n *   fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n *\n * @param n The index of the element to compute.\n * @return The n-th element of the FibFib sequence.\n */\nint fibfib(int n) {\n  if (n <= 1) return 0; // base cases\n  if (n == 2) return 1; // base case\n\n  // Use dynamic programming to store previously computed values\n  int fibfib_values[n + 1];\n  fibfib_values[0] = 0;\n  fibfib_values[1] = 0;\n  fibfib_values[2] = 1;\n\n  // Compute the n-th element using the recurrence relation\n  for (int i = 3; i <= n; i++) {\n    fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n  }\n\n  return fibfib_values[n];\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            int ascii_offset = isupper(c) ? 65 : 97;\n            result += (char)((c - ascii_offset + 2*2) % 26 + ascii_offset);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/26", "generation": "vector<int> remove_duplicates(vector<int> numbers) {\n    vector<int> result;\n    for (int num : numbers) {\n        if (count(numbers.begin(), numbers.end(), num) == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool has_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        n /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "int next_smallest(vector<int> lst) {\n    // Check if the list is empty\n    if (lst.empty()) {\n        return -1; // Return -1 to indicate no 2nd smallest element\n    }\n\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n\n    // Check if there are at least two distinct elements\n    if (lst.size() < 2 || lst[0] == lst[1]) {\n        return -1; // Return -1 to indicate no 2nd smallest element\n    }\n\n    // Return the 2nd smallest element\n    return lst[1];\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    vector<int> sorted_lst = lst;\n    sort(sorted_lst.begin(), sorted_lst.end());\n    if (lst != sorted_lst) return false;\n\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < lst.size(); j++) {\n            if (lst[i] == lst[j]) count++;\n        }\n        if (count > 2) return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits>\n\n/**\n * Plucks the node with the smallest even value from the given tree branch.\n * If multiple nodes have the same smallest even value, returns the node with the smallest index.\n * If no even values are found or the input vector is empty, returns an empty vector.\n *\n * @param arr The input vector representing the tree branch.\n * @return A vector containing the smallest even value and its index, or an empty vector if no even values are found.\n */\nvector<int> pluck(vector<int> arr) {\n    int smallestEven = std::numeric_limits<int>::max(); // Initialize with max int value\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallestEven) {\n            smallestEven = arr[i];\n            smallestIndex = i;\n        }\n    }\n\n    if (smallestIndex == -1) {\n        return {}; // Return empty vector if no even values are found\n    }\n\n    return {smallestEven, smallestIndex};\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates from l1 and l2\n    sort(l1.begin(), l1.end());\n    l1.erase(unique(l1.begin(), l1.end()), l1.end());\n    \n    sort(l2.begin(), l2.end());\n    l2.erase(unique(l2.begin(), l2.end()), l2.end());\n    \n    // Find the intersection of l1 and l2\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n    \n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are present in c\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversed = result;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = result == reversed;\n\n    // Return the result string and the palindrome check result\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n/**\n * Returns a vector of the first n prime numbers less than n.\n *\n * @param n A non-negative integer.\n * @return A vector of prime numbers less than n.\n */\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Returns true if the three sides form a right-angled triangle, false otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or 90 degree.\n *\n * @param a The length of the first side.\n * @param b The length of the second side.\n * @param c The length of the third side.\n * @return True if the three sides form a right-angled triangle, false otherwise.\n */\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides in ascending order\n    if (a > b) {\n        float temp = a;\n        a = b;\n        b = temp;\n    }\n    if (b > c) {\n        float temp = b;\n        b = c;\n        c = temp;\n    }\n\n    // Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return (a * a + b * b == c * c);\n}\n\n"}
{"task_id": "CPP/99", "generation": "int closest_integer(string value) {\n    double num = stod(value); // convert string to double\n    double fractional_part = num - floor(num); // get fractional part\n\n    if (fractional_part < 0.5) {\n        return floor(num); // round down\n    } else if (fractional_part > 0.5) {\n        return ceil(num); // round up\n    } else {\n        // equidistant from two integers, round away from zero\n        if (num > 0) {\n            return ceil(num);\n        } else {\n            return floor(num);\n        }\n    }\n}\n"}
{"task_id": "CPP/149", "generation": "vector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/86", "generation": "string anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        // If the character is a space, add the sorted word to the result and reset the word\n        if (c == ' ') {\n            sort(word.begin(), word.end()); // Sort the characters in the word\n            result += word + \" \"; // Add the sorted word to the result\n            word = \"\"; // Reset the word\n        } else {\n            word += c; // Add the character to the current word\n        }\n    }\n    \n    // Sort and add the last word to the result\n    sort(word.begin(), word.end());\n    result += word;\n    \n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n\nvector<int> minPath(std::vector<std::vector<int>> grid, int k) {\n    int n = grid.size();\n    std::vector<int> directions = {0, 1, 0, -1, 0};\n    std::vector<int> minPath(k, INT_MAX);\n\n    std::function<void(int, int, int, std::vector<int>&)> dfs =\n        [&](int i, int j, int pathLen, std::vector<int>& currentPath) {\n            if (pathLen == k) {\n                if (currentPath < minPath) {\n                    minPath = currentPath;\n                }\n                return;\n            }\n            for (int d = 0; d < 4; ++d) {\n                int ni = i + directions[d];\n                int nj = j + directions[d + 1];\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                    currentPath.push_back(grid[ni][nj]);\n                    dfs(ni, nj, pathLen + 1, currentPath);\n                    currentPath.pop_back();\n                }\n            }\n        };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> currentPath = {grid[i][j]};\n            dfs(i, j, 1, currentPath);\n        }\n    }\n\n    return minPath;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\n/**\n * Returns 2^n modulo p.\n *\n * @param n The exponent.\n * @param p The modulus.\n * @return 2^n modulo p.\n */\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/156", "generation": "string int_to_mini_roman(int number) {\n    // Define the mapping of integers to roman numerals\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result;\n    for (const auto& pair : roman_numerals) {\n        // Subtract the largest possible roman numeral value from the number\n        while (number >= pair.first) {\n            number -= pair.first;\n            result += pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm>\n\nstring circular_shift(int x, int shift) {\n    string num_str = to_string(x);\n    int num_digits = num_str.length();\n    shift = shift % num_digits;\n    if (shift == 0) {\n        std::reverse(num_str.begin(), num_str.end());\n        return num_str;\n    } else {\n        string shifted_str = num_str.substr(num_digits - shift, shift) + num_str.substr(0, num_digits - shift);\n        return shifted_str;\n    }\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> result;\n    int max_so_far = INT_MIN;\n    for (int num : numbers) {\n        max_so_far = max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/158", "generation": "string find_max(vector<string> words) {\n    int max_unique_chars = 0;\n    string result = \"\";\n\n    for (const string& word : words) {\n        set<char> unique_chars(word.begin(), word.end());\n        int num_unique_chars = unique_chars.size();\n\n        if (num_unique_chars > max_unique_chars) {\n            max_unique_chars = num_unique_chars;\n            result = word;\n        } else if (num_unique_chars == max_unique_chars) {\n            result = min(result, word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Returns a vector containing the sum and product of all integers in the input vector.\n * Empty sum is 0 and empty product is 1.\n *\n * @param numbers Input vector of integers\n * @return Vector containing sum and product of integers\n */\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate over each number in the input vector\n    for (int num : numbers) {\n        sum += num;  // Add number to sum\n        product *= num;  // Multiply number with product\n    }\n\n    // Create a new vector with sum and product\n    std::vector<int> result = {sum, product};\n\n    return result;\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\n/**\n * Checks if all keys in a map are strings and are either all in lower case or all in upper case.\n *\n * @param dict The input map to check.\n * @return True if all keys are strings and are either all in lower case or all in upper case, false otherwise.\n */\nbool check_dict_case(map<string, string> dict) {\n    // If the map is empty, return false\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Check if all keys are strings (this is always true in C++ since map keys are typed)\n    // Check if all keys are either all in lower case or all in upper case\n    bool allLower = true;\n    bool allUpper = true;\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        for (char c : key) {\n            if (isupper(c)) {\n                allLower = false;\n            } else if (islower(c)) {\n                allUpper = false;\n            } else {\n                // If the key contains a non-alphabetic character, return false\n                return false;\n            }\n        }\n    }\n\n    // If all keys are either all in lower case or all in upper case, return true\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    int a = 0, b = 1, result = 0;\n    for (int i = 2; i <= n; i++) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Filter an input vector of strings only for ones that start with a given prefix.\n *\n * @param strings Input vector of strings\n * @param prefix Prefix to filter by\n * @return Filtered vector of strings\n */\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(prefix) == 0) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    if (q != reversed_q) {\n        return false; // Not a palindrome, won't fly\n    }\n\n    // Check if the sum of elements is less than or equal to the maximum weight\n    int sum = 0;\n    for (int i : q) {\n        sum += i;\n    }\n    if (sum > w) {\n        return false; // Too heavy, won't fly\n    }\n\n    return true; // Balanced and not too heavy, will fly\n}\n"}
{"task_id": "CPP/54", "generation": "bool same_chars(string s0, string s1) {\n    // Create a set of unique characters from each string\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n\n    // Compare the two sets\n    return chars0 == chars1;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint is_bored(string S) {\n    vector<string> sentences;\n    string temp = \"\";\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            sentences.push_back(temp);\n            temp = \"\";\n        } else {\n            temp += c;\n        }\n    }\n    if (!temp.empty()) {\n        sentences.push_back(temp);\n    }\n\n    int boredoms = 0;\n    for (string sentence : sentences) {\n        if (!sentence.empty() && toupper(sentence[0]) == 'I') {\n            boredoms++;\n        }\n    }\n    return boredoms;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\n#include <iostream>\n\nbool iscube(int a) {\n    int cube_root = round(std::pow(std::abs(a), 1.0/3.0));\n    return cube_root * cube_root * cube_root == std::abs(a);\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Returns the minimum number of elements that need to be changed to make the vector palindromic.\n *\n * @param arr The input vector of integers.\n * @return The minimum number of changes required.\n */\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end of the vector, moving towards the center.\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\n/**\n * Calculates the area of a triangle given the lengths of its three sides.\n * \n * @param a The length of the first side.\n * @param b The length of the second side.\n * @param c The length of the third side.\n * @return The area of the triangle rounded to 2 decimal points if the sides form a valid triangle, -1 otherwise.\n */\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return roundf(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Returns true if the length of the input string is a prime number, false otherwise.\n *\n * @param str The input string.\n * @return True if the length of the string is prime, false otherwise.\n */\nbool prime_length(string str) {\n    int length = str.length();\n    if (length <= 1) {\n        return false; // 0 and 1 are not prime numbers\n    }\n\n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) {\n            return false; // if length is divisible by any number, it's not prime\n        }\n    }\n\n    return true; // if no divisors found, length is prime\n}\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Finds the minimum sum of any non-empty sub-vector of nums.\n *\n * @param nums A vector of integers.\n * @return The minimum sum of any non-empty sub-vector of nums.\n */\nlong long minSubArraySum(vector<long long> nums) {\n    // Initialize the minimum sum to the first element of the vector\n    long long min_sum = nums[0];\n    \n    // Initialize the current sum to the first element of the vector\n    long long current_sum = nums[0];\n    \n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < nums.size(); i++) {\n        // Update the current sum by adding the current element\n        current_sum = min(nums[i], current_sum + nums[i]);\n        \n        // Update the minimum sum if the current sum is smaller\n        min_sum = min(min_sum, current_sum);\n    }\n    \n    // Return the minimum sum\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\n/**\n * Evaluates whether the given number n can be written as the sum of exactly 4 positive even numbers.\n *\n * @param n The number to check.\n * @return True if n can be written as the sum of exactly 4 positive even numbers, false otherwise.\n */\nbool is_equal_to_sum_even(int n) {\n    // We need to find 4 positive even numbers that sum up to n.\n    // The smallest possible even number is 2, so we start from there.\n    for (int a = 2; a <= n / 4; a += 2) {\n        for (int b = a; b <= (n - a) / 3; b += 2) {\n            for (int c = b; c <= (n - a - b) / 2; c += 2) {\n                int d = n - a - b - c;\n                // Check if d is a positive even number.\n                if (d > 0 && d % 2 == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <stack>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']') {\n            if (s.size() > 1) {\n                return true;\n            }\n            if (!s.empty()) {\n                s.pop();\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/3", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n/**\n * Detects if the balance of a bank account falls below zero at any point.\n *\n * @param operations A vector of deposit and withdrawal operations.\n * @return True if the balance falls below zero, false otherwise.\n */\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/142", "generation": "int sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Encodes a string by shifting every character by 5 positions in the alphabet.\n *\n * @param s The input string to be encoded.\n * @return The encoded string.\n */\nstring encode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n\n/**\n * Decodes a string that was previously encoded with the encode_shift function.\n *\n * @param s The input string to be decoded.\n * @return The decoded string.\n */\nstring decode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "string rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    int sum = (n + m) * (m - n + 1) / 2;\n    int avg = floor((double)sum / (m - n + 1));\n\n    string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n"}
{"task_id": "CPP/57", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n/**\n * Returns true if the vector elements are monotonically increasing or decreasing.\n *\n * @param l The input vector.\n * @return True if the vector is monotonically increasing or decreasing, false otherwise.\n */\nbool monotonic(const std::vector<float>& l) {\n    if (l.size() <= 1) {\n        return true; // A single element or empty vector is considered monotonic.\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\n/**\n * Concatenates a vector of strings into a single string.\n *\n * @param strings Vector of strings to concatenate.\n * @return A single string containing all the input strings concatenated together.\n */\nstring concatenate(const vector<string>& strings) {\n    string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n\nbool is_prime(int num) {\n    if (num < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(num); i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int a = 0;\n    int b = 1;\n    int count = 0;\n    while (true) {\n        if (is_prime(b)) {\n            count++;\n            if (count == n) {\n                return b;\n            }\n        }\n        int temp = a;\n        a = b;\n        b = temp + b;\n    }\n}\n"}
{"task_id": "CPP/45", "generation": "/**\n * Calculates the area of a triangle given the length of a side and the height.\n *\n * @param a The length of a side of the triangle.\n * @param h The height of the triangle.\n * @return The area of the triangle.\n */\nfloat triangle_area(float a, float h) {\n    // The formula for the area of a triangle is (base * height) / 2.\n    // In this case, we're assuming 'a' is the base and 'h' is the height.\n    return (a * h) / 2;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    std::string str = std::to_string(std::abs(n));\n    for (char c : str) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    std::vector<std::pair<int, int>> sums;\n    for (int i = 0; i < nums.size(); i++) {\n        sums.push_back({sumOfDigits(nums[i]), i});\n    }\n    std::sort(sums.begin(), sums.end());\n    std::vector<int> sortedNums;\n    for (auto& sum : sums) {\n        sortedNums.push_back(nums[sum.second]);\n    }\n    return sortedNums;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring solve(int N) {\n    int sum_of_digits = 0;\n    while (N > 0) {\n        sum_of_digits += N % 10;\n        N /= 10;\n    }\n    return bitset<32>(sum_of_digits).to_string();\n}\n"}
{"task_id": "CPP/113", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        string temp = \"the number of odd elements \";\n        temp += to_string(odd_count);\n        temp += \"n the str\";\n        temp += to_string(odd_count);\n        temp += \"ng \";\n        temp += to_string(odd_count);\n        temp += \" of the \";\n        temp += to_string(odd_count);\n        temp += \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n\n/**\n * Returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n *\n * @param n The upper limit (exclusive) for the range of numbers to check.\n * @return The count of occurrences of the digit 7 in the specified range.\n */\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nbool simplify(string x, string n) {\n    // Split the input strings into numerator and denominator\n    int x_num, x_den, n_num, n_den;\n    char slash;\n    stringstream(x) >> x_num >> slash >> x_den;\n    stringstream(n) >> n_num >> slash >> n_den;\n\n    // Calculate the product of the numerators and denominators\n    long long product_num = (long long)x_num * n_num;\n    long long product_den = (long long)x_den * n_den;\n\n    // Check if the product is a whole number\n    return product_num % product_den == 0;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n/**\n * Checks if any two numbers in the given vector are closer to each other than the given threshold.\n *\n * @param numbers The vector of numbers to check.\n * @param threshold The minimum distance between two numbers.\n * @return True if any two numbers are closer than the threshold, false otherwise.\n */\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector of numbers in ascending order\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted vector and check the distance between each pair of adjacent numbers\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        // Calculate the distance between the current number and the next number\n        float distance = numbers[i + 1] - numbers[i];\n\n        // If the distance is less than or equal to the threshold, return true\n        if (distance <= threshold) {\n            return true;\n        }\n    }\n\n    // If no pairs of numbers are closer than the threshold, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Parse a string of musical notes in a special ASCII format and return a vector of integers\n * representing the number of beats each note lasts.\n *\n * Legend:\n * \"o\" - whole note, lasts four beats\n * \"o|\" - half note, lasts two beats\n * \".|\" - quarter note, lasts one beat\n *\n * @param music_string The input string of musical notes\n * @return A vector of integers representing the number of beats each note lasts\n */\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int i = 0;\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                // Half note\n                beats.push_back(2);\n                i += 2;\n            } else {\n                // Whole note\n                beats.push_back(4);\n                i += 1;\n            }\n        } else if (music_string[i] == '.') {\n            // Quarter note\n            beats.push_back(1);\n            i += 2; // Skip the \"|\" character\n        } else {\n            // Skip whitespace characters\n            i += 1;\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/**\n * Returns the median of elements in the vector l.\n *\n * @param l A vector of floating point numbers.\n * @return The median of the elements in the vector.\n */\nfloat median(vector<float> l) {\n    // First, we need to sort the vector in ascending order\n    sort(l.begin(), l.end());\n\n    // Get the size of the vector\n    int n = l.size();\n\n    // If the size of the vector is odd, the median is the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    }\n    // If the size of the vector is even, the median is the average of the two middle elements\n    else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if a number is the product of 3 prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all prime numbers less than 100\n    std::vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) primes.push_back(i);\n    }\n\n    // Check all combinations of 3 prime numbers\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i; j < primes.size(); j++) {\n            for (int k = j; k < primes.size(); k++) {\n                if (a == primes[i] * primes[j] * primes[k]) return true;\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if date string is not empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Split date string into month, day, and year\n    int month, day, year;\n    char delimiter;\n    stringstream ss(date);\n    ss >> month >> delimiter >> day >> delimiter >> year;\n\n    // Check if date is in the correct format (mm-dd-yyyy)\n    if (ss.fail() || delimiter != '-' || month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid for the given month\n    if (month == 2) {\n        // February has 29 days\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // April, June, September, and November have 30 days\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        // All other months have 31 days\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Splits a string of words separated by commas or spaces into a vector of words.\n *\n * @param s The input string of words.\n * @return A vector of words.\n */\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a vector of all prefixes from shortest to longest of the input string.\n *\n * @param str The input string.\n * @return A vector of all prefixes of the input string.\n */\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <string>\n#include <cctype> // for std::isdigit and std::isalpha\n\nstring file_name_check(const string& file_name) {\n    // Check if the file name contains exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Check if the substring before the dot is not empty and starts with a letter\n    if (dot_pos == 0 || !std::isalpha(file_name[0])) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of the allowed extensions\n    string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (std::isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all checks pass, return \"Yes\"\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/123", "generation": "vector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_numbers.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    odd_numbers.push_back(1); // 1 is always an odd number in the sequence\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n    if (it1 > it2) {\n        swap(it1, it2);\n    }\n    return vector<string>(next(it1), it2);\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num); // round to upper int\n        sum += rounded_num * rounded_num; // square and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <algorithm>\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    for (int i = 0; i < arr.size(); i++) {\n        std::vector<int> rotated_arr(arr.size());\n        std::copy(arr.begin() + i, arr.end(), rotated_arr.begin());\n        std::copy(arr.begin(), arr.begin() + i, rotated_arr.begin() + arr.size() - i);\n        if (rotated_arr == sorted_arr) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\n\n/**\n * Creates a pile of n levels of stones, where the number of stones in each level\n * is determined by the parity of the initial number of stones.\n *\n * @param n The initial number of stones.\n * @return A vector of integers, where each element represents the number of stones\n *         in the corresponding level.\n */\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current = n;\n\n    // Loop until we have n levels\n    for (int i = 0; i < n; i++) {\n        // Add the current number of stones to the vector\n        stones.push_back(current);\n\n        // Determine the next number of stones based on the parity of the current number\n        if (current % 2 == 0) { // even\n            current += 2; // next even number\n        } else { // odd\n            current += 2; // next odd number\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\n// Function to check if a number is prime\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\n// Function to return x if n is prime, y otherwise\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    auto calculate_strength = [&](const string& extension) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) cap++;\n            if (islower(c)) sm++;\n        }\n        return cap - sm;\n    };\n\n    auto strongest_extension = *max_element(extensions.begin(), extensions.end(),\n        [&](const string& a, const string& b) {\n            return calculate_strength(a) < calculate_strength(b);\n        });\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n/**\n * Returns a vector containing the number of even and odd integer palindromes\n * within the range [1, n].\n *\n * @param n A positive integer.\n * @return A vector of two integers, where the first element is the number of even\n *         integer palindromes and the second element is the number of odd integer\n *         palindromes.\n */\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate over the range [1, n]\n    for (int i = 1; i <= n; i++) {\n        // Convert the integer to a string to check if it's a palindrome\n        string str = to_string(i);\n        string rev_str = str;\n        reverse(rev_str.begin(), rev_str.end());\n\n        // Check if the string is a palindrome\n        if (str == rev_str) {\n            // Check if the palindrome is even or odd\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/110", "generation": "string exchange(vector<int> lst1, vector<int> lst2) {\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountInLst1++;\n        }\n    }\n\n    return (evenCountInLst2 >= oddCountInLst1) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\nusing namespace std;\n\n/**\n * Returns a map of the letter(s) with the most repetition and their corresponding count.\n * If several letters have the same occurrence, returns all of them.\n *\n * @param test a string representing a space separated lowercase letters\n * @return a map of char to int, where each key is a letter and its value is the count\n */\nmap<char, int> histogram(string test) {\n    map<char, int> letterCounts;\n    int maxCount = 0;\n\n    // Count the occurrences of each letter\n    for (char c : test) {\n        if (c != ' ') { // ignore spaces\n            letterCounts[c]++;\n            maxCount = max(maxCount, letterCounts[c]);\n        }\n    }\n\n    // Filter the map to only include letters with the maximum count\n    map<char, int> result;\n    for (auto& pair : letterCounts) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n/**\n * Checks if a string is happy.\n * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n *\n * @param s The input string.\n * @return True if the string is happy, false otherwise.\n */\nbool is_happy(string s) {\n    // Check if the string length is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate over the string with a sliding window of size 3\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the current 3 consecutive letters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If we reach this point, the string is happy\n    return true;\n}\n\n"}
