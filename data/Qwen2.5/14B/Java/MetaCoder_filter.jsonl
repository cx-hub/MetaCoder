{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers that are closer to each other than a given threshold.\n     *\n     * @param numbers List<Double> - A list of floating-point numbers.\n     * @param threshold double - The minimum distance between any two elements for them not to be considered close.\n     * @return boolean - Returns true if there are at least two elements in the list that are closer than the threshold, otherwise false.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Additional test cases\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.5, 8.7), 0.4);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        boolean result4 = solution.has_close_elements(Arrays.asList(-2.0, -1.0, 0.5, 1.5), 0.6);\n        System.out.println(\"Test Case 4: \" + (result4 ? \"Passed\" : \"Failed\")); // Expected output: Failed\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * Example:\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < cleanString.length(); i++) {\n            char c = cleanString.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(cleanString.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String input = \"( ) (( )) (( )( ))\";\n        List<String> output = solution.separate_paren_groups(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Output: [\" + String.join(\", \", output) + \"]\");\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to check the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n        System.out.println(solution.truncate_number(0.123));  // Expected output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposit (positive) or withdrawal (negative) amounts.\n     * @return boolean indicating whether the balance goes negative at any point.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance has fallen below zero\n            }\n        }\n        return false; // No negative balance detected\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false as the balance never goes below zero.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true as after -4, the balance is negative.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyList); // Expected output: []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyList); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, returns the deepest level of nesting of parentheses as an integer in a list.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A List<Integer> where each element represents the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    /**\n     * A test method to verify the correctness of parse_nested_parens function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result;\n\n        // Test case 1\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        result = solution.parse_nested_parens(input1);\n        System.out.println(\"Test Case 1: \" + (result.equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        String input2 = \"() ()\";\n        List<Integer> expectedOutput2 = Arrays.asList(1, 1);\n        result = solution.parse_nested_parens(input2);\n        System.out.println(\"Test Case 2: \" + (result.equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        String input3 = \"(())() ((()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(2, 3);\n        result = solution.parse_nested_parens(input3);\n        System.out.println(\"Test Case 3: \" + (result.equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java 8 Streams API for filtering the list based on a condition.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        \n        // Generate rolling max\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n        \n        // Verify correctness\n        if (expectedOutput.equals(output)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     * Algorithm idea is simple:\n     * - Find the longest postfix of supplied string that is a palindrome.\n     * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    public String make_palindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        // Find the longest palindromic suffix\n        int n = string.length();\n        for (int i = 0; i < n; i++) {\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // The prefix before the palindromic suffix\n                String prefixBeforeSuffix = string.substring(0, i);\n                // Append reverse of this prefix to the original string\n                return string + new StringBuilder(prefixBeforeSuffix).reverse().toString();\n            }\n        }\n\n        // If no palindromic suffix is found (should not happen for non-empty strings)\n        return string;\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11011\"));  // Expected output: \"01110\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\"));  // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\"));  // Expected output: \"0000\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-9, -18)); // Expected output: 9\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        // Additional test cases\n        List<String> emptyPrefixes = solution.all_prefixes(\"\");\n        System.out.println(emptyPrefixes);  // Expected output: []\n        \n        List<String> singleCharPrefixes = solution.all_prefixes(\"x\");\n        System.out.println(singleCharPrefixes);  // Expected output: [x]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string representing musical notes in a special ASCII format.\n     * Your task is to parse this string and return list of integers corresponding to how many beats does each\n     * note last.\n     *\n     * Here is a legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quarter note, lasts one beat\n     *\n     * >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n     * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n    public List<Integer> parse_music(String string) {\n        // Split the input string into individual notes\n        String[] notes = string.split(\" \");\n        \n        // Initialize a list to store the number of beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Iterate through each note and determine its corresponding beat duration\n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                beats.add(1);\n            }\n        }\n        \n        // Return the list of beat durations\n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each number word to its corresponding integer value.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its integer value and sort them.\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into number words.\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            String word = \"\";\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key).equals(num)) {\n                    word = key;\n                    break;\n                }\n            }\n            result.append(word);\n            result.append(\" \");\n        }\n\n        // Remove the trailing space and return the result.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected output: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding closest elements easier.\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), applies a linear transform such that \n     * the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledNumber = (number - min) / (max - min);\n            scaledNumbers.add(scaledNumber);\n        }\n        \n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Collections.emptyMap(), Collections.emptyList());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i > 0; i--) { // Start from half of n and go down to 1\n            if (n % i == 0) { // Check if i divides n evenly\n                return i; // Return the first divisor found, which is the largest one\n            }\n        }\n        return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n        System.out.println(solution.largest_divisor(60)); // Expected output: 30\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 to get rid of all even factors\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once and preserve the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     * \n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over the list and append each string to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test function to verify the correctness of the filter_by_prefix method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print: []\n\n        List<String> listWithPrefixes = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(listWithPrefixes, \"a\")); // Should print: [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n\n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.List;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * Finds a zero point of the polynomial defined by coefficients in xs.\n     */\n    public double find_zero(List<Double> xs) {\n        // Implementing bisection method for root finding\n        double left = -100;  // Initial guess for lower bound\n        double right = 100;   // Initial guess for upper bound\n\n        while (Math.abs(right - left) > 1e-6) {\n            double mid = (left + right) / 2;\n            if (poly(xs, mid) == 0) {\n                return mid;\n            } else if (poly(xs, left) * poly(xs, mid) < 0) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three\n     * are equal to the values of the corresponding indices of l, but sorted in ascending order.\n     *\n     * Example:\n     * >>> sort_third(Arrays.asList(1, 2, 3))\n     * [1, 2, 3]\n     * >>> sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))\n     * [2, 6, 3, 4, 8, 9, 5]\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by three\n        List<Integer> divisibleByThree = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                divisibleByThree.add(l.get(i));\n            }\n        }\n\n        // Sort the extracted elements\n        Collections.sort(divisibleByThree);\n\n        // Construct the result list\n        List<Integer> result = new ArrayList<>();\n        int j = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                result.add(divisibleByThree.get(j));\n                j++;\n            } else {\n                result.add(l.get(i));\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + testList1);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList1));\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 5, 4, 3, 2, 1);\n        System.out.println(\"Original: \" + testList2);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList2));\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(9, 7, 5, 3, 1);\n        System.out.println(\"Original: \" + testList3);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0); // Assume the first element is the largest initially\n        \n        for (int i = 1; i < l.size(); i++) { // Start from the second element\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Expected output: 0\n        System.out.println(solution.fizz_buzz(78)); // Expected output: 2\n        System.out.println(solution.fizz_buzz(79)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the elements at even indices\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the 'evens' list\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the 'evens' list\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values from 'evens'\n        for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n            sortedList.set(i, evens.get(j));\n        }\n        \n        return sortedList;\n    }\n\n    // Method to test the sort_even function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Cycle elements in each group. Unless group has fewer elements than 3.\n        List<String> encodedGroups = new ArrayList<>();\n        for (String group : groups) {\n            if (group.length() == 3) {\n                encodedGroups.add(group.substring(1) + group.charAt(0));\n            } else {\n                encodedGroups.add(group);\n            }\n        }\n\n        return String.join(\"\", encodedGroups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // Split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n\n        // Reverse cycle elements in each group. Unless group has fewer elements than 3.\n        List<String> decodedGroups = new ArrayList<>();\n        for (String group : groups) {\n            if (group.length() == 3) {\n                decodedGroups.add(group.charAt(2) + group.substring(0, 2));\n            } else {\n                decodedGroups.add(group);\n            }\n        }\n\n        return String.join(\"\", decodedGroups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n        }\n\n        return primes.get(primes.size() - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for easier traversal\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on a straight road.\n     *\n     * @param n The number of cars in each set (one set moving left to right, and one set moving right to left).\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from the left will collide with every car from the right,\n        // the total number of collisions is simply n (left cars) times n (right cars).\n        return n * n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 4\n        System.out.println(solution.car_race_collision(3));  // Expected output: 9\n        System.out.println(solution.car_race_collision(5));  // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and high return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        // Area formula: (1/2) * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Area of triangle with base=10 and height=4: \" + area2); // Expected output: 20.0\n        \n        // Test case 3 (with floating point numbers)\n        double area3 = solution.triangle_area(7.5, 2.5);\n        System.out.println(\"Area of triangle with base=7.5 and height=2.5: \" + area3); // Expected output: 9.375\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) {\n            return 0;\n        } else if (n == 2) {\n            return 2;\n        } else if (n == 3) {\n            return 0;\n        }\n\n        // Initialize base cases\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; i++) {\n            int next_value = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next_value;\n        }\n\n        return d;\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list first\n        Collections.sort(l);\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return the middle element\n            return l.get(size / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "class Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left++) != text.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test cases using assertions\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        assert solution.is_palindrome(\"\") : \"Empty string should be a palindrome\";\n        assert solution.is_palindrome(\"aba\") : \"'aba' is a palindrome\";\n        assert solution.is_palindrome(\"aaaaa\") : \"'aaaaa' is a palindrome\";\n        assert !solution.is_palindrome(\"zbcd\") : \"'zbcd' is not a palindrome\";\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // 2^0 = 1 for any p\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base value\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5)); // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101)); // Expected output: 1\n        System.out.println(solution.modp(3, 11)); // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"hello\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should output \"mjqqt\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should output \"hello\"\n\n        String testString2 = \"World\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should output \"BTQYI\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should output \"World\"\n\n        // Test with non-letter characters\n        String testString3 = \"abc123\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should output \"fghi123\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should output \"abc123\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string and append non-vowel characters to result\n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + (solution.below_threshold(list1, threshold1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + (solution.below_threshold(list2, threshold2) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"add(2, 3): \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7): \" + solution.add(5, 7)); // Expected output: 12\n\n        // Additional test cases for robustness\n        System.out.println(\"add(-10, 4): \" + solution.add(-10, 4)); // Expected output: -6\n        System.out.println(\"add(0, 0): \" + solution.add(0, 0));     // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from the first string\n        Set<Character> charSet = new HashSet<>();\n        \n        // Add all characters from the first string into the set\n        for (char c : s0.toCharArray()) {\n            charSet.add(c);\n        }\n        \n        // Check if every character in the second string is present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charSet.contains(c)) {\n                return false;\n            }\n        }\n\n        // Create a set to store unique characters from the second string\n        Set<Character> charSet2 = new HashSet<>();\n        \n        // Add all characters from the second string into the set\n        for (char c : s1.toCharArray()) {\n            charSet2.add(c);\n        }\n        \n        // Check if every character in the first string is present in this new set\n        for (char c : s0.toCharArray()) {\n            if (!charSet2.contains(c)) {\n                return false;\n            }\n        }\n\n        // If all checks pass, both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the number of open and close brackets\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n\n            // If at any point the number of closing brackets is more than opening ones, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // At the end, there should be no unmatched open brackets left\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() <= 1) return true; // A single element is trivially monotonic\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(\"Largest prime factor of 13195: \" + solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(\"Largest prime factor of 2048: \" + solution.largest_prime_factor(2048));   // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    /**\n     * A method to test the correctness of the sum_to_n function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5));    // Expected output: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1));    // Expected output: 1\n        \n        // Additional test case to ensure correctness\n        System.out.println(\"sum_to_n(1000): \" + solution.sum_to_n(1000)); // Expected output: 500500\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the balance between '(' and ')'\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++; // Increment when an opening bracket is found\n            } else if (c == ')') {\n                balance--; // Decrement when a closing bracket is found\n                \n                // If at any point the balance goes negative, it means there are more closing brackets than opening ones.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative will have one less term than the original polynomial,\n        // unless it's a constant (degree 0), which has no terms after differentiation.\n        if (xs.size() <= 1) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.length() == 0) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        \n        // Determine the number of digits\n        int numDigits = numStr.length();\n        \n        // Handle cases where shift is greater than or equal to the number of digits\n        if (shift >= numDigits) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Compute effective shift within bounds of the number's length\n        shift %= numDigits;\n        \n        // Perform circular shift\n        String shiftedStr = numStr.substring(numDigits - shift) + numStr.substring(0, numDigits - shift);\n        \n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in a basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the count of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mango fruits\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the record.\n                if (value < smallestEvenValue || i < index) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1; // Initialize result to -1\n        \n        // Iterate through the entries of the frequency map\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            \n            // Check if the number's frequency is greater than or equal to the number itself\n            if (num <= freq) {\n                result = Math.max(result, num); // Update result with the maximum value found\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        \n        while (!lst.isEmpty()) {\n            // Find and remove the minimum value from the list\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) {\n                break;\n            }\n            \n            // Find and remove the maximum value from the list\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the object q will fly, and false otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w and the list is a palindrome\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic.\n     *\n     * @param arr List<Integer> representing the input array.\n     * @return int representing the minimum number of changes needed.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            if (!arr.get(i).equals(arr.get(n - i - 1))) {\n                changes++;\n            }\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));   // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList(\"a\", \"b\", \"c\"))); // []\n        System.out.println(solution.total_match(Arrays.asList(\"abc\", \"def\"), Arrays.asList(\"ghi\"))); // [\"ghi\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            \n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a) return true;\n                    \n                    if (p1 * p2 * p3 > a) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n\n        int currentPower = n;\n\n        while (currentPower < x) {\n            currentPower *= n;\n        }\n\n        return currentPower == x;\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube of some integer.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cubeRoot = Math.cbrt(absA);\n        long roundedCubeRoot = Math.round(cubeRoot);\n\n        // Check if cubing the rounded value equals the original number\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube method\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Define a set of hexadecimal digits that are prime numbers.\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of characters in the input string that are prime hex digits.\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A test method to check the correctness of the decimal_to_binary function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(7));   // Expected output: \"db111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is a happy string.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A\n            > 3.3                A-\n            > 3.0                B+\n            > 2.7                B\n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                D+\n            > 0.7                D\n            >= 0.0               D-\n              < 0.0              E\n\n    Example:\n    numerical_letter_grade(Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        \n        // Check for edge cases\n        if (len <= 1) return false;\n        if (len == 2) return true; // 2 is the only even prime number\n        \n        // Check divisibility by numbers up to sqrt(len)\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        \n        // For numbers with more than one digit, calculate the count of numbers that start or end with 1.\n        long totalNumbers = 9 * (long)Math.pow(10, n - 2);\n        \n        // Calculate the overlap for numbers that both start and end with 1.\n        long overlap = (n > 2) ? 8 * (long)Math.pow(10, n - 3) : 0;\n        \n        // The final count is calculated as follows:\n        return (int)(2 * totalNumbers + 2 - overlap);\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        // Calculate the sum of digits of N\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2, 9))); // Expected output: 5 (since only one even number at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 7, 8, 2))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string where each word's characters are sorted alphabetically.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                \n                // Append sorted characters to the result, followed by a space\n                result.append(new String(chars));\n            }\n            \n            // Append a space after each non-empty word\n            result.append(\" \");\n        }\n\n        // Remove trailing space if present and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinate to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, it's both the first and last.\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        // Create a copy of the original list to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a given string by rotating each letter down by 4 places in the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted and remain the same.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Set<Integer> uniqueElements = new HashSet<>(lst);\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(uniqueElements);\n        Collections.sort(sortedList);\n\n        return Optional.of(sortedList.get(1));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the sentence into individual sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. Are you? I think so!\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility)\n     * @param y Second number (Object type for flexibility)\n     * @param z Third number (Object type for flexibility)\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (will be false because inputs are not all integers)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet.\n     Assume only letters.\n\n     Examples:\n     >>> encode(\"test\")\n     \"TGST\"\n     >>> encode(\"This is a message\")\n     \"tHKS KS C MGSSCGG\"\n      */\n    public String encode(String message) {\n        // Define vowels and their shifted counterparts\n        char[] vowels = {'a', 'e', 'i', 'o', 'u'};\n        Map<Character, Character> shiftedVowels = new HashMap<>();\n        shiftedVowels.put('a', 'c');\n        shiftedVowels.put('A', 'C');\n        shiftedVowels.put('e', 'g');\n        shiftedVowels.put('E', 'G');\n        shiftedVowels.put('i', 'k');\n        shiftedVowels.put('I', 'K');\n        shiftedVowels.put('o', 'q');\n        shiftedVowels.put('O', 'Q');\n        shiftedVowels.put('u', 'w');\n        shiftedVowels.put('U', 'W');\n\n        // Build the encoded message\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Shift vowels by 2 places ahead\n                if (isVowel(swappedChar, shiftedVowels.keySet())) {\n                    encodedMessage.append(shiftedVowels.get(swappedChar));\n                } else {\n                    encodedMessage.append(swappedChar);\n                }\n            } else {\n                // Non-alphabetic characters remain unchanged\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    private boolean isVowel(char c, Set<Character> vowels) {\n        return vowels.contains(Character.toLowerCase(c));\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\npublic class Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        int maxPrime = -1;\n        \n        for (int num : lst) {\n            if (isPrime(num) && num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n\n        return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False if the given map is empty.\n     * Examples:\n     * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n     * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n     * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n     * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n     * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLower = true;\n        boolean allUpper = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                allLower = false;\n                allUpper = false;\n                break;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLower = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpper = false;\n            }\n        }\n\n        return allLower || allUpper;\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of their unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels for easy lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        \n        // Iterate through the string, checking each character at even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            \n            // Check if the current character is an uppercase vowel\n            if (vowels.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is negative or positive to determine rounding direction\n        if (num < 0) {\n            return (int)Math.ceil(num - 0.5); // Round towards more negative for negative numbers\n        } else {\n            return (int)Math.floor(num + 0.5); // Round towards more positive for non-negative numbers\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"));\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"));\n     */\n    public List<String> words_string(String s) {\n        // Split the string using a regular expression pattern for commas and spaces\n        String[] splitArray = s.split(\"[,\\\\s]\\\\s*\");\n        \n        // Convert array to list and return it\n        List<String> result = new ArrayList<>(Arrays.asList(splitArray));\n        return result;\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number \n     * that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x <= y\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the rounded average of integers from n through m (inclusive) and returns its binary representation.\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return The binary string of the rounded average if valid, otherwise -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of numbers from n to m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute the average and round it to the nearest integer\n        double avg = (double) sum / count;\n        int roundedAvg = (int) Math.round(avg);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Helper method to check if an integer has only odd digits\n        return x.stream()\n                .filter(this::hasOnlyOddDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasOnlyOddDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // All digits are odd\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define an array of strings representing numbers from 1 to 9.\n        String[] numberNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter the input list for integers between 1 and 9 inclusive.\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted() // Sort in ascending order\n                                        .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredList);\n        \n        // Convert each integer to its corresponding name and collect into a new list.\n        List<String> result = filteredList.stream()\n                                          .map(num -> numberNames[num - 1])\n                                          .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        int originalNumber = number, reversedNumber = 0;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            number /= 10;\n        }\n\n        return originalNumber == reversedNumber;\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                        .filter(num -> sum_of_digits(num) > 0)\n                        .count();\n    }\n\n    private int sum_of_digits(int n) {\n        if (n == 0) {\n            return 0;\n        } else if (n > 0) {\n            return Arrays.stream(String.valueOf(n).split(\"\"))\n                         .mapToInt(Integer::parseInt)\n                         .sum();\n        } else {\n            String str = String.valueOf(-n);\n            int sum = Arrays.stream(str.split(\"\"))\n                            .mapToInt(Integer::parseInt)\n                            .sum();\n            if (str.length() > 1) {\n                return sum - Integer.parseInt(String.valueOf(str.charAt(0)));\n            }\n            return sum;\n        }\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to get an array sorted in non-decreasing order by performing right shift operations.\n     *\n     * @param arr List of integers representing the array.\n     * @return true if it's possible to sort the array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, return true\n        if (arr.size() <= 1) {\n            return true;\n        }\n\n        int count = 0; // Count of rotations needed to get non-decreasing order\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element\n        if (arr.get(arr.size() - 1) > arr.get(0)) {\n            count++;\n        }\n\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.List;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCount = 0;\n        \n        // Count how many odd numbers are in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenExchangeable = 0;\n\n        // Count how many even numbers are available in lst2 to exchange with odd numbers from lst1\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenExchangeable++;\n            }\n        }\n\n        return oddCount <= evenExchangeable ? \"YES\" : \"NO\";\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Example:\n    histogram(\"a b c\") == {\"a\": 1, \"b\": 1, \"c\": 1}\n    histogram(\"a b b a\") == {\"a\": 2, \"b\": 2}\n    histogram(\"a b c a b\") == {\"a\": 2, \"b\": 2}\n    histogram(\"b b b b a\") == {\"b\": 4}\n    histogram(\"\") == {}\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into individual letters\n        String[] letters = test.split(\"\\\\s+\");\n        \n        // Initialize a map to count occurrences of each letter\n        Map<String, Integer> letterCount = new HashMap<>();\n        int maxCount = 0;\n        \n        // Count occurrences of each letter\n        for (String letter : letters) {\n            if (!letter.isEmpty()) { // Ensure the letter is not an empty string\n                int count = letterCount.getOrDefault(letter, 0) + 1;\n                letterCount.put(letter, count);\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n\n        // Collect all letters with the maximum occurrence\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCount.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left) != resultString.charAt(right)) {\n                isPalindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> result = new ArrayList<>();\n        result.add(resultString);\n        result.add(isPalindrome);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum at each step\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.List;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Calculate total water units in all wells\n        int totalWaterUnits = 0;\n        for (List<Integer> row : grid) {\n            for (int cell : row) {\n                if (cell == 1) {\n                    totalWaterUnits++;\n                }\n            }\n        }\n\n        // Calculate the number of times buckets need to be lowered\n        return (totalWaterUnits + capacity - 1) / capacity;\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.util.stream.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Helper method to count the number of 1s in binary representation\n        return arr.stream()\n                .sorted(Comparator.comparingInt(Solution::count_ones)\n                        .thenComparingInt(n -> n))\n                .collect(Collectors.toList());\n    }\n\n    private static int count_ones(int n) {\n        int ones = 0;\n        while (n != 0) {\n            ones += n & 1;\n            n >>>= 1;\n        }\n        return ones;\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a method to count consonants in a word\n        java.util.function.Function<String, Integer> countConsonants = word -> {\n            int count = 0;\n            for (char c : word.toCharArray()) {\n                if (\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\".indexOf(c) >= 0) {\n                    count++;\n                }\n            }\n            return count;\n        };\n\n        // Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Filter and collect words with exactly n consonants\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (countConsonants.apply(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!vowels.contains(leftChar) && !vowels.contains(rightChar) && vowels.contains(middleChar)) {\n                return String.valueOf(middleChar); // Found the vowel\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < lst.size(); i++) {\n            int balance = 0;\n            boolean isBalanced = true;\n\n            for (String s : lst) {\n                for (char c : s.toCharArray()) {\n                    if (c == '(') {\n                        balance++;\n                    } else {\n                        balance--;\n                    }\n                    // If at any point the balance goes negative, it's not balanced\n                    if (balance < 0) {\n                        isBalanced = false;\n                        break;\n                    }\n                }\n            }\n\n            // Swap the order of strings and check again if first attempt failed\n            if (!isBalanced && i == 0) {\n                Collections.swap(lst, 0, 1);\n                balance = 0;\n                for (String s : lst) {\n                    for (char c : s.toCharArray()) {\n                        if (c == '(') {\n                            balance++;\n                        } else {\n                            balance--;\n                        }\n                        // If at any point the balance goes negative, it's not balanced\n                        if (balance < 0) {\n                            isBalanced = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isBalanced && balance == 0) {\n                return \"Yes\";\n            }\n        }\n\n        // If no combination works, return \"No\"\n        return \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap)\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        // Add elements to the heap until it reaches size k\n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.add(num);\n            } else if (num > pq.peek()) {  // If current element is greater than the smallest in heap, replace it.\n                pq.poll();  // Remove the smallest element\n                pq.add(num);  // Add the new element\n            }\n        }\n\n        // Convert priority queue to list and sort it since we need ascending order\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Expected: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i); // Add to sum if it's an odd number in an even position\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr, k)); // Expected output is 24\n        \n        // Additional test case\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 3;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr2, k2)); // Expected output is 28\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        \n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected output: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the required date format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input string matches the regular expression\n        boolean isFormatValid = date.matches(regex);\n        \n        // If format is not valid, return false\n        if (!isFormatValid) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is between 1 and 12\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Determine the number of days in a given month\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        int maxDaysInMonth = getMaxDays(month, isLeapYear);\n\n        // Check if the day is within the valid range for the month\n        return day >= 1 && day <= maxDaysInMonth;\n    }\n\n    private int getMaxDays(int month, boolean isLeapYear) {\n        switch (month) {\n            case 2: return isLeapYear ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11: return 30;\n            default: return 31;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace and split if found\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // If no whitespaces, check for commas and split if found\n        words = txt.split(\",\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // Count lowercase letters with odd order indices in the alphabet\n        int countOddOrderLetters = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    countOddOrderLetters++;\n                }\n            }\n        }\n\n        return countOddOrderLetters;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"NoSpacesHere\")); // Should print the number of odd-order lowercase letters\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"));\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (previousNumber != null && lst.get(i) < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (i > 0 && lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = lst.get(i);\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.List;\n\npublic class Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start_max = Math.max(interval1.get(0), interval2.get(0));\n        int end_min = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start_max > end_min) {\n            return \"NO\";\n        }\n\n        int length = end_min - start_max + 1;\n        return isPrime(length) ? \"YES\" : \"NO\";\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize the answer with a large value to ensure any path will be smaller\n        List<Integer> ans = new ArrayList<>(Collections.nCopies(k, Integer.MAX_VALUE));\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start DFS from each cell to find the minimum path\n                dfs(grid, k, new ArrayList<>(), i, j, ans);\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, List<Integer> path, int row, int col, List<Integer> ans) {\n        if (path.size() == k) {\n            // Update the answer with the lexicographically smaller path\n            if (isSmaller(path, ans)) {\n                ans.clear();\n                ans.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0], newCol = col + dir[1];\n            // Check bounds and add the next cell to the path\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid.get(0).size()) {\n                path.add(grid.get(newRow).get(newCol));\n                dfs(grid, k, path, newRow, newCol, ans);\n                // Backtrack to explore other paths\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        int size = Math.min(a.size(), b.size());\n        for (int i = 0; i < size; ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> tribonacciSequence = new ArrayList<>();\n        tribonacciSequence.add(1); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + i / 2;\n            } else {\n                nextValue = tribonacciSequence.get(i - 2) + \n                            tribonacciSequence.get(i - 3) + \n                            triHelper(n, i + 1);\n            }\n            tribonacciSequence.add(nextValue);\n        }\n        \n        // Add the initial value of 3 at index 1\n        tribonacciSequence.set(0, 3);\n        return tribonacciSequence;\n    }\n\n    private int triHelper(int n, int i) {\n        if (i > n + 1 || i < 2) {\n            return 0; // Base case for out-of-bounds indices\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(1); // tri(1)\n        \n        for (int j = 2; j <= n + 1; j++) {\n            int nextValue;\n            if (j % 2 == 0) {\n                nextValue = 1 + j / 2;\n            } else {\n                nextValue = sequence.get(j - 2) + \n                            sequence.get(j - 3) + \n                            triHelper(n, j + 1);\n            }\n            sequence.add(nextValue);\n        }\n        \n        return sequence.get(i - 2); // Return the value at index i-2\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean hasNested = false;\n\n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n            } else if (ch == ']') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                stack.pop();\n                // Check if there was a nested structure before popping the current bracket\n                if (!stack.isEmpty() || hasNested) {\n                    hasNested = true;\n                }\n            }\n        }\n\n        return hasNested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilValue = Math.ceil(num);\n            // Square the rounded value and add it to the sum\n            sum += (int)Math.pow(ceilValue, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") -> false\n    check_if_last_char_is_a_letter(\"apple pi e\") -> true\n    check_if_last_char_is_a_letter(\"apple pi e \") -> false\n    check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n        \n        // Strip trailing spaces\n        String strippedTxt = txt.trim();\n        \n        // Get the last character of the stripped string\n        char lastChar = strippedTxt.charAt(strippedTxt.length() - 1);\n        \n        // Check if the last character is an alphabetical letter and not part of a word\n        boolean isLastCharLetter = Character.isAlphabetic(lastChar);\n        boolean isNotPartOfWord = (strippedTxt.length() == 0 || strippedTxt.charAt(strippedTxt.length() - 2) == ' ');\n        \n        return isLastCharLetter && isNotPartOfWord;\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object obj) {\n        if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(',', '.'); // Convert comma to dot for parsing\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        }\n\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        }\n\n        if (obj instanceof Float || obj instanceof Double) {\n            return ((Number) obj).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(compare_one(1, \"2,3\")); // Optional[2,3]\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional[6]\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers greater than or equal to 8 can be expressed this way,\n        // but we know that n - 8 must be expressible as a sum of three positive even numbers for n >= 12.\n        if (n % 2 == 0 && n >= 12) {\n            return true;\n        }\n\n        // For the edge case where n is between 8 and 11, we need to check manually:\n        int[] testCases = {8, 10};\n        for (int testCase : testCases) {\n            if (n == testCase) return true;\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long product = 1;\n        for (int j = 2; j <= number; j++) {\n            product *= j;\n        }\n        return product;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        return result.replaceAll(\" \", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));          // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));       // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));      // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));    // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex == -1 || fileName.lastIndexOf('.') != dotIndex) {\n            return \"No\";\n        }\n\n        // Split the file name into two parts: before and after the dot\n        String baseName = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        // Check if the part before the dot is valid\n        if (!isValidBase(baseName)) {\n            return \"No\";\n        }\n\n        // Check if the part after the dot is a valid extension\n        if (!isValidExtension(extension)) {\n            return \"No\";\n        }\n\n        // Count digits in the base name and ensure there are no more than three\n        int digitCount = 0;\n        for (char c : baseName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n\n    private boolean isValidBase(String baseName) {\n        // Check that the base name starts with a letter and is not empty\n        if (baseName.isEmpty() || !Character.isLetter(baseName.charAt(0))) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isValidExtension(String extension) {\n        // Valid extensions are \"txt\", \"exe\", or \"dll\"\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        for (String ext : validExtensions) {\n            if (ext.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"file1234.txt\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     *\n     * Examples:\n     * For lst = [1,2,3] the output should be 6\n     * For lst = []  the output should be 0\n     * For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sum_squares(List<Integer> lst) {\n        int totalSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                totalSum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                totalSum += Math.pow(lst.get(i), 3);\n            } else {\n                totalSum += lst.get(i);\n            }\n        }\n        \n        return totalSum;\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Checks if a given number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected output: \"is\"\n\n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n and checks if it evaluates to a whole number.\n     *\n     * @param x The first fraction in string format \"<numerator>/<denominator>\".\n     * @param n The second fraction in string format \"<numerator>/<denominator>\".\n     * @return true if x * n is a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Calculate the product of the two fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number by seeing if the remainder is zero when dividing the numerator by the denominator.\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Helper function to calculate digits of a number\n        class DigitSumCalculator {\n            private int[] getDigits(int n) {\n                boolean isNegative = n < 0;\n                List<Integer> digits = new ArrayList<>();\n                if (n == 0) {\n                    digits.add(0);\n                } else {\n                    n = Math.abs(n);\n                    while (n > 0) {\n                        digits.add(n % 10);\n                        n /= 10;\n                    }\n                    if (isNegative) {\n                        digits.set(0, -digits.get(0));\n                    }\n                }\n                return digits.stream().mapToInt(i -> i).toArray();\n            }\n\n            private int sumDigits(int[] digits) {\n                int sum = 0;\n                for (int digit : digits) {\n                    sum += Math.abs(digit);\n                }\n                if (isNegative(digits)) {\n                    sum -= digits[0];\n                }\n                return sum;\n            }\n\n            private boolean isNegative(int[] digits) {\n                return digits.length > 0 && digits[0] < 0;\n            }\n        }\n\n        DigitSumCalculator calculator = new DigitSumCalculator();\n        \n        // Pair each number with its index\n        List<int[]> numsWithIndex = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            int[] pair = {nums.get(i), i};\n            numsWithIndex.add(pair);\n        }\n\n        // Sort based on digit sum and original index in case of ties\n        Collections.sort(numsWithIndex, (a, b) -> {\n            int sumA = calculator.sumDigits(calculator.getDigits(a[0]));\n            int sumB = calculator.sumDigits(calculator.getDigits(b[0]));\n            if (sumA != sumB) {\n                return Integer.compare(sumA, sumB);\n            } else {\n                return Integer.compare(a[1], b[1]);\n            }\n        });\n\n        // Extract sorted numbers\n        List<Integer> result = new ArrayList<>();\n        for (int[] pair : numsWithIndex) {\n            result.add(pair[0]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                         .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                         .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many numbers in the array are congruent to each of 0, 1, and 2 modulo 3\n        int countMod0 = 0, countMod1 = 0, countMod2 = 0;\n\n        for (int num : a) {\n            if (num % 3 == 0) countMod0++;\n            else if (num % 3 == 1) countMod1++;\n            else countMod2++;\n        }\n\n        // Calculate the number of valid triples\n        int result = 0;\n        result += countMod0 * (countMod0 - 1) * (countMod0 - 2) / 6; // All three numbers are congruent to 0 mod 3\n        result += countMod1 * (countMod1 - 1) * (countMod1 - 2) / 6; // All three numbers are congruent to 1 mod 3\n        result += countMod2 * (countMod2 - 1) * (countMod2 - 2) / 6; // All three numbers are congruent to 2 mod 3\n        result += countMod0 * countMod1 * countMod2; // One number is congruent to each of 0, 1, and 2 mod 3\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) return Collections.emptyList();\n\n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> evenLengthStrings = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                evenLengthStrings.add(s);\n            }\n        }\n\n        // Sort the list by length, and then alphabetically for strings of the same length\n        Collections.sort(evenLengthStrings, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return Integer.compare(s1.length(), s2.length());\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return evenLengthStrings;\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));   // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sumOfSquares = 0;\n\n        for (Object item : lst) {\n            if (item instanceof Integer) {\n                int number = (Integer) item;\n                if (number > 0 && number % 2 != 0) {\n                    sumOfSquares += number * number;\n                }\n            }\n        }\n\n        return sumOfSquares;\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list to its corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class based on the provided list of extensions.\n     * The strength of an extension is calculated as CAP - SM, where CAP is the number of uppercase letters,\n     * and SM is the number of lowercase letters in the extension's name. If there are multiple extensions\n     * with the same strength, the first one in the list is chosen.\n     *\n     * @param class_name The name of the class to which the strongest extension will be attached.\n     * @param extensions A List containing names of possible extensions for the class.\n     * @return A string representing the class and its strongest extension in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        // Initialize variables to track the strongest extension\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String name) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : name.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given  2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n     * cycpattern_check(\"abcd\",\"abd\") => false\n     * cycpattern_check(\"hello\",\"ell\") => true\n     * cycpattern_check(\"whassup\",\"psus\") => false\n     * cycpattern_check(\"abab\",\"baa\") => true\n     * cycpattern_check(\"efef\",\"eeff\") => false\n     * cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the first word with itself\n        String doubled_a = a + a;\n        \n        // Check if the second word is a substring of the concatenated string\n        return doubled_a.contains(b);\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a positive value and then to string for easy iteration\n        String strNum = Integer.toString(Math.abs(num));\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char c = strNum.charAt(i);\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not, it's odd\n                oddCount++;\n            }\n        }\n\n        // Return the counts as a list [even count, odd count]\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the method\n        System.out.println(solution.even_odd_count(-12));  // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        // Mapping of integers to Roman numerals (in lowercase)\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Update the maximum if this word has more unique characters or is lexicographically smaller\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    // Test function to verify the correctness of find_max\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1));  // Expected: string\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2));  // Expected: enam\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Determine how many carrots are left after eating.\n        int leftoverCarrots = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of eaten carrots and the number of leftover carrots.\n        return new ArrayList<>(List.of(totalEaten, leftoverCarrots));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        expression.append(operand.get(0));\n        \n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n        \n        // Java does not have an eval function, so we need to manually parse and evaluate the expression.\n        return evaluateExpression(expression.toString());\n    }\n\n    private int evaluateExpression(String expression) {\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> operators = new Stack<>();\n        \n        for (int i = 0; i < expression.length(); ) {\n            char c = expression.charAt(i);\n            \n            if (Character.isDigit(c)) {\n                int num = 0;\n                while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                    num = num * 10 + (expression.charAt(i) - '0');\n                    i++;\n                }\n                values.push(num);\n            } else if (\"+-*/\".indexOf(c) >= 0) {\n                while (!operators.isEmpty() && precedence(operators.peek()) >= precedence(c)) {\n                    applyOperation(values, operators);\n                }\n                operators.push(c);\n                i++;\n            } else {\n                i++;\n            }\n        }\n\n        while (!operators.isEmpty()) {\n            applyOperation(values, operators);\n        }\n\n        return values.pop();\n    }\n\n    private void applyOperation(Stack<Integer> values, Stack<Character> operators) {\n        int b = values.pop();\n        int a = values.pop();\n        char op = operators.pop();\n\n        switch (op) {\n            case '+':\n                values.push(a + b);\n                break;\n            case '-':\n                values.push(a - b);\n                break;\n            case '*':\n                values.push(a * b);\n                break;\n            case '/':\n                values.push(a / b); // Assuming integer division\n                break;\n        }\n    }\n\n    private int precedence(char op) {\n        if (op == '+' || op == '-') return 1;\n        else if (op == '*' || op == '/') return 2;\n        else return -1; // For '**' or other invalid operators\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = digest.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hash);\n        String hashtext = number.toString(16);\n\n        // Add leading zeros to make sure it's 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is less than or equal to b for simplicity in generating even digits\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n\n        List<Integer> evenDigits = new ArrayList<>();\n        \n        for (int num = start; num <= end; num++) {\n            if (num < 10 && num % 2 == 0) {\n                evenDigits.add(num);\n            }\n        }\n\n        return evenDigits;\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers that are closer to each other than a given threshold.\n     *\n     * @param numbers List<Double> - A list of floating-point numbers.\n     * @param threshold double - The minimum distance between any two elements for them not to be considered close.\n     * @return boolean - Returns true if there are at least two elements in the list that are closer than the threshold, otherwise false.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Additional test cases\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.5, 8.7), 0.4);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        boolean result4 = solution.has_close_elements(Arrays.asList(-2.0, -1.0, 0.5, 1.5), 0.6);\n        System.out.println(\"Test Case 4: \" + (result4 ? \"Passed\" : \"Failed\")); // Expected output: Failed\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * Example:\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < cleanString.length(); i++) {\n            char c = cleanString.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(cleanString.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String input = \"( ) (( )) (( )( ))\";\n        List<String> output = solution.separate_paren_groups(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Output: [\" + String.join(\", \", output) + \"]\");\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to check the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n        System.out.println(solution.truncate_number(0.123));  // Expected output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposit (positive) or withdrawal (negative) amounts.\n     * @return boolean indicating whether the balance goes negative at any point.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance has fallen below zero\n            }\n        }\n        return false; // No negative balance detected\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false as the balance never goes below zero.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true as after -4, the balance is negative.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyList); // Expected output: []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyList); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, returns the deepest level of nesting of parentheses as an integer in a list.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A List<Integer> where each element represents the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    /**\n     * A test method to verify the correctness of parse_nested_parens function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result;\n\n        // Test case 1\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        result = solution.parse_nested_parens(input1);\n        System.out.println(\"Test Case 1: \" + (result.equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        String input2 = \"() ()\";\n        List<Integer> expectedOutput2 = Arrays.asList(1, 1);\n        result = solution.parse_nested_parens(input2);\n        System.out.println(\"Test Case 2: \" + (result.equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        String input3 = \"(())() ((()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(2, 3);\n        result = solution.parse_nested_parens(input3);\n        System.out.println(\"Test Case 3: \" + (result.equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java 8 Streams API for filtering the list based on a condition.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        \n        // Generate rolling max\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n        \n        // Verify correctness\n        if (expectedOutput.equals(output)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String str) {\n        int i = 0;\n        int j = str.length() - 1;\n        while (i < j) {\n            if (str.charAt(i) != str.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     * Algorithm idea is simple:\n     * - Find the longest postfix of supplied string that is a palindrome.\n     * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    public String make_palindrome(String str) {\n        // Iterate over possible lengths of postfixes starting from the length of the entire string down to 0\n        for (int i = str.length(); i >= 0; i--) {\n            if (isPalindrome(str.substring(i))) {\n                // If a palindromic suffix is found, break out of the loop\n                String prefix = str.substring(0, i);\n                return str + new StringBuilder(prefix).reverse().toString();\n            }\n        }\n        // In case no palindromic postfix is found (though it should always find at least an empty string as a palindromic suffix)\n        return str;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.make_palindrome(\"\"));  // Output: \"\"\n        System.out.println(solution.make_palindrome(\"cat\"));  // Output: \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\"));  // Output: \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11011\"));  // Expected output: \"01110\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\"));  // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\"));  // Expected output: \"0000\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-9, -18)); // Expected output: 9\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        // Additional test cases\n        List<String> emptyPrefixes = solution.all_prefixes(\"\");\n        System.out.println(emptyPrefixes);  // Expected output: []\n        \n        List<String> singleCharPrefixes = solution.all_prefixes(\"x\");\n        System.out.println(singleCharPrefixes);  // Expected output: [x]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string representing musical notes in a special ASCII format.\n     * Your task is to parse this string and return list of integers corresponding to how many beats does each\n     * note last.\n     *\n     * Here is a legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quarter note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        // Split the input string into individual notes using whitespace as delimiter\n        String[] notes = string.split(\"\\\\s+\");\n        \n        // Initialize a list to store the number of beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Iterate through each note and determine its duration in beats\n        for (String note : notes) {\n            if (note.equals(\"o\")) {\n                beats.add(4);\n            } else if (note.equals(\"o|\")) {\n                beats.add(2);\n            } else if (note.equals(\".|\")) {\n                beats.add(1);\n            }\n        }\n        \n        // Return the list of beat durations\n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each number word to its corresponding integer value.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its integer value and sort them.\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into number words.\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            String word = \"\";\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key).equals(num)) {\n                    word = key;\n                    break;\n                }\n            }\n            result.append(word);\n            result.append(\" \");\n        }\n\n        // Remove the trailing space and return the result.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected output: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding closest elements easier.\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), applies a linear transform such that \n     * the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledNumber = (number - min) / (max - min);\n            scaledNumbers.add(scaledNumber);\n        }\n        \n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Collections.emptyMap(), Collections.emptyList());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i > 0; i--) { // Start from half of n and go down to 1\n            if (n % i == 0) { // Check if i divides n evenly\n                return i; // Return the first divisor found, which is the largest one\n            }\n        }\n        return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n        System.out.println(solution.largest_divisor(60)); // Expected output: 30\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 to get rid of all even factors\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once and preserve the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     * \n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over the list and append each string to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test function to verify the correctness of the filter_by_prefix method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print: []\n\n        List<String> listWithPrefixes = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(listWithPrefixes, \"a\")); // Should print: [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n\n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.List;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        // Implementing a simple bisection method to find the root of the polynomial.\n        double left = -100.0;  // Start with a large negative number\n        double right = 100.0;   // Start with a large positive number\n        \n        while (Math.abs(right - left) > 1e-6) {\n            double mid = (left + right) / 2;\n            if (poly(xs, mid) == 0) {\n                return mid;\n            } else if (poly(xs, left) * poly(xs, mid) < 0) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three\n     * are equal to the values of the corresponding indices of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 (0-based indexing)\n        List<Integer> divisibleByThree = new ArrayList<>();\n        for (int i = 2; i < l.size(); i += 3) {\n            divisibleByThree.add(l.get(i));\n        }\n\n        // Sort the extracted elements\n        Collections.sort(divisibleByThree);\n\n        // Create a result list to store the final output\n        List<Integer> result = new ArrayList<>();\n        int sortedIndex = 0;\n\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Check if index is divisible by 3 in 1-based indexing\n                result.add(divisibleByThree.get(sortedIndex));\n                sortedIndex++;\n            } else {\n                result.add(l.get(i));\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + testList1);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList1));\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 5, 4, 3, 2, 1);\n        System.out.println(\"Original: \" + testList2);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList2));\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(9, 7, 5, 3, 1);\n        System.out.println(\"Original: \" + testList3);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0); // Assume the first element is the largest initially\n        \n        for (int i = 1; i < l.size(); i++) { // Start from the second element\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Expected output: 0\n        System.out.println(solution.fizz_buzz(78)); // Expected output: 2\n        System.out.println(solution.fizz_buzz(79)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the elements at even indices\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the 'evens' list\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the 'evens' list\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values from 'evens'\n        for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n            sortedList.set(i, evens.get(j));\n        }\n        \n        return sortedList;\n    }\n\n    // Method to test the sort_even function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    public String encodeCyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Cycle elements in each group unless group has fewer than 3 characters\n        List<String> encodedGroups = new ArrayList<>();\n        for (String group : groups) {\n            if (group.length() == 3) {\n                encodedGroups.add(group.substring(1) + group.charAt(0));\n            } else {\n                encodedGroups.add(group);\n            }\n        }\n\n        return String.join(\"\", encodedGroups);\n    }\n\n    public String decodeCyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Reverse the cycle operation to decode each group\n        List<String> decodedGroups = new ArrayList<>();\n        for (String group : groups) {\n            if (group.length() == 3) {\n                decodedGroups.add(group.charAt(2) + group.substring(0, 2));\n            } else {\n                decodedGroups.add(group);\n            }\n        }\n\n        return String.join(\"\", decodedGroups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n        }\n\n        return primes.get(primes.size() - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for easier traversal\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on a straight road.\n     *\n     * @param n The number of cars in each set (one set moving left to right, and one set moving right to left).\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from the left will collide with every car from the right,\n        // the total number of collisions is simply n (left cars) times n (right cars).\n        return n * n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 4\n        System.out.println(solution.car_race_collision(3));  // Expected output: 9\n        System.out.println(solution.car_race_collision(5));  // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and high return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        // Area formula: (1/2) * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Area of triangle with base=10 and height=4: \" + area2); // Expected output: 20.0\n        \n        // Test case 3 (with floating point numbers)\n        double area3 = solution.triangle_area(7.5, 2.5);\n        System.out.println(\"Area of triangle with base=7.5 and height=2.5: \" + area3); // Expected output: 9.375\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        else if (n == 2) return 2;\n        else if (n == 3) return 0;\n\n        // Initialize base cases\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; i++) {\n            int next_value = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next_value;\n        }\n\n        return d;\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list first\n        Collections.sort(l);\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return the middle element\n            return l.get(size / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "class Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left++) != text.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test cases using assertions\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        assert solution.is_palindrome(\"\") : \"Empty string should be a palindrome\";\n        assert solution.is_palindrome(\"aba\") : \"'aba' is a palindrome\";\n        assert solution.is_palindrome(\"aaaaa\") : \"'aaaaa' is a palindrome\";\n        assert !solution.is_palindrome(\"zbcd\") : \"'zbcd' is not a palindrome\";\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // 2^0 = 1 for any p\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base value\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5)); // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101)); // Expected output: 1\n        System.out.println(solution.modp(3, 11)); // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"hello\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should output \"mjqqt\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should output \"hello\"\n\n        String testString2 = \"World\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should output \"BTQYI\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should output \"World\"\n\n        // Test with non-letter characters\n        String testString3 = \"abc123\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should output \"fghi123\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should output \"abc123\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string and append non-vowel characters to result\n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + (solution.below_threshold(list1, threshold1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + (solution.below_threshold(list2, threshold2) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"add(2, 3): \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7): \" + solution.add(5, 7)); // Expected output: 12\n\n        // Additional test cases for robustness\n        System.out.println(\"add(-10, 4): \" + solution.add(-10, 4)); // Expected output: -6\n        System.out.println(\"add(0, 0): \" + solution.add(0, 0));     // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from the first string\n        Set<Character> charSet = new HashSet<>();\n        \n        // Add all characters from the first string into the set\n        for (char c : s0.toCharArray()) {\n            charSet.add(c);\n        }\n        \n        // Check if every character in the second string is present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charSet.contains(c)) {\n                return false;\n            }\n        }\n\n        // Create a set to store unique characters from the second string\n        Set<Character> charSet2 = new HashSet<>();\n        \n        // Add all characters from the second string into the set\n        for (char c : s1.toCharArray()) {\n            charSet2.add(c);\n        }\n        \n        // Check if every character in the first string is present in this new set\n        for (char c : s0.toCharArray()) {\n            if (!charSet2.contains(c)) {\n                return false;\n            }\n        }\n\n        // If all checks pass, both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the number of open and close brackets\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n\n            // If at any point the number of closing brackets is more than opening ones, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // At the end, there should be no unmatched open brackets left\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() <= 1) return true; // A single element is trivially monotonic\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(\"Largest prime factor of 13195: \" + solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(\"Largest prime factor of 2048: \" + solution.largest_prime_factor(2048));   // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    /**\n     * A method to test the correctness of the sum_to_n function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5));    // Expected output: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1));    // Expected output: 1\n        \n        // Additional test case to ensure correctness\n        System.out.println(\"sum_to_n(1000): \" + solution.sum_to_n(1000)); // Expected output: 500500\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the balance between '(' and ')'\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++; // Increment when an opening bracket is found\n            } else if (c == ')') {\n                balance--; // Decrement when a closing bracket is found\n                \n                // If at any point the balance goes negative, it means there are more closing brackets than opening ones.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative will have one less term than the original polynomial,\n        // unless it's a constant (degree 0), which has no terms after differentiation.\n        if (xs.size() <= 1) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.length() == 0) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     * >>> circular_shift(12, 1)\n     * \"21\"\n     * >>> circular_shift(12, 2)\n     * \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        \n        // Get the number of digits in the string\n        int numDigits = numStr.length();\n        \n        // If shift is greater than the number of digits, return the reversed string\n        if (shift > numDigits) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Calculate the effective shift value\n        int effectiveShift = shift % numDigits;\n        \n        // Perform the circular shift operation\n        String shiftedStr = numStr.substring(numDigits - effectiveShift) + numStr.substring(0, numDigits - effectiveShift);\n        \n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in a basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the count of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mango fruits\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the record.\n                if (value < smallestEvenValue || i < index) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1; // Initialize result to -1\n        \n        // Iterate through the entries of the frequency map\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            \n            // Check if the number's frequency is greater than or equal to the number itself\n            if (num <= freq) {\n                result = Math.max(result, num); // Update result with the maximum value found\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given list of integers, return list in strange order.\n     Strange sorting, is when you start with the minimum value,\n     then maximum of the remaining integers, then minimum and so on.\n\n     Examples:\n     strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        \n        while (!lst.isEmpty()) {\n            // Find and append the minimum value\n            int minVal = Integer.MAX_VALUE;\n            for (int num : lst) {\n                if (num < minVal) {\n                    minVal = num;\n                }\n            }\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) {\n                break;\n            }\n\n            // Find and append the maximum value\n            int maxVal = Integer.MIN_VALUE;\n            for (int num : lst) {\n                if (num > maxVal) {\n                    maxVal = num;\n                }\n            }\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the object q will fly, and false otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w and the list is a palindrome\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic.\n     *\n     * @param arr List<Integer> representing the input array.\n     * @return int representing the minimum number of changes needed.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            if (!arr.get(i).equals(arr.get(n - i - 1))) {\n                changes++;\n            }\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));   // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList(\"a\", \"b\", \"c\"))); // []\n        System.out.println(solution.total_match(Arrays.asList(\"abc\", \"def\"), Arrays.asList(\"ghi\"))); // [\"ghi\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            \n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a) return true;\n                    \n                    if (p1 * p2 * p3 > a) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        int currentPower = n;\n        while (currentPower < x) {\n            currentPower *= n;\n        }\n        \n        return currentPower == x;\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube of some integer.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cubeRoot = Math.cbrt(absA);\n        long roundedCubeRoot = Math.round(cubeRoot);\n\n        // Check if cubing the rounded value equals the original number\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube method\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Define a set of hexadecimal digits that are prime numbers.\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of characters in the input string that are prime hex digits.\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A test method to check the correctness of the decimal_to_binary function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(7));   // Expected output: \"db111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is a happy string.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\"); // This case should not happen as GPA is non-negative\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        \n        // Check for edge cases\n        if (len <= 1) return false;\n        if (len == 2) return true; // 2 is the only even prime number\n        \n        // Check divisibility by numbers up to sqrt(len)\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        \n        // Numbers starting with 1\n        long start_with_1 = (long) Math.pow(9, n - 1);\n        \n        // Numbers ending with 1\n        long end_with_1 = (long) Math.pow(9, n - 1);\n        \n        // Double counting: numbers that both start and end with 1\n        long double_counting = (n > 2) ? (long) Math.pow(8, n - 2) : 0;\n        \n        return (int)(start_with_1 + end_with_1 - double_counting);\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        // Calculate the sum of digits of N\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2, 9))); // Expected output: 5 (since only one even number at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 7, 8, 2))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string where each word's characters are sorted alphabetically.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                \n                // Append sorted characters to the result, followed by a space\n                result.append(new String(chars));\n            }\n            \n            // Append a space after each non-empty word\n            result.append(\" \");\n        }\n\n        // Remove trailing space if present and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinate to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, it's both the first and last.\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        // Create a copy of the original list to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a given string by rotating each letter down by 4 places in the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted and remain the same.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Set<Integer> uniqueElements = new HashSet<>(lst);\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(uniqueElements);\n        Collections.sort(sortedList);\n\n        return Optional.of(sortedList.get(1));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the sentence into individual sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. Are you? I think so!\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility)\n     * @param y Second number (Object type for flexibility)\n     * @param z Third number (Object type for flexibility)\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (will be false because inputs are not all integers)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Write a function that takes a message, and encodes in such a\n     way that it swaps case of all letters, replaces all vowels in\n     the message with the letter that appears 2 places ahead of that\n     vowel in the english alphabet.\n     Assume only letters.\n\n     Examples:\n     >>> encode(\"test\")\n     \"TGST\"\n     >>> encode(\"This is a message\")\n     \"tHKS KS C MGSSCGG\"\n      */\n    public String encode(String message) {\n        // Define shifted vowels mapping\n        Map<Character, Character> shiftedVowels = new HashMap<>();\n        shiftedVowels.put('a', 'c');\n        shiftedVowels.put('e', 'g');\n        shiftedVowels.put('i', 'k');\n        shiftedVowels.put('o', 'q');\n        shiftedVowels.put('u', 'w');\n        shiftedVowels.put('A', 'C');\n        shiftedVowels.put('E', 'G');\n        shiftedVowels.put('I', 'K');\n        shiftedVowels.put('O', 'Q');\n        shiftedVowels.put('U', 'W');\n\n        // Initialize a StringBuilder to build the encoded message\n        StringBuilder encodedMessage = new StringBuilder();\n\n        // Iterate through each character in the input message\n        for (char charAt : message.toCharArray()) {\n            if (Character.isLetter(charAt)) {\n                char newChar = Character.isUpperCase(charAt) ? Character.toLowerCase(charAt) : Character.toUpperCase(charAt);\n                \n                if (shiftedVowels.containsKey(newChar)) {\n                    newChar = shiftedVowels.get(newChar);\n                }\n            } else {\n                newChar = charAt;\n            }\n\n            // Append the transformed character to the encoded message\n            encodedMessage.append(newChar);\n        }\n\n        return encodedMessage.toString();\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\n\nclass Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        int maxPrime = -1;\n        \n        for (int num : lst) {\n            if (isPrime(num) && num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n\n        return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLower = true;\n        boolean allUpper = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                allLower = false;\n                allUpper = false;\n                break;\n            }\n            \n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLower = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpper = false;\n            }\n        }\n\n        return allLower || allUpper;\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of their unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels for easy lookup\n        String vowels = \"AEIOU\";\n        int count = 0;\n        \n        // Iterate through the string, checking each character at even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            if (vowels.indexOf(s.charAt(i)) != -1) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is negative or positive to determine rounding direction\n        if (num < 0) {\n            return (int)Math.ceil(num - 0.5); // Round towards more negative for negative numbers\n        } else {\n            return (int)Math.floor(num + 0.5); // Round towards more positive for non-negative numbers\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a string of words separated by commas or spaces.\n     * Your task is to split the string into words and return an array of the words.\n     *\n     * For example:\n     * words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"));\n     * words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"));\n     */\n    public List<String> words_string(String s) {\n        // Use a regular expression to split the string based on commas and spaces\n        String[] words = s.split(\"[,\\\\s]+\");\n        \n        // Convert the array of strings into a list\n        return new ArrayList<>(Arrays.asList(words));\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number \n     * that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x <= y\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the rounded average of integers from n through m (inclusive) and returns its binary representation.\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return The binary string of the rounded average if valid, otherwise -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of numbers from n to m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute the average and round it to the nearest integer\n        double avg = (double) sum / count;\n        int roundedAvg = (int) Math.round(avg);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Helper method to check if an integer has only odd digits\n        return x.stream()\n                .filter(this::hasOnlyOddDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasOnlyOddDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // All digits are odd\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define an array of strings representing numbers from 1 to 9.\n        String[] numberNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter the input list for integers between 1 and 9 inclusive.\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted() // Sort in ascending order\n                                        .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredList);\n        \n        // Convert each integer to its corresponding name and collect into a new list.\n        List<String> result = filteredList.stream()\n                                          .map(num -> numberNames[num - 1])\n                                          .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        int originalNumber = number, reversedNumber = 0;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            number /= 10;\n        }\n\n        return originalNumber == reversedNumber;\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream().filter(num -> sum_of_digits(num) > 0).count();\n    }\n\n    private int sum_of_digits(int n) {\n        if (n == 0) {\n            return 0;\n        } else if (n > 0) {\n            String str = Integer.toString(n);\n            int sum = 0;\n            for (int i = 0; i < str.length(); i++) {\n                sum += Character.getNumericValue(str.charAt(i));\n            }\n            return sum;\n        } else {\n            String str = Integer.toString(-n);\n            int sum = -Character.getNumericValue(str.charAt(0)); // First digit is negative\n            for (int i = 1; i < str.length(); i++) {\n                sum += Character.getNumericValue(str.charAt(i));\n            }\n            return sum;\n        }\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to get an array sorted in non-decreasing order by performing right shift operations.\n     *\n     * @param arr List of integers representing the array.\n     * @return true if it's possible to sort the array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, return true\n        if (arr.size() <= 1) {\n            return true;\n        }\n\n        int count = 0; // Count of rotations needed to get non-decreasing order\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element\n        if (arr.get(arr.size() - 1) > arr.get(0)) {\n            count++;\n        }\n\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = (int) lst1.stream().filter(num -> num % 2 != 0).count();\n        int evenCountInLst2 = (int) lst2.stream().filter(num -> num % 2 == 0).count();\n\n        if (oddCountInLst1 <= evenCountInLst2) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Example:\n    histogram(\"a b c\") == {\"a\": 1, \"b\": 1, \"c\": 1}\n    histogram(\"a b b a\") == {\"a\": 2, \"b\": 2}\n    histogram(\"a b c a b\") == {\"a\": 2, \"b\": 2}\n    histogram(\"b b b b a\") == {\"b\": 4}\n    histogram(\"\") == {}\n     */\n    public Map<String, Integer> histogram(String test) {\n        if (test.isEmpty()) {\n            return new HashMap<>();\n        }\n\n        // Split the string into an array of letters\n        String[] letters = test.split(\" \");\n\n        // Create a map to count occurrences of each letter\n        Map<String, Integer> counts = new HashMap<>();\n\n        for (String letter : letters) {\n            counts.put(letter, counts.getOrDefault(letter, 0) + 1);\n        }\n\n        // Find the maximum occurrence value\n        int maxCount = Collections.max(counts.values());\n\n        // Filter out letters that do not have the maximum occurrence\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left) != resultString.charAt(right)) {\n                isPalindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> result = new ArrayList<>();\n        result.add(resultString);\n        result.add(isPalindrome);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum at each step\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.List;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Flatten the grid into a list of water units per well\n        List<Integer> waterUnits = new ArrayList<>();\n        for (List<Integer> row : grid) {\n            int sum = 0;\n            for (int unit : row) {\n                sum += unit;\n            }\n            waterUnits.add(sum);\n        }\n\n        // Calculate the number of times buckets need to be lowered\n        int numBucketsLowered = 0;\n        for (int units : waterUnits) {\n            numBucketsLowered += units / capacity + (units % capacity > 0 ? 1 : 0);\n        }\n        \n        return numBucketsLowered;\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Custom comparator for sorting\n        Comparator<Integer> customComparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                int countA = count_ones(a);\n                int countB = count_ones(b);\n\n                if (countA != countB) {\n                    return countA - countB;\n                } else {\n                    return a - b;\n                }\n            }\n\n            private int count_ones(int n) {\n                // Count the number of ones in the binary representation of n.\n                String binary = Integer.toBinaryString(n);\n                if (n < 0) {\n                    binary = Integer.toBinaryString(-(n + 1));\n                    return binary.length() - binary.replace(\"1\", \"\").length();\n                }\n                return binary.replaceAll(\"0\", \"\").length();\n            }\n        };\n\n        // Sort the array using the custom comparator\n        Collections.sort(arr, customComparator);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1)); // Expected: [1, 2, 4, 3, 5]\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2)); // Expected: [-4, -2, -6, -5, -3]\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3)); // Expected: [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a method to count consonants in a word\n        java.util.function.Function<String, Integer> countConsonants = word -> {\n            int count = 0;\n            for (char c : word.toCharArray()) {\n                if (\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\".indexOf(c) >= 0) {\n                    count++;\n                }\n            }\n            return count;\n        };\n\n        // Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Filter and collect words with exactly n consonants\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (countConsonants.apply(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!vowels.contains(leftChar) && !vowels.contains(rightChar) && vowels.contains(middleChar)) {\n                return String.valueOf(middleChar); // Found the vowel\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < lst.size(); i++) {\n            int balance = 0;\n            boolean isBalanced = true;\n\n            for (String s : lst) {\n                for (char c : s.toCharArray()) {\n                    if (c == '(') {\n                        balance++;\n                    } else {\n                        balance--;\n                    }\n                    // If at any point the balance goes negative, it's not balanced\n                    if (balance < 0) {\n                        isBalanced = false;\n                        break;\n                    }\n                }\n            }\n\n            // Swap the order of strings and check again if first attempt failed\n            if (!isBalanced && i == 0) {\n                Collections.swap(lst, 0, 1);\n                balance = 0;\n                for (String s : lst) {\n                    for (char c : s.toCharArray()) {\n                        if (c == '(') {\n                            balance++;\n                        } else {\n                            balance--;\n                        }\n                        // If at any point the balance goes negative, it's not balanced\n                        if (balance < 0) {\n                            isBalanced = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isBalanced && balance == 0) {\n                return \"Yes\";\n            }\n        }\n\n        // If no combination works, return \"No\"\n        return \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap)\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        // Add elements to the heap until it reaches size k\n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.add(num);\n            } else if (num > pq.peek()) {  // If current element is greater than the smallest in heap, replace it.\n                pq.poll();  // Remove the smallest element\n                pq.add(num);  // Add the new element\n            }\n        }\n\n        // Convert priority queue to list and sort it since we need ascending order\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Expected: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i); // Add to sum if it's an odd number in an even position\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr, k)); // Expected output is 24\n        \n        // Additional test case\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 3;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr2, k2)); // Expected output is 28\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        \n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected output: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the required date format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input string matches the regular expression\n        boolean isFormatValid = date.matches(regex);\n        \n        // If format is not valid, return false\n        if (!isFormatValid) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is between 1 and 12\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Determine the number of days in a given month\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        int maxDaysInMonth = getMaxDays(month, isLeapYear);\n\n        // Check if the day is within the valid range for the month\n        return day >= 1 && day <= maxDaysInMonth;\n    }\n\n    private int getMaxDays(int month, boolean isLeapYear) {\n        switch (month) {\n            case 2: return isLeapYear ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11: return 30;\n            default: return 31;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace and split if found\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // If no whitespaces, check for commas and split if found\n        words = txt.split(\",\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // Count lowercase letters with odd order indices in the alphabet\n        int countOddOrderLetters = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    countOddOrderLetters++;\n                }\n            }\n        }\n\n        return countOddOrderLetters;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"NoSpacesHere\")); // Should print the number of odd-order lowercase letters\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"));\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (previousNumber != null && lst.get(i) < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (i > 0 && lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = lst.get(i);\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Helper method to check if a number is prime\n        return isPrime(interval1, interval2) ? \"YES\" : \"NO\";\n    }\n\n    private boolean isPrime(List<Integer> interval1, List<Integer> interval2) {\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        if (startMax > endMin) {\n            return false;\n        }\n\n        int length = endMin - startMax + 1;\n        return isPrimeNumber(length);\n    }\n\n    private boolean isPrimeNumber(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize the answer with a large value to ensure any path will be smaller\n        List<Integer> ans = new ArrayList<>(Collections.nCopies(k, Integer.MAX_VALUE));\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start DFS from each cell to find the minimum path\n                dfs(grid, k, new ArrayList<>(), i, j, ans);\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, List<Integer> path, int row, int col, List<Integer> ans) {\n        if (path.size() == k) {\n            // Update the answer with the lexicographically smaller path\n            if (isSmaller(path, ans)) {\n                ans.clear();\n                ans.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0], newCol = col + dir[1];\n            // Check bounds and add the next cell to the path\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid.get(0).size()) {\n                path.add(grid.get(newRow).get(newCol));\n                dfs(grid, k, path, newRow, newCol, ans);\n                // Backtrack to explore other paths\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        int size = Math.min(a.size(), b.size());\n        for (int i = 0; i < size; ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n     * the last couple centuries. However, what people don't know is Tribonacci sequence.\n     * Tribonacci sequence is defined by the recurrence:\n     * tri(1) = 3\n     * tri(n) = 1 + n / 2, if n is even.\n     * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n     * For example:\n     * tri(2) = 1 + (2 / 2) = 2\n     * tri(4) = 3\n     * tri(3) = tri(2) + tri(1) + tri(4)\n     *        = 2 + 3 + 3 = 8\n     * You are given a non-negative integer number n, you have to return a list of the\n     * first n + 1 numbers of the Tribonacci sequence.\n     */\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                nextValue = sequence.get(i - 2) + sequence.get(i - 3) + tri(i + 1).get(0); // Calculate tri(i+1)\n            }\n            sequence.add(nextValue);\n        }\n        \n        return new ArrayList<>(sequence.subList(0, n + 1));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Expected output: [1, 3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets\n    where at least one bracket in the subsequence is nested.\n\n    is_nested(\"[[]]\") -> true\n    is_nested(\"[]]]]]]][[[[[]\") -> false\n    is_nested(\"[][]\") -> false\n    is_nested(\"[]\") -> false\n    is_nested(\"[[][]]\") -> true\n    is_nested(\"[[]][[\") -> true\n     */\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean hasNested = false;\n\n        for (char bracket : string.toCharArray()) {\n            if (bracket == '[') {\n                stack.push(bracket);\n            } else if (bracket == ']') {\n                if (!stack.isEmpty() && !hasNested && stack.size() > 1) {\n                    hasNested = true;\n                }\n                stack.pop();\n            }\n        }\n\n        return hasNested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilValue = Math.ceil(num);\n            // Square the rounded value and add it to the sum\n            sum += (int)Math.pow(ceilValue, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") -> false\n    check_if_last_char_is_a_letter(\"apple pi e\") -> true\n    check_if_last_char_is_a_letter(\"apple pi e \") -> false\n    check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n        \n        char lastChar = txt.charAt(txt.length() - 1);\n        \n        // Check if the last character is an alphabetical character and not part of a word\n        if (!lastCharIsPartOfWord(txt, lastChar)) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    private boolean lastCharIsPartOfWord(String txt, char lastChar) {\n        if (txt.length() == 1 || !Character.isWhitespace(txt.charAt(txt.length() - 2))) {\n            return false; // Last character is not part of a word\n        }\n        return true; // Last character is part of a word or the string has only one character\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object obj) {\n        if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(',', '.'); // Convert comma to dot for parsing\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        }\n\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        }\n\n        if (obj instanceof Float || obj instanceof Double) {\n            return ((Number) obj).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(compare_one(1, \"2,3\")); // Optional[2,3]\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional[6]\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers greater than or equal to 8 can be expressed this way,\n        // but we know that n - 8 must be expressible as a sum of three positive even numbers for n >= 12.\n        if (n % 2 == 0 && n >= 12) {\n            return true;\n        }\n\n        // For the edge case where n is between 8 and 11, we need to check manually:\n        int[] testCases = {8, 10};\n        for (int testCase : testCases) {\n            if (n == testCase) return true;\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long product = 1;\n        for (int j = 2; j <= number; j++) {\n            product *= j;\n        }\n        return product;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        return result.replaceAll(\" \", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));          // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));       // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));      // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));    // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex == -1 || fileName.lastIndexOf('.') != dotIndex) {\n            return \"No\";\n        }\n\n        // Split the file name into two parts: before and after the dot\n        String baseName = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        // Check if the part before the dot is valid\n        if (!isValidBase(baseName)) {\n            return \"No\";\n        }\n\n        // Check if the part after the dot is a valid extension\n        if (!isValidExtension(extension)) {\n            return \"No\";\n        }\n\n        // Count digits in the base name and ensure there are no more than three\n        int digitCount = 0;\n        for (char c : baseName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n\n    private boolean isValidBase(String baseName) {\n        // Check that the base name starts with a letter and is not empty\n        if (baseName.isEmpty() || !Character.isLetter(baseName.charAt(0))) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isValidExtension(String extension) {\n        // Valid extensions are \"txt\", \"exe\", or \"dll\"\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        for (String ext : validExtensions) {\n            if (ext.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"file1234.txt\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     *\n     * Examples:\n     * For lst = [1,2,3] the output should be 6\n     * For lst = []  the output should be 0\n     * For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sum_squares(List<Integer> lst) {\n        int resultSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                resultSum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                resultSum += Math.pow(lst.get(i), 3);\n            } else {\n                // If the index is not a multiple of 3 or 4, add the original value to the sum\n                resultSum += lst.get(i);\n            }\n        }\n\n        return resultSum;\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Checks if a given number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected output: \"is\"\n\n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n and checks if it evaluates to a whole number.\n     *\n     * @param x The first fraction in string format \"<numerator>/<denominator>\".\n     * @param n The second fraction in string format \"<numerator>/<denominator>\".\n     * @return true if x * n is a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Calculate the product of the two fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number by seeing if the remainder is zero when dividing the numerator by the denominator.\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Helper function to calculate individual digits of an integer\n        class DigitSumCalculator {\n            private static int[] digit_sum(int n) {\n                if (n == 0) return new int[]{0};\n                \n                boolean isNegative = false;\n                if (n < 0) {\n                    isNegative = true;\n                    n = -n; // Make the number positive for processing\n                }\n                \n                List<Integer> digits = new ArrayList<>();\n                while (n > 0) {\n                    digits.add(n % 10);\n                    n /= 10;\n                }\n                \n                if (isNegative) digits.set(0, -digits.get(0));\n                \n                return digits.stream().mapToInt(i -> i).toArray();\n            }\n\n            private static int sum_of_digits(int[] digits) {\n                return Arrays.stream(digits).sum();\n            }\n        }\n\n        // Create a list of pairs (index, number)\n        List<int[]> indexedNums = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums.add(new int[]{i, nums.get(i)});\n        }\n\n        // Sort the list based on sum of digits and original index\n        Collections.sort(indexedNums, (a, b) -> {\n            int[] aDigits = DigitSumCalculator.digit_sum(a[1]);\n            int[] bDigits = DigitSumCalculator.digit_sum(b[1]);\n\n            int sumA = DigitSumCalculator.sum_of_digits(aDigits);\n            int sumB = DigitSumCalculator.sum_of_digits(bDigits);\n\n            if (sumA != sumB) {\n                return Integer.compare(sumA, sumB);\n            } else {\n                return Integer.compare(a[0], b[0]);\n            }\n        });\n\n        // Extract the sorted numbers\n        List<Integer> result = new ArrayList<>();\n        for (int[] pair : indexedNums) {\n            result.add(pair[1]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                         .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                         .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many numbers in the array are congruent to each of 0, 1, and 2 modulo 3\n        int countMod0 = 0, countMod1 = 0, countMod2 = 0;\n\n        for (int num : a) {\n            if (num % 3 == 0) countMod0++;\n            else if (num % 3 == 1) countMod1++;\n            else countMod2++;\n        }\n\n        // Calculate the number of valid triples\n        int result = 0;\n        result += countMod0 * (countMod0 - 1) * (countMod0 - 2) / 6; // All three numbers are congruent to 0 mod 3\n        result += countMod1 * (countMod1 - 1) * (countMod1 - 2) / 6; // All three numbers are congruent to 1 mod 3\n        result += countMod2 * (countMod2 - 1) * (countMod2 - 2) / 6; // All three numbers are congruent to 2 mod 3\n        result += countMod0 * countMod1 * countMod2; // One number is congruent to each of 0, 1, and 2 mod 3\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) return Collections.emptyList();\n\n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> evenLengthStrings = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                evenLengthStrings.add(s);\n            }\n        }\n\n        // Sort the list by length, and then alphabetically for strings of the same length\n        Collections.sort(evenLengthStrings, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return Integer.compare(s1.length(), s2.length());\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return evenLengthStrings;\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));   // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * doubleTheDifference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n     * doubleTheDifference(Arrays.asList(-1, -2, 0)) == 0\n     * doubleTheDifference(Arrays.asList(9, -2)) == 81\n     * doubleTheDifference(Arrays.asList(0)) == 0\n     *\n     * If the input list is empty, return 0.\n     */\n    public int doubleTheDifference(List<Object> lst) {\n        int totalSum = 0;\n        \n        for (Object item : lst) {\n            if (item instanceof Integer && ((Integer)item > 0) && (((Integer)item % 2) != 0)) {\n                totalSum += Math.pow((Integer)item, 2);\n            }\n        }\n        \n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.doubleTheDifference(Arrays.asList(1, 3, 2, 0))); // Output: 10\n        System.out.println(solution.doubleTheDifference(Arrays.asList(-1, -2, 0)));  // Output: 0\n        System.out.println(solution.doubleTheDifference(Arrays.asList(9, -2)));      // Output: 81\n        System.out.println(solution.doubleTheDifference(Arrays.asList(0)));          // Output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list to its corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class based on the provided list of extensions.\n     * The strength of an extension is calculated as CAP - SM, where CAP is the number of uppercase letters,\n     * and SM is the number of lowercase letters in the extension's name. If there are multiple extensions\n     * with the same strength, the first one in the list is chosen.\n     *\n     * @param class_name The name of the class to which the strongest extension will be attached.\n     * @param extensions A List containing names of possible extensions for the class.\n     * @return A string representing the class and its strongest extension in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        // Initialize variables to track the strongest extension\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String name) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : name.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => false\n    cycpattern_check(\"hello\",\"ell\") => true\n    cycpattern_check(\"whassup\",\"psus\") => false\n    cycpattern_check(\"abab\",\"baa\") => true\n    cycpattern_check(\"efef\",\"eeff\") => false\n    cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the first word with itself\n        String concatenatedA = a + a;\n        \n        // Check if the second word is a substring of the concatenated string\n        return concatenatedA.contains(b);\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a positive value and then to string for easy iteration\n        String strNum = Integer.toString(Math.abs(num));\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char c = strNum.charAt(i);\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not, it's odd\n                oddCount++;\n            }\n        }\n\n        // Return the counts as a list [even count, odd count]\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the method\n        System.out.println(solution.even_odd_count(-12));  // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        // Mapping of integers to Roman numerals (in lowercase)\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Update the maximum if this word has more unique characters or is lexicographically smaller\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    // Test function to verify the correctness of find_max\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1));  // Expected: string\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2));  // Expected: enam\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Determine how many carrots are left after eating.\n        int leftoverCarrots = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of eaten carrots and the number of leftover carrots.\n        return new ArrayList<>(List.of(totalEaten, leftoverCarrots));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\nclass Solution {\n    /**\n     Given two lists operator, and operand. The first list has basic algebra operations, and\n     the second list is a list of integers. Use the two given lists to build the algebraic\n     expression and return the evaluation of this expression.\n\n     The basic algebra operations:\n     Addition ( + )\n     Subtraction ( - )\n     Multiplication ( * )\n     Floor division ( / )  // Note: Java does not have floor division, use integer division instead.\n     Exponentiation ( ** )\n\n     Example:\n     operator = [\"+\", \"*\", \"-\"]\n     operand = [2, 3, 4, 5]\n     result = 2 + 3 * 4 - 5\n     => result = 9\n\n     Note:\n         The length of operator list is equal to the length of operand list minus one.\n         Operand is a list of non-negative integers.\n         Operator list has at least one operator, and operand list has at least two operands.\n      */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        for (int i = 0; i < operator.size(); i++) {\n            if (i > 0) {\n                expression.append(\" \");\n            }\n            expression.append(operand.get(i));\n            expression.append(operator.get(i));\n        }\n        expression.append(\" \").append(operand.get(operator.size()));\n\n        // Evaluate the expression using Java's scripting engine\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n        try {\n            return (int) engine.eval(expression.toString());\n        } catch (ScriptException e) {\n            throw new RuntimeException(\"Error evaluating expression: \" + expression, e);\n        }\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = digest.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hash);\n        String hashtext = number.toString(16);\n\n        // Add leading zeros to make sure it's 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is less than or equal to b for simplicity\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n\n        List<Integer> evenDigits = new ArrayList<>();\n        \n        // Iterate through the range from start to end\n        for (int num = start; num <= end; num++) {\n            if (num % 2 == 0 && num < 10) {\n                evenDigits.add(num);\n            }\n        }\n\n        return evenDigits;\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers that are closer to each other than a given threshold.\n     *\n     * @param numbers List<Double> - A list of floating-point numbers.\n     * @param threshold double - The minimum distance between any two elements for them not to be considered close.\n     * @return boolean - Returns true if there are at least two elements in the list that are closer than the threshold, otherwise false.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Additional test cases\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.5, 8.7), 0.4);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        boolean result4 = solution.has_close_elements(Arrays.asList(-2.0, -1.0, 0.5, 1.5), 0.6);\n        System.out.println(\"Test Case 4: \" + (result4 ? \"Passed\" : \"Failed\")); // Expected output: Failed\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * Example:\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < cleanString.length(); i++) {\n            char c = cleanString.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(cleanString.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String input = \"( ) (( )) (( )( ))\";\n        List<String> output = solution.separate_paren_groups(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Output: [\" + String.join(\", \", output) + \"]\");\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to check the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n        System.out.println(solution.truncate_number(0.123));  // Expected output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposit (positive) or withdrawal (negative) amounts.\n     * @return boolean indicating whether the balance goes negative at any point.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance has fallen below zero\n            }\n        }\n        return false; // No negative balance detected\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false as the balance never goes below zero.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true as after -4, the balance is negative.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyList); // Expected output: []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyList); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, returns the deepest level of nesting of parentheses as an integer in a list.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A List<Integer> where each element represents the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    /**\n     * A test method to verify the correctness of parse_nested_parens function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result;\n\n        // Test case 1\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        result = solution.parse_nested_parens(input1);\n        System.out.println(\"Test Case 1: \" + (result.equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        String input2 = \"() ()\";\n        List<Integer> expectedOutput2 = Arrays.asList(1, 1);\n        result = solution.parse_nested_parens(input2);\n        System.out.println(\"Test Case 2: \" + (result.equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        String input3 = \"(())() ((()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(2, 3);\n        result = solution.parse_nested_parens(input3);\n        System.out.println(\"Test Case 3: \" + (result.equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java 8 Streams API for filtering the list based on a condition.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        \n        // Generate rolling max\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n        \n        // Verify correctness\n        if (expectedOutput.equals(output)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     * Algorithm idea is simple:\n     * - Find the longest postfix of supplied string that is a palindrome.\n     * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    public String make_palindrome(String string) {\n        if (string == null || string.length() <= 1) {\n            return string;\n        }\n\n        int len = string.length();\n        for (int i = len; i >= 0; i--) {\n            // Check if the substring from start to index i is a palindrome\n            if (isPalindrome(string.substring(0, i))) {\n                String prefixToReverse = string.substring(i);\n                return new StringBuilder(prefixToReverse).reverse().append(string).toString();\n            }\n        }\n\n        // If no palindromic suffix found, return the reversed string itself.\n        return new StringBuilder(string).reverse().toString();\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11011\"));  // Expected output: \"01110\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\"));  // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\"));  // Expected output: \"0000\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-9, -18)); // Expected output: 9\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        // Additional test cases\n        List<String> emptyPrefixes = solution.all_prefixes(\"\");\n        System.out.println(emptyPrefixes);  // Expected output: []\n        \n        List<String> singleCharPrefixes = solution.all_prefixes(\"x\");\n        System.out.println(singleCharPrefixes);  // Expected output: [x]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string representing musical notes in a special ASCII format.\n     * Your task is to parse this string and return list of integers corresponding to how many beats does each\n     * note last.\n     *\n     * Here is a legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quarter note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        // Split the input string into individual notes based on spaces\n        String[] notes = string.split(\" \");\n        \n        // Initialize a list to store the number of beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Loop through each note in the notes array\n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                // Whole note, lasts four beats\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                // Half note, lasts two beats\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                // Quarter note, lasts one beat\n                beats.add(1);\n            }\n        }\n        \n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each number word to its corresponding integer value.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its integer value and sort them.\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into number words.\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            String word = \"\";\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key).equals(num)) {\n                    word = key;\n                    break;\n                }\n            }\n            result.append(word);\n            result.append(\" \");\n        }\n\n        // Remove the trailing space and return the result.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected output: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding closest elements easier.\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), applies a linear transform such that \n     * the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledNumber = (number - min) / (max - min);\n            scaledNumbers.add(scaledNumber);\n        }\n        \n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Collections.emptyMap(), Collections.emptyList());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i > 0; i--) { // Start from half of n and go down to 1\n            if (n % i == 0) { // Check if i divides n evenly\n                return i; // Return the first divisor found, which is the largest one\n            }\n        }\n        return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n        System.out.println(solution.largest_divisor(60)); // Expected output: 30\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 to get rid of all even factors\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once and preserve the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     * \n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over the list and append each string to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test function to verify the correctness of the filter_by_prefix method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print: []\n\n        List<String> listWithPrefixes = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(listWithPrefixes, \"a\")); // Should print: [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n\n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.List;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        // Implementing a simple root-finding method using binary search\n        double left = -100.0;  // Start with a wide range\n        double right = 100.0;\n\n        while (right - left > 1e-6) {\n            double mid = (left + right) / 2;\n            if (poly(xs, mid) == 0) {\n                return mid;\n            } else if (poly(xs, left) * poly(xs, mid) < 0) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three\n     * are equal to the values of the corresponding indices of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 and store them in a separate list\n        List<Integer> divisibleByThree = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                divisibleByThree.add(l.get(i));\n            }\n        }\n\n        // Sort the extracted elements in ascending order\n        Collections.sort(divisibleByThree);\n\n        // Create a new list to store the final result\n        List<Integer> result = new ArrayList<>();\n        int sortedIndex = 0;\n\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                // Append the sorted element at indices divisible by three\n                result.add(divisibleByThree.get(sortedIndex));\n                sortedIndex++;\n            } else {\n                // Keep other elements unchanged\n                result.add(l.get(i));\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + testList1);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList1));\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 5, 4, 3, 2, 1);\n        System.out.println(\"Original: \" + testList2);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList2));\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(9, 7, 5, 3, 1);\n        System.out.println(\"Original: \" + testList3);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0); // Assume the first element is the largest initially\n        \n        for (int i = 1; i < l.size(); i++) { // Start from the second element\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Expected output: 0\n        System.out.println(solution.fizz_buzz(78)); // Expected output: 2\n        System.out.println(solution.fizz_buzz(79)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the elements at even indices\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the 'evens' list\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the 'evens' list\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values from 'evens'\n        for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n            sortedList.set(i, evens.get(j));\n        }\n        \n        return sortedList;\n    }\n\n    // Method to test the sort_even function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Encodes a string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string into groups of 3 characters\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Cycle elements in each group if it has exactly 3 characters\n        StringBuilder encodedString = new StringBuilder();\n        for (String group : groups) {\n            if (group.length() == 3) {\n                encodedString.append(group.substring(1)).append(group.charAt(0));\n            } else {\n                encodedString.append(group);\n            }\n        }\n        return encodedString.toString();\n    }\n\n    /**\n     * Decodes a string that was encoded with the encodeCyclic function.\n     */\n    public String decode_cyclic(String s) {\n        // Split string into groups of 3 characters\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Reverse the cycle operation on each group if it has exactly 3 characters\n        StringBuilder decodedString = new StringBuilder();\n        for (String group : groups) {\n            if (group.length() == 3) {\n                decodedString.append(group.charAt(2)).append(group.substring(0, 2));\n            } else {\n                decodedString.append(group);\n            }\n        }\n        return decodedString.toString();\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n        }\n\n        return primes.get(primes.size() - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for easier traversal\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on a straight road.\n     *\n     * @param n The number of cars in each set (one set moving left to right, and one set moving right to left).\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from the left will collide with every car from the right,\n        // the total number of collisions is simply n (left cars) times n (right cars).\n        return n * n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 4\n        System.out.println(solution.car_race_collision(3));  // Expected output: 9\n        System.out.println(solution.car_race_collision(5));  // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and high return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        // Area formula: (1/2) * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Area of triangle with base=10 and height=4: \" + area2); // Expected output: 20.0\n        \n        // Test case 3 (with floating point numbers)\n        double area3 = solution.triangle_area(7.5, 2.5);\n        System.out.println(\"Area of triangle with base=7.5 and height=2.5: \" + area3); // Expected output: 9.375\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        else if (n == 2) return 2;\n        else if (n == 3) return 0;\n\n        // Initialize base cases\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; i++) {\n            int next_value = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next_value;\n        }\n\n        return d;\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list first\n        Collections.sort(l);\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return the middle element\n            return l.get(size / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "class Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left++) != text.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test cases using assertions\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        assert solution.is_palindrome(\"\") : \"Empty string should be a palindrome\";\n        assert solution.is_palindrome(\"aba\") : \"'aba' is a palindrome\";\n        assert solution.is_palindrome(\"aaaaa\") : \"'aaaaa' is a palindrome\";\n        assert !solution.is_palindrome(\"zbcd\") : \"'zbcd' is not a palindrome\";\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // 2^0 = 1 for any p\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base value\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5)); // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101)); // Expected output: 1\n        System.out.println(solution.modp(3, 11)); // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"hello\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should output \"mjqqt\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should output \"hello\"\n\n        String testString2 = \"World\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should output \"BTQYI\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should output \"World\"\n\n        // Test with non-letter characters\n        String testString3 = \"abc123\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should output \"fghi123\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should output \"abc123\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string and append non-vowel characters to result\n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + (solution.below_threshold(list1, threshold1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + (solution.below_threshold(list2, threshold2) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"add(2, 3): \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7): \" + solution.add(5, 7)); // Expected output: 12\n\n        // Additional test cases for robustness\n        System.out.println(\"add(-10, 4): \" + solution.add(-10, 4)); // Expected output: -6\n        System.out.println(\"add(0, 0): \" + solution.add(0, 0));     // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from the first string\n        Set<Character> charSet = new HashSet<>();\n        \n        // Add all characters from the first string into the set\n        for (char c : s0.toCharArray()) {\n            charSet.add(c);\n        }\n        \n        // Check if every character in the second string is present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charSet.contains(c)) {\n                return false;\n            }\n        }\n\n        // Create a set to store unique characters from the second string\n        Set<Character> charSet2 = new HashSet<>();\n        \n        // Add all characters from the second string into the set\n        for (char c : s1.toCharArray()) {\n            charSet2.add(c);\n        }\n        \n        // Check if every character in the first string is present in this new set\n        for (char c : s0.toCharArray()) {\n            if (!charSet2.contains(c)) {\n                return false;\n            }\n        }\n\n        // If all checks pass, both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the number of open and close brackets\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n\n            // If at any point the number of closing brackets is more than opening ones, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // At the end, there should be no unmatched open brackets left\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() <= 1) return true; // A single element is trivially monotonic\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(\"Largest prime factor of 13195: \" + solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(\"Largest prime factor of 2048: \" + solution.largest_prime_factor(2048));   // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    /**\n     * A method to test the correctness of the sum_to_n function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5));    // Expected output: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1));    // Expected output: 1\n        \n        // Additional test case to ensure correctness\n        System.out.println(\"sum_to_n(1000): \" + solution.sum_to_n(1000)); // Expected output: 500500\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the balance between '(' and ')'\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++; // Increment when an opening bracket is found\n            } else if (c == ')') {\n                balance--; // Decrement when a closing bracket is found\n                \n                // If at any point the balance goes negative, it means there are more closing brackets than opening ones.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative will have one less term than the original polynomial,\n        // unless it's a constant (degree 0), which has no terms after differentiation.\n        if (xs.size() <= 1) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.length() == 0) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        \n        // Get the length of the string representation\n        int numDigits = numStr.length();\n        \n        // If shift is greater than the number of digits, return reversed string\n        if (shift > numDigits) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Calculate effective shift value\n        int effectiveShift = shift % numDigits;\n        \n        // Perform circular shift\n        String shiftedStr = numStr.substring(numDigits - effectiveShift) + numStr.substring(0, numDigits - effectiveShift);\n        \n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in a basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the count of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mango fruits\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the record.\n                if (value < smallestEvenValue || i < index) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1; // Initialize result to -1\n        \n        // Iterate through the entries of the frequency map\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            \n            // Check if the number's frequency is greater than or equal to the number itself\n            if (num <= freq) {\n                result = Math.max(result, num); // Update result with the maximum value found\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        \n        while (!lst.isEmpty()) {\n            // Find and append minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) {\n                break;\n            }\n            \n            // Find and append maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(list1)); // Expected: [1, 4, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(list2)); // Expected: [5, 5, 5, 5]\n        \n        List<Integer> list3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(list3)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the object q will fly, and false otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w and the list is a palindrome\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic.\n     *\n     * @param arr List<Integer> representing the input array.\n     * @return int representing the minimum number of changes needed.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            if (!arr.get(i).equals(arr.get(n - i - 1))) {\n                changes++;\n            }\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));   // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList(\"a\", \"b\", \"c\"))); // []\n        System.out.println(solution.total_match(Arrays.asList(\"abc\", \"def\"), Arrays.asList(\"ghi\"))); // [\"ghi\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            \n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a) return true;\n                    \n                    if (p1 * p2 * p3 > a) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        int currentPower = n;\n        while (currentPower < x) {\n            currentPower *= n;\n        }\n        \n        return currentPower == x;\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube of some integer.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cubeRoot = Math.cbrt(absA);\n        long roundedCubeRoot = Math.round(cubeRoot);\n\n        // Check if cubing the rounded value equals the original number\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube method\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Define a set of hexadecimal digits that are prime numbers.\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of characters in the input string that are prime hex digits.\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A test method to check the correctness of the decimal_to_binary function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(7));   // Expected output: \"db111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is a happy string.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * It is the last week of the semester and the teacher has to give the grades\n     * to students. The teacher has been making her own algorithm for grading.\n     * The only problem is, she has lost the code she used for grading.\n     * She has given you a list of GPAs for some students and you have to write\n     * a function that can output a list of letter grades using the following table:\n     *             GPA       |    Letter grade\n     *              4.0                A+\n     *            > 3.7                A\n     *            > 3.3                A-\n     *            > 3.0                B+\n     *            > 2.7                B\n     *            > 2.3                B-\n     *            > 2.0                C+\n     *            > 1.7                C\n     *            > 1.3                C-\n     *            > 1.0                D+\n     *            > 0.7                D\n     *            > 0.0                D-\n     *              0.0                E\n     *\n     * Example:\n     * numerical_letter_grade(Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letter_grades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letter_grades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letter_grades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letter_grades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letter_grades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letter_grades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letter_grades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letter_grades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letter_grades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letter_grades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letter_grades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letter_grades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letter_grades.add(\"D-\");\n            } else {\n                letter_grades.add(\"E\");\n            }\n        }\n\n        return letter_grades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        \n        // Check for edge cases\n        if (len <= 1) return false;\n        if (len == 2) return true; // 2 is the only even prime number\n        \n        // Check divisibility by numbers up to sqrt(len)\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // For single digit number, there is only one such number: '1'\n            return 1;\n        } else {\n            // Count of numbers starting with 1\n            long startWithOne = (long)Math.pow(10, n - 1);\n            \n            // Count of numbers ending with 1\n            long endWithOne = (long)Math.pow(10, n - 1);\n            \n            // Overlap count: Numbers that both start and end with 1\n            long overlapCount = (n > 2) ? (long)Math.pow(10, n - 2) : 0;\n            \n            // Total count is the sum of numbers starting or ending with 1 minus the overlap count\n            return (int)(startWithOne + endWithOne - overlapCount);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.starts_one_ends(2)); // Example: For n=2, output should be 18\n        System.out.println(solution.starts_one_ends(3)); // Example: For n=3, output should be 190\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        // Calculate the sum of digits of N\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2, 9))); // Expected output: 5 (since only one even number at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 7, 8, 2))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string where each word's characters are sorted alphabetically.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                \n                // Append sorted characters to the result, followed by a space\n                result.append(new String(chars));\n            }\n            \n            // Append a space after each non-empty word\n            result.append(\" \");\n        }\n\n        // Remove trailing space if present and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinate to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, it's both the first and last.\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        // Create a copy of the original list to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a given string by rotating each letter down by 4 places in the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted and remain the same.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Set<Integer> uniqueElements = new HashSet<>(lst);\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(uniqueElements);\n        Collections.sort(sortedList);\n\n        return Optional.of(sortedList.get(1));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the sentence into individual sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. Are you? I think so!\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility)\n     * @param y Second number (Object type for flexibility)\n     * @param z Third number (Object type for flexibility)\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (will be false because inputs are not all integers)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    public String encode(String message) {\n        // Define mappings for vowels shifted by 2 places ahead in the alphabet\n        Map<Character, Character> vowelShiftMap = new HashMap<>();\n        vowelShiftMap.put('a', 'c');\n        vowelShiftMap.put('e', 'g');\n        vowelShiftMap.put('i', 'k');\n        vowelShiftMap.put('o', 'q');\n        vowelShiftMap.put('u', 'w');\n        vowelShiftMap.put('A', 'C');\n        vowelShiftMap.put('E', 'G');\n        vowelShiftMap.put('I', 'K');\n        vowelShiftMap.put('O', 'Q');\n        vowelShiftMap.put('U', 'W');\n\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char ch : message.toCharArray()) {\n            if (Character.isLetter(ch)) {\n                // Swap case\n                char swappedChar = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);\n                \n                // Shift vowels by 2 places ahead\n                if (vowelShiftMap.containsKey(swappedChar)) {\n                    swappedChar = vowelShiftMap.get(swappedChar);\n                }\n                \n                encodedMessage.append(swappedChar);\n            } else {\n                encodedMessage.append(ch);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\n\npublic class Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        int maxPrime = -1;\n        \n        for (int num : lst) {\n            if (isPrime(num) && num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n\n        return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLower = true;\n        boolean allUpper = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                allLower = false;\n                allUpper = false;\n                break;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLower = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpper = false;\n            }\n        }\n\n        return allLower || allUpper;\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of their unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        int count = 0;\n        \n        for (int i = 1; i < s.length(); i += 2) { // Start from index 1 and increment by 2 to check even indices\n            if (vowels.contains(s.charAt(i))) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is negative or positive to determine rounding direction\n        if (num < 0) {\n            return (int)Math.ceil(num - 0.5); // Round towards more negative for negative numbers\n        } else {\n            return (int)Math.floor(num + 0.5); // Round towards more positive for non-negative numbers\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"));\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"));\n     */\n    public List<String> words_string(String s) {\n        // Split the string using regex pattern to match commas and spaces.\n        String[] splitWords = s.split(\"[,\\\\s]\\\\s*\");\n        \n        // Convert array of strings to a list\n        return new ArrayList<>(Arrays.asList(splitWords));\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number \n     * that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x <= y\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the rounded average of integers from n through m (inclusive) and returns its binary representation.\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return The binary string of the rounded average if valid, otherwise -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of numbers from n to m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute the average and round it to the nearest integer\n        double avg = (double) sum / count;\n        int roundedAvg = (int) Math.round(avg);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Helper method to check if an integer has only odd digits\n        return x.stream()\n                .filter(this::hasOnlyOddDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasOnlyOddDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // All digits are odd\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define an array of strings representing numbers from 1 to 9.\n        String[] numberNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter the input list for integers between 1 and 9 inclusive.\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted() // Sort in ascending order\n                                        .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredList);\n        \n        // Convert each integer to its corresponding name and collect into a new list.\n        List<String> result = filteredList.stream()\n                                          .map(num -> numberNames[num - 1])\n                                          .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        int originalNumber = number, reversedNumber = 0;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            number /= 10;\n        }\n\n        return originalNumber == reversedNumber;\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream().filter(num -> sumOfDigits(num) > 0).count();\n    }\n\n    private int sumOfDigits(int num) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        boolean isNegative = num < 0;\n        int digitsSum = 0;\n\n        while (num != 0) {\n            int digit = Math.abs(num % 10);\n            if (isNegative && num >= 0 || !isNegative && num < 0) {\n                digit *= -1; // Adjust the sign for negative numbers\n            }\n            digitsSum += digit;\n            num /= 10;\n        }\n\n        return digitsSum;\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to get an array sorted in non-decreasing order by performing right shift operations.\n     *\n     * @param arr List of integers representing the array.\n     * @return true if it's possible to sort the array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, return true\n        if (arr.size() <= 1) {\n            return true;\n        }\n\n        int count = 0; // Count of rotations needed to get non-decreasing order\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element\n        if (arr.get(arr.size() - 1) > arr.get(0)) {\n            count++;\n        }\n\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.List;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCount = 0;\n        \n        // Count how many odd numbers are in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenCountInLst2 = 0;\n\n        // Count how many even numbers are available in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        if (oddCount <= evenCountInLst2) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        if (test == null || test.isEmpty()) {\n            return new HashMap<>();\n        }\n\n        Map<String, Integer> letterCounts = new HashMap<>();\n        int maxCount = 0;\n        Map<String, Integer> result = new HashMap<>();\n\n        for (String charStr : test.split(\" \")) {\n            int count = letterCounts.getOrDefault(charStr, 0) + 1;\n            letterCounts.put(charStr, count);\n            maxCount = Math.max(maxCount, count);\n        }\n\n        for (Map.Entry<String, Integer> entry : letterCounts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left) != resultString.charAt(right)) {\n                isPalindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> result = new ArrayList<>();\n        result.add(resultString);\n        result.add(isPalindrome);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum at each step\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.List;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalWaterUnits = 0;\n        \n        for (List<Integer> row : grid) {\n            int waterUnitsInRow = 0;\n            for (int cell : row) {\n                waterUnitsInRow += cell; // Sum up the water units in the current row\n            }\n            \n            // Calculate how many times buckets need to be lowered for this well\n            int bucketOperationsForRow = (waterUnitsInRow + capacity - 1) / capacity;\n            totalWaterUnits += bucketOperationsForRow;\n        }\n        \n        return totalWaterUnits;\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Custom comparator based on number of ones in binary representation and decimal value\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                int countA = count_ones(a);\n                int countB = count_ones(b);\n                \n                if (countA != countB) {\n                    return countA - countB;\n                } else {\n                    return a - b;\n                }\n            }\n\n            private int count_ones(int n) {\n                // Count the number of ones in binary representation\n                int count = 0;\n                while (n > 0) {\n                    count += n & 1;\n                    n >>= 1;\n                }\n                return count;\n            }\n        });\n        \n        return arr;\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a method to count consonants in a word\n        java.util.function.Function<String, Integer> countConsonants = word -> {\n            int count = 0;\n            for (char c : word.toCharArray()) {\n                if (\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\".indexOf(c) >= 0) {\n                    count++;\n                }\n            }\n            return count;\n        };\n\n        // Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Filter and collect words with exactly n consonants\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (countConsonants.apply(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!vowels.contains(leftChar) && !vowels.contains(rightChar) && vowels.contains(middleChar)) {\n                return String.valueOf(middleChar); // Found the vowel\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < lst.size(); i++) {\n            int balance = 0;\n            boolean isBalanced = true;\n\n            for (String s : lst) {\n                for (char c : s.toCharArray()) {\n                    if (c == '(') {\n                        balance++;\n                    } else {\n                        balance--;\n                    }\n                    // If at any point the balance goes negative, it's not balanced\n                    if (balance < 0) {\n                        isBalanced = false;\n                        break;\n                    }\n                }\n            }\n\n            // Swap the order of strings and check again if first attempt failed\n            if (!isBalanced && i == 0) {\n                Collections.swap(lst, 0, 1);\n                balance = 0;\n                for (String s : lst) {\n                    for (char c : s.toCharArray()) {\n                        if (c == '(') {\n                            balance++;\n                        } else {\n                            balance--;\n                        }\n                        // If at any point the balance goes negative, it's not balanced\n                        if (balance < 0) {\n                            isBalanced = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isBalanced && balance == 0) {\n                return \"Yes\";\n            }\n        }\n\n        // If no combination works, return \"No\"\n        return \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap)\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        // Add elements to the heap until it reaches size k\n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.add(num);\n            } else if (num > pq.peek()) {  // If current element is greater than the smallest in heap, replace it.\n                pq.poll();  // Remove the smallest element\n                pq.add(num);  // Add the new element\n            }\n        }\n\n        // Convert priority queue to list and sort it since we need ascending order\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Expected: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i); // Add to sum if it's an odd number in an even position\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr, k)); // Expected output is 24\n        \n        // Additional test case\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 3;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr2, k2)); // Expected output is 28\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        \n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected output: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the required date format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input string matches the regular expression\n        boolean isFormatValid = date.matches(regex);\n        \n        // If format is not valid, return false\n        if (!isFormatValid) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is between 1 and 12\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Determine the number of days in a given month\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        int maxDaysInMonth = getMaxDays(month, isLeapYear);\n\n        // Check if the day is within the valid range for the month\n        return day >= 1 && day <= maxDaysInMonth;\n    }\n\n    private int getMaxDays(int month, boolean isLeapYear) {\n        switch (month) {\n            case 2: return isLeapYear ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11: return 30;\n            default: return 31;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace and split if found\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // If no whitespaces, check for commas and split if found\n        words = txt.split(\",\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // Count lowercase letters with odd order indices in the alphabet\n        int countOddOrderLetters = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    countOddOrderLetters++;\n                }\n            }\n        }\n\n        return countOddOrderLetters;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"NoSpacesHere\")); // Should print the number of odd-order lowercase letters\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"));\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (previousNumber != null && lst.get(i) < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (i > 0 && lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = lst.get(i);\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.List;\n\npublic class Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        if (startMax > endMin) {\n            return \"NO\";\n        }\n\n        int length = endMin - startMax + 1;\n        return isPrime(length) ? \"YES\" : \"NO\";\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize the answer with a large value to ensure any path will be smaller\n        List<Integer> ans = new ArrayList<>(Collections.nCopies(k, Integer.MAX_VALUE));\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start DFS from each cell to find the minimum path\n                dfs(grid, k, new ArrayList<>(), i, j, ans);\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, List<Integer> path, int row, int col, List<Integer> ans) {\n        if (path.size() == k) {\n            // Update the answer with the lexicographically smaller path\n            if (isSmaller(path, ans)) {\n                ans.clear();\n                ans.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0], newCol = col + dir[1];\n            // Check bounds and add the next cell to the path\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid.get(0).size()) {\n                path.add(grid.get(newRow).get(newCol));\n                dfs(grid, k, path, newRow, newCol, ans);\n                // Backtrack to explore other paths\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        int size = Math.min(a.size(), b.size());\n        for (int i = 0; i < size; ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                nextValue = sequence.get(i - 2) + sequence.get(i - 3) + triHelper(sequence, i + 1);\n            }\n            sequence.add(nextValue);\n        }\n        \n        return new ArrayList<>(sequence.subList(0, n + 1));\n    }\n\n    private int triHelper(List<Integer> sequence, int index) {\n        if (index == 4) { // Base case for tri(4)\n            return 3;\n        } else if (index % 2 == 0) {\n            return 1 + (index / 2);\n        } else {\n            List<Integer> tempSequence = new ArrayList<>(sequence);\n            tempSequence.add(triHelper(tempSequence, index - 1));\n            tempSequence.add(triHelper(tempSequence, index - 2));\n            tempSequence.add(triHelper(tempSequence, index + 1));\n            return tempSequence.get(index - 3) + tempSequence.get(index - 4) + tempSequence.get(index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.tri(3);\n        System.out.println(result); // Expected output: [1, 3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets\n    where at least one bracket in the subsequence is nested.\n\n    is_nested(\"[[]]\") -> true\n    is_nested(\"[]]]]]]][[[[[]\") -> false\n    is_nested(\"[][]\") -> false\n    is_nested(\"[]\") -> false\n    is_nested(\"[[][]]\") -> true\n    is_nested(\"[[]][[\") -> true\n     */\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean hasNested = false;\n\n        for (char bracket : string.toCharArray()) {\n            if (bracket == '[') {\n                stack.push(bracket);\n            } else if (bracket == ']') {\n                if (!stack.isEmpty() && !hasNested && stack.size() > 1) {\n                    hasNested = true;\n                }\n                stack.pop();\n            }\n        }\n\n        return hasNested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilValue = Math.ceil(num);\n            // Square the rounded value and add it to the sum\n            sum += (int)Math.pow(ceilValue, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") -> false\n    check_if_last_char_is_a_letter(\"apple pi e\") -> true\n    check_if_last_char_is_a_letter(\"apple pi e \") -> false\n    check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n        \n        // Strip trailing spaces\n        String strippedTxt = txt.trim();\n        int lastNonSpaceIndex = strippedTxt.length() - 1;\n\n        char lastChar = strippedTxt.charAt(lastNonSpaceIndex);\n        \n        // Check if the last character is an alphabetical character\n        boolean isLastCharLetter = Character.isAlphabetic(lastChar);\n\n        // Check if there are no characters before it or if the second-to-last character was a space\n        boolean notPartOfWord = (lastNonSpaceIndex == 0) || txt.charAt(txt.length() - 2) == ' ';\n        \n        return isLastCharLetter && notPartOfWord;\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object obj) {\n        if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(',', '.'); // Convert comma to dot for parsing\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        }\n\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        }\n\n        if (obj instanceof Float || obj instanceof Double) {\n            return ((Number) obj).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(compare_one(1, \"2,3\")); // Optional[2,3]\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional[6]\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers greater than or equal to 8 can be expressed this way,\n        // but we know that n - 8 must be expressible as a sum of three positive even numbers for n >= 12.\n        if (n % 2 == 0 && n >= 12) {\n            return true;\n        }\n\n        // For the edge case where n is between 8 and 11, we need to check manually:\n        int[] testCases = {8, 10};\n        for (int testCase : testCases) {\n            if (n == testCase) return true;\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long product = 1;\n        for (int j = 2; j <= number; j++) {\n            product *= j;\n        }\n        return product;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        return result.replaceAll(\" \", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));          // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));       // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));      // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));    // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex == -1 || fileName.lastIndexOf('.') != dotIndex) {\n            return \"No\";\n        }\n\n        // Split the file name into two parts: before and after the dot\n        String baseName = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        // Check if the part before the dot is valid\n        if (!isValidBase(baseName)) {\n            return \"No\";\n        }\n\n        // Check if the part after the dot is a valid extension\n        if (!isValidExtension(extension)) {\n            return \"No\";\n        }\n\n        // Count digits in the base name and ensure there are no more than three\n        int digitCount = 0;\n        for (char c : baseName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n\n    private boolean isValidBase(String baseName) {\n        // Check that the base name starts with a letter and is not empty\n        if (baseName.isEmpty() || !Character.isLetter(baseName.charAt(0))) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isValidExtension(String extension) {\n        // Valid extensions are \"txt\", \"exe\", or \"dll\"\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        for (String ext : validExtensions) {\n            if (ext.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"file1234.txt\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     *\n     * Examples:\n     * For lst = [1,2,3] the output should be 6\n     * For lst = []  the output should be 0\n     * For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sum_squares(List<Integer> lst) {\n        int resultSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                resultSum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                resultSum += Math.pow(lst.get(i), 3);\n            } else {\n                // Entries whose indexes are not multiples of 3 or 4 remain unchanged.\n                resultSum += lst.get(i);\n            }\n        }\n        \n        return resultSum;\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Checks if a given number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected output: \"is\"\n\n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n and checks if it evaluates to a whole number.\n     *\n     * @param x The first fraction in string format \"<numerator>/<denominator>\".\n     * @param n The second fraction in string format \"<numerator>/<denominator>\".\n     * @return true if x * n is a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Calculate the product of the two fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number by seeing if the remainder is zero when dividing the numerator by the denominator.\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Helper method to calculate the sum of digits of a number\n        class DigitSumCalculator {\n            private int digitSum(int n) {\n                if (n == 0) return 0;\n                boolean isNegative = n < 0;\n                int sum = 0;\n                n = Math.abs(n);\n                \n                while (n > 0) {\n                    sum += n % 10;\n                    n /= 10;\n                }\n                \n                if (isNegative) {\n                    return -Math.abs(sum); // Adjust for negative numbers\n                } else {\n                    return sum;\n                }\n            }\n        }\n\n        DigitSumCalculator calculator = new DigitSumCalculator();\n        \n        // Create a list of tuples containing the digit sum, original index, and number itself\n        List<int[]> tuples = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums.get(i);\n            tuples.add(new int[]{calculator.digitSum(num), i, num});\n        }\n        \n        // Sort the list of tuples based on digit sum and then by original index\n        Collections.sort(tuples, (a, b) -> {\n            if (a[0] != b[0]) return Integer.compare(a[0], b[0]);\n            else return Integer.compare(a[1], b[1]);\n        });\n        \n        // Extract the numbers from the sorted tuples to form the final list\n        List<Integer> result = new ArrayList<>();\n        for (int[] tuple : tuples) {\n            result.add(tuple[2]);\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                         .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                         .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many numbers in the array are congruent to each of 0, 1, and 2 modulo 3\n        int countMod0 = 0, countMod1 = 0, countMod2 = 0;\n\n        for (int num : a) {\n            if (num % 3 == 0) countMod0++;\n            else if (num % 3 == 1) countMod1++;\n            else countMod2++;\n        }\n\n        // Calculate the number of valid triples\n        int result = 0;\n        result += countMod0 * (countMod0 - 1) * (countMod0 - 2) / 6; // All three numbers are congruent to 0 mod 3\n        result += countMod1 * (countMod1 - 1) * (countMod1 - 2) / 6; // All three numbers are congruent to 1 mod 3\n        result += countMod2 * (countMod2 - 1) * (countMod2 - 2) / 6; // All three numbers are congruent to 2 mod 3\n        result += countMod0 * countMod1 * countMod2; // One number is congruent to each of 0, 1, and 2 mod 3\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) return Collections.emptyList();\n\n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, \n     * and you should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> evenLengthStrings = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                evenLengthStrings.add(s);\n            }\n        }\n\n        // Sort the list by length, and then alphabetically for strings of the same length\n        Collections.sort(evenLengthStrings, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return Integer.compare(s1.length(), s2.length());\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return evenLengthStrings;\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> inputList = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(inputList));  // Output: [\"aa\"]\n\n        List<String> inputList2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(inputList2));  // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));   // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a list of numbers, return the sum of squares of the numbers\n     in the list that are odd. Ignore numbers that are negative or not integers.\n\n     doubleTheDifference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n     doubleTheDifference(Arrays.asList(-1, -2, 0)) == 0\n     doubleTheDifference(Arrays.asList(9, -2)) == 81\n     doubleTheDifference(Arrays.asList(0)) == 0\n\n     If the input list is empty, return 0.\n      */\n    public int doubleTheDifference(List<Object> lst) {\n        int result = 0;\n        for (Object item : lst) {\n            if (item instanceof Integer && ((Integer) item > 0) && (((Integer) item % 2) != 0)) {\n                result += Math.pow((Integer) item, 2);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Object> list1 = Arrays.asList(1, 3, 2, 0);\n        System.out.println(solution.doubleTheDifference(list1)); // Expected output: 10\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list to its corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class based on the provided list of extensions.\n     * The strength of an extension is calculated as CAP - SM, where CAP is the number of uppercase letters,\n     * and SM is the number of lowercase letters in the extension's name. If there are multiple extensions\n     * with the same strength, the first one in the list is chosen.\n     *\n     * @param class_name The name of the class to which the strongest extension will be attached.\n     * @param extensions A List containing names of possible extensions for the class.\n     * @return A string representing the class and its strongest extension in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        // Initialize variables to track the strongest extension\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String name) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : name.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => false\n    cycpattern_check(\"hello\",\"ell\") => true\n    cycpattern_check(\"whassup\",\"psus\") => false\n    cycpattern_check(\"abab\",\"baa\") => true\n    cycpattern_check(\"efef\",\"eeff\") => false\n    cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the first word with itself\n        String concatenated_a = a + a;\n        \n        // Check if the second word is a substring of the concatenated string\n        return concatenated_a.contains(b);\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a positive value and then to string for easy iteration\n        String strNum = Integer.toString(Math.abs(num));\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char c = strNum.charAt(i);\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not, it's odd\n                oddCount++;\n            }\n        }\n\n        // Return the counts as a list [even count, odd count]\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the method\n        System.out.println(solution.even_odd_count(-12));  // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        // Mapping of integers to Roman numerals (in lowercase)\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Update the maximum if this word has more unique characters or is lexicographically smaller\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    // Test function to verify the correctness of find_max\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1));  // Expected: string\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2));  // Expected: enam\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Determine how many carrots are left after eating.\n        int leftoverCarrots = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of eaten carrots and the number of leftover carrots.\n        return new ArrayList<>(List.of(totalEaten, leftoverCarrots));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) throws Exception {\n        // Initialize a ScriptEngine for evaluating expressions\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n\n        // Start with the first operand as the initial expression string\n        StringBuilder expression = new StringBuilder(String.valueOf(operand.get(0)));\n\n        // Construct the algebraic expression using operators and operands\n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n\n        // Evaluate the constructed expression\n        Object result = engine.eval(expression.toString());\n\n        return Integer.parseInt(result.toString());\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = digest.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hash);\n        String hashtext = number.toString(16);\n\n        // Add leading zeros to make sure it's 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is less than or equal to b for simplicity\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n\n        List<Integer> evenDigits = new ArrayList<>();\n        \n        // Iterate through the range and collect even digits\n        for (int num = start; num <= end; num++) {\n            if (num % 2 == 0 && num < 10) {\n                evenDigits.add(num);\n            }\n        }\n\n        return evenDigits;\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers that are closer to each other than a given threshold.\n     *\n     * @param numbers List<Double> - A list of floating-point numbers.\n     * @param threshold double - The minimum distance between any two elements for them not to be considered close.\n     * @return boolean - Returns true if there are at least two elements in the list that are closer than the threshold, otherwise false.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Additional test cases\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.5, 8.7), 0.4);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        boolean result4 = solution.has_close_elements(Arrays.asList(-2.0, -1.0, 0.5, 1.5), 0.6);\n        System.out.println(\"Test Case 4: \" + (result4 ? \"Passed\" : \"Failed\")); // Expected output: Failed\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * Example:\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < cleanString.length(); i++) {\n            char c = cleanString.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(cleanString.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String input = \"( ) (( )) (( )( ))\";\n        List<String> output = solution.separate_paren_groups(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Output: [\" + String.join(\", \", output) + \"]\");\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to check the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n        System.out.println(solution.truncate_number(0.123));  // Expected output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposit (positive) or withdrawal (negative) amounts.\n     * @return boolean indicating whether the balance goes negative at any point.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance has fallen below zero\n            }\n        }\n        return false; // No negative balance detected\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false as the balance never goes below zero.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true as after -4, the balance is negative.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyList); // Expected output: []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyList); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, returns the deepest level of nesting of parentheses as an integer in a list.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A List<Integer> where each element represents the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    /**\n     * A test method to verify the correctness of parse_nested_parens function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result;\n\n        // Test case 1\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        result = solution.parse_nested_parens(input1);\n        System.out.println(\"Test Case 1: \" + (result.equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        String input2 = \"() ()\";\n        List<Integer> expectedOutput2 = Arrays.asList(1, 1);\n        result = solution.parse_nested_parens(input2);\n        System.out.println(\"Test Case 2: \" + (result.equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        String input3 = \"(())() ((()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(2, 3);\n        result = solution.parse_nested_parens(input3);\n        System.out.println(\"Test Case 3: \" + (result.equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java 8 Streams API for filtering the list based on a condition.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        \n        // Generate rolling max\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n        \n        // Verify correctness\n        if (expectedOutput.equals(output)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String s) {\n        int i = 0;\n        int j = s.length() - 1;\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     * Algorithm idea is simple:\n     * - Find the longest postfix of supplied string that is a palindrome.\n     * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    public String make_palindrome(String s) {\n        if (s == null || s.isEmpty() || isPalindrome(s)) {\n            return s;\n        }\n\n        String prefix = \"\"; // Declare and initialize prefix here\n        for (int i = 0; i < s.length(); i++) {\n            if (isPalindrome(s.substring(i))) {\n                prefix = s.substring(0, i);\n                break;\n            }\n        }\n\n        StringBuilder reversedPrefix = new StringBuilder(prefix).reverse();\n        return reversedPrefix.toString() + s;\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11011\"));  // Expected output: \"01110\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\"));  // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\"));  // Expected output: \"0000\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-9, -18)); // Expected output: 9\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        // Additional test cases\n        List<String> emptyPrefixes = solution.all_prefixes(\"\");\n        System.out.println(emptyPrefixes);  // Expected output: []\n        \n        List<String> singleCharPrefixes = solution.all_prefixes(\"x\");\n        System.out.println(singleCharPrefixes);  // Expected output: [x]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last.\n\n    Here is a legend:\n    \"o\" - whole note, lasts four beats\n    \"o|\" - half note, lasts two beats\n    \".|\" - quarter note, lasts one beat\n\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n    public List<Integer> parse_music(String string) {\n        // Split the input string into individual notes\n        String[] notes = string.split(\" \");\n        \n        // Initialize a list to store the number of beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Iterate through each note and determine its duration in beats\n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                beats.add(1);\n            }\n        }\n        \n        // Return the list of beats\n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each number word to its corresponding integer value.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its integer value and sort them.\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into number words.\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            String word = \"\";\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key).equals(num)) {\n                    word = key;\n                    break;\n                }\n            }\n            result.append(word);\n            result.append(\" \");\n        }\n\n        // Remove the trailing space and return the result.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected output: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding closest elements easier.\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), applies a linear transform such that \n     * the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledNumber = (number - min) / (max - min);\n            scaledNumbers.add(scaledNumber);\n        }\n        \n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Collections.emptyMap(), Collections.emptyList());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i > 0; i--) { // Start from half of n and go down to 1\n            if (n % i == 0) { // Check if i divides n evenly\n                return i; // Return the first divisor found, which is the largest one\n            }\n        }\n        return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n        System.out.println(solution.largest_divisor(60)); // Expected output: 30\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 to get rid of all even factors\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once and preserve the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     * \n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over the list and append each string to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test function to verify the correctness of the filter_by_prefix method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print: []\n\n        List<String> listWithPrefixes = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(listWithPrefixes, \"a\")); // Should print: [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n\n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.List;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        // Implement a simple root-finding algorithm, such as the bisection method.\n        double left = -100.0;\n        double right = 100.0;\n\n        while (Math.abs(right - left) > 1e-6) {\n            double mid = (left + right) / 2;\n            if (poly(xs, mid) == 0) {\n                return mid;\n            } else if (poly(xs, left) * poly(xs, mid) < 0) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three\n     * are equal to the values of the corresponding indices of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 and sort them\n        List<Integer> thirdIndicesElements = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                thirdIndicesElements.add(l.get(i));\n            }\n        }\n        Collections.sort(thirdIndicesElements);\n\n        // Create a result list to store the final output\n        List<Integer> result = new ArrayList<>();\n        \n        // Construct the final output list\n        int sortedIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                result.add(thirdIndicesElements.get(sortedIndex++));\n            } else {\n                result.add(l.get(i));\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + testList1);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList1));\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 5, 4, 3, 2, 1);\n        System.out.println(\"Original: \" + testList2);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList2));\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(9, 7, 5, 3, 1);\n        System.out.println(\"Original: \" + testList3);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0); // Assume the first element is the largest initially\n        \n        for (int i = 1; i < l.size(); i++) { // Start from the second element\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Expected output: 0\n        System.out.println(solution.fizz_buzz(78)); // Expected output: 2\n        System.out.println(solution.fizz_buzz(79)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the elements at even indices\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the 'evens' list\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the 'evens' list\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values from 'evens'\n        for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n            sortedList.set(i, evens.get(j));\n        }\n        \n        return sortedList;\n    }\n\n    // Method to test the sort_even function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string into groups. Each group has a maximum length of 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Cycle elements in each group. Unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n\n        // Join the encoded groups back into a single string.\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input an encoded string and returns the decoded string.\n     */\n    public String decodeCyclic(String s) {\n        // Split string into groups. Each group has a maximum length of 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Reverse the cycle operation in each group. Unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n\n        // Join the decoded groups back into a single string.\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n        }\n\n        return primes.get(primes.size() - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for easier traversal\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on a straight road.\n     *\n     * @param n The number of cars in each set (one set moving left to right, and one set moving right to left).\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from the left will collide with every car from the right,\n        // the total number of collisions is simply n (left cars) times n (right cars).\n        return n * n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 4\n        System.out.println(solution.car_race_collision(3));  // Expected output: 9\n        System.out.println(solution.car_race_collision(5));  // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and high return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        // Area formula: (1/2) * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Area of triangle with base=10 and height=4: \" + area2); // Expected output: 20.0\n        \n        // Test case 3 (with floating point numbers)\n        double area3 = solution.triangle_area(7.5, 2.5);\n        System.out.println(\"Area of triangle with base=7.5 and height=2.5: \" + area3); // Expected output: 9.375\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        else if (n == 2) return 2;\n        else if (n == 3) return 0;\n\n        // Initialize base cases\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; i++) {\n            int next_value = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next_value;\n        }\n\n        return d;\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list first\n        Collections.sort(l);\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return the middle element\n            return l.get(size / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "class Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left++) != text.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test cases using assertions\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        assert solution.is_palindrome(\"\") : \"Empty string should be a palindrome\";\n        assert solution.is_palindrome(\"aba\") : \"'aba' is a palindrome\";\n        assert solution.is_palindrome(\"aaaaa\") : \"'aaaaa' is a palindrome\";\n        assert !solution.is_palindrome(\"zbcd\") : \"'zbcd' is not a palindrome\";\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // 2^0 = 1 for any p\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base value\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5)); // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101)); // Expected output: 1\n        System.out.println(solution.modp(3, 11)); // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"hello\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should output \"mjqqt\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should output \"hello\"\n\n        String testString2 = \"World\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should output \"BTQYI\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should output \"World\"\n\n        // Test with non-letter characters\n        String testString3 = \"abc123\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should output \"fghi123\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should output \"abc123\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string and append non-vowel characters to result\n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + (solution.below_threshold(list1, threshold1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + (solution.below_threshold(list2, threshold2) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"add(2, 3): \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7): \" + solution.add(5, 7)); // Expected output: 12\n\n        // Additional test cases for robustness\n        System.out.println(\"add(-10, 4): \" + solution.add(-10, 4)); // Expected output: -6\n        System.out.println(\"add(0, 0): \" + solution.add(0, 0));     // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from the first string\n        Set<Character> charSet = new HashSet<>();\n        \n        // Add all characters from the first string into the set\n        for (char c : s0.toCharArray()) {\n            charSet.add(c);\n        }\n        \n        // Check if every character in the second string is present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charSet.contains(c)) {\n                return false;\n            }\n        }\n\n        // Create a set to store unique characters from the second string\n        Set<Character> charSet2 = new HashSet<>();\n        \n        // Add all characters from the second string into the set\n        for (char c : s1.toCharArray()) {\n            charSet2.add(c);\n        }\n        \n        // Check if every character in the first string is present in this new set\n        for (char c : s0.toCharArray()) {\n            if (!charSet2.contains(c)) {\n                return false;\n            }\n        }\n\n        // If all checks pass, both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the number of open and close brackets\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n\n            // If at any point the number of closing brackets is more than opening ones, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // At the end, there should be no unmatched open brackets left\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() <= 1) return true; // A single element is trivially monotonic\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(\"Largest prime factor of 13195: \" + solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(\"Largest prime factor of 2048: \" + solution.largest_prime_factor(2048));   // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    /**\n     * A method to test the correctness of the sum_to_n function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5));    // Expected output: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1));    // Expected output: 1\n        \n        // Additional test case to ensure correctness\n        System.out.println(\"sum_to_n(1000): \" + solution.sum_to_n(1000)); // Expected output: 500500\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the balance between '(' and ')'\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++; // Increment when an opening bracket is found\n            } else if (c == ')') {\n                balance--; // Decrement when a closing bracket is found\n                \n                // If at any point the balance goes negative, it means there are more closing brackets than opening ones.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative will have one less term than the original polynomial,\n        // unless it's a constant (degree 0), which has no terms after differentiation.\n        if (xs.size() <= 1) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.length() == 0) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     * >>> circular_shift(12, 1)\n     * \"21\"\n     * >>> circular_shift(12, 2)\n     * \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        \n        // Get the length of the number as a string\n        int numLength = numStr.length();\n        \n        // If shift is greater than the number of digits, return the reversed string\n        if (shift > numLength) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Handle cases where shift is larger than the length of the string\n        shift %= numLength;\n        \n        // Perform circular shift\n        String shiftedStr = numStr.substring(numLength - shift) + numStr.substring(0, numLength - shift);\n        \n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in a basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the count of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mango fruits\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the record.\n                if (value < smallestEvenValue || i < index) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1; // Initialize result to -1\n        \n        // Iterate through the entries of the frequency map\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            \n            // Check if the number's frequency is greater than or equal to the number itself\n            if (num <= freq) {\n                result = Math.max(result, num); // Update result with the maximum value found\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of integers, return a list in strange order.\n     * Strange sorting involves starting with the minimum value,\n     * followed by the maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        \n        while (!lst.isEmpty()) {\n            // Find and remove the minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) {\n                break;\n            }\n            \n            // Find and remove the maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the object q will fly, and false otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w and the list is a palindrome\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic.\n     *\n     * @param arr List<Integer> representing the input array.\n     * @return int representing the minimum number of changes needed.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            if (!arr.get(i).equals(arr.get(n - i - 1))) {\n                changes++;\n            }\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));   // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList(\"a\", \"b\", \"c\"))); // []\n        System.out.println(solution.total_match(Arrays.asList(\"abc\", \"def\"), Arrays.asList(\"ghi\"))); // [\"ghi\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            \n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a) return true;\n                    \n                    if (p1 * p2 * p3 > a) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double logResult = Math.log(x) / Math.log(n);\n        return logResult == Math.floor(logResult);\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube of some integer.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cubeRoot = Math.cbrt(absA);\n        long roundedCubeRoot = Math.round(cubeRoot);\n\n        // Check if cubing the rounded value equals the original number\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube method\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Define a set of hexadecimal digits that are prime numbers.\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of characters in the input string that are prime hex digits.\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A test method to check the correctness of the decimal_to_binary function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(7));   // Expected output: \"db111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is a happy string.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"E\");\n            } else {\n                letterGrades.add(\"Invalid GPA\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        \n        // Check for edge cases\n        if (len <= 1) return false;\n        if (len == 2) return true; // 2 is the only even prime number\n        \n        // Check divisibility by numbers up to sqrt(len)\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1;\n        }\n\n        // For numbers with more than one digit, calculate the count.\n        long totalNumbers = (long) Math.pow(10, n - 1);\n        \n        // Numbers starting with 1\n        long startsWithOne = totalNumbers;\n\n        // Numbers ending with 1 but not starting with 1\n        long endsWithOneNotStartingWithOne = (totalNumbers / 10) * 9;\n\n        return (int)(startsWithOne + endsWithOneNotStartingWithOne);\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        // Calculate the sum of digits of N\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2, 9))); // Expected output: 5 (since only one even number at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 7, 8, 2))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string where each word's characters are sorted alphabetically.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                \n                // Append sorted characters to the result, followed by a space\n                result.append(new String(chars));\n            }\n            \n            // Append a space after each non-empty word\n            result.append(\" \");\n        }\n\n        // Remove trailing space if present and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinate to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, it's both the first and last.\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        // Create a copy of the original list to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a given string by rotating each letter down by 4 places in the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted and remain the same.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Set<Integer> uniqueElements = new HashSet<>(lst);\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(uniqueElements);\n        Collections.sort(sortedList);\n\n        return Optional.of(sortedList.get(1));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the sentence into individual sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. Are you? I think so!\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility)\n     * @param y Second number (Object type for flexibility)\n     * @param z Third number (Object type for flexibility)\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (will be false because inputs are not all integers)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the English alphabet.\n     Assume only letters.\n\n     Examples:\n     >>> encode(\"test\")\n     \"TGST\"\n     >>> encode(\"This is a message\")\n     \"tHKS KS C MGSSCGG\"\n      */\n    public String encode(String message) {\n        // Define a map for vowel replacements\n        Map<Character, Character> vowels = new HashMap<>();\n        vowels.put('a', 'c');\n        vowels.put('e', 'g');\n        vowels.put('i', 'k');\n        vowels.put('o', 'q');\n        vowels.put('u', 'w');\n\n        // Initialize the encoded message as a StringBuilder\n        StringBuilder encodedMessage = new StringBuilder();\n\n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case of the character\n                char swappedChar;\n                if (Character.isUpperCase(c)) {\n                    swappedChar = Character.toLowerCase(c);\n                } else {\n                    swappedChar = Character.toUpperCase(c);\n                }\n\n                // Replace vowels with the letter 2 places ahead\n                if (vowels.containsKey(Character.toLowerCase(swappedChar))) {\n                    swappedChar = vowels.get(Character.toLowerCase(swappedChar));\n                }\n\n                encodedMessage.append(swappedChar);\n            } else {\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\npublic class Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        int maxPrime = -1;\n        \n        for (int num : lst) {\n            if (isPrime(num) && num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n\n        return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowercase = true;\n        boolean allUppercase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false; // Key is not a string\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowercase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUppercase = false;\n            }\n        }\n\n        return allLowercase || allUppercase;\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of their unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        // Initialize the count variable to zero\n        int count = 0;\n        \n        // Iterate through the string, starting from index 1 and incrementing by 2\n        for (int i = 1; i < s.length(); i += 2) {\n            // Check if the character at position i-1 is an uppercase vowel\n            if (vowels.contains(s.charAt(i - 1))) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is negative or positive to determine rounding direction\n        if (num < 0) {\n            return (int)Math.ceil(num - 0.5); // Round towards more negative for negative numbers\n        } else {\n            return (int)Math.floor(num + 0.5); // Round towards more positive for non-negative numbers\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a string of words separated by commas or spaces. Your task is\n     * to split the string into words and return an array of the words.\n     *\n     * For example:\n     * words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"])\n     * words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\n     */\n    public List<String> words_string(String s) {\n        // Split the string using a regular expression that matches commas and spaces\n        String[] wordsArray = s.split(\"[,\\\\s]+\");\n        \n        // Convert the array to a list and return it\n        List<String> wordsList = new ArrayList<>(Arrays.asList(wordsArray));\n        return wordsList;\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number \n     * that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x <= y\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the rounded average of integers from n through m (inclusive) and returns its binary representation.\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return The binary string of the rounded average if valid, otherwise -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of numbers from n to m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute the average and round it to the nearest integer\n        double avg = (double) sum / count;\n        int roundedAvg = (int) Math.round(avg);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Helper method to check if an integer has only odd digits\n        return x.stream()\n                .filter(this::hasOnlyOddDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasOnlyOddDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // All digits are odd\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define an array of strings representing numbers from 1 to 9.\n        String[] numberNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter the input list for integers between 1 and 9 inclusive.\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted() // Sort in ascending order\n                                        .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredList);\n        \n        // Convert each integer to its corresponding name and collect into a new list.\n        List<String> result = filteredList.stream()\n                                          .map(num -> numberNames[num - 1])\n                                          .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        int originalNumber = number, reversedNumber = 0;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            number /= 10;\n        }\n\n        return originalNumber == reversedNumber;\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        // Helper function to calculate the sum of signed digits\n        return (int) arr.stream().filter(num -> sum_of_digits(num) > 0).count();\n    }\n\n    private int sum_of_digits(int num) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n        int digitSum = 0;\n\n        while (num > 0) {\n            int digit = num % 10;\n            // If it's the first signed digit of a negative number, make it negative\n            if (isNegative && num / 10 == 0) {\n                digit *= -1;\n            }\n            digitSum += digit;\n            num /= 10;\n        }\n\n        return digitSum;\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to get an array sorted in non-decreasing order by performing right shift operations.\n     *\n     * @param arr List of integers representing the array.\n     * @return true if it's possible to sort the array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, return true\n        if (arr.size() <= 1) {\n            return true;\n        }\n\n        int count = 0; // Count of rotations needed to get non-decreasing order\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element\n        if (arr.get(arr.size() - 1) > arr.get(0)) {\n            count++;\n        }\n\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count the number of odd numbers in lst1\n        int oddCountLst1 = (int) lst1.stream().filter(num -> num % 2 != 0).count();\n        \n        // Count the number of even numbers in lst2\n        int evenCountLst2 = (int) lst2.stream().filter(num -> num % 2 == 0).count();\n        \n        // Check if there are enough even numbers in lst2 to make all elements in lst1 even\n        return oddCountLst1 <= evenCountLst2 ? \"YES\" : \"NO\";\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Example:\n    histogram(\"a b c\") == {\"a\": 1, \"b\": 1, \"c\": 1}\n    histogram(\"a b b a\") == {\"a\": 2, \"b\": 2}\n    histogram(\"a b c a b\") == {\"a\": 2, \"b\": 2}\n    histogram(\"b b b b a\") == {\"b\": 4}\n    histogram(\"\") == {}\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into individual letters\n        String[] letters = test.split(\"\\\\s+\");\n        \n        // Initialize a map to count occurrences of each letter\n        Map<String, Integer> letterCount = new HashMap<>();\n        int maxCount = 0;\n        \n        // Count occurrences of each letter\n        for (String letter : letters) {\n            if (!letter.isEmpty()) { // Ensure that empty strings are not counted\n                int count = letterCount.getOrDefault(letter, 0) + 1;\n                letterCount.put(letter, count);\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n\n        // Collect all letters with the maximum occurrence\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCount.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left) != resultString.charAt(right)) {\n                isPalindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> result = new ArrayList<>();\n        result.add(resultString);\n        result.add(isPalindrome);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum at each step\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.List;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Flatten the grid into a list of water units per well\n        List<Integer> waterUnits = new ArrayList<>();\n        for (List<Integer> row : grid) {\n            int sum = 0;\n            for (int unit : row) {\n                sum += unit;\n            }\n            waterUnits.add(sum);\n        }\n\n        // Calculate the number of times buckets need to be lowered\n        int numBucketsLowered = 0;\n        for (int units : waterUnits) {\n            numBucketsLowered += units / capacity + (units % capacity != 0 ? 1 : 0);\n        }\n        \n        return numBucketsLowered;\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     In this Kata, you have to sort an array of integers according to\n     number of ones in their binary representation in ascending order.\n     For similar number of ones, sort based on decimal value.\n     <p>\n     It must be implemented like this:\n     >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n      */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Custom comparator to sort based on number of ones and decimal value\n        Comparator<Integer> customComparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                int countA = count_ones(a);\n                int countB = count_ones(b);\n                \n                if (countA != countB) {\n                    return countA - countB;\n                } else {\n                    return a - b;\n                }\n            }\n        };\n\n        // Sort the array using the custom comparator\n        Collections.sort(arr, customComparator);\n\n        return arr;\n    }\n\n    private int count_ones(int n) {\n        int count = 0;\n        while (n != 0) {\n            count += n & 1; // Check if the least significant bit is set\n            n >>>= 1; // Right shift without sign extension\n        }\n        return count;\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a method to count consonants in a word\n        java.util.function.Function<String, Integer> countConsonants = word -> {\n            int count = 0;\n            for (char c : word.toCharArray()) {\n                if (\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\".indexOf(c) >= 0) {\n                    count++;\n                }\n            }\n            return count;\n        };\n\n        // Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Filter and collect words with exactly n consonants\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (countConsonants.apply(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!vowels.contains(leftChar) && !vowels.contains(rightChar) && vowels.contains(middleChar)) {\n                return String.valueOf(middleChar); // Found the vowel\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < lst.size(); i++) {\n            int balance = 0;\n            boolean isBalanced = true;\n\n            for (String s : lst) {\n                for (char c : s.toCharArray()) {\n                    if (c == '(') {\n                        balance++;\n                    } else {\n                        balance--;\n                    }\n                    // If at any point the balance goes negative, it's not balanced\n                    if (balance < 0) {\n                        isBalanced = false;\n                        break;\n                    }\n                }\n            }\n\n            // Swap the order of strings and check again if first attempt failed\n            if (!isBalanced && i == 0) {\n                Collections.swap(lst, 0, 1);\n                balance = 0;\n                for (String s : lst) {\n                    for (char c : s.toCharArray()) {\n                        if (c == '(') {\n                            balance++;\n                        } else {\n                            balance--;\n                        }\n                        // If at any point the balance goes negative, it's not balanced\n                        if (balance < 0) {\n                            isBalanced = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isBalanced && balance == 0) {\n                return \"Yes\";\n            }\n        }\n\n        // If no combination works, return \"No\"\n        return \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap)\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        // Add elements to the heap until it reaches size k\n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.add(num);\n            } else if (num > pq.peek()) {  // If current element is greater than the smallest in heap, replace it.\n                pq.poll();  // Remove the smallest element\n                pq.add(num);  // Add the new element\n            }\n        }\n\n        // Convert priority queue to list and sort it since we need ascending order\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Expected: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i); // Add to sum if it's an odd number in an even position\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr, k)); // Expected output is 24\n        \n        // Additional test case\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 3;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr2, k2)); // Expected output is 28\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        \n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected output: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the required date format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input string matches the regular expression\n        boolean isFormatValid = date.matches(regex);\n        \n        // If format is not valid, return false\n        if (!isFormatValid) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is between 1 and 12\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Determine the number of days in a given month\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        int maxDaysInMonth = getMaxDays(month, isLeapYear);\n\n        // Check if the day is within the valid range for the month\n        return day >= 1 && day <= maxDaysInMonth;\n    }\n\n    private int getMaxDays(int month, boolean isLeapYear) {\n        switch (month) {\n            case 2: return isLeapYear ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11: return 30;\n            default: return 31;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace and split if found\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // If no whitespaces, check for commas and split if found\n        words = txt.split(\",\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // Count lowercase letters with odd order indices in the alphabet\n        int countOddOrderLetters = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    countOddOrderLetters++;\n                }\n            }\n        }\n\n        return countOddOrderLetters;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"NoSpacesHere\")); // Should print the number of odd-order lowercase letters\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"));\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (previousNumber != null && lst.get(i) < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (i > 0 && lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = lst.get(i);\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Calculate the maximum start point and minimum end point\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        // Check if there is an intersection\n        if (startMax > endMin) {\n            return \"NO\";\n        }\n\n        // Calculate the length of the intersection\n        int length = endMin - startMax + 1;\n\n        // Check if the length is a prime number using the helper method\n        return isPrime(length) ? \"YES\" : \"NO\";\n    }\n    \n    boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize the answer with a large value to ensure any path will be smaller\n        List<Integer> ans = new ArrayList<>(Collections.nCopies(k, Integer.MAX_VALUE));\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start DFS from each cell to find the minimum path\n                dfs(grid, k, new ArrayList<>(), i, j, ans);\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, List<Integer> path, int row, int col, List<Integer> ans) {\n        if (path.size() == k) {\n            // Update the answer with the lexicographically smaller path\n            if (isSmaller(path, ans)) {\n                ans.clear();\n                ans.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0], newCol = col + dir[1];\n            // Check bounds and add the next cell to the path\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid.get(0).size()) {\n                path.add(grid.get(newRow).get(newCol));\n                dfs(grid, k, path, newRow, newCol, ans);\n                // Backtrack to explore other paths\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        int size = Math.min(a.size(), b.size());\n        for (int i = 0; i < size; ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(1); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                nextValue = sequence.get(i - 2) + sequence.get(i - 3) + sequence.get(i);\n            }\n            sequence.add(nextValue);\n        }\n        \n        return new ArrayList<>(sequence.subList(0, n + 1));\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets\n    where at least one bracket in the subsequence is nested.\n\n    is_nested(\"[[]]\") -> true\n    is_nested(\"[]]]]]]][[[[[]\") -> false\n    is_nested(\"[][]\") -> false\n    is_nested(\"[]\") -> false\n    is_nested(\"[[][]]\") -> true\n    is_nested(\"[[]][[\") -> true\n     */\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean hasNested = false;\n\n        for (char bracket : string.toCharArray()) {\n            if (bracket == '[') {\n                stack.push(bracket);\n            } else if (bracket == ']') {\n                // Check if there are at least two brackets in the stack\n                if (!stack.isEmpty() && !stack.peek().equals('[')) {\n                    return false;  // Invalid sequence, unmatched closing bracket\n                }\n                if (stack.size() > 1) {\n                    hasNested = true;\n                }\n                stack.pop();\n            }\n        }\n\n        // Ensure there are no unmatched brackets left in the stack and at least one nested structure was found\n        return hasNested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilValue = Math.ceil(num);\n            // Square the rounded value and add it to the sum\n            sum += (int)Math.pow(ceilValue, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check for empty string\n        if (txt == null || txt.length() == 0) {\n            return false;\n        }\n        \n        char lastChar = txt.charAt(txt.length() - 1);\n        \n        // Check if the last character is an alphabetical character and not part of a word.\n        if (Character.isLetter(lastChar)) {\n            if ((txt.length() == 1 || !Character.isWhitespace(txt.charAt(txt.length() - 2)))) {\n                return false;\n            }\n            return true;\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object obj) {\n        if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(',', '.'); // Convert comma to dot for parsing\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        }\n\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        }\n\n        if (obj instanceof Float || obj instanceof Double) {\n            return ((Number) obj).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(compare_one(1, \"2,3\")); // Optional[2,3]\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional[6]\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers greater than or equal to 8 can be expressed this way,\n        // but we know that n - 8 must be expressible as a sum of three positive even numbers for n >= 12.\n        if (n % 2 == 0 && n >= 12) {\n            return true;\n        }\n\n        // For the edge case where n is between 8 and 11, we need to check manually:\n        int[] testCases = {8, 10};\n        for (int testCase : testCases) {\n            if (n == testCase) return true;\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long product = 1;\n        for (int j = 2; j <= number; j++) {\n            product *= j;\n        }\n        return product;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        return result.replaceAll(\" \", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));          // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));       // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));      // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));    // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex == -1 || fileName.lastIndexOf('.') != dotIndex) {\n            return \"No\";\n        }\n\n        // Split the file name into two parts: before and after the dot\n        String baseName = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        // Check if the part before the dot is valid\n        if (!isValidBase(baseName)) {\n            return \"No\";\n        }\n\n        // Check if the part after the dot is a valid extension\n        if (!isValidExtension(extension)) {\n            return \"No\";\n        }\n\n        // Count digits in the base name and ensure there are no more than three\n        int digitCount = 0;\n        for (char c : baseName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n\n    private boolean isValidBase(String baseName) {\n        // Check that the base name starts with a letter and is not empty\n        if (baseName.isEmpty() || !Character.isLetter(baseName.charAt(0))) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isValidExtension(String extension) {\n        // Valid extensions are \"txt\", \"exe\", or \"dll\"\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        for (String ext : validExtensions) {\n            if (ext.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"file1234.txt\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     *\n     * Examples:\n     * For lst = [1,2,3] the output should be 6\n     * For lst = []  the output should be 0\n     * For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sum_squares(List<Integer> lst) {\n        int resultSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                resultSum += Math.pow(lst.get(i), 2);\n            } else if ((i + 1) % 4 == 0) {\n                // Cube the value if index is a multiple of 4 but not a multiple of 3\n                resultSum += Math.pow(lst.get(i), 3);\n            } else {\n                // Add the original value to the sum if index is neither a multiple of 3 nor 4\n                resultSum += lst.get(i);\n            }\n        }\n\n        return resultSum;\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Checks if a given number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected output: \"is\"\n\n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n and checks if it evaluates to a whole number.\n     *\n     * @param x The first fraction in string format \"<numerator>/<denominator>\".\n     * @param n The second fraction in string format \"<numerator>/<denominator>\".\n     * @return true if x * n is a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Calculate the product of the two fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number by seeing if the remainder is zero when dividing the numerator by the denominator.\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (sum_of_digits, original_index)\n        List<Pair<Integer, Integer>> pairs = new ArrayList<>();\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int sumOfDigits = digitSum(nums.get(i));\n            pairs.add(new Pair<>(sumOfDigits, i));\n        }\n        \n        // Sort the list of pairs based on the custom comparator\n        Collections.sort(pairs, new Comparator<Pair<Integer, Integer>>() {\n            @Override\n            public int compare(Pair<Integer, Integer> p1, Pair<Integer, Integer> p2) {\n                if (!p1.getKey().equals(p2.getKey())) {\n                    return p1.getKey() - p2.getKey();\n                } else {\n                    return p1.getValue() - p2.getValue();\n                }\n            }\n        });\n        \n        // Reconstruct the sorted list of integers\n        List<Integer> result = new ArrayList<>();\n        for (Pair<Integer, Integer> pair : pairs) {\n            result.add(nums.get(pair.getValue()));\n        }\n        \n        return result;\n    }\n\n    private int digitSum(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        boolean isNegative = n < 0;\n        int sum = 0;\n\n        n = Math.abs(n);\n        \n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n\n        if (isNegative) {\n            sum -= 2 * (sum % 10); // Adjust for the negative first digit\n        }\n        \n        return sum;\n    }\n}\n\n// Helper class to store pairs of integers\nclass Pair<K, V> {\n    private K key;\n    private V value;\n\n    public Pair(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public K getKey() {\n        return key;\n    }\n\n    public V getValue() {\n        return value;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                         .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                         .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many numbers in the array are congruent to each of 0, 1, and 2 modulo 3\n        int countMod0 = 0, countMod1 = 0, countMod2 = 0;\n\n        for (int num : a) {\n            if (num % 3 == 0) countMod0++;\n            else if (num % 3 == 1) countMod1++;\n            else countMod2++;\n        }\n\n        // Calculate the number of valid triples\n        int result = 0;\n        result += countMod0 * (countMod0 - 1) * (countMod0 - 2) / 6; // All three numbers are congruent to 0 mod 3\n        result += countMod1 * (countMod1 - 1) * (countMod1 - 2) / 6; // All three numbers are congruent to 1 mod 3\n        result += countMod2 * (countMod2 - 1) * (countMod2 - 2) / 6; // All three numbers are congruent to 2 mod 3\n        result += countMod0 * countMod1 * countMod2; // One number is congruent to each of 0, 1, and 2 mod 3\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) return Collections.emptyList();\n\n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> evenLengthStrings = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                evenLengthStrings.add(s);\n            }\n        }\n\n        // Sort the list by length, and then alphabetically if lengths are equal\n        Collections.sort(evenLengthStrings, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                int lenCompare = Integer.compare(s1.length(), s2.length());\n                return (lenCompare != 0) ? lenCompare : s1.compareTo(s2);\n            }\n        });\n\n        return evenLengthStrings;\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));   // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * doubleTheDifference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n     * doubleTheDifference(Arrays.asList(-1, -2, 0)) == 0\n     * doubleTheDifference(Arrays.asList(9, -2)) == 81\n     * doubleTheDifference(Arrays.asList(0)) == 0\n     *\n     * If the input list is empty, return 0.\n     */\n    public int doubleTheDifference(List<Object> lst) {\n        int sumOfSquares = 0;\n        \n        for (Object item : lst) {\n            if (item instanceof Integer && ((Integer)item > 0) && (((Integer)item % 2) != 0)) {\n                sumOfSquares += Math.pow((Integer)item, 2);\n            }\n        }\n\n        return sumOfSquares;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.doubleTheDifference(Arrays.asList(1, 3, 2, 0)));\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list to its corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class based on the provided list of extensions.\n     * The strength of an extension is calculated as CAP - SM, where CAP is the number of uppercase letters,\n     * and SM is the number of lowercase letters in the extension's name. If there are multiple extensions\n     * with the same strength, the first one in the list is chosen.\n     *\n     * @param class_name The name of the class to which the strongest extension will be attached.\n     * @param extensions A List containing names of possible extensions for the class.\n     * @return A string representing the class and its strongest extension in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        // Initialize variables to track the strongest extension\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String name) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : name.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => false\n    cycpattern_check(\"hello\",\"ell\") => true\n    cycpattern_check(\"whassup\",\"psus\") => false\n    cycpattern_check(\"abab\",\"baa\") => true\n    cycpattern_check(\"efef\",\"eeff\") => false\n    cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the first word with itself\n        String concatenatedA = a + a;\n        \n        // Check if the second word is a substring of the concatenated string\n        return concatenatedA.contains(b);\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a positive value and then to string for easy iteration\n        String strNum = Integer.toString(Math.abs(num));\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char c = strNum.charAt(i);\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not, it's odd\n                oddCount++;\n            }\n        }\n\n        // Return the counts as a list [even count, odd count]\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the method\n        System.out.println(solution.even_odd_count(-12));  // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        // Mapping of integers to Roman numerals (in lowercase)\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Update the maximum if this word has more unique characters or is lexicographically smaller\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    // Test function to verify the correctness of find_max\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1));  // Expected: string\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2));  // Expected: enam\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Determine how many carrots are left after eating.\n        int leftoverCarrots = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of eaten carrots and the number of leftover carrots.\n        return new ArrayList<>(List.of(totalEaten, leftoverCarrots));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        for (int i = 0; i < operator.size(); i++) {\n            if (i > 0) {\n                expression.append(\" \");\n            }\n            expression.append(operand.get(i));\n            expression.append(operator.get(i));\n        }\n        // Append the last operand\n        expression.append(\" \").append(operand.get(operand.size() - 1));\n\n        // Evaluate the expression using a custom method or library (since Java does not have eval)\n        return evaluateExpression(expression.toString());\n    }\n\n    private int evaluateExpression(String expression) {\n        // Implement a simple parser to evaluate the expression\n        String[] tokens = expression.split(\" \");\n        Stack<Integer> stack = new Stack<>();\n        \n        for (String token : tokens) {\n            if (\"+\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a + b);\n            } else if (\"-\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a - b);\n            } else if (\"*\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a * b);\n            } else if (\"/\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a / b); // Assuming integer division\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n        }\n\n        return stack.pop(); // The final result is the only element left in the stack\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = digest.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hash);\n        String hashtext = number.toString(16);\n\n        // Add leading zeros to make sure it's 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is less than or equal to b for simplicity\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n\n        List<Integer> evenDigits = new ArrayList<>();\n        \n        // Iterate over the range from start to end\n        for (int num = start; num <= end; num++) {\n            if (num % 2 == 0 && num < 10) {\n                evenDigits.add(num);\n            }\n        }\n\n        return evenDigits;\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers that are closer to each other than a given threshold.\n     *\n     * @param numbers List<Double> - A list of floating-point numbers.\n     * @param threshold double - The minimum distance between any two elements for them not to be considered close.\n     * @return boolean - Returns true if there are at least two elements in the list that are closer than the threshold, otherwise false.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Additional test cases\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.5, 8.7), 0.4);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        boolean result4 = solution.has_close_elements(Arrays.asList(-2.0, -1.0, 0.5, 1.5), 0.6);\n        System.out.println(\"Test Case 4: \" + (result4 ? \"Passed\" : \"Failed\")); // Expected output: Failed\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * Example:\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < cleanString.length(); i++) {\n            char c = cleanString.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(cleanString.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String input = \"( ) (( )) (( )( ))\";\n        List<String> output = solution.separate_paren_groups(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Output: [\" + String.join(\", \", output) + \"]\");\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to check the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n        System.out.println(solution.truncate_number(0.123));  // Expected output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposit (positive) or withdrawal (negative) amounts.\n     * @return boolean indicating whether the balance goes negative at any point.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance has fallen below zero\n            }\n        }\n        return false; // No negative balance detected\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false as the balance never goes below zero.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true as after -4, the balance is negative.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyList); // Expected output: []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyList); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, returns the deepest level of nesting of parentheses as an integer in a list.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A List<Integer> where each element represents the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    /**\n     * A test method to verify the correctness of parse_nested_parens function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result;\n\n        // Test case 1\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        result = solution.parse_nested_parens(input1);\n        System.out.println(\"Test Case 1: \" + (result.equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        String input2 = \"() ()\";\n        List<Integer> expectedOutput2 = Arrays.asList(1, 1);\n        result = solution.parse_nested_parens(input2);\n        System.out.println(\"Test Case 2: \" + (result.equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        String input3 = \"(())() ((()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(2, 3);\n        result = solution.parse_nested_parens(input3);\n        System.out.println(\"Test Case 3: \" + (result.equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java 8 Streams API for filtering the list based on a condition.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        \n        // Generate rolling max\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n        \n        // Verify correctness\n        if (expectedOutput.equals(output)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        if (string == null || string.isEmpty()) {\n            return \"\";\n        }\n\n        // Find the longest palindromic suffix\n        int i = 0;\n        while (!isPalindrome(string.substring(i))) {\n            i++;\n        }\n        \n        // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n        String prefix_to_reverse = string.substring(0, i);\n        return string + new StringBuilder(prefix_to_reverse).reverse().toString();\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11011\"));  // Expected output: \"01110\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\"));  // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\"));  // Expected output: \"0000\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-9, -18)); // Expected output: 9\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        // Additional test cases\n        List<String> emptyPrefixes = solution.all_prefixes(\"\");\n        System.out.println(emptyPrefixes);  // Expected output: []\n        \n        List<String> singleCharPrefixes = solution.all_prefixes(\"x\");\n        System.out.println(singleCharPrefixes);  // Expected output: [x]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last.\n\n    Here is a legend:\n    \"o\" - whole note, lasts four beats\n    \"o|\" - half note, lasts two beats\n    \".|\" - quarter note, lasts one beat\n\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n    public List<Integer> parse_music(String string) {\n        // Split the input string into individual notes\n        String[] notes = string.split(\" \");\n        \n        // Initialize a list to store the number of beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Iterate through each note in the notes array\n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                // Whole note, lasts four beats\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                // Half note, lasts two beats\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                // Quarter note, lasts one beat\n                beats.add(1);\n            }\n        }\n        \n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each number word to its corresponding integer value.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its integer value and sort them.\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into number words.\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            String word = \"\";\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key).equals(num)) {\n                    word = key;\n                    break;\n                }\n            }\n            result.append(word);\n            result.append(\" \");\n        }\n\n        // Remove the trailing space and return the result.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected output: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding closest elements easier.\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), applies a linear transform such that \n     * the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledNumber = (number - min) / (max - min);\n            scaledNumbers.add(scaledNumber);\n        }\n        \n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Collections.emptyMap(), Collections.emptyList());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i > 0; i--) { // Start from half of n and go down to 1\n            if (n % i == 0) { // Check if i divides n evenly\n                return i; // Return the first divisor found, which is the largest one\n            }\n        }\n        return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n        System.out.println(solution.largest_divisor(60)); // Expected output: 30\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 to get rid of all even factors\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once and preserve the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     * \n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over the list and append each string to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test function to verify the correctness of the filter_by_prefix method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print: []\n\n        List<String> listWithPrefixes = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(listWithPrefixes, \"a\")); // Should print: [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n\n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n    xs are coefficients of a polynomial.\n    find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients\n    and the largest non-zero coefficient as it guarantees a solution.\n     */\n    public double find_zero(List<Double> xs) {\n        // Initialize search boundaries\n        double left = -100;\n        double right = 100;\n\n        // Tolerance level for precision\n        final double tolerance = 1e-6;\n\n        while (right - left > tolerance) {\n            double mid = (left + right) / 2.0;\n            double evalLeft = poly(xs, left);\n            double evalMid = poly(xs, mid);\n\n            if ((evalLeft * evalMid) < 0) {\n                // Root is in the interval [left, mid]\n                right = mid;\n            } else {\n                // Root is in the interval [mid, right]\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2.0;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three\n     * are equal to the values of the corresponding indices of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 (1-based index)\n        List<Integer> thirdIndicesValues = new ArrayList<>();\n        for (int i = 2; i < l.size(); i += 3) {\n            thirdIndicesValues.add(l.get(i));\n        }\n\n        // Sort the extracted values\n        Collections.sort(thirdIndicesValues);\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        int sortedIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                // Append the sorted value at indices divisible by three\n                result.add(thirdIndicesValues.get(sortedIndex));\n                sortedIndex++;\n            } else {\n                // Append other elements as they are\n                result.add(l.get(i));\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + testList1);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList1));\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 5, 4, 3, 2, 1);\n        System.out.println(\"Original: \" + testList2);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList2));\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(9, 7, 5, 3, 1);\n        System.out.println(\"Original: \" + testList3);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0); // Assume the first element is the largest initially\n        \n        for (int i = 1; i < l.size(); i++) { // Start from the second element\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Expected output: 0\n        System.out.println(solution.fizz_buzz(78)); // Expected output: 2\n        System.out.println(solution.fizz_buzz(79)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the elements at even indices\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the 'evens' list\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the 'evens' list\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values from 'evens'\n        for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n            sortedList.set(i, evens.get(j));\n        }\n        \n        return sortedList;\n    }\n\n    // Method to test the sort_even function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string into groups. Each group has length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Cycle elements in each group unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                String group = groups.get(i);\n                groups.set(i, group.substring(1) + group.charAt(0));\n            }\n        }\n\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // Split the string into groups of length 3\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n\n        // Decode each group by reversing the cyclic shift if it has exactly three characters\n        for (int i = 0; i < groups.size(); i++) {\n            String group = groups.get(i);\n            if (group.length() == 3) {\n                groups.set(i, group.charAt(2) + group.substring(0, 2));\n            }\n        }\n\n        // Join all decoded groups back together to form the original string\n        return String.join(\"\", groups);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n        }\n\n        return primes.get(primes.size() - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for easier traversal\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on a straight road.\n     *\n     * @param n The number of cars in each set (one set moving left to right, and one set moving right to left).\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from the left will collide with every car from the right,\n        // the total number of collisions is simply n (left cars) times n (right cars).\n        return n * n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 4\n        System.out.println(solution.car_race_collision(3));  // Expected output: 9\n        System.out.println(solution.car_race_collision(5));  // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and high return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        // Area formula: (1/2) * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Area of triangle with base=10 and height=4: \" + area2); // Expected output: 20.0\n        \n        // Test case 3 (with floating point numbers)\n        double area3 = solution.triangle_area(7.5, 2.5);\n        System.out.println(\"Area of triangle with base=7.5 and height=2.5: \" + area3); // Expected output: 9.375\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) {\n            return 0;\n        } else if (n == 2) {\n            return 2;\n        } else if (n == 3) {\n            return 0;\n        }\n\n        // Initialize the first four values of the sequence\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; i++) {\n            int next_value = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next_value;\n        }\n\n        return d;\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list first\n        Collections.sort(l);\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return the middle element\n            return l.get(size / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "class Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left++) != text.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test cases using assertions\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        assert solution.is_palindrome(\"\") : \"Empty string should be a palindrome\";\n        assert solution.is_palindrome(\"aba\") : \"'aba' is a palindrome\";\n        assert solution.is_palindrome(\"aaaaa\") : \"'aaaaa' is a palindrome\";\n        assert !solution.is_palindrome(\"zbcd\") : \"'zbcd' is not a palindrome\";\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // 2^0 = 1 for any p\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base value\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5)); // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101)); // Expected output: 1\n        System.out.println(solution.modp(3, 11)); // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"hello\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should output \"mjqqt\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should output \"hello\"\n\n        String testString2 = \"World\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should output \"BTQYI\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should output \"World\"\n\n        // Test with non-letter characters\n        String testString3 = \"abc123\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should output \"fghi123\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should output \"abc123\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string and append non-vowel characters to result\n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + (solution.below_threshold(list1, threshold1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + (solution.below_threshold(list2, threshold2) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"add(2, 3): \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7): \" + solution.add(5, 7)); // Expected output: 12\n\n        // Additional test cases for robustness\n        System.out.println(\"add(-10, 4): \" + solution.add(-10, 4)); // Expected output: -6\n        System.out.println(\"add(0, 0): \" + solution.add(0, 0));     // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from the first string\n        Set<Character> charSet = new HashSet<>();\n        \n        // Add all characters from the first string into the set\n        for (char c : s0.toCharArray()) {\n            charSet.add(c);\n        }\n        \n        // Check if every character in the second string is present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charSet.contains(c)) {\n                return false;\n            }\n        }\n\n        // Create a set to store unique characters from the second string\n        Set<Character> charSet2 = new HashSet<>();\n        \n        // Add all characters from the second string into the set\n        for (char c : s1.toCharArray()) {\n            charSet2.add(c);\n        }\n        \n        // Check if every character in the first string is present in this new set\n        for (char c : s0.toCharArray()) {\n            if (!charSet2.contains(c)) {\n                return false;\n            }\n        }\n\n        // If all checks pass, both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the number of open and close brackets\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n\n            // If at any point the number of closing brackets is more than opening ones, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // At the end, there should be no unmatched open brackets left\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() <= 1) return true; // A single element is trivially monotonic\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(\"Largest prime factor of 13195: \" + solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(\"Largest prime factor of 2048: \" + solution.largest_prime_factor(2048));   // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    /**\n     * A method to test the correctness of the sum_to_n function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5));    // Expected output: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1));    // Expected output: 1\n        \n        // Additional test case to ensure correctness\n        System.out.println(\"sum_to_n(1000): \" + solution.sum_to_n(1000)); // Expected output: 500500\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the balance between '(' and ')'\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++; // Increment when an opening bracket is found\n            } else if (c == ')') {\n                balance--; // Decrement when a closing bracket is found\n                \n                // If at any point the balance goes negative, it means there are more closing brackets than opening ones.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative will have one less term than the original polynomial,\n        // unless it's a constant (degree 0), which has no terms after differentiation.\n        if (xs.size() <= 1) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.length() == 0) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        \n        // Get the length of the string representation\n        int numDigits = numStr.length();\n        \n        // If shift is greater than the number of digits, return reversed string\n        if (shift > numDigits) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Calculate effective shift value\n        int effectiveShift = shift % numDigits;\n        \n        // Perform circular shift\n        String shiftedStr = numStr.substring(numDigits - effectiveShift) + \n                            numStr.substring(0, numDigits - effectiveShift);\n        \n        return shiftedStr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(solution.circular_shift(12345, 7)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in a basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the count of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mango fruits\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the record.\n                if (value < smallestEvenValue || i < index) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1; // Initialize result to -1\n        \n        // Iterate through the entries of the frequency map\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            \n            // Check if the number's frequency is greater than or equal to the number itself\n            if (num <= freq) {\n                result = Math.max(result, num); // Update result with the maximum value found\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        \n        while (!lst.isEmpty()) {\n            // Find and append minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) break;\n            \n            // Find and append maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the object q will fly, and false otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w and the list is a palindrome\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic.\n     *\n     * @param arr List<Integer> representing the input array.\n     * @return int representing the minimum number of changes needed.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            if (!arr.get(i).equals(arr.get(n - i - 1))) {\n                changes++;\n            }\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));   // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList(\"a\", \"b\", \"c\"))); // []\n        System.out.println(solution.total_match(Arrays.asList(\"abc\", \"def\"), Arrays.asList(\"ghi\"))); // [\"ghi\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            \n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a) return true;\n                    \n                    if (p1 * p2 * p3 > a) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        int currentPower = n;\n        while (currentPower < x) {\n            currentPower *= n;\n        }\n        \n        return currentPower == x;\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube of some integer.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cubeRoot = Math.cbrt(absA);\n        long roundedCubeRoot = Math.round(cubeRoot);\n\n        // Check if cubing the rounded value equals the original number\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube method\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Define a set of hexadecimal digits that are prime numbers.\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of characters in the input string that are prime hex digits.\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A test method to check the correctness of the decimal_to_binary function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(7));   // Expected output: \"db111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is a happy string.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A\n            > 3.3                A-\n            > 3.0                B+\n            > 2.7                B\n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+\n            > 0.7                D\n            > 0.0                D-\n              0.0                E\n\n    Example:\n    numerical_letter_grade(Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letter_grades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letter_grades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letter_grades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letter_grades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letter_grades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letter_grades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letter_grades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letter_grades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letter_grades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letter_grades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letter_grades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letter_grades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letter_grades.add(\"D-\");\n            } else {\n                letter_grades.add(\"E\"); // For invalid or negative GPAs\n            }\n        }\n\n        return letter_grades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        \n        // Check for edge cases\n        if (len <= 1) return false;\n        if (len == 2) return true; // 2 is the only even prime number\n        \n        // Check divisibility by numbers up to sqrt(len)\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Only one single digit number starting and ending with 1\n        }\n\n        long starts_with_1 = 2;\n        for (int i = 1; i < n - 1; i++) {\n            starts_with_1 *= 8; // Each additional digit can be any of the 9 digits except 0, plus an extra 1 at the start\n        }\n\n        long ends_with_1_not_starting_with_1 = 2;\n        for (int i = 1; i < n - 1; i++) {\n            ends_with_1_not_starting_with_1 *= 8; // Each additional digit can be any of the 9 digits except 0, plus an extra 1 at the end\n        }\n\n        long overlap = 2;\n        for (int i = 1; i < n - 1; i++) {\n            overlap *= 7; // Overlap occurs when both start and end with 1, so each additional digit can be any of the 8 digits except 0\n        }\n\n        return (int)(starts_with_1 + ends_with_1_not_starting_with_1 - overlap);\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        // Calculate the sum of digits of N\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2, 9))); // Expected output: 5 (since only one even number at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 7, 8, 2))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string where each word's characters are sorted alphabetically.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                \n                // Append sorted characters to the result, followed by a space\n                result.append(new String(chars));\n            }\n            \n            // Append a space after each non-empty word\n            result.append(\" \");\n        }\n\n        // Remove trailing space if present and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinate to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, it's both the first and last.\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        // Create a copy of the original list to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a given string by rotating each letter down by 4 places in the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted and remain the same.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Set<Integer> uniqueElements = new HashSet<>(lst);\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(uniqueElements);\n        Collections.sort(sortedList);\n\n        return Optional.of(sortedList.get(1));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the sentence into individual sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. Are you? I think so!\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility)\n     * @param y Second number (Object type for flexibility)\n     * @param z Third number (Object type for flexibility)\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (will be false because inputs are not all integers)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Write a function that takes a message, and encodes it in such a way that it swaps case of all letters,\n     replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the English alphabet.\n     Assume only letters.\n\n     Examples:\n     >>> encode(\"test\")\n     \"TGST\"\n     >>> encode(\"This is a message\")\n     \"tHKS KS C MGSSCGG\"\n      */\n    public String encode(String message) {\n        // Define vowels and their shifted counterparts\n        char[] vowels = {'a', 'e', 'i', 'o', 'u'};\n        Map<Character, Character> shiftedVowelsMap = new HashMap<>();\n        shiftedVowelsMap.put('a', 'c');\n        shiftedVowelsMap.put('A', 'C');\n        shiftedVowelsMap.put('e', 'g');\n        shiftedVowelsMap.put('E', 'G');\n        shiftedVowelsMap.put('i', 'k');\n        shiftedVowelsMap.put('I', 'K');\n        shiftedVowelsMap.put('o', 'q');\n        shiftedVowelsMap.put('O', 'Q');\n        shiftedVowelsMap.put('u', 'w');\n        shiftedVowelsMap.put('U', 'W');\n\n        // Build the encoded message\n        StringBuilder encodedMessage = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Shift vowels by 2 places ahead\n                if (isVowel(swappedChar, shiftedVowelsMap.keySet())) {\n                    encodedMessage.append(shiftedVowelsMap.get(swappedChar));\n                } else {\n                    encodedMessage.append(swappedChar);\n                }\n            } else {\n                // Non-letter characters are appended as is\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    private boolean isVowel(char c, Set<Character> vowels) {\n        return vowels.contains(Character.toLowerCase(c));\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\n\nclass Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        // Helper method to check if a number is prime\n        return lst.stream()\n                .filter(this::isPrime)\n                .max(Integer::compare)\n                .map(num -> sumOfDigits(num))\n                .orElse(0);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        int lowerCaseCount = 0;\n        int upperCaseCount = 0;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false; // If the key is not a string, return false\n            }\n            \n            String strKey = (String) key;\n            if (strKey.equals(strKey.toLowerCase())) {\n                lowerCaseCount++;\n            } else if (strKey.equals(strKey.toUpperCase())) {\n                upperCaseCount++;\n            }\n        }\n\n        int totalKeys = dict.size();\n        boolean allLowerCase = lowerCaseCount == totalKeys;\n        boolean allUpperCase = upperCaseCount == totalKeys;\n\n        return allLowerCase || allUpperCase;\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of their unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define a set of uppercase vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        // Initialize the count variable to zero\n        int count = 0;\n        \n        // Iterate through each character in the string using its index\n        for (int i = 0; i < s.length(); i++) {\n            // Check if the current index is even and the character at that position is an uppercase vowel\n            if (i % 2 == 0 && vowels.contains(s.charAt(i))) {\n                count++;\n            }\n        }\n        \n        // Return the final count of uppercase vowels in even indices\n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is negative or positive to determine rounding direction\n        if (num < 0) {\n            return (int)Math.ceil(num - 0.5); // Round towards more negative for negative numbers\n        } else {\n            return (int)Math.floor(num + 0.5); // Round towards more positive for non-negative numbers\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a string of words separated by commas or spaces. Your task is\n     * to split the string into words and return an array of the words.\n     *\n     * For example:\n     * words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"])\n     * words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\n     */\n    public List<String> words_string(String s) {\n        // Define the regular expression pattern to match commas and spaces\n        String regex = \"[\\\\s,]+\";\n        \n        // Split the string using the defined pattern\n        String[] wordsArray = s.split(regex);\n        \n        // Convert the array of strings into a list\n        List<String> wordsList = new ArrayList<>(Arrays.asList(wordsArray));\n        \n        return wordsList;\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number \n     * that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x <= y\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the rounded average of integers from n through m (inclusive) and returns its binary representation.\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return The binary string of the rounded average if valid, otherwise -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of numbers from n to m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute the average and round it to the nearest integer\n        double avg = (double) sum / count;\n        int roundedAvg = (int) Math.round(avg);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Helper method to check if an integer has only odd digits\n        return x.stream()\n                .filter(this::hasOnlyOddDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasOnlyOddDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // All digits are odd\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define an array of strings representing numbers from 1 to 9.\n        String[] numberNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter the input list for integers between 1 and 9 inclusive.\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted() // Sort in ascending order\n                                        .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredList);\n        \n        // Convert each integer to its corresponding name and collect into a new list.\n        List<String> result = filteredList.stream()\n                                          .map(num -> numberNames[num - 1])\n                                          .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        int originalNumber = number, reversedNumber = 0;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            number /= 10;\n        }\n\n        return originalNumber == reversedNumber;\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                        .filter(num -> sumOfDigits(num) > 0)\n                        .count();\n    }\n\n    private int sumOfDigits(int n) {\n        if (n == 0) {\n            return 0;\n        } else if (n > 0) {\n            String str = Integer.toString(n);\n            int sum = 0;\n            for (int i = 0; i < str.length(); i++) {\n                sum += Character.getNumericValue(str.charAt(i));\n            }\n            return sum;\n        } else {\n            String str = Integer.toString(-n);\n            int sum = 0;\n            for (int i = 0; i < str.length(); i++) {\n                sum += Character.getNumericValue(str.charAt(i));\n            }\n            return -sum;\n        }\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to get an array sorted in non-decreasing order by performing right shift operations.\n     *\n     * @param arr List of integers representing the array.\n     * @return true if it's possible to sort the array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, return true\n        if (arr.size() <= 1) {\n            return true;\n        }\n\n        int count = 0; // Count of rotations needed to get non-decreasing order\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element\n        if (arr.get(arr.size() - 1) > arr.get(0)) {\n            count++;\n        }\n\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.List;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCount = 0;\n        \n        // Count how many odd numbers are in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenExchangeable = 0;\n\n        // Count how many even numbers are available in lst2 for potential exchanges\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenExchangeable++;\n            }\n        }\n\n        return oddCount <= evenExchangeable ? \"YES\" : \"NO\";\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Check for empty string\n        if (test.isEmpty()) {\n            return new HashMap<>();\n        }\n\n        // Initialize a map to count occurrences of each letter\n        Map<String, Integer> letterCount = new HashMap<>();\n\n        // Split the input string into individual letters and count them\n        String[] words = test.split(\" \");\n        int maxCount = 0;\n        for (String word : words) {\n            int count = letterCount.getOrDefault(word, 0);\n            count++;\n            letterCount.put(word, count);\n            maxCount = Math.max(maxCount, count);\n        }\n\n        // Create a result map containing only the letters with the maximum frequency\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCount.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left) != resultString.charAt(right)) {\n                isPalindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> result = new ArrayList<>();\n        result.add(resultString);\n        result.add(isPalindrome);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum at each step\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.List;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalLowerings = 0;\n        \n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n            // Count the number of units of water in the current well\n            for (int unit : well) {\n                waterUnits += unit;\n            }\n            \n            // Calculate how many times the bucket needs to be lowered for this well\n            int loweringsNeeded = (waterUnits + capacity - 1) / capacity;\n            totalLowerings += loweringsNeeded;\n        }\n        \n        return totalLowerings;\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Custom comparator for sorting based on binary representation and decimal value\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                int countA = count_ones(a);\n                int countB = count_ones(b);\n                \n                if (countA != countB) {\n                    return Integer.compare(countA, countB); // Compare based on number of ones\n                } else {\n                    return Integer.compare(a, b); // Compare based on decimal value\n                }\n            }\n\n            private int count_ones(int n) {\n                int count = 0;\n                while (n != 0) {\n                    count += n & 1; // Check if the least significant bit is set\n                    n >>>= 1; // Right shift to check the next bit\n                }\n                return count;\n            }\n        });\n\n        return arr;\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a method to count consonants in a word\n        java.util.function.Function<String, Integer> countConsonants = word -> {\n            int count = 0;\n            for (char c : word.toCharArray()) {\n                if (\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\".indexOf(c) >= 0) {\n                    count++;\n                }\n            }\n            return count;\n        };\n\n        // Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Filter and collect words with exactly n consonants\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (countConsonants.apply(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!vowels.contains(leftChar) && !vowels.contains(rightChar) && vowels.contains(middleChar)) {\n                return String.valueOf(middleChar); // Found the vowel\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < lst.size(); i++) {\n            int balance = 0;\n            boolean isBalanced = true;\n\n            for (String s : lst) {\n                for (char c : s.toCharArray()) {\n                    if (c == '(') {\n                        balance++;\n                    } else {\n                        balance--;\n                    }\n                    // If at any point the balance goes negative, it's not balanced\n                    if (balance < 0) {\n                        isBalanced = false;\n                        break;\n                    }\n                }\n            }\n\n            // Swap the order of strings and check again if first attempt failed\n            if (!isBalanced && i == 0) {\n                Collections.swap(lst, 0, 1);\n                balance = 0;\n                for (String s : lst) {\n                    for (char c : s.toCharArray()) {\n                        if (c == '(') {\n                            balance++;\n                        } else {\n                            balance--;\n                        }\n                        // If at any point the balance goes negative, it's not balanced\n                        if (balance < 0) {\n                            isBalanced = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isBalanced && balance == 0) {\n                return \"Yes\";\n            }\n        }\n\n        // If no combination works, return \"No\"\n        return \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap)\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        // Add elements to the heap until it reaches size k\n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.add(num);\n            } else if (num > pq.peek()) {  // If current element is greater than the smallest in heap, replace it.\n                pq.poll();  // Remove the smallest element\n                pq.add(num);  // Add the new element\n            }\n        }\n\n        // Convert priority queue to list and sort it since we need ascending order\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Expected: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i); // Add to sum if it's an odd number in an even position\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr, k)); // Expected output is 24\n        \n        // Additional test case\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 3;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr2, k2)); // Expected output is 28\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        \n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected output: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the required date format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input string matches the regular expression\n        boolean isFormatValid = date.matches(regex);\n        \n        // If format is not valid, return false\n        if (!isFormatValid) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is between 1 and 12\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Determine the number of days in a given month\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        int maxDaysInMonth = getMaxDays(month, isLeapYear);\n\n        // Check if the day is within the valid range for the month\n        return day >= 1 && day <= maxDaysInMonth;\n    }\n\n    private int getMaxDays(int month, boolean isLeapYear) {\n        switch (month) {\n            case 2: return isLeapYear ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11: return 30;\n            default: return 31;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace and split if found\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // If no whitespaces, check for commas and split if found\n        words = txt.split(\",\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // Count lowercase letters with odd order indices in the alphabet\n        int countOddOrderLetters = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    countOddOrderLetters++;\n                }\n            }\n        }\n\n        return countOddOrderLetters;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"NoSpacesHere\")); // Should print the number of odd-order lowercase letters\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"));\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (previousNumber != null && lst.get(i) < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (i > 0 && lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = lst.get(i);\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given two intervals,\n     * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n     * The given intervals are closed which means that the interval (start, end)\n     * includes both start and end.\n     * For each given interval, it is assumed that its start is less or equal its end.\n     * Your task is to determine whether the length of intersection of these two\n     * intervals is a prime number.\n     * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n     * which its length is 1, which not a prime number.\n     * If the length of the intersection is a prime number, return \"YES\",\n     * otherwise, return \"NO\".\n     * If the two intervals don't intersect, return \"NO\".\n     *\n     * [input/output] samples:\n     * intersection((1, 2), (2, 3)) ==> \"NO\"\n     * intersection((-1, 1), (0, 4)) ==> \"NO\"\n     * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Extract start and end points of the intervals\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        // Calculate the maximum start point and minimum end point for intersection\n        int start_max = Math.max(start1, start2);\n        int end_min = Math.min(end1, end2);\n\n        // Check if there is an intersection\n        if (start_max > end_min) {\n            return \"NO\";\n        }\n\n        // Calculate the length of the intersection\n        int length = end_min - start_max + 1;\n\n        // Check if the length is a prime number\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    /**\n     * Helper function to check if a given integer n is a prime number.\n     */\n    private boolean isPrime(int n) {\n        // Check for numbers less than or equal to 1\n        if (n <= 1) {\n            return false;\n        }\n\n        // Iterate from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize the answer with a large value to ensure any path will be smaller\n        List<Integer> ans = new ArrayList<>(Collections.nCopies(k, Integer.MAX_VALUE));\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start DFS from each cell to find the minimum path\n                dfs(grid, k, new ArrayList<>(), i, j, ans);\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, List<Integer> path, int row, int col, List<Integer> ans) {\n        if (path.size() == k) {\n            // Update the answer with the lexicographically smaller path\n            if (isSmaller(path, ans)) {\n                ans.clear();\n                ans.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0], newCol = col + dir[1];\n            // Check bounds and add the next cell to the path\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid.get(0).size()) {\n                path.add(grid.get(newRow).get(newCol));\n                dfs(grid, k, path, newRow, newCol, ans);\n                // Backtrack to explore other paths\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        int size = Math.min(a.size(), b.size());\n        for (int i = 0; i < size; ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int value;\n            if (i % 2 == 0) {\n                value = 1 + (i / 2);\n            } else {\n                value = sequence.get(i - 2) + sequence.get(i - 3) + sequence.get(i);\n            }\n            sequence.add(value);\n        }\n        \n        return sequence;\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a string as input which contains only square brackets.\n     * The function should return true if and only if there is a valid subsequence of brackets\n     * where at least one bracket in the subsequence is nested.\n     *\n     * Examples:\n     * is_nested(\"[[]]\") -> true\n     * is_nested(\"[]]]]]]][[[[[]\") -> false\n     * is_nested(\"[][]\") -> false\n     * is_nested(\"[]\") -> false\n     * is_nested(\"[[][]]\") -> true\n     * is_nested(\"[[]][[\") -> true\n     */\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean hasNested = false;\n\n        for (char bracket : string.toCharArray()) {\n            if (bracket == '[') {\n                stack.push(bracket);\n            } else if (bracket == ']') {\n                // Check if there are at least two brackets in the stack\n                if (!stack.isEmpty() && !stack.peek().equals('[')) {\n                    return false;  // Invalid sequence, unmatched closing bracket\n                }\n                if (stack.size() > 1) {\n                    hasNested = true;\n                }\n                stack.pop();\n            }\n        }\n\n        // Ensure that the stack is empty and there was at least one nested bracket\n        return hasNested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilValue = Math.ceil(num);\n            // Square the rounded value and add it to the sum\n            sum += (int)Math.pow(ceilValue, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * Examples:\n     * check_if_last_char_is_a_letter(\"apple pie\") -> false\n     * check_if_last_char_is_a_letter(\"apple pi e\") -> true\n     * check_if_last_char_is_a_letter(\"apple pi e \") -> false\n     * check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n\n        // Strip trailing spaces and get the last character of the stripped string\n        String strippedTxt = txt.trim();\n        int length = strippedTxt.length();\n\n        if (length == 0) {\n            return false;\n        }\n\n        char lastChar = strippedTxt.charAt(length - 1);\n\n        // Check if the last character is an alphabetical character and it's not part of a word\n        if (Character.isLetter(lastChar)) {\n            if (length == 1 || strippedTxt.charAt(length - 2) == ' ') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i-1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object obj) {\n        if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(',', '.'); // Convert comma to dot for parsing\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        }\n\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        }\n\n        if (obj instanceof Float || obj instanceof Double) {\n            return ((Number) obj).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(compare_one(1, \"2,3\")); // Optional[2,3]\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional[6]\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers greater than or equal to 8 can be expressed this way,\n        // but we know that n - 8 must be expressible as a sum of three positive even numbers for n >= 12.\n        if (n % 2 == 0 && n >= 12) {\n            return true;\n        }\n\n        // For the edge case where n is between 8 and 11, we need to check manually:\n        int[] testCases = {8, 10};\n        for (int testCase : testCases) {\n            if (n == testCase) return true;\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long product = 1;\n        for (int j = 2; j <= number; j++) {\n            product *= j;\n        }\n        return product;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        return result.replaceAll(\" \", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));          // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));       // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));      // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));    // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex == -1 || fileName.lastIndexOf('.') != dotIndex) {\n            return \"No\";\n        }\n\n        // Split the file name into two parts: before and after the dot\n        String baseName = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        // Check if the part before the dot is valid\n        if (!isValidBase(baseName)) {\n            return \"No\";\n        }\n\n        // Check if the part after the dot is a valid extension\n        if (!isValidExtension(extension)) {\n            return \"No\";\n        }\n\n        // Count digits in the base name and ensure there are no more than three\n        int digitCount = 0;\n        for (char c : baseName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n\n    private boolean isValidBase(String baseName) {\n        // Check that the base name starts with a letter and is not empty\n        if (baseName.isEmpty() || !Character.isLetter(baseName.charAt(0))) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isValidExtension(String extension) {\n        // Valid extensions are \"txt\", \"exe\", or \"dll\"\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        for (String ext : validExtensions) {\n            if (ext.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"file1234.txt\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     *\n     * Examples:\n     * For lst = [1,2,3] the output should be 6\n     * For lst = []  the output should be 0\n     * For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sum_squares(List<Integer> lst) {\n        int totalSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                totalSum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                totalSum += Math.pow(lst.get(i), 3);\n            }\n        }\n        \n        return totalSum;\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Checks if a given number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected output: \"is\"\n\n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n and checks if it evaluates to a whole number.\n     *\n     * @param x The first fraction in string format \"<numerator>/<denominator>\".\n     * @param n The second fraction in string format \"<numerator>/<denominator>\".\n     * @return true if x * n is a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Calculate the product of the two fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number by seeing if the remainder is zero when dividing the numerator by the denominator.\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function which sorts the given list of integers\n     * in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * For example:\n     * >>> order_by_points(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points(Arrays.asList()) == []\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list to store tuples (sum of digits, original index, number)\n        List<int[]> numsWithInfo = new ArrayList<>();\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int sumOfDigits = sum_of_digits(nums.get(i));\n            numsWithInfo.add(new int[]{sumOfDigits, i, nums.get(i)});\n        }\n        \n        // Sort the list based on custom comparator\n        Collections.sort(numsWithInfo, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] a, int[] b) {\n                if (a[0] != b[0]) {\n                    return Integer.compare(a[0], b[0]);\n                } else {\n                    return Integer.compare(a[1], b[1]);\n                }\n            }\n        });\n        \n        // Extract the sorted numbers\n        List<Integer> result = new ArrayList<>();\n        for (int[] info : numsWithInfo) {\n            result.add(info[2]);\n        }\n        \n        return result;\n    }\n\n    private int sum_of_digits(int n) {\n        if (n == 0) {\n            return 0;\n        } else if (n < 0) {\n            // Handle negative numbers\n            String str = Integer.toString(n);\n            char firstChar = str.charAt(0); // Get the first character, which is '-'\n            int sumOfRestDigits = sum_of_digits(Integer.parseInt(str.substring(1))); // Parse rest of digits as integer\n            return -Character.getNumericValue(firstChar) + sumOfRestDigits; // Convert '-' to its numeric value and negate it\n        } else {\n            int lastDigit = n % 10;\n            return lastDigit + sum_of_digits(n / 10);\n        }\n    }\n\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                         .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                         .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many numbers in the array are congruent to each of 0, 1, and 2 modulo 3\n        int countMod0 = 0, countMod1 = 0, countMod2 = 0;\n\n        for (int num : a) {\n            if (num % 3 == 0) countMod0++;\n            else if (num % 3 == 1) countMod1++;\n            else countMod2++;\n        }\n\n        // Calculate the number of valid triples\n        int result = 0;\n        result += countMod0 * (countMod0 - 1) * (countMod0 - 2) / 6; // All three numbers are congruent to 0 mod 3\n        result += countMod1 * (countMod1 - 1) * (countMod1 - 2) / 6; // All three numbers are congruent to 1 mod 3\n        result += countMod2 * (countMod2 - 1) * (countMod2 - 2) / 6; // All three numbers are congruent to 2 mod 3\n        result += countMod0 * countMod1 * countMod2; // One number is congruent to each of 0, 1, and 2 mod 3\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) return Collections.emptyList();\n\n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                filteredList.add(s);\n            }\n        }\n\n        // Sort the list by length, and then alphabetically for strings of the same length\n        filteredList.sort((a, b) -> {\n            int lengthCompare = Integer.compare(a.length(), b.length());\n            if (lengthCompare != 0) {\n                return lengthCompare;\n            } else {\n                return a.compareTo(b);\n            }\n        });\n\n        return filteredList;\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));   // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * doubleTheDifference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n     * doubleTheDifference(Arrays.asList(-1, -2, 0)) == 0\n     * doubleTheDifference(Arrays.asList(9, -2)) == 81\n     * doubleTheDifference(Arrays.asList(0)) == 0\n     *\n     * If the input list is empty, return 0.\n     */\n    public int doubleTheDifference(List<Integer> lst) {\n        int sumOfSquares = 0;\n        \n        for (Integer item : lst) {\n            if (item > 0 && item % 2 != 0) {\n                sumOfSquares += Math.pow(item, 2);\n            }\n        }\n        \n        return sumOfSquares;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> list = Arrays.asList(1, 3, 2, 0); // Ensure the list is of type Integer\n        int result = solution.doubleTheDifference(list);\n        System.out.println(result);\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list to its corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class based on the provided list of extensions.\n     * The strength of an extension is calculated as CAP - SM, where CAP is the number of uppercase letters,\n     * and SM is the number of lowercase letters in the extension's name. If there are multiple extensions\n     * with the same strength, the first one in the list is chosen.\n     *\n     * @param class_name The name of the class to which the strongest extension will be attached.\n     * @param extensions A List containing names of possible extensions for the class.\n     * @return A string representing the class and its strongest extension in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        // Initialize variables to track the strongest extension\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String name) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : name.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => false\n    cycpattern_check(\"hello\",\"ell\") => true\n    cycpattern_check(\"whassup\",\"psus\") => false\n    cycpattern_check(\"abab\",\"baa\") => true\n    cycpattern_check(\"efef\",\"eeff\") => false\n    cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the first word with itself\n        String concatenated_a = a + a;\n        \n        // Check if the second word is a substring of the concatenated string\n        return concatenated_a.contains(b);\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a positive value and then to string for easy iteration\n        String strNum = Integer.toString(Math.abs(num));\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char c = strNum.charAt(i);\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not, it's odd\n                oddCount++;\n            }\n        }\n\n        // Return the counts as a list [even count, odd count]\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the method\n        System.out.println(solution.even_odd_count(-12));  // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        // Mapping of integers to Roman numerals (in lowercase)\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Update the maximum if this word has more unique characters or is lexicographically smaller\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    // Test function to verify the correctness of find_max\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1));  // Expected: string\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2));  // Expected: enam\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Determine how many carrots are left after eating.\n        int leftoverCarrots = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of eaten carrots and the number of leftover carrots.\n        return new ArrayList<>(List.of(totalEaten, leftoverCarrots));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\nclass Solution {\n    /**\n     * Given two lists operator, and operand. The first list has basic algebra operations,\n     * and the second list is a list of integers. Use the two given lists to build the\n     * algebraic expression and return the evaluation of this expression.\n     *\n     * The basic algebra operations:\n     * Addition ( + )\n     * Subtraction ( - )\n     * Multiplication ( * )\n     * Floor division ( / )\n     * Exponentiation ( ** )\n     *\n     * Example:\n     * operator = [\"+\", \"*\", \"-\"]\n     * operand = [2, 3, 4, 5]\n     * result = 2 + 3 * 4 - 5\n     * => result = 9\n     *\n     * Note:\n     * The length of operator list is equal to the length of operand list minus one.\n     * Operand is a list of non-negative integers.\n     * Operator list has at least one operator, and operand list has at least two operands.\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        for (int i = 0; i < operand.size(); i++) {\n            if (i > 0) {\n                expression.append(operator.get(i - 1));\n            }\n            expression.append(operand.get(i));\n        }\n\n        // Evaluate the expression using Java's scripting engine\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n        try {\n            return (int) engine.eval(expression.toString());\n        } catch (ScriptException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = digest.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hash);\n        String hashtext = number.toString(16);\n\n        // Add leading zeros to make sure it's 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that 'a' is the smaller value and 'b' is the larger value\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n\n        List<Integer> evenDigits = new ArrayList<>();\n\n        // Iterate through the range from start to end (inclusive)\n        for (int num = start; num <= end; num++) {\n            if (num % 2 == 0 && num < 10) {  // Check if the number is even and a single digit\n                evenDigits.add(num);\n            }\n        }\n\n        return evenDigits;\n    }\n}\n"}
