{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(result1); // Expected: false\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(result2); // Expected: true\n\n        // Additional test case\n        boolean result3 = solution.has_close_elements(Arrays.asList(-1.0, -2.9, -3.0, -4.0, -5.0, -2.8), 0.3);\n        System.out.println(result3); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Separates groups of nested parentheses into individual strings.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A list of separate, balanced groups of parentheses as strings.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : cleanString.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n\n            // Append the character to the current group\n            currentGroup.append(c);\n\n            // If we have a balanced group, add it to the result and reset the current group\n            if (balance == 0 && currentGroup.length() > 0) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Clear the StringBuilder for the next group\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> groups = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(groups);\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to verify the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"truncate_number(3.5): \" + solution.truncate_number(3.5));  // Expected: 0.5\n        System.out.println(\"truncate_number(123.456): \" + solution.truncate_number(123.456));  // Expected: 0.456\n        System.out.println(\"truncate_number(7.999): \" + solution.truncate_number(7.999));  // Expected: 0.999\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance ever goes below zero.\n     *\n     * @param operations List of Integer representing deposit (positive) and withdrawal (negative) amounts.\n     * @return true if the balance falls below zero at any point, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Starting balance is zero\n        \n        for (int operation : operations) {\n            balance += operation;\n            \n            // Check if balance goes below zero\n            if (balance < 0) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Expected output: false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation\n     * around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each\n     * element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be empty or null\");\n        }\n\n        // Calculate the mean\n        double sum = 0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        boolean firstElementAdded = false;\n\n        for (Integer num : numbers) {\n            if (!firstElementAdded) {\n                // Add the first element without a preceding delimiter\n                result.add(num);\n                firstElementAdded = true;\n            } else {\n                // Add the delimiter and then the current number\n                result.add(delimiter);\n                result.add(num);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(new ArrayList<>(), 4)); // Should print: []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Should print: [1, 4, 2, 4, 3]\n\n        // Assertions for testing\n        assert solution.intersperse(new ArrayList<>(), 4).equals(List.of());\n        assert solution.intersperse(Arrays.asList(1, 2, 3), 4).equals(List.of(1, 4, 2, 4, 3));\n\n        System.out.println(\"All tests passed!\");\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> parse_nested_parens(String paren_string) {\n        // Split the input string into individual groups based on spaces.\n        String[] groups = paren_string.split(\" \");\n        List<Integer> result = new ArrayList<>();\n\n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n\n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n\n            result.add(maxDepth);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredList = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredList.add(str);\n            }\n        }\n        return filteredList;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number; // Add each number to the sum\n            product *= number; // Multiply each number to the product\n        }\n\n        return Arrays.asList(sum, product);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> emptyListResult = solution.sum_product(new ArrayList<>());\n        System.out.println(\"Empty list result: \" + emptyListResult); // Should print [0, 1]\n        \n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        List<Integer> resultList = solution.sum_product(numbers);\n        System.out.println(\"Sum and product of the list: \" + resultList); // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers.isEmpty()) return Collections.emptyList();\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    // Test function to verify the correctness of rolling_max method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        System.out.println(solution.rolling_max(testList1)); // Expected: [1, 2, 3, 3, 3, 4, 4]\n        \n        List<Integer> testList2 = Arrays.asList(5, 4, 3, 2, 1);\n        System.out.println(solution.rolling_max(testList2)); // Expected: [5, 5, 5, 5, 5]\n        \n        List<Integer> testList3 = Arrays.asList();\n        System.out.println(solution.rolling_max(testList3)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        // If the input is empty, return an empty string\n        if (string == null || string.length() == 0) {\n            return \"\";\n        }\n        \n        int n = string.length();\n        for (int i = n; i >= 0; i--) {\n            if (isPalindrome(string.substring(0, i))) {\n                String prefix = string.substring(i);\n                // Reverse the non-palindromic part and append it to the original string\n                return new StringBuilder(prefix).reverse().append(string).toString();\n            }\n        }\n        \n        // If no palindromic suffix is found (which shouldn't happen), just reverse and append\n        return new StringBuilder(string).reverse().append(string).toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.make_palindrome(\"\"));  // Output: \"\"\n        System.out.println(solution.make_palindrome(\"cat\"));  // Output: \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\"));  // Output: \"catac\"\n\n        // Additional test cases\n        System.out.println(solution.make_palindrome(\"race\"));  // Output: \"ecarace\"\n        System.out.println(solution.make_palindrome(\"madam\"));  // Output: \"madam\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     * @param a The first string representing a binary number.\n     * @param b The second string representing a binary number.\n     * @return A string representing the result of the binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Pad the shorter string with leading zeros to match the length of the longer one\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append(\"0\");\n            } else {\n                result.append(\"1\");\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11110\"));  // Expected output: \"01011\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.longest(new ArrayList<>())); // Expected output: Optional.empty\n\n        // Test case 2: Single element\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected output: Optional[a]\n\n        // Test case 3: Multiple elements with different lengths\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected output: Optional[ccc]\n\n        // Test case 4: Multiple elements with the same length (should return the first one)\n        System.out.println(solution.longest(Arrays.asList(\"abc\", \"def\", \"ghi\"))); // Expected output: Optional[abc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test method to verify the correctness of the GCD function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.greatest_common_divisor(3, 5));   // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(100, 75)); // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method to verify the correctness of the all_prefixes function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> expectedOutput = Arrays.asList(\"a\", \"ab\", \"abc\");\n        List<String> actualOutput = solution.all_prefixes(\"abc\");\n\n        System.out.println(\"Expected Output: [\" + String.join(\", \", expectedOutput) + \"]\");\n        System.out.println(\"Actual Output:   [\" + String.join(\", \", actualOutput) + \"]\");\n        \n        // Check if the output matches the expected result\n        boolean isCorrect = expectedOutput.equals(actualOutput);\n        System.out.println(\"Is Correct? \" + isCorrect);\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected: \"0 1 2 3 4 5\"\n        System.out.println(solution.string_sequence(-1)); // Edge case, expected: \"\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ensure case-insensitivity\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a Set to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        // Iterate through each character in the string and add it to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters\n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"Hello, World!\")); // Expected output: 10\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format and returns a list of integers.\n     *\n     * Legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quater note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> durations = new ArrayList<>();\n        \n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    durations.add(4);\n                    break;\n                case \"o|\":\n                    durations.add(2);\n                    break;\n                case \".|\":\n                    durations.add(1);\n                    break;\n                default:\n                    // Handle unexpected input if necessary\n                    System.out.println(\"Unexpected note: \" + note);\n            }\n        }\n\n        return durations;\n    }\n}\n\n// Test class to verify the correctness of Solution.parse_music method.\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        String input = \"o o| .| o| o| .| .| .| .| o o\";\n        List<Integer> expectedOutput = Arrays.asList(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4);\n        \n        // Call the parse_music method\n        List<Integer> actualOutput = solution.parse_music(input);\n\n        // Verify the output matches expected result\n        if (expectedOutput.equals(actualOutput)) {\n            System.out.println(\"Test passed: Output matches expected.\");\n        } else {\n            System.out.println(\"Test failed: Expected \" + expectedOutput + \", but got \" + actualOutput);\n        }\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            // Check if the current position in 'string' matches 'substring'\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each word to its corresponding integer value\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Split the input string into an array of words\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its corresponding integer value and sort them\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numberMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back to their word representations\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            for (String key : numberMap.keySet()) {\n                if (numberMap.get(key).equals(num)) {\n                    result.append(key);\n                    break;\n                }\n            }\n            if (result.length() > 0 && i < words.length - 1) {\n                result.append(\" \");\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testInput = \"three one five\";\n        System.out.println(solution.sort_numbers(testInput)); // Expected output: \"one three five\"\n\n        testInput = \"nine eight zero\";\n        System.out.println(solution.sort_numbers(testInput)); // Expected output: \"zero eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each other.\n     * The returned elements should be in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (Double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Double> testList = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        List<Double> scaledList = solution.rescale_to_unit(testList);\n\n        System.out.println(\"Original list: \" + testList);\n        System.out.println(\"Scaled list: \" + scaledList);\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> list1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(list1)); // Expected: [5]\n\n        List<Object> list2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(list2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    // Test code starts here\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty string\n        String testString1 = \"\";\n        System.out.println(\"strlen(\\\"\" + testString1 + \"\\\") = \" + solution.strlen(testString1)); // Expected output: 0\n\n        // Test case 2: Non-empty string with multiple characters\n        String testString2 = \"abc\";\n        System.out.println(\"strlen(\\\"\" + testString2 + \"\\\") = \" + solution.strlen(testString2)); // Expected output: 3\n\n        // Additional test cases can be added here for further verification\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     * >>> largest_divisor(15)\n     * 5\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, which should not happen as 1 always divides any number.\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> primeFactors = new ArrayList<>();\n        \n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            primeFactors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                primeFactors.add(i);\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2) {\n            primeFactors.add(n);\n        }\n\n        return primeFactors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.factorize(8);\n        System.out.println(result1); // Expected: [2, 2, 2]\n        \n        List<Integer> result2 = solution.factorize(25);\n        System.out.println(result2); // Expected: [5, 5]\n        \n        List<Integer> result3 = solution.factorize(70);\n        System.out.println(result3); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Count occurrences of each number\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (Integer num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Filter out elements that occur more than once and preserve order\n        return numbers.stream()\n                .filter(num -> countMap.get(num) == 1)\n                .collect(Collectors.toList());\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(testList)); // Expected: [1, 3, 4]\n        \n        List<Integer> anotherTestList = Arrays.asList(5, 6, 7, 8, 9, 5);\n        System.out.println(solution.remove_duplicates(anotherTestList)); // Expected: [6, 7, 8, 9]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n\n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     * >>> concatenate(List.of())\n     * \"\"\n     * >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n     * \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder result = new StringBuilder();\n        for (String str : strings) {\n            result.append(str);\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(\"Test Case 1 (Empty List): \" + solution.concatenate(emptyList));\n\n        // Test case 2: Non-empty list with multiple elements\n        List<String> nonEmptyList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Test Case 2 (Non-Empty List): \" + solution.concatenate(nonEmptyList));\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings starting with the prefix\n        List<String> stringList = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(stringList, \"a\")); // Should print [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(x -> x > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "class Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n        \n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of is_prime method\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class TestSolution {\n    private Solution solution = new Solution();\n\n    @Test\n    public void testPoly() {\n        // Test case 1: f(x) = 1 + 2x\n        List<Double> coefficients1 = Arrays.asList(1.0, 2.0);\n        assertEquals(-0.5, solution.poly(coefficients1, -0.5), 1e-6);\n\n        // Test case 2: f(x) = 3 + 4x - x^2\n        List<Double> coefficients2 = Arrays.asList(3.0, 4.0, -1.0);\n        assertEquals(-1.0, solution.poly(coefficients2, -1.0), 1e-6);\n\n        // Test case 3: f(x) = 5 + 6x\n        List<Double> coefficients3 = Arrays.asList(5.0, 6.0);\n        assertEquals(-0.8333333333333334, solution.poly(coefficients3, -0.8333333333333334), 1e-6);\n\n        // Add more test cases as needed\n    }\n\n    @Test\n    public void testFindZero() {\n        // Test case 1: f(x) = 1 + 2x\n        List<Double> coefficients1 = Arrays.asList(1.0, 2.0);\n        assertEquals(-0.5, solution.find_zero(coefficients1), 1e-6);\n\n        // Test case 2: (x - 1)(x - 2)(x - 3) = -6 + 11x - 6x^2 + x^3\n        List<Double> coefficients2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        assertEquals(1.0, solution.find_zero(coefficients2), 1e-6);\n\n        // Test case 3: f(x) = x^4 + 5x^3 + 6x^2\n        List<Double> coefficients3 = Arrays.asList(0.0, 0.0, 6.0, 5.0, 1.0);\n        assertEquals(-3.0, solution.find_zero(coefficients3), 1e-6);\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n     * to the values of the corresponding indicies of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> indicesToSort = new ArrayList<>();\n        \n        // Collect elements at indices divisible by 3\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering 1-based index\n                indicesToSort.add(l.get(i));\n            }\n        }\n\n        // Sort the collected elements\n        Collections.sort(indicesToSort);\n\n        // Place sorted elements back at their original positions\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering 1-based index\n                result.set(i, indicesToSort.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(list1)); // Expected: [1, 2, 3]\n\n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(list2)); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and remove duplicates\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back into a list\n        List<Integer> result = new ArrayList<>(set);\n\n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0);\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n        \n        // Test case with an empty list\n        List<Integer> listEmpty = new ArrayList<>();\n        try {\n            System.out.println(solution.max_element(listEmpty));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected output: List must not be empty or null\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) { // Count occurrences of '7'\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list for storing elements at even indices\n        List<Integer> evenIndices = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the list\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndices.add(l.get(i));\n        }\n        \n        // Sort the extracted elements\n        Collections.sort(evenIndices);\n        \n        // Create a new list to store the result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values\n        int index = 0;\n        for (int i = 1; i < l.size(); i += 2) {\n            sortedList.set(i, evenIndices.get(index++));\n        }\n        \n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected output: [1, 2, 3]\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected output: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestSolution {\n    private Solution solution = new Solution();\n\n    @Test\n    public void testEncodeDecode() {\n        String input1 = \"abc\";\n        String encoded1 = solution.encodeCyclic(input1);\n        String decoded1 = solution.decode_cyclic(encoded1);\n        assertEquals(\"Original: \" + input1, input1, decoded1);\n\n        String input2 = \"abcd\";\n        String encoded2 = solution.encodeCyclic(input2);\n        String decoded2 = solution.decode_cyclic(encoded2);\n        assertEquals(\"Original: \" + input2, input2.substring(0, 3), decoded2.substring(0, 3));\n        // The last character remains unchanged as there's only one character left in the group.\n\n        String input3 = \"abcdefg\";\n        String encoded3 = solution.encodeCyclic(input3);\n        String decoded3 = solution.decode_cyclic(encoded3);\n        assertEquals(\"Original: \" + input3, input3, decoded3);\n\n        // Add more test cases as needed\n    }\n\n    @Test\n    public void testDecode() {\n        String encoded1 = \"bca\";\n        String decoded1 = solution.decode_cyclic(encoded1);\n        assertEquals(\"Decoded from bca\", \"abc\", decoded1);\n\n        String encoded2 = \"bcd\";\n        String decoded2 = solution.decode_cyclic(encoded2);\n        assertEquals(\"Decoded from bcd\", \"bcd\", decoded2); // Only one character is not cycled\n\n        String encoded3 = \"defg\"; // This should be the result of encoding \"cde\"\n        String decoded3 = solution.decode_cyclic(encoded3);\n        assertEquals(\"Decoded from defg\", \"cde\", decoded3);\n\n        // Add more test cases as needed\n    }\n\n    public static void main(String[] args) {\n        TestSolution testSolution = new TestSolution();\n        testSolution.testEncodeDecode();\n        testSolution.testDecode();\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is a Fibonacci number and it's also prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int count = 0;\n        long fib1 = 0, fib2 = 1;\n\n        while (count < n) {\n            if (isPrime(fib2)) {\n                primes.add((int)fib2);\n                count++;\n            }\n            // Generate next Fibonacci number\n            long temp = fib2;\n            fib2 += fib1;\n            fib1 = temp;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(long num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (long i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_fib(1)); // Output: 2\n        System.out.println(solution.prime_fib(2)); // Output: 3\n        System.out.println(solution.prime_fib(3)); // Output: 5\n        System.out.println(solution.prime_fib(4)); // Output: 13\n        System.out.println(solution.prime_fib(5)); // Output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other.\n     *\n     * @param n The number of cars in each set (one moving left to right, and one moving right to left).\n     * @return The total number of collisions that will occur.\n     */\n    public int car_race_collision(int n) {\n        return n * n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test cases to verify the correctness of the incr_list method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(testList1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(testList2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            int complement = -num;\n            if (seen.contains(complement)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n\n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side and height, return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double a, double h) {\n        // Area formula: (base * height) / 2\n        return (a * h) / 2;\n    }\n\n    /**\n     * Test function for the triangle_area method.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Test Case 1: \" + (area1 == 7.5 ? \"Pass\" : \"Fail\"));\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Test Case 2: \" + (area2 == 20.0 ? \"Pass\" : \"Fail\"));\n        \n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the n-th element of the fib4 number sequence.\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1 || n == 3)\n            return 0;\n        \n        // Base cases for fib4(2), fib4(3), fib4(4)\n        int[] dp = {0, 0, 2, 0};\n        \n        // Compute the sequence iteratively\n        for (int i = 4; i <= n; i++) {\n            int nextValue = dp[0] + dp[1] + dp[2] + dp[3];\n            // Shift values to the left and add the new value at the end\n            dp[0] = dp[1];\n            dp[1] = dp[2];\n            dp[2] = dp[3];\n            dp[3] = nextValue;\n        }\n        \n        return dp[3];  // The last computed value is in dp[3]\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5));  // Expected output: 4\n        System.out.println(solution.fib4(6));  // Expected output: 8\n        System.out.println(solution.fib4(7));  // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l); // Sort the list\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return middle element\n            return l.get(size / 2);\n        } else { // If even, return average of two middle elements\n            return (l.get((size - 1) / 2) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.median(Arrays.asList(3, 1, 2, 4, 5))); // Expected: 3\n        System.out.println(solution.median(Arrays.asList(-10, 4, 6, 1000, 10, 20))); // Expected: 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_palindrome(\"\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "class Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If the current power is odd\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns an encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char base = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - base;\n                sb.append((char) ((base + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input a string encoded with the encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char base = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - base;\n                sb.append((char) ((base + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String originalString = \"Hello, World!\";\n        String encodedString = solution.encodeShift(originalString);\n        System.out.println(\"Encoded: \" + encodedString);\n\n        String decodedString = solution.decode_shift(encodedString);\n        System.out.println(\"Decoded: \" + decodedString);\n\n        // Check if the decoded string matches the original\n        assert originalString.equals(decodedString) : \"The decoding did not match the original string.\";\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return \"\";\n\n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        char lowerCaseChar = Character.toLowerCase(c);\n        return \"aeiou\".indexOf(lowerCaseChar) != -1;\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        boolean result1 = solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100);\n        System.out.println(result1); // Expected output: true\n\n        boolean result2 = solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5);\n        System.out.println(result2); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     * >>> add(2, 3)\n     * 5\n     * >>> add(5, 7)\n     * 12\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    // Test method to check the correctness of the 'add' function.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Adding two positive integers\n        System.out.println(\"Test Case 1 - Expected Output: 5\");\n        int result1 = solution.add(2, 3);\n        System.out.println(\"Result: \" + result1);\n\n        // Test case 2: Adding a larger number to a smaller one\n        System.out.println(\"\\nTest Case 2 - Expected Output: 12\");\n        int result2 = solution.add(5, 7);\n        System.out.println(\"Result: \" + result2);\n\n        // Additional test cases can be added here for thorough testing.\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from both strings\n        Set<Character> charsSet = new HashSet<>();\n        \n        // Add all characters from the first string to the set\n        for (char c : s0.toCharArray()) {\n            charsSet.add(c);\n        }\n        \n        // Check if all characters in the second string are present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charsSet.contains(c)) {\n                return false;\n            }\n        }\n        \n        // If we reach here, it means both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n;\n        \n        int a = 0, b = 1;\n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib(10));  // Expected output: 55\n        System.out.println(solution.fib(1));   // Expected output: 1\n        System.out.println(solution.fib(8));   // Expected output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket '<' has a corresponding closing bracket '>'.\n     *\n     * @param brackets A string consisting only of '<' and '>' characters.\n     * @return true if the string is correctly bracketed, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // Keeps track of the balance between opening and closing brackets.\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n                \n                // If at any point the number of closing brackets exceeds opening ones, return false.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n\n        // The string is correctly bracketed only if there are no unmatched opening or closing brackets.\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.correct_bracketing(\"<\"));       // false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.isEmpty() || l.size() == 1) return true;\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing.\n            if (increasing && decreasing) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (intersection)\n        set1.retainAll(set2);\n\n        // Convert the resulting set back to a list and sort it\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1_1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2_1 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(solution.common(l1_1, l2_1)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l1_2 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l2_2 = Arrays.asList(3, 2);\n        System.out.println(solution.common(l1_2, l2_2)); // Expected: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n        \n        // Divide out all factors of 2\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "class Solution {\n    /**\n     * Calculates the sum of all integers from 1 to n.\n     *\n     * @param n The upper limit integer (inclusive).\n     * @return The sum of numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    /**\n     * Test method for the sum_to_n function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(solution.sum_to_n(5));   // Expected output: 15\n        System.out.println(solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(solution.sum_to_n(1));   // Expected output: 1\n\n        // Additional test cases\n        System.out.println(solution.sum_to_n(0));   // Expected output: 0 (edge case)\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n                \n                // If at any point the balance is negative, it means there's a closing bracket without an opening one\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // At the end, if balance is zero, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The result list will have one less element than the input list, except for a constant polynomial (degree 0)\n        if (xs.size() <= 1) return Collections.emptyList();\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected output: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected output: [2, 6]\n\n        // Additional test cases can be added here for further verification.\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        \n        // Compute the n-th element iteratively to avoid recursion overhead and improve efficiency.\n        for (int i = 3; i <= n; i++) {\n            int next = a + b + c;\n            a = b;\n            b = c;\n            c = next;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) >= 0) {\n                count++;\n            } else if (c == 'y' && i == lowerCaseS.length() - 1) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to easily manipulate its digits\n        String numStr = Integer.toString(x);\n        \n        // Calculate effective shift considering the length of the number\n        int len = numStr.length();\n        if (shift >= len) {\n            // If shift is greater than or equal to the length, reverse the digits\n            return new StringBuilder(numStr).reverse().toString();\n        } else {\n            // Perform circular right shift by shifting characters in the string\n            String shiftedPart = numStr.substring(len - shift);\n            String remainingPart = numStr.substring(0, len - shift);\n            return shiftedPart + remainingPart;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the implementation\n        System.out.println(solution.circular_shift(12, 1)); // Expected output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected output: \"12\"\n        System.out.println(solution.circular_shift(12345, 3)); // Expected output: \"34512\"\n        System.out.println(solution.circular_shift(12345, 6)); // Expected output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only'\n     * ASCII codes.\n     *\n     * Examples:\n     *     digitSum(\"\") => 0\n     *     digitSum(\"abAB\") => 131\n     *     digitSum(\"abcCd\") => 67\n     *     digitSum(\"helloE\") => 69\n     *     digitSum(\"woArBld\") => 131\n     *     digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit. This basket contains apples, oranges,\n     * and mango fruits. Given the string that represents the total number of oranges and apples\n     * and an integer that represent the total number of the fruits in the basket return the number\n     * of the mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string using regular expressions\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // Found a new even number or an equal but earlier one\n                smallestEvenValue = value;\n                index = i;\n            }\n        }\n\n        if (index != -1) {\n            return Arrays.asList(smallestEvenValue, index);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     */\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each element\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        // Iterate through the list to find the greatest integer that meets the criteria\n        for (int num : lst) {\n            if (frequencyMap.get(num) >= num && num > result) {\n                result = num;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Create a copy of the original list to avoid modifying it\n        List<Integer> sortedList = new ArrayList<>(lst);\n        Collections.sort(sortedList); // Sort the list in ascending order\n\n        List<Integer> result = new ArrayList<>();\n        int left = 0;\n        int right = sortedList.size() - 1;\n\n        while (left <= right) {\n            if (left == right) {\n                result.add(sortedList.get(left));\n            } else {\n                result.add(sortedList.get(left++)); // Add the minimum\n                result.add(sortedList.get(right--)); // Add the maximum\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle.\n     * Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Round the result to two decimal points and return it\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if an object will fly.\n     *\n     * @param q A list of integers representing the object.\n     * @param w The maximum possible weight for the object to fly.\n     * @return true if the object is balanced and its total weight <= w, false otherwise.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        boolean isBalanced = isPalindromic(q);\n        \n        // Calculate the sum of elements in the list\n        int totalWeight = 0;\n        for (int weight : q) {\n            totalWeight += weight;\n        }\n        \n        // Determine if it will fly based on conditions\n        return isBalanced && totalWeight <= w;\n    }\n\n    /**\n     * Helper method to check if a list is palindromic.\n     *\n     * @param list The list of integers to be checked.\n     * @return true if the list is palindromic, false otherwise.\n     */\n    private boolean isPalindromic(List<Integer> list) {\n        int left = 0;\n        int right = list.size() - 1;\n        \n        while (left < right) {\n            if (!list.get(left).equals(list.get(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // Expected: true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards.\n     * In one change, you can change one element to any other element.\n     *\n     * @param arr List<Integer> representing the input array of integers.\n     * @return int The minimum number of changes needed to make the array palindromic.\n     */\n    public int smallest_change(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) return 0;\n\n        int left = 0;\n        int right = arr.size() - 1;\n        int changeCount = 0;\n\n        while (left < right) {\n            // If elements at positions 'left' and 'right' are not the same, a change is needed.\n            if (!arr.get(left).equals(arr.get(right))) {\n                changeCount++;\n            }\n            left++;\n            right--;\n        }\n\n        return changeCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Expected output: 0\n        System.out.println(solution.smallest_change(Arrays.asList()));                       // Expected output: 0\n        System.out.println(solution.smallest_change(Arrays.asList(5)));                      // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(\"hello\", \"world\"), Arrays.asList(\"java\", \"python\"))); // [\"hello\", \"world\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a)\n                        return true;\n                    \n                    if (p1 * p2 * p3 > a)\n                        break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int max) {\n        boolean[] isPrime = new boolean[max + 1];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i * i <= max; i++) {\n            if (!isPrime[i]) continue;\n            \n            for (int j = i * i; j <= max; j += i) {\n                isPrime[j] = false;\n            }\n        }\n\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < isPrime.length; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // Special case: any number to the power of 0 is 1\n        if (x == 1 && n > 1) return true;\n        \n        // If n is 1, then only 1 can be a simple power of 1.\n        if (n == 1) return x == 1;\n\n        double logResult = Math.log(x) / Math.log(n);\n        int roundedLogResult = (int)logResult;\n        \n        // Check if the result of the logarithm is an integer\n        return logResult == roundedLogResult && Math.pow(n, roundedLogResult) == x;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube.\n     *\n     * @param a The integer to check.\n     * @return true if a is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        // Handle special cases\n        if (a == 0 || a == 1) return true;\n\n        int absA = Math.abs(a);\n        double cubeRoot = Math.cbrt(absA);\n\n        // Check if the cube root is an integer by comparing it to its rounded value.\n        long roundedCubeRoot = Math.round(cubeRoot);\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    /**\n     * Counts the number of prime hexadecimal digits.\n     *\n     * @param num A string representation of a hexadecimal number.\n     * @return The count of prime hexadecimal digits.\n     */\n    public int hex_key(String num) {\n        // Define a set containing all prime hexadecimal digits as characters\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize the counter for prime digits\n        int count = 0;\n        \n        // Iterate through each character in the input string\n        for (char c : num.toCharArray()) {\n            // If the current character is a prime digit, increment the counter\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string starts and ends with 'db'.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format of the input, enclosed in 'db' at both ends.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to binary\n        StringBuilder binary = new StringBuilder();\n        \n        while (decimal > 0) {\n            int remainder = decimal % 2;\n            binary.insert(0, remainder);\n            decimal /= 2;\n        }\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary.toString() + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is happy.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (first == second || second == third || first == third) return false;\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of numerical GPAs to their corresponding letter grades.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\"); // This case should never happen as GPA is non-negative\n            }\n        }\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = solution.numerical_letter_grade(grades);\n        System.out.println(result); // Expected output: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string Input string to be checked.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    /**\n     * Checks if a given number is a prime number.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        // Total number of n-digit numbers is 9 * 10^(n-1)\n        long totalNumbers = 9 * (long)Math.pow(10, n - 1);\n\n        // Numbers starting with 1: There are 10^(n-1) such numbers\n        long startsWithOne = (long)Math.pow(10, n - 1);\n\n        // Numbers ending with 1: There are also 10^(n-1) such numbers\n        long endsWithOne = (long)Math.pow(10, n - 1);\n\n        // Overlap case: Numbers that both start and end with 1. \n        // For a number to start and end with 1, the middle part can be anything.\n        // If n > 1, there are 9 * 10^(n-2) such numbers (since first digit is fixed as 1,\n        // last digit is also fixed as 1, and remaining digits have 10 choices each).\n        long overlap = (long)Math.pow(10, n - 2);\n        if (n == 1) {\n            overlap = 1; // Only one number when n=1\n        }\n\n        // Total count of numbers that start or end with 1 is the sum of startsWithOne and endsWithOne minus overlap.\n        long result = startsWithOne + endsWithOne - overlap;\n\n        return (int)(result % 1000000007); // Return modulo 10^9+7 to prevent overflow\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 18 (numbers are 10, 11, ..., 19 and 21, 31, ..., 91)\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example:\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * @param N integer\n     *          Constraints: 0 <= N <= 10000.\n     * @return a string of binary number\n     */\n    public String solve(int N) {\n        // Convert the integer to its digit components and sum them up\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to the sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum into a binary string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *     add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        // Iterate through the list starting from index 1 (second element), stepping by 2 to get odd indices.\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current odd index is even\n                sum += lst.get(i); // Add it to the sum\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Even elements at odd indices are [2] (index 1)\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        \n        // Test case 2: No even elements at odd indices\n        System.out.println(solution.add(Arrays.asList(5, 3, 8, 9, 10))); // Expected output: 0\n        \n        // Test case 3: Multiple even elements at odd indices are [6] (index 3)\n        System.out.println(solution.add(Arrays.asList(2, 4, 6, 6, 8))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) return s;\n\n        StringBuilder result = new StringBuilder();\n        int start = 0;\n        for (int i = 0; i <= s.length(); i++) {\n            char c = i < s.length() ? s.charAt(i) : ' ';\n            if (c == ' ') {\n                String word = s.substring(start, i);\n                result.append(sortWord(word));\n                start = i + 1;\n            } else if (i == s.length()) {\n                String word = s.substring(start, i);\n                result.append(sortWord(word));\n            }\n        }\n\n        return result.toString();\n    }\n\n    private String sortWord(String word) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Should print \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Should print \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Should print \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    // Add the coordinate to the list\n                    List<Integer> coord = new ArrayList<>();\n                    coord.add(i);\n                    coord.add(j);\n                    result.add(coord);\n                }\n            }\n        }\n\n        // Sort by row in ascending order, then by column in descending order\n        Collections.sort(result, (a, b) -> {\n            if (!a.get(0).equals(b.get(0))) {\n                return a.get(0) - b.get(0);  // Ascending order for rows\n            } else {\n                return b.get(1) - a.get(1);  // Descending order for columns\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> test1 = Arrays.asList(\n            Arrays.asList(1,2,3,4,5,6),\n            Arrays.asList(1,2,3,4,1,6),\n            Arrays.asList(1,2,3,4,5,1)\n        );\n        System.out.println(solution.get_row(test1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> test2 = new ArrayList<>();\n        System.out.println(solution.get_row(test2, 1)); // Expected: []\n\n        List<List<Integer>> test3 = Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(test3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty input\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, just return a copy of it.\n        if (array.size() == 1) {\n            List<Integer> result = new ArrayList<>();\n            result.add(first);\n            return result;\n        }\n\n        // Get the last element\n        last = array.get(array.size() - 1);\n\n        // Determine sorting order based on sum of first and last elements\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        List<Integer> sortedList = new ArrayList<>(array); // Make a copy to avoid modifying the original list\n\n        if (isOddSum) {\n            Collections.sort(sortedList);\n        } else {\n            Collections.sort(sortedList, Collections.reverseOrder());\n        }\n\n        return sortedList;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a string by rotating each letter down in the alphabet by 4 places.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * A simple test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\")); // Expected: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\")); // Expected: \"kj\"\n        System.out.println(solution.encrypt(\"et\")); // Expected: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates by converting to a set and then back to a sorted list.\n        List<Integer> uniqueSorted = new ArrayList<>(new TreeSet<>(lst));\n        \n        // Check if there are at least 2 distinct elements in the list\n        if (uniqueSorted.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Return the second element from the sorted unique list\n        return Optional.of(uniqueSorted.get(1));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));              // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));          // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a given string.\n     * A boredom is defined as a sentence that starts with \"I\".\n     */\n    public int is_bored(String S) {\n        // Split the input string into sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().toLowerCase().startsWith(\"i \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\"));  // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. But tomorrow, I might not be.\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if one number is the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes a message by swapping case of all letters, replacing vowels with the letter that appears 2 places ahead.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                char replacedVowel = replaceVowel(swappedCaseChar);\n                encodedMessage.append(replacedVowel);\n            } else {\n                encodedMessage.append(c); // Non-letter characters are appended as is.\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    private char replaceVowel(char c) {\n        String vowels = \"aeiouAEIOU\";\n        String shiftedVowels = \"cgikmoCGIKMO\"; // Vowels shifted by 2 places\n        int index = vowels.indexOf(c);\n        \n        if (index != -1) {\n            return shiftedVowels.charAt(index);\n        } else {\n            return c; // Non-vowel characters are returned as is.\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.encode(\"test\")); // Expected output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Expected output: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!!!\")); // Expected output: \"jGNNQ yQRLD!!!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime number in a list and returns the sum of its digits.\n     */\n    public int sumOfLargestPrimeDigits(List<Integer> lst) {\n        // Helper method to check if a number is prime\n        return lst.stream()\n                .filter(this::isPrime)\n                .max(Integer::compare)\n                .map(this::sumDigits)\n                .orElse(0);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    private int sumDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Integer> lst1 = Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst1)); // Should print 10\n        \n        List<Integer> lst2 = Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst2)); // Should print 25\n        \n        List<Integer> lst3 = Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst3)); // Should print 13\n        \n        List<Integer> lst4 = Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst4)); // Should print 11\n        \n        List<Integer> lst5 = Arrays.asList(0,81,12,3,1,21);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst5)); // Should print 3\n        \n        List<Integer> lst6 = Arrays.asList(0,8,1,2,1,7);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst6)); // Should print 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case,\n     * else return False. The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false; // If any key is not a string, return false.\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        // If the dictionary is not empty and all keys are either lower or upper case, return true.\n        return (allLowerCase || allUpperCase);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n        System.out.println(solution.check_dict_case(new HashMap<>())); // False\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));   // Expected: [2,3]\n        System.out.println(solution.count_up_to(11));  // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0));   // Expected: []\n        System.out.println(solution.count_up_to(20));  // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1));   // Expected: []\n        System.out.println(solution.count_up_to(18));  // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers by taking modulo 10\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define a set of uppercase vowels for easy lookup\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        // Iterate through the string, checking only even indices (0-based)\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            if (vowels.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero. For example closest_integer(\"14.5\") should\n     * return 15 and closest_integer(\"-14.5\") should return -15.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is positive or negative for rounding away from zero\n        if (num > 0) {\n            return (int)(Math.floor(num + 0.5));\n        } else {\n            return (int)(Math.ceil(num - 0.5));\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));     // Expected output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));   // Expected output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));  // Expected output: -15\n        System.out.println(solution.closest_integer(\"29.6\"));   // Expected output: 30\n        System.out.println(solution.closest_integer(\"-29.6\"));  // Expected output: -30\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected output: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a string of words separated by commas or spaces into an array of words.\n     *\n     * @param s The input string to be split.\n     * @return A List containing each word from the input string as elements.\n     */\n    public List<String> words_string(String s) {\n        // Split the string using regex that matches both commas and spaces\n        String[] parts = s.split(\"[,\\\\s]+\");\n        \n        // Convert array to list for easier handling of results\n        return Arrays.asList(parts);\n    }\n\n    /**\n     * A simple test method to check if words_string works as expected.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1); // Expected: [Hi, my, name, is, John]\n\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2); // Expected: [One, two, three, four, five, six]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If x is greater than y, swap them to ensure x <= y\n        if (x > y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        // Check for the largest even number in the range [x, y]\n        if (y % 2 == 0) { // If y is even, return it as it's the largest even number\n            return y;\n        } else if ((y - 1 >= x) && ((y - 1) % 2 == 0)) { // Check if y-1 is in range and even\n            return y - 1;\n        }\n        \n        // If no even number exists in the range, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 7));   // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the average of integers from n through m (inclusive),\n     * rounds it to the nearest integer, and converts that integer to binary.\n     *\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return A string representing the binary form of the rounded average,\n     *         or -1 if n > m.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of integers from n to m\n        long totalSum = 0;\n        for (int i = n; i <= m; i++) {\n            totalSum += i;\n        }\n        int count = m - n + 1;\n\n        // Calculate the average, round it, and convert to binary\n        double avg = (double) totalSum / count;\n        long roundedAvg = Math.round(avg);\n        \n        return Long.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.rounded_avg(1, 5)); // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5)); // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Filter the numbers to keep only those without even digits\n        List<Integer> filteredList = new ArrayList<>();\n        for (Integer num : x) {\n            if (!hasEvenDigit(num)) {\n                filteredList.add(num);\n            }\n        }\n\n        // Sort the list in increasing order\n        Collections.sort(filteredList);\n\n        return filteredList;\n    }\n\n    /**\n     * Helper method to check if a number contains any even digit.\n     */\n    private boolean hasEvenDigit(int num) {\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) { // Check if it's an even digit\n                return true;\n            }\n            num /= 10; // Remove the last digit\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(list1)); // Expected: [1, 15, 33]\n\n        List<Integer> list2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(list2)); // Expected: []\n\n        List<Integer> list3 = Arrays.asList(19, 77, 83, 25);\n        System.out.println(solution.unique_digits(list3)); // Expected: [19, 77]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Define a mapping of numbers to their word representations.\n        String[] numberWords = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n        // Filter and sort the array, then reverse it\n        List<Integer> filteredSortedReversedList = arr.stream()\n                .filter(num -> num >= 1 && num <= 9)  // Keep only numbers between 1 and 9.\n                .sorted()                             // Sort in ascending order.\n                .collect(Collectors.toList());        // Collect to a list.\n\n        Collections.reverse(filteredSortedReversedList);  // Reverse the sorted list.\n\n        // Convert each number to its corresponding word representation\n        List<String> result = new ArrayList<>();\n        for (Integer num : filteredSortedReversedList) {\n            result.add(numberWords[num]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0, right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Expected output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Expected output: [4, 6]\n\n        List<Integer> result;\n        for (int i = 0; i < args.length; i++) {\n            int n = Integer.parseInt(args[i]);\n            result = solution.even_odd_palindrome(n);\n            System.out.println(result);\n        }\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && num >= 0) { // Change sign for the first negative digit\n                digit *= -1;\n                isNegative = false; // Only change once\n            }\n            sum += digit;\n            num /= 10;\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if an array can be sorted in non-decreasing order by performing right shift operations.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty, return true as per problem statement\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int N = arr.size();\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr);\n\n        for (int i = 0; i < N; i++) {\n            // Check if the current rotation of arr matches with the sorted array\n            boolean isSorted = true;\n            for (int j = 0; j < N - 1; j++) {\n                if (!arr.get((i + j) % N).equals(sortedArr.get(j))) {\n                    isSorted = false;\n                    break;\n                }\n            }\n\n            // If the current rotation matches, return true\n            if (isSorted) {\n                return true;\n            }\n        }\n\n        // If no matching rotation found, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n        System.out.println(solution.move_one_ball(new ArrayList<>()));             // Expected: true\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count odd numbers in lst1 and even numbers in lst2.\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // If there are more odd numbers in lst1 than even numbers in lst2, it's impossible to make all elements of lst1 even.\n        return oddCountInLst1 <= evenCountInLst2 ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5), Arrays.asList(2, 4, 6))); // YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5), Arrays.asList(1, 3, 5))); // NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters,\n     * return a dictionary of the letter(s) with the most repetition along with their corresponding counts.\n     * If several letters have the same maximum occurrence, include all such letters in the result.\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into an array of words\n        String[] words = test.split(\" \");\n        \n        // Create a map to store letter counts\n        Map<String, Integer> countMap = new HashMap<>();\n        \n        // Count occurrences of each letter\n        for (String word : words) {\n            if (!word.isEmpty()) {  // Ensure the word is not an empty string\n                countMap.put(word, countMap.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Find the maximum occurrence value\n        int maxCount = Collections.max(countMap.values());\n        \n        // Create a result map to store letters with the highest occurrences\n        Map<String, Integer> resultMap = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                resultMap.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return resultMap;\n    }\n\n    // Test code to verify the correctness of the histogram method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set to store characters from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = checkPalindrome(resultString);\n\n        // Return the result as a list containing the filtered string and the palindrome status\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n        \n        return resultList;\n    }\n\n    private boolean checkPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left++) != str.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> result1 = solution.reverse_delete(\"abcde\", \"ae\");\n        System.out.println(result1); // Expected output: [\"bcd\", false]\n\n        List<Object> result2 = solution.reverse_delete(\"abcdef\", \"b\");\n        System.out.println(result2); // Expected output: [\"acdef\", false]\n\n        List<Object> result3 = solution.reverse_delete(\"abcdedcba\", \"ab\");\n        System.out.println(result3); // Expected output: [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String str : lst) {\n            int countOdd = 0;\n            \n            // Counting odd digits\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    countOdd++;\n                }\n            }\n            \n            // Constructing the result string with the number of odd elements\n            String formattedString = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(formattedString);\n        }\n        \n        return result;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(test1));\n        \n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(test2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n        \n        int minSum = Integer.MAX_VALUE;\n        int currentSum = 0;\n\n        for (int num : nums) {\n            // If the current sum becomes positive, start a new sub-array from the current element\n            if (currentSum > 0) {\n                currentSum = num;\n            } else {\n                currentSum += num;\n            }\n            \n            minSum = Math.min(minSum, currentSum);\n        }\n\n        return minSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3)));       // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList()));                 // Expected output: 0 (empty list)\n        System.out.println(solution.minSubArraySum(Arrays.asList(5)));                // Expected output: 5 (single element)\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Calculates the number of times buckets need to be lowered to empty all wells.\n     *\n     * @param grid A list of lists representing the grid of wells, where each 1 represents a unit of water.\n     * @param capacity The bucket capacity in units of water.\n     * @return The total number of times buckets need to be lowered to empty all wells.\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Calculate the total amount of water across all wells\n        int totalWater = 0;\n        for (List<Integer> row : grid) {\n            for (int cell : row) {\n                if (cell == 1) {\n                    totalWater++;\n                }\n            }\n        }\n\n        // Calculate how many times buckets need to be lowered\n        return (totalWater + capacity - 1) / capacity;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Expected output: 6\n\n        // Example 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Expected output: 5\n\n        // Example 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort based on custom comparator\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                // Count the number of ones in binary representation\n                int countOnesO1 = Integer.bitCount(o1);\n                int countOnesO2 = Integer.bitCount(o2);\n\n                if (countOnesO1 != countOnesO2) {\n                    return countOnesO1 - countOnesO2;\n                } else {\n                    // If the number of ones is equal, sort by decimal value\n                    return o1.compareTo(o2);\n                }\n            }\n        });\n\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1)); // Expected: [1, 2, 4, 3, 5]\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2)); // Expected: [-4, -2, -6, -5, -3]\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3)); // Expected: [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\"); // Split the string into words based on spaces.\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    private int countConsonants(String word) {\n        int consonantCount = 0;\n\n        // Convert the word to lowercase and iterate through each character.\n        for (char c : word.toLowerCase().toCharArray()) {\n            if (\"bcdfghjklmnpqrstvwxyz\".indexOf(c) != -1) { // Check if it's a consonant.\n                consonantCount++;\n            }\n        }\n\n        return consonantCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the closest vowel standing between two consonants from the right side of the word.\n     */\n    public String get_closest_vowel(String word) {\n        // Define vowels for case-sensitive comparison\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                             'A', 'E', 'I', 'O', 'U'));\n        \n        int n = word.length();\n        char lastVowel = '\\0'; // Initialize with a non-vowel character\n        \n        // Traverse the string from right to left\n        for (int i = n - 1; i >= 0; i--) {\n            char c = word.charAt(i);\n            \n            if (!vowels.contains(c)) { // If current character is not a vowel\n                continue;\n            }\n            \n            // Check if there are consonants on both sides of the vowel\n            boolean hasConsonantLeft = (i - 1 >= 0 && !vowels.contains(word.charAt(i - 1)));\n            boolean hasConsonantRight = (i + 1 < n && !vowels.contains(word.charAt(i + 1)));\n            \n            if (hasConsonantLeft || hasConsonantRight) {\n                lastVowel = c;\n                break; // Found the vowel, no need to continue\n            }\n        }\n\n        return (lastVowel == '\\0') ? \"\" : String.valueOf(lastVowel);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order to form a balanced string.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there is a way to make the concatenated string balanced, otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < 2; i++) { // Only two possibilities: s1 + s2 or s2 + s1\n            String combined = lst.get(i) + lst.get(1 - i); // Concatenate in both orders\n            if (isBalanced(combined)) {\n                return \"Yes\";\n            }\n        }\n        return \"No\"; // If neither concatenation is balanced, return \"No\"\n    }\n\n    /**\n     * Helper method to check if a string of parentheses is balanced.\n     *\n     * @param s The string to be checked for balance.\n     * @return true if the string is balanced, false otherwise.\n     */\n    private boolean isBalanced(String s) {\n        int balance = 0; // Keeps track of open-close balance\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else { // c == ')'\n                balance--;\n            }\n            if (balance < 0) {\n                return false; // If at any point we have more closing parentheses, it's unbalanced.\n            }\n        }\n        return balance == 0; // True if balanced, otherwise false\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));   // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"(\")));  // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the entire list\n        Collections.sort(arr);\n        \n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        // Add the last k elements from the sorted list to the result list\n        for (int i = 0; i < k; i++) {\n            result.add(arr.get(arr.size() - 1 - i));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(solution.maximum(arr1, k1)); // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(solution.maximum(arr2, k2)); // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(solution.maximum(arr3, k3)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element at the current index is odd\n                sum += lst.get(i); // Add to sum if it's an odd number\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(solution.add_elements(test1, k1)); // Expected output: 24\n        \n        List<Integer> test2 = Arrays.asList(10, 23, 45, 67, 89, 100);\n        int k2 = 6;\n        System.out.println(solution.add_elements(test2, k2)); // Expected output: 167 (10 + 23 + 45 + 67 + 89)\n        \n        List<Integer> test3 = Arrays.asList(1, 2, 3, 4, 5);\n        int k3 = 5;\n        System.out.println(solution.add_elements(test3, k3)); // Expected output: 15 (1 + 2 + 3 + 4 + 5)\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if the number is odd.\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next Collatz number.\n        }\n        result.add(1); // The sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order.\n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If even\n            return n / 2;\n        } else { // If odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.get_odd_collatz(5);\n        System.out.println(result1); // Expected: [1, 5]\n        \n        List<Integer> result2 = solution.get_odd_collatz(6);\n        System.out.println(result2); // Expected: [1, 3]\n        \n        List<Integer> result3 = solution.get_odd_collatz(7);\n        System.out.println(result3); // Expected: [1, 7]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check if the input string is empty or null\n        if (date == null || date.isEmpty()) return false;\n\n        // Split the date into its components using '-' as a delimiter\n        String[] parts = date.split(\"-\");\n        \n        // Validate that there are exactly 3 parts in the split result\n        if (parts.length != 3) return false;\n        \n        int month, day, year;\n        try {\n            month = Integer.parseInt(parts[0]);\n            day = Integer.parseInt(parts[1]);\n            year = Integer.parseInt(parts[2]);\n        } catch (NumberFormatException e) {\n            // If any part of the date cannot be parsed as an integer\n            return false;\n        }\n        \n        // Validate the month\n        if (month < 1 || month > 12) return false;\n\n        // Validate the day based on the month and leap year conditions\n        int maxDays = getMaxDayOfMonth(month, year);\n        if (day < 1 || day > maxDays) return false;\n        \n        return true;\n    }\n\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    }\n    \n    private int getMaxDayOfMonth(int month, int year) {\n        if (month == 2) {\n            // February\n            return isLeapYear(year) ? 29 : 28;\n        } else if (Arrays.asList(1, 3, 5, 7, 8, 10, 12).contains(month)) {\n            // Months with 31 days\n            return 31;\n        } else {\n            // All other months have 30 days\n            return 30;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "class Solution {\n    public Object split_words(String txt) {\n        // Check if there are whitespaces in the string.\n        String[] words = txt.split(\"\\\\s+\");\n        \n        // If no whitespaces, check for commas and split on them.\n        if (words.length == 1 && !txt.contains(\" \")) {\n            words = txt.split(\",\");\n        }\n        \n        // If still only one element and it contains no commas, count the odd letters.\n        if (words.length == 1 && !txt.contains(\",\")) {\n            int oddCount = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 != 0)) {\n                    oddCount++;\n                }\n            }\n            return oddCount;\n        }\n\n        // Return the array of words.\n        return Arrays.asList(words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.split_words(\"Hello world!\"));  // Expected: [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\"));  // Expected: [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));         // Expected: 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            Integer currentNumber = lst.get(i);\n\n            if (previousNumber != null && currentNumber < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (previousNumber != null && currentNumber.equals(previousNumber)) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = currentNumber;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start > end) { // No intersection\n            return \"NO\";\n        }\n\n        int length = end - start + 1;\n        return isPrime(length) ? \"YES\" : \"NO\";\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of magnitudes of integers multiplied by the product of all signs.\n     *\n     * @param arr List of integers.\n     * @return Optional<Integer> representing the result or None if the list is empty.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            } else if (num < 0) {\n                // Update sign product to negative\n                signProduct *= -1;\n            }\n            // Add magnitude of current number to sum\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize a queue for BFS and a set to keep track of visited states.\n        Queue<State> q = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        // Start from every cell in the grid\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                List<Integer> path = new ArrayList<>();\n                path.add(grid.get(i).get(j));\n                q.offer(new State(path, i, j, 1)); // Start with a path of length 1\n                visited.add(i + \",\" + j);\n            }\n        }\n\n        while (!q.isEmpty()) {\n            State curr = q.poll();\n            if (curr.path.size() == k) continue; // If the current path is already of length k, skip further exploration\n\n            int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // Right, Down, Up, Left\n            for (int[] dir : directions) {\n                int newX = curr.x + dir[0];\n                int newY = curr.y + dir[1];\n\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N && !visited.contains(newX + \",\" + newY)) { // Check bounds and visited\n                    List<Integer> newPath = new ArrayList<>(curr.path);\n                    newPath.add(grid.get(newX).get(newY));\n                    q.offer(new State(newPath, newX, newY, curr.path.size() + 1));\n                    visited.add(newX + \",\" + newY); // Mark as visited\n\n                    if (newPath.size() == k) {\n                        return newPath; // If we have a path of length k, return it\n                    }\n                }\n            }\n        }\n\n        throw new RuntimeException(\"No valid path found\"); // This should never happen due to problem constraints\n    }\n\n    private class State {\n        List<Integer> path;\n        int x, y;\n        int steps;\n\n        public State(List<Integer> path, int x, int y, int steps) {\n            this.path = path;\n            this.x = x;\n            this.y = y;\n            this.steps = steps;\n        }\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        System.out.println(sol.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        System.out.println(sol.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Generates the first n + 1 numbers of a custom Tribonacci-like sequence.\n     */\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>(); // Handle invalid input\n\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i == 1) {\n                result.add(3); // tri(1) = 3\n            } else if (i % 2 == 0) {\n                result.add(1 + i / 2); // tri(n) = 1 + n / 2, if n is even.\n            } else {\n                int prevPrev = i - 2 > 0 ? result.get(i - 2) : 3; // tri(n-2)\n                int prev = i - 1 > 0 ? result.get(i - 1) : 3;      // tri(n-1)\n                int next = i + 1 <= n ? (i + 1 == 1 ? 3 : 1 + (i + 1) / 2) : 1 + (i + 1) / 2;\n                result.add(prevPrev + prev + next); // tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.tri(3)); // Expected output: [3, 2, 8]\n        System.out.println(solution.tri(4)); // Expected output: [3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if there is at least one nested bracket pair within a string containing only square brackets.\n     *\n     * @param string The input string consisting of '[' and ']' characters.\n     * @return true if the string contains at least one nested bracket, false otherwise.\n     */\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean hasNested = false;\n\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n                // If the balance is positive, it means there's a nested bracket.\n                hasNested |= balance > 0;\n            }\n        }\n\n        return hasNested && balance == 0; // Ensure all brackets are closed properly and at least one is nested.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilNum = Math.ceil(num);\n            // Square the rounded number and add it to the sum\n            sum += (int)(ceilNum * ceilNum);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Expected output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Expected output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Expected output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Expected output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "class Solution {\n    /**\n     * Checks if the last character of a given string is an alphabetical character \n     * and is not part of a word.\n     *\n     * @param txt The input string to check.\n     * @return true if the last character is an alphabetical character and not part of a word, false otherwise.\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Trim trailing spaces\n        String trimmedTxt = txt.trim();\n        \n        // Check if the string is empty after trimming\n        if (trimmedTxt.isEmpty()) {\n            return false;\n        }\n        \n        char lastChar = trimmedTxt.charAt(trimmedTxt.length() - 1);\n        \n        // Check if the last character is an alphabetical letter and not part of a word\n        boolean isLastCharLetter = Character.isAlphabetic(lastChar);\n        boolean isLastCharNotPartOfWord = !Character.isLetterOrDigit(trimmedTxt.charAt(trimmedTxt.length() - 2));\n        \n        return isLastCharLetter && isLastCharNotPartOfWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));   // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\"));  // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\"));            // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(solution.can_arrange(test1)); // Expected output: 3\n        \n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.can_arrange(test2)); // Expected output: -1\n        \n        List<Integer> test3 = Arrays.asList(5, 4, 3, 2, 1);\n        System.out.println(solution.can_arrange(test3)); // Expected output: 1\n        \n        List<Integer> test4 = Arrays.asList(10, 20, 15, 30, 40);\n        System.out.println(solution.can_arrange(test4)); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (maxNegative.isEmpty() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (minPositive.isEmpty() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional[1]]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Additional test cases\n        List<Integer> list4 = Arrays.asList(-2, -5, -1, -7);\n        System.out.println(solution.largest_smallest_integers(list4)); // Expected: [Optional[-1], Optional.empty()]\n\n        List<Integer> list5 = Arrays.asList(3, 6, 9, 12);\n        System.out.println(solution.largest_smallest_integers(list5)); // Expected: [Optional.empty(), Optional[3]]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        // Convert all inputs to Double for comparison\n        double numA = convertToDouble(a);\n        double numB = convertToDouble(b);\n\n        if (numA == numB) {\n            return Optional.empty();\n        }\n\n        if (numA > numB) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private static double convertToDouble(Object obj) {\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        } else if (obj instanceof Double) {\n            return (double) obj;\n        } else if (obj instanceof String) {\n            try {\n                // Replace comma with dot for proper parsing\n                String str = ((String) obj).replace(',', '.');\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid input string: \" + obj, e);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we need a sum of exactly four positive even numbers, the smallest possible sum is 2 + 2 + 2 + 2 = 8.\n        if (n < 8 || n % 2 != 0) {\n            return false;\n        }\n        \n        // If n - 8 is divisible by 2, then we can form a sum of four even numbers that equals n.\n        int remainder = n - 8;\n        return remainder >= 0 && remainder % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected output: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected output: true\n        System.out.println(solution.is_equal_to_sum_even(24)); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) return 1; // Base case: brazilian_factorial(0) = 1\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int x) {\n        if (x == 0 || x == 1) return 1;\n\n        long fact = 1;\n        for (int i = 2; i <= x; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n\n            if (c == ' ') {\n                spaceCount++;\n                continue;\n            }\n\n            // If more than two consecutive spaces, replace with '-'\n            if (spaceCount > 2) {\n                result.append('-');\n                spaceCount = 0; // Reset the count\n            } else if (spaceCount > 0) { \n                // Replace single or double spaces with '_'\n                for (int j = 0; j < spaceCount; j++) {\n                    result.append('_');\n                }\n                spaceCount = 0;\n            }\n\n            result.append(c);\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else if (spaceCount > 0) {\n            for (int i = 0; i < spaceCount; i++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fix_spaces(\"Example\")); // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\")); // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\")); // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\")); // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a given file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot in the file name\n        int dotCount = 0;\n        for (int i = 0; i < fileName.length(); i++) {\n            char c = fileName.charAt(i);\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n\n        if (dotCount != 1) return \"No\";\n\n        // Split the file name into two parts: before and after the dot\n        String[] parts = fileName.split(\"\\\\.\");\n        String prefix = parts[0];\n        String suffix = parts.length > 1 ? parts[1] : \"\";\n\n        // Check that the prefix is not empty, starts with a letter, and contains at most three digits\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) return \"No\";\n        \n        int digitCount = 0;\n        for (char c : prefix.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n                if (digitCount > 3) return \"No\"; // More than three digits\n            }\n        }\n\n        // Check that the suffix is one of [\"txt\", \"exe\", \"dll\"]\n        String[] validSuffixes = {\"txt\", \"exe\", \"dll\"};\n        boolean isValidSuffix = false;\n        for (String valid : validSuffixes) {\n            if (suffix.equals(valid)) {\n                isValidSuffix = true;\n                break;\n            }\n        }\n\n        return isValidSuffix ? \"Yes\" : \"No\";\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.file_name_check(\"example.txt\"));  // Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // No\n        System.out.println(solution.file_name_check(\".txt\"));         // No\n        System.out.println(solution.file_name_check(\"file.exe\"));     // Yes\n        System.out.println(solution.file_name_check(\"file.abc\"));     // No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     */\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Index is a multiple of 3\n                sum += Math.pow(lst.get(i), 2);\n            } else if ((i + 1) % 4 == 0 && (i + 1) % 3 != 0) { // Index is a multiple of 4 but not 3\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                sum += lst.get(i); // No change to the entry\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sum_squares(list1)); // Expected output: 6\n        \n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.sum_squares(list2)); // Expected output: 0\n        \n        List<Integer> list3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(solution.sum_squares(list3)); // Expected output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Helper method to check if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing only words whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String sentence1 = \"This is a test\";\n        System.out.println(solution.words_in_sentence(sentence1));  // Output: \"is\"\n\n        String sentence2 = \"lets go for swimming\";\n        System.out.println(solution.words_in_sentence(sentence2));  // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the string representations of fractions into numerical values\n        int[] fractionX = parseFraction(x);\n        int[] fractionN = parseFraction(n);\n\n        // Multiply the two fractions\n        long numeratorProduct = (long) fractionX[0] * fractionN[0];\n        long denominatorProduct = (long) fractionX[1] * fractionN[1];\n\n        // Check if the result is a whole number by checking if the remainder of division is zero\n        return numeratorProduct % denominatorProduct == 0;\n    }\n\n    private int[] parseFraction(String fraction) {\n        String[] parts = fraction.split(\"/\");\n        int numerator = Integer.parseInt(parts[0]);\n        int denominator = Integer.parseInt(parts[1]);\n\n        // Simplify the fraction if necessary (though not strictly required for this problem)\n        return new int[]{numerator, denominator};\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\"));  // Expected output: true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\"));  // Expected output: false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\"));  // Expected output: false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts the given list of integers in ascending order according to the sum of their digits.\n     * If there are several items with similar sum of their digits, they are ordered based on their index in the original list.\n     * For negative numbers, the first digit is considered negative.\n     *\n     * @param nums List of integers to be sorted\n     * @return Sorted list of integers\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        return nums.stream()\n                .sorted(Comparator.comparingInt(Solution::sumOfDigits)\n                        .thenComparingInt(nums::indexOf))\n                .collect(Collectors.toList());\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) {\n                sum -= digit; // Subtract positive digits for negative numbers\n            } else {\n                sum += Math.abs(digit); // Add absolute value of each digit\n            }\n            num /= 10;\n        }\n        return isNegative ? -sum : sum; // Adjust the sign based on original number's negativity\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(test1)); // Expected: [-1, -11, 1, -12, 11]\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(10, 9, -8, 7);\n        System.out.println(solution.order_by_points(test3)); // Expected: [-8, 7, 9, 10]\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many triples satisfy the condition\n        return countValidTriples(a);\n    }\n\n    private int countValidTriples(int[] a) {\n        int count = 0;\n\n        for (int i = 0; i < a.length - 2; i++) {\n            for (int j = i + 1; j < a.length - 1; j++) {\n                for (int k = j + 1; k < a.length; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Test the solution with an example\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int n = 5; // Example input\n        System.out.println(sol.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns a list of planets orbiting between the orbits of two given planets.\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define an array with all planets in order from closest to farthest from the Sun\n        String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n        \n        // Find indices of planet1 and planet2 in the array\n        int index1 = -1;\n        int index2 = -1;\n\n        for (int i = 0; i < planets.length; i++) {\n            if (planets[i].equals(planet1)) {\n                index1 = i;\n            }\n            if (planets[i].equals(planet2)) {\n                index2 = i;\n            }\n\n            // If both indices are found, break the loop\n            if (index1 != -1 && index2 != -1) {\n                break;\n            }\n        }\n\n        // Check if either planet name is invalid\n        if (index1 == -1 || index2 == -1) {\n            return new ArrayList<>();\n        }\n\n        // Ensure index1 < index2 for correct order of planets between them\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n\n        // Add all planets between the two indices to the result list\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(planets[i]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filters out strings of odd length from a given list, then sorts the remaining strings.\n     * The sorting is first by string length in ascending order, and if two strings have the same length,\n     * they are sorted alphabetically.\n     *\n     * @param lst List of strings to be filtered and sorted.\n     * @return A new list containing only even-length strings from the input list, sorted as described.\n     */\n    public List<String> filterAndSort(List<String> lst) {\n        // Filter out odd length strings\n        List<String> filteredList = lst.stream()\n                                       .filter(s -> s.length() % 2 == 0)\n                                       .sorted(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()))\n                                       .collect(Collectors.toList());\n        \n        return filteredList;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.filterAndSort(test1));  // Expected: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.filterAndSort(test2));  // Expected: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(19, 20, 10)); // Should print 20\n        System.out.println(solution.x_or_y(21, 40, 30)); // Should print 30\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List of objects (integers expected)\n     * @return Sum of squares of positive odd integers from the list\n     */\n    public int sumOfSquaresOfOdd(List<Object> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int sum = 0;\n\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) { // Check if the number is positive and odd\n                    sum += num * num; // Square the number and add to sum\n                }\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(9, -2))); // Expected output: 81\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(0))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares the given scores and guesses for matches.\n     * @param game A list of integers representing match scores.\n     * @param guess A list of integers representing match guesses.\n     * @return A list of integers indicating how far off each guess was from the actual score.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class name.\n     * The strength of an extension is calculated as CAP - SM,\n     * where CAP is the number of uppercase letters and SM is the number of lowercase letters in the extension's name.\n     *\n     * @param class_name The name of the class to which extensions are being added.\n     * @param extensions A list of extension names.\n     * @return The strongest extension in the format ClassName.Strongest_Extension.\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        String strongest = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n        \n        for (String ext : extensions) {\n            int strength = calculateStrength(ext);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongest = ext;\n            }\n        }\n\n        return class_name + \".\" + strongest;\n    }\n\n    private int calculateStrength(String extension) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\")));  // Expected: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\")));                      // Expected: my_class.AA\n        System.out.println(solution.Strongest_Extension(\"Example\", new ArrayList<>()));                                     // Expected: Example\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the second word or any of its rotations is a substring in the first word.\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate 'a' with itself to handle rotation checks easily\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated string\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> (1, 1)\n     *      even_odd_count(123) ==> (1, 2)\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Handle negative numbers by converting to positive\n        if (num < 0) {\n            num = -num;\n        }\n\n        int evenCount = 0;\n        int oddCount = 0;\n\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n\n            if (digit % 2 == 0) {\n                evenCount++; // Increment even count\n            } else {\n                oddCount++; // Increment odd count\n            }\n\n            num /= 10; // Remove the last digit\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.even_odd_count(-12);\n        System.out.println(result1); // Expected output: [1, 1]\n        \n        List<Integer> result2 = solution.even_odd_count(123);\n        System.out.println(result2); // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        if (number < 1 || number > 1000) {\n            throw new IllegalArgumentException(\"Number must be between 1 and 1000\");\n        }\n\n        // Mapping of Roman numerals to integers\n        final String[][] romanNumerals = {\n                {\"i\", \"v\"},   // 1, 5\n                {\"x\", \"l\"},   // 10, 50\n                {\"c\", \"d\"}    // 100, 500\n        };\n\n        StringBuilder result = new StringBuilder();\n        \n        for (int i = romanNumerals.length - 1; i >= 0; i--) {\n            int baseValue = (int) Math.pow(10, i + 1);\n            \n            if (number < baseValue / 10) continue;\n\n            // Calculate the current digit in the number\n            int digit = number / baseValue;\n            if (digit == 9) {\n                result.append(romanNumerals[i][0]).append(romanNumerals[i+1][0]);\n            } else if (digit >= 5) {\n                result.append(romanNumerals[i][1]);\n                for (int j = 0; j < digit - 5; j++) {\n                    result.append(romanNumerals[i][0]);\n                }\n            } else if (digit == 4) {\n                result.append(romanNumerals[i][0]).append(romanNumerals[i][1]);\n            } else {\n                for (int j = 0; j < digit; j++) {\n                    result.append(romanNumerals[i][0]);\n                }\n            }\n\n            // Subtract the value we've processed from number\n            number -= digit * baseValue / 10;\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.int_to_mini_roman(19));   // Output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle.\n     * Return true if the three sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is 90 degrees.\n     *\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to make sure 'c' is the longest side.\n        int[] sides = new int[]{a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if it's a right-angled triangle using Pythagorean theorem\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If multiple words have the same number of unique characters,\n     * returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the word with maximum unique characters\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Check if this word has more unique characters than the current max\n            // or is lexicographically smaller with the same number of unique characters\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(test1)); // Expected: string\n\n        List<String> test2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(test2)); // Expected: enam\n\n        List<String> test3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(test3)); // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "class Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int toEat = Math.min(need, remaining);\n        \n        // Total number of carrots eaten after the meals.\n        int totalEaten = number + toEat;\n        \n        // Number of remaining carrots after eating as much as possible.\n        int leftOver = remaining - toEat;\n\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two lists operator, and operand. The first list has basic algebra operations,\n     * and the second list is a list of integers. Use the two given lists to build the algebric\n     * expression and return the evaluation of this expression.\n     *\n     * @param operators List of String representing arithmetic operators.\n     * @param operands  List of Integer representing operands.\n     * @return The result of evaluating the algebraic expression.\n     */\n    public int do_algebra(List<String> operators, List<Integer> operands) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < operands.size(); i++) {\n            if (!operators.isEmpty() && i > 0) {\n                String op = operators.get(i - 1);\n                int b = operands.get(i);\n                int a = operands.get(i - 1);\n\n                switch (op) {\n                    case \"+\":\n                        stack.push(a + b);\n                        break;\n                    case \"-\":\n                        stack.push(a - b);\n                        break;\n                    case \"*\":\n                        stack.push(a * b);\n                        break;\n                    case \"/\":\n                        stack.push(a / b); // Assuming a > 0 and b > 0 to avoid division by zero\n                        break;\n                    case \"**\":\n                        stack.push((int) Math.pow(a, b));\n                        break;\n                }\n            } else {\n                stack.push(operands.get(i)); // Push the first operand directly onto the stack.\n            }\n\n            if (i < operators.size()) {\n                // If there are more operations to process and we have a result from previous operation,\n                // pop it back into operands list for further processing.\n                int temp = stack.pop();\n                operands.set(i, temp);\n            }\n        }\n\n        return stack.pop(); // The final result will be the last remaining item in the stack.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Output: 9\n\n        List<String> operators2 = Arrays.asList(\"**\", \"/\", \"+\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 4, 8);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * If s[i] is a letter, reverse its case from lower to upper or vice versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters are present, reverse the string.\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Expected output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add preceding 0s to make it 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure the range is in ascending order\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> evenDigits = new ArrayList<>();\n        for (int i = 2; i <= 8; i += 2) { // Even digits less than 10 are 2, 4, 6, and 8\n            if (i >= a && i <= b) {\n                evenDigits.add(i);\n            }\n        }\n\n        return evenDigits;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.generate_integers(2, 8));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"true\" : \"false\")); // Expected output: false\n        \n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"true\" : \"false\")); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Separates groups of nested parentheses from an input string.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A list of strings, each representing a separate group of balanced parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from the input string\n        String noSpaceString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : noSpaceString.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            currentGroup.append(c);\n\n            // When the balance is zero, we have a complete group\n            if (balance == 0 && currentGroup.length() > 0) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Clear the StringBuilder for the next group\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> groups = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(groups);\n    }\n}\n"}
{"task_id": "Java/2", "generation": "class Solution {\n    /**\n     * Given a positive floating point number, decompose it into an integer part (largest integer smaller than given number) \n     * and decimals (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        // Get the integer part by casting to int or using Math.floor\n        double integerPart = Math.floor(number);\n        \n        // Subtract the integer part from the original number to get the decimal part\n        return number - integerPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n    }\n}\n"}
{"task_id": "Java/3", "generation": "class Solution {\n    /**\n     * Detects if the bank account's balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposits (positive numbers) and withdrawals (negative numbers).\n     * @return true if at any point the balance is negative, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Starting with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance fell below zero\n            }\n        }\n        return false; // No point where balance was negative\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Expected output: false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be empty or null\");\n        }\n\n        // Calculate the mean of the dataset\n        double sum = 0.0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (Double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean firstElementAdded = false;\n\n        for (Integer number : numbers) {\n            if (!firstElementAdded) {\n                // Add the first element without a preceding delimiter\n                result.add(number);\n                firstElementAdded = true;\n            } else {\n                // Add a delimiter before each subsequent element\n                result.add(delimiter);\n                result.add(number);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(\"Empty list interspersed with 4: \" + emptyList);\n\n        // Test case 2: Non-empty list\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(\"List [1, 2, 3] interspersed with 4: \" + nonEmptyList);\n\n        // Test case 3: Single element list\n        List<Integer> singleElementList = solution.intersperse(Arrays.asList(5), 9);\n        System.out.println(\"Single-element list [5] interspersed with 9: \" + singleElementList);\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces,\n     * and returns a list with the deepest level of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        // Split the input string into individual groups based on space delimiter\n        String[] groups = paren_string.split(\" \");\n        List<Integer> depths = new ArrayList<>();\n\n        // Iterate over each group to calculate its deepest level of nesting\n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n\n            // For each character in the group, update the depth accordingly\n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    if (currentDepth > maxDepth) {\n                        maxDepth = currentDepth;\n                    }\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n\n            // Add the deepest level of nesting for this group to the list\n            depths.add(maxDepth);\n        }\n\n        return depths;\n    }\n\n    /**\n     * A method to test the parse_nested_parens function with various inputs.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        System.out.println(\"Test Case 1: \" + (solution.parse_nested_parens(input1).equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        String input2 = \"(()) ()() ((()))\";\n        List<Integer> expectedOutput2 = Arrays.asList(2, 1, 3);\n        System.out.println(\"Test Case 2: \" + (solution.parse_nested_parens(input2).equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        String input3 = \"() ()() ((())(()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(1, 1, 4);\n        System.out.println(\"Test Case 3: \" + (solution.parse_nested_parens(input3).equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java Streams to filter the list based on whether each string contains the substring.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case with an empty list\n        List<Integer> resultEmptyList = solution.sum_product(new ArrayList<>());\n        System.out.println(\"Sum and Product of Empty List: \" + resultEmptyList);  // Expected output: [0, 1]\n\n        // Test case with a non-empty list\n        List<Integer> resultList = solution.sum_product(Arrays.asList(1, 2, 3, 4));\n        System.out.println(\"Sum and Product of List [1, 2, 3, 4]: \" + resultList);  // Expected output: [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome.\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        // If the input string is empty, return an empty string\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        int n = string.length();\n        for (int i = 0; i < n; i++) {\n            // Check if substring from index i to end of string is a palindrome\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // If it's a palindrome, append the reverse of prefix before this suffix\n                return string + new StringBuilder(string.substring(0, i)).reverse().toString();\n            }\n        }\n\n        // Fallback case: if no palindromic suffix is found, just add the first character reversed at the end.\n        return string.charAt(0) + string;\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = padStringWithZeros(a, maxLength);\n        b = padStringWithZeros(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n            \n            // XOR the characters and append to result\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Pad the string with zeros to make it of a specific length.\n     * @param str Input string.\n     * @param length Desired length after padding.\n     * @return Padded string.\n     */\n    private String padStringWithZeros(String str, int length) {\n        while (str.length() < length) {\n            str = \"0\" + str;\n        }\n        return str;\n    }\n\n    /**\n     * Test function to verify the correctness of the string_xor method.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"111\", \"000\"));  // Expected output: \"111\"\n        System.out.println(solution.string_xor(\"10101\", \"00111\"));  // Expected output: \"10010\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-18, -24)); // Expected output: 6\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    /**\n     * Test method to verify the correctness of the all_prefixes function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> expectedOutput1 = Arrays.asList(\"a\", \"ab\", \"abc\");\n        List<String> actualOutput1 = solution.all_prefixes(\"abc\");\n        System.out.println(\"Test Case 1: \" + (expectedOutput1.equals(actualOutput1) ? \"Pass\" : \"Fail\"));\n\n        // Test case 2\n        List<String> expectedOutput2 = Arrays.asList(\"x\", \"xy\", \"xyz\");\n        List<String> actualOutput2 = solution.all_prefixes(\"xyz\");\n        System.out.println(\"Test Case 2: \" + (expectedOutput2.equals(actualOutput2) ? \"Pass\" : \"Fail\"));\n\n        // Test case 3\n        List<String> expectedOutput3 = Arrays.asList();\n        List<String> actualOutput3 = solution.all_prefixes(\"\");\n        System.out.println(\"Test Case 3: \" + (expectedOutput3.equals(actualOutput3) ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test block to verify the correctness of the string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.string_sequence(0));  // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5));  // Expected output: \"0 1 2 3 4 5\"\n\n        // Additional test cases\n        System.out.println(solution.string_sequence(-1)); // Expected output: \"\"\n        System.out.println(solution.string_sequence(10)); // Expected output: \"0 1 2 3 4 5 6 7 8 9 10\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format.\n     * Returns a list of integers corresponding to how many beats each note lasts.\n     *\n     * Legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quater note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> beats = new ArrayList<>();\n        \n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    beats.add(4);\n                    break;\n                case \"o|\":\n                    beats.add(2);\n                    break;\n                case \".|\":\n                    beats.add(1);\n                    break;\n                default:\n                    // Handle unexpected input\n                    System.out.println(\"Unexpected note: \" + note);\n            }\n        }\n\n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty()) return 0; // Edge case: empty substring\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map to store number words as keys and their corresponding integer values as values.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] splitNumbers = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its corresponding integer value and store in a list.\n        List<Integer> intList = new ArrayList<>();\n        for (String numWord : splitNumbers) {\n            intList.add(numMap.get(numWord));\n        }\n\n        // Sort the list of integers.\n        Collections.sort(intList);\n\n        // Convert each sorted integer back to its corresponding number word and build the result string.\n        StringBuilder result = new StringBuilder();\n        for (int numInt : intList) {\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key) == numInt) {\n                    result.append(key).append(\" \");\n                    break;\n                }\n            }\n        }\n\n        // Remove the trailing space and return the sorted string.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements.\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        // Iterate through the sorted list and find the minimum difference between consecutive elements.\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        // Return the closest elements.\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(testList1)); // Expected: [2.0, 2.2]\n\n        List<Double> testList2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(testList2)); // Expected: [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // Or any other consistent behavior for this edge case.\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        // Create a new ArrayList to store the filtered integer values\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through each value in the input list\n        for (Object value : values) {\n            // Check if the current value is an instance of Integer class\n            if (value instanceof Integer) {\n                // If it is, add it to the result list\n                result.add((Integer)value);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: List with mixed types including an integer\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // Expected output: [5]\n\n        // Test case 2: List with integers and other data types\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // Expected output: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "class Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     * >>> largest_divisor(15)\n     * 5\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, which should not happen as long as n > 1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n\n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> result1 = solution.factorize(8);\n        System.out.println(result1); // Expected: [2, 2, 2]\n\n        List<Integer> result2 = solution.factorize(25);\n        System.out.println(result2); // Expected: [5, 5]\n\n        List<Integer> result3 = solution.factorize(70);\n        System.out.println(result3); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> frequencyMap = new LinkedHashMap<>();\n        \n        // Count frequencies while preserving insertion order\n        for (Integer number : numbers) {\n            frequencyMap.put(number, frequencyMap.getOrDefault(number, 0) + 1);\n        }\n        \n        // Collect elements that occur exactly once\n        return frequencyMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n\n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n\n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder result = new StringBuilder();\n        for (String str : strings) {\n            result.append(str);\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(\"Test Case 1 (Empty List): \" + solution.concatenate(emptyList));\n\n        // Test case 2: Non-empty list\n        List<String> nonEmptyList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Test Case 2 (Non-Empty List): \" + solution.concatenate(nonEmptyList));\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings starting with the prefix\n        List<String> stringList = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(stringList, \"a\")); // Should print [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases\n        if (n <= 1) return false;\n        if (n == 2) return true; // 2 is the only even prime number\n\n        // Exclude all other even numbers\n        if (n % 2 == 0) return false;\n\n        // Test odd divisors from 3 to sqrt(n)\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        // Implement the logic to find a zero point of the polynomial\n        // This is a placeholder for the actual implementation.\n        throw new UnsupportedOperationException(\"find_zero method needs to be implemented.\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Linear equation with one root\n        List<Double> linearCoefficients = Arrays.asList(1.0, -2.0);\n        double rootLinear = solution.find_zero(linearCoefficients);\n        System.out.println(\"Root of \" + linearCoefficients + \": \" + rootLinear); // Expected output: 2.0\n\n        // Test case 2: Cubic equation with one real root\n        List<Double> cubicCoefficients = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        double rootCubic = solution.find_zero(cubicCoefficients);\n        System.out.println(\"Root of \" + cubicCoefficients + \": \" + rootCubic); // Expected output: 1.0\n\n        // Test case 3: Quadratic equation with two real roots (only one will be returned)\n        List<Double> quadraticCoefficients = Arrays.asList(1.0, -3.0, 2.0);\n        double rootQuadratic = solution.find_zero(quadraticCoefficients);\n        System.out.println(\"Root of \" + quadraticCoefficients + \": \" + rootQuadratic); // Expected output: 1.0 or 2.0\n\n        // Test case 4: Polynomial with complex roots (only real part returned)\n        List<Double> complexCoefficients = Arrays.asList(1.0, -1.0, 1.0);\n        double rootComplex = solution.find_zero(complexCoefficients);\n        System.out.println(\"Root of \" + complexCoefficients + \": \" + rootComplex); // Expected output: Real part of the root\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n     * to the values of the corresponding indices of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> elementsToSort = new ArrayList<>();\n        \n        // Collect elements at indices divisible by 3\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering index starting from 1, so use (i+1)\n                elementsToSort.add(l.get(i));\n            }\n        }\n\n        // Sort the collected elements\n        Collections.sort(elementsToSort);\n\n        // Place sorted elements back into their original positions\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering index starting from 1, so use (i+1)\n                result.set(i, elementsToSort.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(list1)); // Expected: [1, 2, 3]\n\n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(list2)); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and remove duplicates\n        Set<Integer> set = new LinkedHashSet<>(l);\n        // Convert the set back into a list and sort it\n        List<Integer> result = new ArrayList<>(set);\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.unique(testList1)); // Expected: [0, 2, 3, 5, 9, 123]\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 4, 8, 7);\n        System.out.println(solution.unique(testList2)); // Expected: [4, 6, 7, 8]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n        \n        int max = l.get(0); // Assume first element is the largest initially\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n        \n        // Test case with an empty list\n        List<Integer> list3 = new ArrayList<>();\n        try {\n            System.out.println(solution.max_element(list3));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected output: \"List must not be null or empty\"\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (int j = 0; j < numStr.length(); j++) {\n                    if (numStr.charAt(j) == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the even-indexed elements\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract even-indexed elements and add them to 'evens'\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the extracted even-indexed elements\n        Collections.sort(evens);\n        \n        List<Integer> result = new ArrayList<>();\n        int evenIndex = 0;\n        \n        // Reconstruct the list with sorted even-indexed elements and original odd-indexed elements\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {  // Even index, use sorted value\n                result.add(evens.get(evenIndex++));\n            } else {           // Odd index, keep original value\n                result.add(l.get(i));\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(test1)); // Expected: [1, 2, 3]\n        \n        List<Integer> test2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(test2)); // Expected: [3, 6, 5, 4]\n\n        List<Integer> test3 = Arrays.asList(10, 15, 20, 25, 30);\n        System.out.println(solution.sort_even(test3)); // Expected: [10, 15, 20, 25, 30]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(1) + groups.get(i).substring(2) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test encodeCyclic\n        String encodedString = solution.encodeCyclic(\"abcde\");\n        System.out.println(\"Encoded: \" + encodedString);  // Expected output: \"bcaed\"\n        \n        // Test decode_cyclic\n        String decodedString = solution.decode_cyclic(encodedString);\n        System.out.println(\"Decoded: \" + decodedString);  // Expected output: \"abcde\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int count = 0;\n        long fib1 = 0, fib2 = 1;\n\n        while (count < n) {\n            long nextFib = fib1 + fib2;\n            if (isPrime(nextFib)) {\n                primes.add((int)nextFib);\n                count++;\n            }\n            fib1 = fib2;\n            fib2 = nextFib;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(long num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (long i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_fib(1)); // Output: 2\n        System.out.println(solution.prime_fib(2)); // Output: 3\n        System.out.println(solution.prime_fib(3)); // Output: 5\n        System.out.println(solution.prime_fib(4)); // Output: 13\n        System.out.println(solution.prime_fib(5)); // Output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for efficient searching\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of n cars moving in opposite directions.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from one direction will collide with exactly one car from the other direction,\n        // the total number of collisions is simply 'n'.\n        return n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.car_race_collision(0));  // Expected output: 0 (no cars, no collisions)\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1 (one car from each direction collides once)\n        System.out.println(solution.car_race_collision(5));  // Expected output: 5 (five cars from each direction collide five times)\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n}\n\npublic class TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            int complement = -num;\n            if (seen.contains(complement)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"change_base(8, 3): \" + solution.change_base(8, 3)); // Expected: \"22\"\n        System.out.println(\"change_base(8, 2): \" + solution.change_base(8, 2)); // Expected: \"1000\"\n        System.out.println(\"change_base(7, 2): \" + solution.change_base(7, 2)); // Expected: \"111\"\n\n        // Additional test cases\n        System.out.println(\"change_base(9, 3): \" + solution.change_base(9, 3)); // Expected: \"100\"\n        System.out.println(\"change_base(5, 4): \" + solution.change_base(5, 4)); // Expected: \"11\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     */\n    public double triangle_area(double base, double height) {\n        // The formula to calculate the area of a triangle is 0.5 * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Area with base=5 and height=3: \" + solution.triangle_area(5, 3)); // Expected output: 7.5\n        System.out.println(\"Area with base=10 and height=4: \" + solution.triangle_area(10, 4)); // Expected output: 20.0\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the n-th element of the fib4 number sequence.\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1 || n == 3)\n            return 0;\n        \n        // Initialize the first four elements of the sequence\n        int[] fib = new int[]{0, 0, 2, 0};\n        \n        // If n is less than 4, we already have the result in the array\n        if (n < 4) {\n            return fib[n];\n        }\n        \n        // Compute the sequence iteratively for n >= 4\n        for (int i = 4; i <= n; i++) {\n            int nextFib = fib[0] + fib[1] + fib[2] + fib[3];\n            // Shift the window of four elements to the left and add the new element at the end\n            fib[0] = fib[1];\n            fib[1] = fib[2];\n            fib[2] = fib[3];\n            fib[3] = nextFib;\n        }\n        \n        return fib[3]; // The last computed value is in the fourth position of the array\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        int n = l.size();\n        List<Integer> sortedList = new ArrayList<>(l);\n        Collections.sort(sortedList);\n\n        if (n % 2 == 1) { // If odd, return the middle element\n            return sortedList.get(n / 2);\n        } else { // If even, return the average of the two middle elements\n            return (sortedList.get((n - 1) / 2) + sortedList.get(n / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.median(Arrays.asList(3, 1, 2, 4, 5))); // Expected output: 3\n        System.out.println(solution.median(Arrays.asList(-10, 4, 6, 1000, 10, 20))); // Expected output: 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome.\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "class Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: any number to the power of 0 is 1.\n        \n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply result by base\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n}\n"}
{"task_id": "Java/50", "generation": "class Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                sb.append((char) ((baseChar + (ch - baseChar + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                sb.append((char) ((baseChar + (ch - baseChar - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases for encodeShift and decode_shift methods\n        String testString1 = \"abc\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Expected output: fgh\n\n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Expected output: abc\n\n        String testString2 = \"Hello, World!\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Expected output: Mjqqt, Btwqi!\n\n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Expected output: Hello, World!\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return \"\";\n\n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    private boolean isVowel(char ch) {\n        String vowels = \"aeiouAEIOU\";\n        return vowels.indexOf(ch) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.remove_vowels(\"\")); // \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(solution.below_threshold(list1, threshold1)); // Expected: true\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(solution.below_threshold(list2, threshold2)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "class Solution {\n    /**\n     * Add two numbers x and y.\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Convert both strings to character sets (removes duplicates)\n        Set<Character> setS0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            setS0.add(c);\n        }\n\n        Set<Character> setS1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            setS1.add(c);\n        }\n\n        // Check if both sets are equal\n        return setS0.equals(setS1);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n;\n        \n        int a = 0, b = 1;\n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"fib(10): \" + solution.fib(10));  // Expected output: 55\n        System.out.println(\"fib(1): \" + solution.fib(1));    // Expected output: 1\n        System.out.println(\"fib(8): \" + solution.fib(8));    // Expected output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            // Increment balance for an opening bracket\n            if (c == '<') {\n                balance++;\n            }\n            // Decrement balance for a closing bracket\n            else if (c == '>') {\n                balance--;\n                \n                // If balance is negative, there are more closing brackets than opening ones\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing if balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.isEmpty() || l.size() == 1) return true;\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the common elements\n        set1.retainAll(set2);\n\n        // Convert to a list and sort it\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1_1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2_1 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(solution.common(l1_1, l2_1)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l1_2 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l2_2 = Arrays.asList(3, 2);\n        System.out.println(solution.common(l1_2, l2_2)); // Expected: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "class Solution {\n    /**\n     * Calculates the sum of numbers from 1 to n.\n     *\n     * @param n The upper limit number (inclusive).\n     * @return The sum of all numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n\n    /**\n     * Main method for testing the sum_to_n function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(solution.sum_to_n(5));   // Expected output: 15\n        System.out.println(solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(solution.sum_to_n(1));   // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a string of \"(\" and \")\" is correctly bracketed.\n     *\n     * @param brackets A string containing only '(' and ')'.\n     * @return true if every opening bracket has a corresponding closing bracket, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            // If an opening bracket is found\n            if (c == '(') {\n                balance++;\n            }\n            // If a closing bracket is found\n            else if (c == ')') {\n                balance--;\n                // If balance goes negative, there are more closing brackets than opening ones\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // If balance is zero, all opening brackets have matching closing brackets\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // Expected output: false\n        System.out.println(solution.correct_bracketing(\"()\"));  // Expected output: true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\")(()\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative of a constant term is 0, so we skip it\n        if (xs.size() <= 1) return Collections.emptyList();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            int coefficient = xs.get(i);\n            int power = i;\n            result.add(coefficient * power);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Test Case 1: \" + solution.derivative(test1)); // Expected output: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 2: \" + solution.derivative(test2)); // Expected output: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the number of vowels in the string.\n     * Vowels are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel,\n     * but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) >= 0) {\n                count++;\n            } else if (c == 'y' && i == lowerCaseS.length() - 1) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to manipulate its digits easily\n        String numStr = Integer.toString(x);\n        \n        // Calculate effective shift considering the length of the number\n        int len = numStr.length();\n        if (shift >= len) {\n            // If shift is greater than or equal to the length, reverse the string\n            return new StringBuilder(numStr).reverse().toString();\n        } else {\n            // Perform circular right shift by moving last 'shift' characters to the front\n            String shifted = numStr.substring(len - shift) + numStr.substring(0, len - shift);\n            return shifted;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.circular_shift(12, 1)); // Expected output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected output: \"12\" (no change)\n        System.out.println(solution.circular_shift(12345, 3)); // Expected output: \"34512\"\n        System.out.println(solution.circular_shift(12345, 6)); // Expected output: \"54321\" (reversed)\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of ASCII values of upper-case letters in the input string.\n     *\n     * @param s Input string\n     * @return Sum of ASCII values of upper-case letters\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    // Test the function with provided examples\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (82 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in the basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the number of apples and oranges in the format \"X apples and Y oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        // Iterate through the list to find the smallest even value and its index.\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            if (currentValue % 2 == 0 && currentValue <= smallestEvenValue) {\n                if (currentValue < smallestEvenValue || index > i) {\n                    smallestEvenValue = currentValue;\n                    index = i;\n                }\n            }\n        }\n\n        // If no even value was found, return an empty list.\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a HashMap to store the frequency of each number in the list.\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer.\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Iterate through the entries in the frequency map to find the maximum number\n        // that satisfies the condition of having a frequency greater than or equal to itself.\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        // Test case 3\n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> sortedList = new ArrayList<>();\n        while (!lst.isEmpty()) {\n            // Add the minimum value\n            int minVal = Collections.min(lst);\n            sortedList.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n\n            if (lst.isEmpty()) break;\n\n            // Add the maximum value\n            int maxVal = Collections.max(lst);\n            sortedList.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(10, -1, 3, 9);\n        System.out.println(solution.strange_sort_list(test4)); // Expected: [-1, 10, 3, 9]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Round to two decimal places and return\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed \n     * to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards.\n     * In one change, you can change one element to any other element.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int changes = 0;\n        int left = 0;\n        int right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6);\n        System.out.println(\"Test Case 1: \" + (solution.smallest_change(arr1) == 4 ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(1, 2, 3, 4, 3, 2, 2);\n        System.out.println(\"Test Case 2: \" + (solution.smallest_change(arr2) == 1 ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.smallest_change(arr3) == 0 ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the list with fewer total characters or the first list if they are equal.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String str : lst1) {\n            count1 += str.length();\n        }\n\n        int count2 = 0;\n        for (String str : lst2) {\n            count2 += str.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [hI, Hi]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [hi, admin]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [hI, hi, hi]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [4]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(\"hello\", \"world\"), Arrays.asList(\"java\", \"python\"))); // [hello, world]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     * Knowing that the prime number is less than 100.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        int count = 0;\n        for (int i : primes) {\n            if (a % i == 0 && ++count > 3) return false; // More than three prime factors\n            while (a % i == 0) a /= i; // Divide by the factor until it's no longer divisible\n        }\n        \n        return count == 3 && a == 1; // Check if exactly three prime factors and fully divided\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        for (int i = 2; i * i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                for (int j = i; i * j <= maxPrime; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_multiply_prime(30)); // true\n        System.out.println(solution.is_multiply_prime(60)); // false (2 * 2 * 3 * 5)\n        System.out.println(solution.is_multiply_prime(105)); // true (3 * 5 * 7)\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Your task is to write a function that returns true if a number x is a simple\n     * power of n and false in other cases.\n     * x is a simple power of n if n**int=x\n     * For example:\n     * is_simple_power(1, 4) => true\n     * is_simple_power(2, 2) => true\n     * is_simple_power(8, 2) => true\n     * is_simple_power(3, 2) => false\n     * is_simple_power(3, 1) => false\n     * is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double logResult = Math.log(x) / Math.log(n);\n        return logResult == (int)logResult;\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if an integer is a perfect cube.\n     *\n     * @param a The integer to check.\n     * @return true if a is a perfect cube of some integer, false otherwise.\n     */\n    public boolean iscube(int a) {\n        // Calculate the cube root and round it to the nearest whole number\n        int cubeRoot = (int)Math.round(Math.pow(a, 1.0 / 3.0));\n        \n        // Check if cubing this rounded value equals the original integer\n        return Math.pow(cubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube function\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    /**\n     * Counts the number of hexadecimal digits in the input string that are prime numbers.\n     */\n    public int hex_key(String num) {\n        // Define the set of prime hexadecimal digits as characters\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count and return the number of prime digits in the input string\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n        \n        // Additional test cases to ensure correctness\n        System.out.println(solution.hex_key(\"\"));            // Expected output: 0 (empty string)\n        System.out.println(solution.hex_key(\"1F\"));          // Expected output: 0 (no prime digits)\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string using Integer.toBinaryString()\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' prefix and suffix to the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given string is happy.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n     */\n    public boolean is_happy(String s) {\n        // Check if the string's length is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string to check for any three consecutive characters that are not distinct\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If no issues found, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));      // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));     // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));   // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));   // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));    // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of GPAs into their corresponding letter grades.\n     *\n     * @param grades A List<Double> containing GPA values for students.\n     * @return A List<String> with the letter grade equivalent to each GPA value.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\"); // In case of GPA < 0, which is not expected but handled.\n            }\n        }\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = solution.numerical_letter_grade(grades);\n        System.out.println(result); // Expected output: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a given string is a prime number.\n     *\n     * @param string The input string to be checked.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        return isPrime(len);\n    }\n\n    /**\n     * Helper method to check if a given integer is a prime number.\n     *\n     * @param n The integer to be checked.\n     * @return true if the integer is a prime number, false otherwise.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * A simple check function to verify the correctness of the prime_length method.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.prime_length(\"Hello\")); // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // If there's only one digit, all single-digit numbers are valid.\n            return 10;\n        } else {\n            // For more than one digit:\n            // - There are 9 options for the second to last but one digits (2-9).\n            // - The first and last digit can be 1 independently of each other,\n            //   so we need to subtract the overlap where both start and end with 1.\n            int count = 2 * (int)Math.pow(10, n - 1) - (int)Math.pow(10, n - 2);\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1)); // Expected output: 10\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 18 (11, 12, ..., 19, 21, 31, ..., 91)\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example:\n     * For N = 1000, the sum of digits will be 1, so the output should be \"1\".\n     * For N = 150, the sum of digits will be 6, so the output should be \"110\".\n     * For N = 147, the sum of digits will be 12, so the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     *      Constraints: 0 <= N <= 10000.\n     * Output:\n     *      a string of binary number\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n        \n        // Convert the sum to binary and return it as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000));  // Expected output: \"1\"\n        System.out.println(solution.solve(150));   // Expected output: \"110\"\n        System.out.println(solution.solve(147));   // Expected output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, return the sum of even elements that are at odd indices.\n     *\n     * Examples:\n     * add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        // Iterate through the list starting from index 1 (the first odd index)\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    // Test code to verify the correctness of the add method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2))); // Expected output: 5 (since only one even element at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 8, 9, 12))); // Expected output: 12\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string with each word's characters sorted.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        // Process each word to sort its characters and then join them back together\n        StringBuilder result = new StringBuilder();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            \n            // Append the sorted word to the result, followed by a space if it's not the last word\n            result.append(new String(chars));\n            if (!word.equals(words[words.length - 1])) {\n                result.append(\" \");\n            }\n        }\n        \n        return result.toString();\n    }\n\n    /**\n     * Test method for anti_shuffle function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Initialize a list to store the coordinates of occurrences of x.\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D data structure.\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            // For each element in the current row, check if it matches x.\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // If a match is found, add its coordinates to the result list.\n                    List<Integer> coordinate = new ArrayList<>();\n                    coordinate.add(i);\n                    coordinate.add(j);\n                    result.add(coordinate);\n                }\n            }\n        }\n\n        // Sort the result by row in ascending order and then by column in descending order.\n        Collections.sort(result, (a, b) -> {\n            if (!a.get(0).equals(b.get(0))) {\n                return a.get(0) - b.get(0);  // Ascending sort on rows\n            } else {\n                return b.get(1) - a.get(1);  // Descending sort on columns within the same row\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        // Test case 2\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        // Test case 3\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int sum = array.get(0) + array.get(array.size() - 1);\n        \n        // Create a copy of the original list to avoid modifying it\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Sort in ascending order if the sum is odd, otherwise sort in descending order\n        if (sum % 2 == 0) {\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts the given string by rotating each letter down by 4 places in the alphabet.\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                encrypted.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not changed\n                encrypted.append(c);\n            }\n        }\n\n        return encrypted.toString();\n    }\n\n    /**\n     * Test method for the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\")); // Expected: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\")); // Expected: \"kj\"\n        System.out.println(solution.encrypt(\"et\")); // Expected: \"ix\"\n        System.out.println(solution.encrypt(\"Hello, World!\")); // Expected: \"Lipps, Asvph!\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * Return Optional.empty if there is no such element.\n     */\n    public static Optional<Integer> next_smallest(List<Integer> lst) {\n        // Check for null or empty list\n        if (lst == null || lst.isEmpty()) {\n            return Optional.empty();\n        }\n\n        Integer firstMin = null;\n        Integer secondMin = null;\n\n        for (Integer num : lst) {\n            if (num.equals(firstMin)) continue; // Skip duplicates of the smallest number\n\n            if (firstMin == null || num < firstMin) {\n                secondMin = firstMin;  // Update secondMin to current firstMin\n                firstMin = num;        // Update firstMin with new minimum\n            } else if ((secondMin == null && num != firstMin) || (num < secondMin)) {\n                secondMin = num;       // Update secondMin with new second smallest number\n            }\n        }\n\n        return Optional.ofNullable(secondMin);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(next_smallest(Arrays.asList(1, 2, 3, 4, 5)));   // Expected: Optional[2]\n        System.out.println(next_smallest(Arrays.asList(5, 1, 4, 3, 2)));   // Expected: Optional[2]\n        System.out.println(next_smallest(Arrays.asList()));                 // Expected: Optional.empty\n        System.out.println(next_smallest(Arrays.asList(1, 1)));            // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a given string.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!' characters.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the input string into sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            // Trim leading and trailing spaces from each sentence\n            String trimmedSentence = sentence.trim();\n            \n            // Check if the first word of the sentence is \"I\" (case-insensitive)\n            if (!trimmedSentence.isEmpty() && trimmedSentence.toLowerCase().startsWith(\"i \")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. I will go for a walk. It's sunny outside.\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if one number is the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes a message by swapping case of all letters and replacing vowels \n     * with the letter that appears 2 places ahead in the English alphabet.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                switch(swappedCaseChar) {\n                    case 'a', 'A' -> encodedMessage.append(\"c\");\n                    case 'e', 'E' -> encodedMessage.append(\"g\");\n                    case 'i', 'I' -> encodedMessage.append(\"k\");\n                    case 'o', 'O' -> encodedMessage.append(\"q\");\n                    case 'u', 'U' -> encodedMessage.append(\"w\");\n                    default -> encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are not modified\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\"));  // Expected output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected output: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!!!\"));  // Expected output: \"hKLLQ wRLLD!!!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime number in a list and returns the sum of its digits.\n     */\n    public int sumOfLargestPrimeDigits(List<Integer> lst) {\n        // Helper method to check if a number is prime\n        return lst.stream()\n                .filter(this::isPrime)\n                .max(Integer::compare)\n                .map(num -> digitSum(num))\n                .orElse(0);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    private int digitSum(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst1)); // Expected output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst2)); // Expected output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst3)); // Expected output: 13\n        \n        List<Integer> lst4 = Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst4)); // Expected output: 11\n        \n        List<Integer> lst5 = Arrays.asList(0,81,12,3,1,21);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst5)); // Expected output: 3\n        \n        List<Integer> lst6 = Arrays.asList(0,8,1,2,1,7);\n        System.out.println(solution.sumOfLargestPrimeDigits(lst6)); // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case,\n     * else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;  // If any key is not a string, return false.\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        // If the dictionary is not empty and either all keys are in lower case or upper case, return true.\n        return !dict.isEmpty() && (allLowerCase || allUpperCase);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> test1 = new HashMap<>();\n        test1.put(\"a\", \"apple\");\n        test1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(test1));  // Expected: true\n\n        Map<Object, Object> test2 = new HashMap<>();\n        test2.put(\"a\", \"apple\");\n        test2.put(\"A\", \"banana\");\n        test2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(test2));  // Expected: false\n\n        Map<Object, Object> test3 = new HashMap<>();\n        test3.put(\"a\", \"apple\");\n        test3.put(8, \"banana\");  // Note that '8' is not a string\n        test3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(test3));  // Expected: false\n\n        Map<Object, Object> test4 = new HashMap<>();\n        test4.put(\"Name\", \"John\");\n        test4.put(\"Age\", \"36\");\n        test4.put(\"City\", \"Houston\");\n        System.out.println(solution.check_dict_case(test4));  // Expected: false\n\n        Map<Object, Object> test5 = new HashMap<>();\n        test5.put(\"STATE\", \"NC\");\n        test5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(test5));  // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers by taking modulo 10\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of these unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 1; i < s.length(); i += 2) { // Start from index 1 to check only even positions\n            char c = s.charAt(i);\n            if (\"AEIOU\".indexOf(c) != -1) { // Check if the character is an uppercase vowel\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     * For example closest_integer(\"14.5\") should return 15 and\n     * closest_integer(\"-14.5\") should return -15.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is positive or negative for rounding away from zero\n        if (num > 0) {\n            return (int)(num + 0.5);\n        } else {\n            return (int)(num - 0.5);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n        System.out.println(solution.closest_integer(\"2.5\"));  // Output: 3\n        System.out.println(solution.closest_integer(\"-2.5\")); // Output: -3\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            pile.add(currentStones);\n            // Determine the next number of stones based on whether the current number is odd or even\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n\n        return pile;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: n = 3\n        System.out.println(solution.make_a_pile(3)); // Expected output: [3, 5, 7]\n        \n        // Test case 2: n = 4\n        System.out.println(solution.make_a_pile(4)); // Expected output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a string into words based on commas and spaces.\n     *\n     * @param s The input string to split.\n     * @return A List of strings representing the words in the input string.\n     */\n    public List<String> words_string(String s) {\n        // Split the string using regex that matches both comma and space as delimiters\n        String[] parts = s.split(\"[,\\\\s]+\");\n        \n        // Convert array to list for easier handling\n        return Arrays.asList(parts);\n    }\n\n    // Method to test the functionality of words_string method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1);  // Expected: [Hi, my, name, is, John]\n        \n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2);  // Expected: [One, two, three, four, five, six]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        if (x > y) return -1; // If the range is invalid\n\n        // Ensure x is even and within bounds\n        if (x % 2 != 0) x++;\n\n        // Check if there's an even number in the range [x, y]\n        while (x <= y && x % 2 == 0) {\n            return x;\n        }\n\n        return -1; // No even number found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 8));   // Expected output: 8 (if 8 is even)\n        System.out.println(solution.choose_num(9, 9));   // Expected output: -1 (since 9 is odd and no range to find an even number)\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum of integers from n to m\n        long totalSum = 0;\n        for (int i = n; i <= m; i++) {\n            totalSum += i;\n        }\n\n        // Calculate the average and round it to the nearest integer\n        int roundedAvg = Math.round(totalSum / (m - n + 1));\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        return result;\n    }\n\n    private boolean hasEvenDigit(int number) {\n        while (number > 0) {\n            int digit = number % 10; // Get the last digit\n            if (digit % 2 == 0) { // Check if it's even\n                return true;\n            }\n            number /= 10; // Remove the last digit\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(19, 27, 35, 48);\n        System.out.println(solution.unique_digits(test3)); // Expected: [19, 27, 35]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Create a list of strings representing the digits 1 through 9.\n        String[] digitNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter and sort the input array, keeping only numbers between 1 and 9\n        List<Integer> filteredSortedArr = arr.stream()\n            .filter(num -> num >= 1 && num <= 9)\n            .sorted()\n            .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredSortedArr);\n        \n        // Map each integer to its corresponding string representation.\n        List<String> result = new ArrayList<>();\n        for (Integer num : filteredSortedArr) {\n            result.add(digitNames[num - 1]);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n        \n        // Test case 2\n        List<Integer> arr2 = Arrays.asList();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n        \n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n        \n        // Additional test cases\n        System.out.println(solution.f(3)); // Expected output: [1, 2, 6]\n        System.out.println(solution.f(7)); // Expected output: [1, 2, 6, 24, 15, 120, 28]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int num) {\n        String strNum = Integer.toString(num);\n        int left = 0, right = strNum.length() - 1;\n\n        while (left < right) {\n            if (strNum.charAt(left++) != strNum.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> result1 = solution.even_odd_palindrome(3);\n        System.out.println(\"Test Case 1: \" + result1); // Expected output: [1, 2]\n\n        // Test case 2\n        List<Integer> result2 = solution.even_odd_palindrome(12);\n        System.out.println(\"Test Case 2: \" + result2); // Expected output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) {\n                digit = -digit; // Make positive digits negative for the first occurrence\n            }\n            sum += digit;\n            num /= 10;\n            isNegative &= digit < 0; // Continue marking as negative until a non-negative digit appears\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true; // An empty list is considered sorted.\n        \n        int N = arr.size();\n        List<Integer> shiftedArr = new ArrayList<>(arr);\n        \n        for (int i = 0; i < N; i++) { // Try all possible shifts\n            Collections.rotate(shiftedArr, -1); // Perform a left shift to simulate right shifting the original array\n            \n            if (isNonDecreasing(shiftedArr)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n    private boolean isNonDecreasing(List<Integer> arr) {\n        for (int i = 0; i < arr.size() - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether it is possible to exchange elements between lst1 and lst2\n     * to make lst1 a list of only even numbers.\n     *\n     * @param lst1 The first list of integers.\n     * @param lst2 The second list of integers.\n     * @return \"YES\" if all elements in lst1 can be made even by exchanging with lst2, otherwise \"NO\".\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count the number of odd numbers in lst1 and even numbers in lst2\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // If there are more odd numbers in lst1 than even numbers in lst2, it's impossible to make all elements of lst1 even\n        return oddCountInLst1 <= evenCountInLst2 ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters,\n     * return a dictionary of the letter with the most repetition and containing the corresponding count.\n     * If several letters have the same occurrence, return all of them.\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into an array of words\n        String[] words = test.split(\" \");\n        \n        // Create a map to store letter counts\n        Map<String, Integer> countMap = new HashMap<>();\n        \n        // Count occurrences of each letter\n        for (String word : words) {\n            if (!word.isEmpty()) {  // Ensure the word is not an empty string\n                countMap.put(word, countMap.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Find the maximum occurrence value\n        int maxCount = Collections.max(countMap.values());\n\n        // Create a result map to store letters with the highest occurrences\n        Map<String, Integer> result = new HashMap<>();\n        \n        // Add all entries from countMap that have the maxCount to result\n        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n        \n        // Print in a format similar to Python's dict\n        for (Map.Entry<String, Integer> entry : solution.histogram(\"a b c\").entrySet()) {\n            System.out.print(entry.getKey() + \": \" + entry.getValue() + \", \");\n        }\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Remove all characters in 's' that are present in 'c'\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!c.contains(Character.toString(ch))) {\n                result.append(ch);\n            }\n        }\n\n        // Check if the resulting string is a palindrome\n        String reversedResult = result.reverse().toString();\n        boolean isPalindrome = result.toString().equals(reversedResult);\n\n        // Return the result as a list containing the modified string and the palindrome check\n        List<Object> output = new ArrayList<>();\n        output.add(result.toString());\n        output.add(isPalindrome);\n        return output;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [\"bcd\", false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Expected: [\"acdef\", false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Expected: [\"cdedc\", true]\n\n        // Additional test cases\n        System.out.println(solution.reverse_delete(\"\", \"\"));          // Expected: [\"\", true]\n        System.out.println(solution.reverse_delete(\"madam\", \"d\"));   // Expected: [\"maa\", false]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1)); // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2)); // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize variables to store the current and minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum by considering including or excluding the current element\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if the current one is smaller\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of times buckets need to be lowered to empty all wells.\n     *\n     * @param grid A list of lists representing the grid of wells, where each 1 represents a unit of water.\n     * @param capacity The capacity of each bucket used to extract water from the wells.\n     * @return The total number of times buckets need to be lowered to empty all wells.\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Sum up all units of water in the grid\n        int totalWaterUnits = 0;\n        for (List<Integer> row : grid) {\n            for (int unit : row) {\n                totalWaterUnits += unit;\n            }\n        }\n\n        // Calculate how many times buckets need to be lowered\n        return (totalWaterUnits + capacity - 1) / capacity; // Ceiling division\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Expected output: 6\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Expected output: 5\n\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation.\n     * For similar number of ones, sort based on decimal value.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Custom comparator\n        Comparator<Integer> customComparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                int countA = Integer.bitCount(a);\n                int countB = Integer.bitCount(b);\n\n                if (countA != countB) {\n                    return countA - countB;\n                } else {\n                    return a - b; // Sort by decimal value\n                }\n            }\n        };\n\n        // Sorting the list using the custom comparator\n        Collections.sort(arr, customComparator);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1)); // Expected: [1, 2, 4, 3, 5]\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2)); // Expected: [-4, -2, -6, -5, -3]\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3)); // Expected: [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a set of consonants for easy checking\n        Set<Character> consonants = new HashSet<>(Arrays.asList(\n                'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',\n                'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'\n        ));\n\n        List<String> result = new ArrayList<>();\n        for (String word : s.split(\"\\\\s+\")) {\n            int consonantCount = 0;\n            for (char c : word.toLowerCase().toCharArray()) {\n                if (consonants.contains(c)) {\n                    consonantCount++;\n                }\n            }\n\n            // Check if the current word has exactly n consonants\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the closest vowel that stands between two consonants from the right side of the word.\n     *\n     * @param word The input string containing only English letters.\n     * @return The closest vowel meeting the condition, or an empty string if none found.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            \n            if (!vowels.contains(leftChar) && !vowels.contains(middleChar)) {\n                if (vowels.contains(word.charAt(i + 1))) { // Check the right neighbor\n                    return String.valueOf(word.charAt(i));\n                }\n            }\n        }\n\n        return \"\"; // Return empty string if no vowel meets the condition\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order \n     * such that the resulting string is balanced.\n     */\n    public String match_parens(List<String> lst) {\n        // Check all combinations: str1 + str2 and str2 + str1\n        return (isBalanced(lst.get(0) + lst.get(1)) || isBalanced(lst.get(1) + lst.get(0))) ? \"Yes\" : \"No\";\n    }\n\n    /**\n     * Helper method to check if a string of parentheses is balanced.\n     */\n    private boolean isBalanced(String str) {\n        int balance = 0;\n        for (char c : str.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            // If at any point the balance goes negative, it's not balanced\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // The string is balanced only if the final balance is zero\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\"))); // Expected output: \"Yes\"\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));   // Expected output: \"No\"\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \")\"))); // Expected output: \"Yes\"\n        System.out.println(solution.match_parens(Arrays.asList(\"(\", \"(\")));   // Expected output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap) to store the top k elements\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k);\n        \n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.offer(num);  // Add element if heap size is less than k\n            } else if (num > pq.peek()) { \n                pq.poll();      // Remove the smallest element in the heap\n                pq.offer(num);  // Add the current number to the heap\n            }\n        }\n\n        // Convert priority queue to a sorted list and return it\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(solution.maximum(arr1, k1));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(solution.maximum(arr2, k2));  // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(solution.maximum(arr3, k3));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element at the current position is odd\n                sum += lst.get(i); // Add it to the sum\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(test1)); // Expected output: 12\n        \n        List<Integer> test2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(test2)); // Expected output: 9\n        \n        List<Integer> test3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(test3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Sum of elements with at most two digits from the first \" + k + \" elements: \" + solution.add_elements(testArr, k));\n        \n        // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        // Use a set to avoid duplicates and automatically keep elements sorted.\n        Set<Integer> oddNumbers = new TreeSet<>();\n\n        // Generate the Collatz sequence for the given number n.\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Apply the Collatz function.\n        }\n\n        // Add the final number in the sequence, which is always 1 (odd).\n        oddNumbers.add(1);\n\n        // Convert set to list and return it.\n        return new ArrayList<>(oddNumbers);\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check if the date is not empty and follows mm-dd-yyyy format\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3 || !date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) {\n            return false;\n        }\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is valid\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Check if the day is valid based on the month\n        switch(month) {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n            case 10:\n            case 12: \n                if (day < 1 || day > 31) return false;\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                if (day < 1 || day > 30) return false;\n                break;\n            case 2: \n                // Check for leap year\n                boolean isLeapYear = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n                if (!isLeapYear && day > 28) return false;\n                else if (isLeapYear && day > 29) return false;\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n}\n"}
{"task_id": "Java/125", "generation": "class Solution {\n    public Object split_words(String txt) {\n        // Check for spaces first\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) return Arrays.asList(words);\n\n        // If no spaces, check for commas\n        words = txt.split(\",\");\n        if (words.length > 1) return Arrays.asList(words);\n\n        // Count lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) count++;\n            }\n        }\n\n        return count;\n    }\n\n    // Test code to verify the correctness of the split_words method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // Check if the list is empty or contains a single element, which is always considered sorted.\n        if (lst.size() <= 1) return true;\n\n        int count = 1; // To keep track of consecutive duplicates\n        Integer previousNumber = null; // To store the last seen number\n\n        for (Integer currentNumber : lst) {\n            // Check if the list is not in ascending order.\n            if (previousNumber != null && currentNumber < previousNumber) return false;\n\n            // Count occurrences of each number and check if any number appears more than twice.\n            if (currentNumber.equals(previousNumber)) {\n                count++;\n                if (count > 2) return false;\n            } else {\n                count = 1; // Reset the count for a new number\n            }\n\n            previousNumber = currentNumber; // Update the last seen number\n        }\n        \n        return true; // The list is sorted and no number appears more than twice.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks whether the given number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Determines whether the length of intersection of two intervals is a prime number.\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = Math.max(interval1.get(0), interval2.get(0));\n        int end1 = Math.min(interval1.get(1), interval2.get(1));\n\n        // Check if there is an intersection\n        if (start1 > end1) return \"NO\";\n\n        int lengthOfIntersection = end1 - start1 + 1;\n\n        // Check if the length of intersection is a prime number\n        return isPrime(lengthOfIntersection) ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of magnitudes of integers multiplied by the product of all signs.\n     *\n     * @param arr List of integers.\n     * @return Optional<Integer> containing the result or empty if the list is empty.\n     */\n    public static Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            // Update the sum of magnitudes\n            sumOfMagnitudes += Math.abs(num);\n\n            // Update the product of signs\n            if (num == 0) {\n                return Optional.of(0); // If there's a zero, result is zero.\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // Right, Down, Up, Left\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        boolean[][] visited = new boolean[N][N];\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                dfs(grid, k, i, j, new ArrayList<>(), visited, result);\n            }\n        }\n\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, int row, int col, List<Integer> path, boolean[][] visited, List<Integer> result) {\n        if (path.size() == k) {\n            if (result.isEmpty() || isLexicographicallySmaller(path, result)) {\n                result.clear();\n                result.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol, visited)) {\n                path.add(grid.get(newRow).get(newCol));\n                visited[newRow][newCol] = true;\n                dfs(grid, k, newRow, newCol, path, visited, result);\n                visited[newRow][newCol] = false;\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isValid(List<List<Integer>> grid, int row, int col, boolean[][] visited) {\n        return row >= 0 && row < grid.size() && col >= 0 && col < grid.get(0).size() && !visited[row][col];\n    }\n\n    private boolean isLexicographicallySmaller(List<Integer> path1, List<Integer> path2) {\n        int size = Math.min(path1.size(), path2.size());\n        for (int i = 0; i < size; i++) {\n            if (!path1.get(i).equals(path2.get(i))) {\n                return path1.get(i) < path2.get(i);\n            }\n        }\n        return path1.size() < path2.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Generates the first n + 1 numbers of a custom Tribonacci-like sequence.\n     */\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>(); // Handle invalid input\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i == 1) {\n                result.add(3); // Base case\n            } else if (i % 2 == 0) {\n                result.add(1 + i / 2);\n            } else {\n                int prevPrev = i - 2 > 0 ? result.get(i - 2) : 3; // Handle edge cases for odd n\n                int prev = i - 1 > 0 ? result.get(i - 1) : 3;\n                int next = i + 1 <= n ? tri(n).get(i) : 3; // This line is problematic as it would cause infinite recursion.\n                \n                // Correcting the problematic part with a proper approach\n                if (i == 3) {\n                    result.add(prevPrev + prev + 3); // Assuming tri(4) = 3 for simplicity\n                } else {\n                    throw new IllegalArgumentException(\"Invalid input or sequence definition.\");\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.tri(0)); // Should print [1]\n        System.out.println(solution.tri(3)); // Should print [1, 3, 2, 8] based on the given rules\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if there is at least one nested bracket in the input string.\n     *\n     * @param string The input string containing only square brackets.\n     * @return true if there is at least one nested bracket, false otherwise.\n     */\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean hasNested = false;\n\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n                // If the balance is greater than 1 at any point, there's a nested bracket.\n                if (balance > 0) {\n                    hasNested = true;\n                }\n            }\n\n            // Early exit if we find that nesting occurs\n            if (hasNested) return true;\n\n            // Ensure no unbalanced brackets are left open or closed without being opened first\n            if (balance < 0) {\n                return false; // Unbalanced closing bracket found before finding a nested one.\n            }\n        }\n\n        // If balance is not zero, the string has unmatched brackets and is invalid.\n        return balance == 0 && hasNested;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            double ceilValue = Math.ceil(num);\n            sum += (int)(ceilValue * ceilValue);\n        }\n        return sum;\n    }\n\n    // Test function to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Expected output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Expected output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Expected output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Expected output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character of a given string is an alphabetical character and is not part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * Examples:\n     * check_if_last_char_is_a_letter(\"apple pie\") -> false\n     * check_if_last_char_is_a_letter(\"apple pi e\") -> true\n     * check_if_last_char_is_a_letter(\"apple pi e \") -> false\n     * check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n\n        int length = txt.length();\n        char lastChar = txt.charAt(length - 1);\n\n        // Check if the last character is an alphabetical character and not part of a word\n        boolean isLastCharAlphabetical = Character.isLetter(lastChar);\n        boolean isNotPartOfWord = (length > 1 && !Character.isWhitespace(txt.charAt(length - 2)));\n\n        return isLastCharAlphabetical && isNotPartOfWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(solution.can_arrange(test1)); // Expected output: 3\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.can_arrange(test2)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!largestNegative.isPresent() || num > largestNegative.get())) {\n                largestNegative = Optional.of(num);\n            } else if (num > 0 && (!smallestPositive.isPresent() || num < smallestPositive.get())) {\n                smallestPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Additional test cases can be added here to further validate the solution.\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object value) {\n        if (value instanceof String) {\n            String strValue = ((String) value).replace(',', '.');\n            try {\n                return Double.parseDouble(strValue);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + value, e);\n            }\n        }\n\n        if (value instanceof Integer) {\n            return ((Integer) value).doubleValue();\n        }\n\n        if (value instanceof Float) {\n            return ((Float) value).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + value.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly 4 positive even numbers, \n        // the minimum possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, the condition to check is whether n - 8 can be divided into three positive even parts.\n        // This means that n must be at least 10 (since 2+2+2+4=10) and a multiple of 2 beyond 8.\n\n        // Since we are adding four even numbers, the result will always be divisible by 4 if it's possible.\n        return n % 4 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_equal_to_sum_even(4)); // false\n        System.out.println(solution.is_equal_to_sum_even(6)); // false\n        System.out.println(solution.is_equal_to_sum_even(8)); // true\n        System.out.println(solution.is_equal_to_sum_even(10)); // true\n        System.out.println(solution.is_equal_to_sum_even(12)); // true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n\n            if (c == ' ') {\n                spaceCount++;\n                // If more than two consecutive spaces, replace them with '-'\n                if (spaceCount > 2) continue;\n            } else {\n                // Replace single or double spaces with '_'\n                for (int j = Math.max(0, spaceCount - 1); j < spaceCount; j++) {\n                    result.append('_');\n                }\n                spaceCount = 0;\n            }\n\n            if (spaceCount == 3) {\n                result.append('-');\n                spaceCount = 0;\n            } else {\n                result.append(c);\n            }\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.setLength(result.length() - spaceCount + 1); // Remove extra underscores and add '-'\n            result.append('-');\n        } else {\n            for (int j = Math.max(0, spaceCount - 1); j < spaceCount; j++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fix_spaces(\"Example\")); // Expected: \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\")); // Expected: \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\")); // Expected: \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\")); // Expected: \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file's name is valid according to specific rules.\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot in the filename\n        int dotCount = 0;\n        for (int i = 0; i < file_name.length(); i++) {\n            char c = file_name.charAt(i);\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n        if (dotCount != 1) {\n            return \"No\";\n        }\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2 || parts[0].isEmpty()) {\n            return \"No\";\n        }\n\n        // Check if the part before the dot starts with a letter and contains at most three digits\n        boolean validStart = Character.isLetter(parts[0].charAt(0));\n        int digitCount = 0;\n        for (int i = 1; i < parts[0].length(); i++) {\n            char c = parts[0].charAt(i);\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (!validStart || digitCount > 3) {\n            return \"No\";\n        }\n\n        // Check the extension\n        String extension = parts[1];\n        List<String> validExtensions = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validExtensions.contains(extension)) {\n            return \"No\";\n        }\n\n        return \"Yes\";\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file.exe\"));     // Expected: Yes\n        System.out.println(solution.file_name_check(\"file.abc\"));     // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n            if (i % 3 == 0) {\n                // Square the number if index is a multiple of 3\n                sum += Math.pow(num, 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the number if index is a multiple of 4 but not 3\n                sum += Math.pow(num, 3);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sum_squares(lst1)); // Expected output: 6\n\n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(solution.sum_squares(lst2)); // Expected output: 0\n\n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(solution.sum_squares(lst3)); // Expected output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Returns words with prime length from the sentence.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String sentence1 = \"This is a test\";\n        System.out.println(solution.words_in_sentence(sentence1)); // Expected output: \"is\"\n        \n        String sentence2 = \"lets go for swimming\";\n        System.out.println(solution.words_in_sentence(sentence2)); // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n.\n     * Returns true if x * n evaluates to a whole number and false otherwise.\n     * Both x and n are string representations of fractions in the format <numerator>/<denominator>.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] fractionX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(fractionX[0]);\n        int denominatorX = Integer.parseInt(fractionX[1]);\n\n        String[] fractionN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(fractionN[0]);\n        int denominatorN = Integer.parseInt(fractionN[1]);\n\n        // Multiply the fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // Expected: true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // Expected: false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts a list of integers according to the sum of their digits.\n     * If multiple items have the same sum of digits, order them based on their index in the original list.\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a map to store each number and its digit sum\n        Map<Integer, Integer> numToDigitSum = new HashMap<>();\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums.get(i);\n            int digitSum = getDigitSum(num);\n            numToDigitSum.put(num, digitSum);\n        }\n        \n        // Sort the list based on digit sum and original index\n        Collections.sort(nums, (a, b) -> {\n            Integer digitSumA = numToDigitSum.get(a);\n            Integer digitSumB = numToDigitSum.get(b);\n            \n            if (!digitSumA.equals(digitSumB)) {\n                return digitSumA - digitSumB;\n            } else {\n                // Find the original index of a and b\n                int indexA = nums.indexOf(a);\n                int indexB = nums.indexOf(b);\n                \n                return Integer.compare(indexA, indexB);\n            }\n        });\n        \n        return nums;\n    }\n\n    /**\n     * Helper method to calculate the sum of digits of an integer.\n     */\n    private int getDigitSum(int num) {\n        int sum = 0;\n        while (num != 0) {\n            sum += Math.abs(num % 10);\n            num /= num > 0 ? 10 : -10; // Handle negative numbers\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(testList1)); // Expected: [-1, -11, 1, -12, 11]\n        \n        List<Integer> testList2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(testList2)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, -73, 14, -15);\n        System.out.println(solution.specialFilter(test1)); // Expected output: 1\n\n        List<Integer> test2 = Arrays.asList(33, -2, -3, 45, 21, 109);\n        System.out.println(solution.specialFilter(test2)); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count the number of valid triples\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Test the solution with an example\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int n = 5; // Example input\n        System.out.println(sol.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns a list of planets whose orbits are located between the orbit of planet1 and the orbit of planet2.\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define an array with all planets in order from closest to farthest from the Sun\n        String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n        \n        // Find the indices of planet1 and planet2 in the array\n        int index1 = -1;\n        int index2 = -1;\n\n        for (int i = 0; i < planets.length; i++) {\n            if (planets[i].equals(planet1)) {\n                index1 = i;\n            }\n            if (planets[i].equals(planet2)) {\n                index2 = i;\n            }\n\n            // If both indices are found, break the loop\n            if (index1 != -1 && index2 != -1) {\n                break;\n            }\n        }\n\n        // Check if either planet is not valid\n        if (index1 == -1 || index2 == -1) {\n            return new ArrayList<>();\n        }\n\n        // Ensure index1 < index2 for correct order\n        int start = Math.min(index1, index2);\n        int end = Math.max(index1, index2);\n\n        // Create a list of planets between the two indices (inclusive)\n        List<String> result = new ArrayList<>();\n        for (int i = start; i <= end; i++) {\n            result.add(planets[i]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Accepts a list of strings, deletes the strings that have odd lengths,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     */\n    public List<String> filterAndSort(List<String> lst) {\n        // Remove strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Sort the list by length and then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return Integer.compare(s1.length(), s2.length());\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return filteredList;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.filterAndSort(test1));  // Expected: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.filterAndSort(test2));  // Expected: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));    // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List of objects (integers expected)\n     * @return Sum of squares of positive odd integers from the list\n     */\n    public int sumOfSquaresForOddNumbers(List<Object> lst) {\n        int sum = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) { // Check if the object is an integer\n                int num = (Integer) obj; // Cast to integer\n                if (num > 0 && num % 2 != 0) { // Check if positive and odd\n                    sum += num * num; // Add square of number to sum\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(1, 3, 2, 0))); // Should print 10\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(-1, -2, 0))); // Should print 0\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(9, -2))); // Should print 81\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(0))); // Should print 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list against the corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class name.\n     *\n     * @param class_name The name of the class to which extensions are being added.\n     * @param extensions A list of extension names.\n     * @return A string in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        // Initialize variables to track the strongest extension and its strength\n        String strongest_extension = \"\";\n        int max_strength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            // Calculate the strength of the current extension\n            int strength = calculateStrength(extension);\n\n            // Update the strongest extension if necessary\n            if (strength > max_strength || (strength == max_strength && strongest_extension.equals(\"\"))) {\n                strongest_extension = extension;\n                max_strength = strength;\n            }\n        }\n\n        return class_name + \".\" + strongest_extension;\n    }\n\n    /**\n     * Calculates the strength of an extension based on uppercase and lowercase letters.\n     *\n     * @param extension The name of the extension to calculate strength for.\n     * @return The calculated strength as an integer (CAP - SM).\n     */\n    private int calculateStrength(String extension) {\n        int cap = 0;\n        int sm = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                cap++;\n            } else if (Character.isLowerCase(c)) {\n                sm++;\n            }\n        }\n\n        return cap - sm;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\")));  // Expected: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\")));                      // Expected: my_class.AA\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the second word or any of its rotations is a substring in the first word.\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate 'a' with itself to handle rotation checks easily\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated string\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a list that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *     even_odd_count(-12) ==> [1, 1]\n     *     even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        int even = 0;\n        int odd = 0;\n\n        // Handle negative numbers\n        if (num < 0) {\n            num = -num; // Make the number positive to simplify digit extraction\n        }\n\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n            num /= 10;\n        }\n\n        return Arrays.asList(even, odd);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_count(-12)); // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123)); // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define arrays for roman numerals and their integer values.\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral string.\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is 90 degrees.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure c is the longest side (hypotenuse)\n        if (a > c) {\n            int temp = a;\n            a = c;\n            c = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If multiple words have the same number of unique characters,\n     * returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to track the word with maximum unique characters\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> charSet = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                charSet.add(c);\n            }\n\n            // Check if this word has more unique characters than the current max\n            if (charSet.size() > maxUniqueChars || \n                (charSet.size() == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = charSet.size();\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\")));  // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\")));  // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));   // Output: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate how many carrots are left after eating.\n        int leftOver = Math.max(0, remaining - need);\n\n        // Return a list containing the total number of eaten carrots and the leftover carrots.\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a stack to hold operators and operands\n        Stack<String> ops = new Stack<>();\n        Stack<Integer> nums = new Stack<>();\n\n        // Add an initial dummy operator to handle the last number correctly\n        ops.push(\"+\");\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int num = operand.get(i);\n\n            while (!ops.isEmpty() && precedence(ops.peek(), op)) {\n                applyOperation(nums, ops);\n            }\n            ops.push(op);\n            nums.push(num);\n        }\n\n        // Process the remaining operators\n        while (!ops.isEmpty()) {\n            applyOperation(nums, ops);\n        }\n\n        return nums.pop();\n    }\n\n    private void applyOperation(Stack<Integer> nums, Stack<String> ops) {\n        int b = nums.pop();\n        int a = nums.pop();\n        String op = ops.pop();\n\n        switch (op) {\n            case \"+\":\n                nums.push(a + b);\n                break;\n            case \"-\":\n                nums.push(a - b);\n                break;\n            case \"*\":\n                nums.push(a * b);\n                break;\n            case \"/\":\n                nums.push(a / b); // Assuming a > 0 and b > 0 for simplicity\n                break;\n            case \"**\":\n                nums.push((int) Math.pow(a, b));\n                break;\n        }\n    }\n\n    private boolean precedence(String op1, String op2) {\n        if ((op1.equals(\"*\") || op1.equals(\"/\")) && (op2.equals(\"+\") || op2.equals(\"-\"))) return false;\n        else return true;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> operators = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands = Arrays.asList(2, 3, 4, 5);\n        int result = solution.do_algebra(operators, operands);\n\n        System.out.println(\"Result: \" + result); // Expected output is 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * If s[i] is a letter, reverse its case from lower to upper or vice versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters, reverse the string\n        if (!hasLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        \n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add leading zeros to make sure hash is 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that 'a' is less than or equal to 'b'\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> evenDigits = new ArrayList<>();\n        for (int i = 2; i <= 8 && i <= b; i += 2) { // Only consider numbers from 2 to 8\n            if (i >= a) {\n                evenDigits.add(i);\n            }\n        }\n        return evenDigits;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.generate_integers(2, 8)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        Collections.sort(numbers); // Sort the list first\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) <= threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(result1); // Expected output: false\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(result2); // Expected output: true\n\n        // Additional test case\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.8, 11.0, 12.5), 0.4);\n        System.out.println(result3); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Separates a string containing multiple groups of nested parentheses into separate strings.\n     * Each group is balanced and not nested within each other. Spaces in the input are ignored.\n     *\n     * @param paren_string The input string containing groups of nested parentheses.\n     * @return A list of strings, where each string represents a separated group of parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from the input string\n        String noSpaceString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        int start = 0;\n        for (int i = 0; i < noSpaceString.length(); i++) {\n            if (noSpaceString.charAt(i) == '(' || noSpaceString.charAt(i) == ')') {\n                // Check if the current character is an opening parenthesis\n                if (noSpaceString.charAt(i) == '(') {\n                    int balance = 1;\n                    for (int j = i + 1; j < noSpaceString.length(); j++) {\n                        char c = noSpaceString.charAt(j);\n                        if (c == '(') {\n                            balance++;\n                        } else if (c == ')') {\n                            balance--;\n                        }\n                        // When the group is balanced, add it to the result\n                        if (balance == 0) {\n                            result.add(noSpaceString.substring(start, j + 1));\n                            start = j + 1;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> groups = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : groups) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance ever goes below zero.\n     *\n     * @param operations List of Integer representing deposit and withdrawal operations.\n     * @return true if at any point the balance falls below zero, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Starting with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance went below zero\n            }\n        }\n        return false; // No point where balance was below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be empty or null\");\n        }\n\n        // Calculate the mean\n        double sum = 0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>(2 * numbers.size());\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i != numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Empty list\n        System.out.println(solution.intersperse(new ArrayList<>(), 4)); // Expected output: []\n\n        // Test case 2: List with elements\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.parse_nested_parens(\"(()()) ((())) () ((())()())\");\n        \n        System.out.println(result); // Expected output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Create a new ArrayList to store the filtered results\n        List<String> result = new ArrayList<>();\n        \n        // Iterate through each string in the input list\n        for (String str : strings) {\n            // Check if the current string contains the given substring\n            if (str.contains(substring)) {\n                // If it does, add it to the result list\n                result.add(str);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyListResult = solution.sum_product(new ArrayList<>());\n        System.out.println(\"Empty list result: \" + emptyListResult); // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        List<Integer> resultList = solution.sum_product(numbers);\n        System.out.println(\"Sum and product of the list: \" + resultList); // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) return Collections.emptyList();\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        System.out.println(solution.rolling_max(testList1)); // Expected: [1, 2, 3, 3, 3, 4, 4]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, 6, 7, 2);\n        System.out.println(solution.rolling_max(testList2)); // Expected: [5, 5, 6, 7, 7]\n        \n        // Test case 3 (empty list)\n        List<Integer> testList3 = new ArrayList<>();\n        System.out.println(solution.rolling_max(testList3)); // Expected: []\n\n        // Test case 4 (null input)\n        List<Integer> testList4 = null;\n        System.out.println(solution.rolling_max(testList4)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        // If the input string is empty, return an empty string\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        int n = string.length();\n        for (int i = 0; i < n; ++i) {\n            // Check for palindrome starting from index i to end of the string\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // Append reverse of prefix before palindromic suffix to make a palindrome\n                return string + new StringBuilder(string.substring(0, i)).reverse().toString();\n            }\n        }\n\n        // If no palindromic suffix is found, the entire string needs to be reversed and appended.\n        return string + new StringBuilder(string).reverse().toString();\n    }\n}\n"}
{"task_id": "Java/11", "generation": "class Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a The first input string.\n     * @param b The second input string.\n     * @return A string representing the result of the binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of equal length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Input strings must be of the same length\");\n        }\n\n        StringBuilder result = new StringBuilder();\n        \n        for (int i = 0; i < a.length(); i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            // Perform XOR on each pair of characters\n            if ((ca == '1' && cb == '1') || (ca == '0' && cb == '0')) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"111\", \"000\"));  // Expected output: \"111\"\n        System.out.println(solution.string_xor(\"101010\", \"010101\"));  // Expected output: \"111111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty in case the input list is empty.\n     */\n    public static Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(\"Test Case 1: \" + longest(List.of())); // Expected output: Optional.empty\n        System.out.println(\"Test Case 2: \" + longest(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: Optional[a]\n        System.out.println(\"Test Case 3: \" + longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected output: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure that both numbers are positive\n        if (a < 0 || b < 0) {\n            throw new IllegalArgumentException(\"Both numbers must be non-negative.\");\n        }\n\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a; // At this point, 'a' contains the GCD\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(7, 14)); // Expected output: 7\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5 (since GCD of any number and 0 is the number itself)\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        String input = \"abc\";\n        List<String> prefixes = solution.all_prefixes(input);\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format and returns a list of integers.\n     * Each integer corresponds to how many beats each note lasts.\n     *\n     * Legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quarter note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        List<Integer> result = new ArrayList<>();\n        String[] notes = string.split(\" \");\n        \n        for (String note : notes) {\n            switch(note) {\n                case \"o\":\n                    result.add(4);\n                    break;\n                case \"o|\":\n                    result.add(2);\n                    break;\n                case \".|\":\n                    result.add(1);\n                    break;\n                default:\n                    // Handle unexpected input if necessary\n                    System.out.println(\"Unexpected note: \" + note);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String testInput = \"o o| .| o| o| .| .| .| .| o o\";\n        List<Integer> expectedResult = Arrays.asList(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4);\n        \n        List<Integer> result = solution.parse_music(testInput);\n        System.out.println(\"Result: \" + result);\n        System.out.println(\"Expected Result: \" + expectedResult);\n        \n        // Verify the correctness of the function\n        if (result.equals(expectedResult)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/18", "generation": "class Solution {\n    /**\n     * Find how many times a given substring can be found in the original string, counting overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\npublic class TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n\n        // Additional test cases\n        System.out.println(solution.how_many_times(\"ababa\", \"aba\"));  // Expected output: 2\n        System.out.println(solution.how_many_times(\"abcde\", \"fgh\"));  // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Mapping of number words to their integer values\n        Map<String, Integer> wordToNum = new HashMap<>();\n        wordToNum.put(\"zero\", 0);\n        wordToNum.put(\"one\", 1);\n        wordToNum.put(\"two\", 2);\n        wordToNum.put(\"three\", 3);\n        wordToNum.put(\"four\", 4);\n        wordToNum.put(\"five\", 5);\n        wordToNum.put(\"six\", 6);\n        wordToNum.put(\"seven\", 7);\n        wordToNum.put(\"eight\", 8);\n        wordToNum.put(\"nine\", 9);\n\n        // Split the input string into an array of words\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its corresponding integer value and sort them\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = wordToNum.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into their string representations\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            for (Map.Entry<String, Integer> entry : wordToNum.entrySet()) {\n                if (entry.getValue().equals(num)) {\n                    result.append(entry.getKey()).append(\" \");\n                    break;\n                }\n            }\n        }\n\n        // Remove the trailing space and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight zero\")); // Expected: \"zero eight nine\"\n        System.out.println(solution.sort_numbers(\"four six two\"));    // Expected: \"two four six\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find the closest elements.\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        // Iterate through the sorted list and find the pair with the minimum difference.\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        // Return the closest elements in order.\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> list1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(list1)); // Expected: [2.0, 2.2]\n\n        // Test case 2\n        List<Double> list2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(list2)); // Expected: [2.0, 2.0]\n\n        // Additional test case\n        List<Double> list3 = Arrays.asList(1.0, 3.0, 4.0, 5.0, 6.0);\n        System.out.println(solution.find_closest_elements(list3)); // Expected: [3.0, 4.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is scaled between 0 and 1 based on its original value relative to min and max in the input list.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or throw an exception based on requirements\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (Double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Double> testList = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(solution.rescale_to_unit(testList));\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Object> list1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(list1)); // Expected: [5]\n\n        // Test case 2\n        List<Object> list2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(list2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    // Test cases to verify the functionality\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     * >>> largest_divisor(15)\n     * 5\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, which should not happen for n > 1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> primeFactors = new ArrayList<>();\n        \n        // Divide n by 2 to remove all even factors (if any)\n        while (n % 2 == 0) {\n            primeFactors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, so we can skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                primeFactors.add(i);\n                n /= i;\n            }\n        }\n\n        // This condition is to handle the case when n is a prime number greater than 2\n        if (n > 2) {\n            primeFactors.add(n);\n        }\n\n        return primeFactors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8)); // Expected output: [2, 2, 2]\n        System.out.println(solution.factorize(25)); // Expected output: [5, 5]\n        System.out.println(solution.factorize(70)); // Expected output: [2, 5, 7]\n\n        // Additional test cases\n        System.out.println(solution.factorize(13)); // Expected output: [13] (since 13 is a prime number)\n        System.out.println(solution.factorize(100)); // Expected output: [2, 2, 5, 5]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences of each number while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Collect elements that occur exactly once in the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(testList1)); // Expected: [1, 3, 4]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 6, 7, 8, 9, 5, 6);\n        System.out.println(solution.remove_duplicates(testList2)); // Expected: [7, 8, 9]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n\n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenates list of strings into a single string.\n     *\n     * @param strings List of strings to be concatenated.\n     * @return A single string that is the concatenation of all input strings.\n     */\n    public String concatenate(List<String> strings) {\n        // Initialize a StringBuilder object\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each string in the list and append it to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n\n        // Additional test cases can be added here for more thorough testing\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings starting with the prefix\n        List<String> stringList = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(stringList, \"a\")); // Should print [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of 'get_positive'\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(list1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(list2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n\n        // Exclude even numbers greater than 2\n        if (n % 2 == 0) return false;\n\n        // Test divisibility from 3 to sqrt(n)\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass SolutionTest {\n    private static final double DELTA = 1e-6; // Tolerance for floating point comparison\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases for poly method\n        System.out.println(\"Testing poly method:\");\n        testPoly(solution, Arrays.asList(1.0, 2.0), -0.5, -0.0); // f(x) = 1 + 2x at x = -0.5 should be close to 0\n        testPoly(solution, Arrays.asList(-6.0, 11.0, -6.0, 1.0), 1.0, 0.0); // (x-1)(x-2)(x-3) at x = 1 should be exactly 0\n\n        // Test cases for find_zero method\n        System.out.println(\"\\nTesting find_zero method:\");\n        testFindZero(solution, Arrays.asList(1.0, 2.0), -0.5);\n        testFindZero(solution, Arrays.asList(-6.0, 11.0, -6.0, 1.0), 1.0);\n    }\n\n    private static void testPoly(Solution solution, List<Double> coefficients, double x, double expected) {\n        double result = solution.poly(coefficients, x);\n        if (Math.abs(result - expected) <= DELTA) {\n            System.out.println(\"PASS: poly(\" + coefficients + \", \" + x + \") = \" + result);\n        } else {\n            System.out.println(\"FAIL: poly(\" + coefficients + \", \" + x + \") expected \" + expected + \" but was \" + result);\n        }\n    }\n\n    private static void testFindZero(Solution solution, List<Double> coefficients, double expected) {\n        double zero = solution.find_zero(coefficients);\n        if (Math.abs(zero - expected) <= DELTA) {\n            System.out.println(\"PASS: find_zero(\" + coefficients + \") = \" + zero);\n        } else {\n            System.out.println(\"FAIL: find_zero(\" + coefficients + \") expected \" + expected + \" but was \" + zero);\n        }\n    }\n\n    // Implement the missing find_zero method in Solution class\n    public double find_zero(List<Double> xs) {\n        // Placeholder implementation, needs to be replaced with actual logic.\n        return 0.0;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three\n     * are equal to the values of the corresponding indicies of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 and sort them\n        List<Integer> divisibleByThree = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering index starting from 1, so use (i+1)\n                divisibleByThree.add(l.get(i));\n            }\n        }\n        Collections.sort(divisibleByThree);\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace elements at indices divisible by 3 with sorted values\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering index starting from 1, so use (i+1)\n                result.set(i, divisibleByThree.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(list1)); // Expected: [1, 2, 3]\n\n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(list2)); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Using LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list in natural order\n        Collections.sort(result);\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> expectedOutput1 = Arrays.asList(0, 2, 3, 5, 9, 123);\n        assert solution.unique(testList1).equals(expectedOutput1) : \"Test case 1 failed\";\n        \n        // Test case 2\n        List<Integer> testList2 = new ArrayList<>();\n        List<Integer> expectedOutput2 = new ArrayList<>();\n        assert solution.unique(testList2).equals(expectedOutput2) : \"Test case 2 failed\";\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(1, 4, 2, 7, 5, 8);\n        List<Integer> expectedOutput3 = Arrays.asList(1, 2, 4, 5, 7, 8);\n        assert solution.unique(testList3).equals(expectedOutput3) : \"Test case 3 failed\";\n        \n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = Integer.MIN_VALUE;\n        for (int num : l) {\n            if (num > max) {\n                max = num;\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n        \n        // Test case with an empty list\n        List<Integer> list3 = new ArrayList<>();\n        try {\n            System.out.println(solution.max_element(list3));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Exception caught: \" + e.getMessage());\n        }\n        \n        // Test case with null list\n        try {\n            System.out.println(solution.max_element(null));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Exception caught: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fizz_buzz(50));  // Expected output: 0\n        System.out.println(solution.fizz_buzz(78));  // Expected output: 2 (numbers are 52 and 63)\n        System.out.println(solution.fizz_buzz(79));  // Expected output: 3 (numbers are 52, 63, and 77)\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list for storing elements at even indices\n        List<Integer> evenIndices = new ArrayList<>();\n        \n        // Extract elements from even indices and add them to the list\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndices.add(l.get(i));\n        }\n        \n        // Sort the extracted elements at even indices\n        Collections.sort(evenIndices);\n        \n        // Create a new list to store the result\n        List<Integer> sortedList = new ArrayList<>();\n        \n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) { // Even index, use sorted value from evenIndices\n                sortedList.add(evenIndices.get(evenIndex++));\n            } else { // Odd index, keep the original value\n                sortedList.add(l.get(i));\n            }\n        }\n        \n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(test1)); // Expected: [1, 2, 3]\n        \n        List<Integer> test2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(test2)); // Expected: [3, 6, 5, 4]\n\n        List<Integer> test3 = Arrays.asList(10, 15, 2, 30, 9);\n        System.out.println(solution.sort_even(test3)); // Expected: [2, 15, 9, 30, 10]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group back to original position. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        String originalString = \"abcde\";\n        String encodedString = solution.encodeCyclic(originalString);\n        System.out.println(\"Encoded: \" + encodedString);  // Expected output: \"bca\"\n        \n        String decodedString = solution.decode_cyclic(encodedString);\n        System.out.println(\"Decoded: \" + decodedString);  // Expected output: \"abcde\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int count = 0;\n        long fib1 = 0, fib2 = 1;\n\n        while (count < n) {\n            long nextFib = fib1 + fib2;\n            if (isPrime(nextFib)) {\n                primes.add((int)nextFib);\n                count++;\n            }\n            fib1 = fib2;\n            fib2 = nextFib;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(long num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (long i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_fib(1)); // Expected output: 2\n        System.out.println(solution.prime_fib(2)); // Expected output: 3\n        System.out.println(solution.prime_fib(3)); // Expected output: 5\n        System.out.println(solution.prime_fib(4)); // Expected output: 13\n        System.out.println(solution.prime_fib(5)); // Expected output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the array first for efficient searching\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; ++i) {\n            // To find the other two numbers that sum to zero with l[i]\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n\n                if (sum == 0) {\n                    return true; // Found a triplet that sums to zero\n                } else if (sum < 0) {\n                    ++left; // Increase the left index to increase the sum\n                } else {\n                    --right; // Decrease the right index to decrease the sum\n                }\n            }\n        }\n\n        return false; // No such triplet found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on an infinite straight road.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from one direction will collide with exactly one car from the opposite direction,\n        // the total number of collisions is equal to the number of cars, n.\n        return n;\n    }\n\n    /**\n     * A test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 2\n        System.out.println(solution.car_race_collision(5));  // Expected output: 5\n        System.out.println(solution.car_race_collision(0));  // Expected output: 0 (no cars, no collisions)\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + solution.incr_list(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Test Case 2: \" + solution.incr_list(list2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (Integer num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base); // Prepend the remainder to the result\n            x /= base; // Divide x by base for next iteration\n        }\n        return result.toString(); // Convert StringBuilder to String and return it\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Base = 5, Height = 3\n        System.out.println(\"Test Case 1 (Base=5, Height=3): \" + solution.triangle_area(5, 3)); // Expected output: 7.5\n        \n        // Additional test cases can be added here for further verification.\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the n-th element of the fib4 number sequence.\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1)\n            return 0;\n        else if (n == 2)\n            return 2;\n\n        // Initialize base cases\n        int[] dp = new int[4];\n        dp[0] = 0;    // fib4(0)\n        dp[1] = 0;    // fib4(1)\n        dp[2] = 2;    // fib4(2)\n\n        if (n >= 3) {\n            for (int i = 3; i <= n; i++) {\n                int nextValue = dp[0] + dp[1] + dp[2];\n                // Shift the values to the left\n                dp[3] = dp[2];\n                dp[2] = dp[1];\n                dp[1] = dp[0];\n                dp[0] = nextValue;\n            }\n        }\n\n        return dp[0];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5));  // Expected output: 4\n        System.out.println(solution.fib4(6));  // Expected output: 8\n        System.out.println(solution.fib4(7));  // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l); // Sort the list\n        \n        int n = l.size();\n        \n        if (n % 2 == 1) { // If odd, return the middle element\n            return l.get(n / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get((n - 1) / 2) + l.get(n / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.median(Arrays.asList(3, 1, 2, 4, 5))); // Expected output: 3\n        System.out.println(solution.median(Arrays.asList(-10, 4, 6, 1000, 10, 20))); // Expected output: 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "class Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If the current power is odd\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide exponent by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));    // Expected output: 1\n        System.out.println(solution.modp(3, 11));     // Expected output: 8\n        System.out.println(solution.modp(100, 101));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "class Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char base = Character.isUpperCase(ch) ? 'A' : 'a';\n                sb.append((char) ((ch - base + 5) % 26 + base));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char base = Character.isUpperCase(ch) ? 'A' : 'a';\n                sb.append((char) ((ch - base - 5 + 26) % 26 + base));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases for encodeShift and decode_shift methods\n        String testString1 = \"abc\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should print \"fgh\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should print \"abc\"\n\n        String testString2 = \"Hello, World!\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should print \"Mjqqt, Btwqi!\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should print \"Hello, World!\"\n\n        // Test with uppercase letters\n        String testString3 = \"Java\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should print \"Qfye\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should print \"Java\"\n\n        // Test with mixed case and non-letter characters\n        String testString4 = \"Alibaba Cloud!\";\n        String encoded4 = solution.encodeShift(testString4);\n        System.out.println(\"Encoded: \" + encoded4); // Should print \"Fqffnf Fwkyi!\"\n        \n        String decoded4 = solution.decode_shift(encoded4);\n        System.out.println(\"Decoded: \" + decoded4); // Should print \"Alibaba Cloud!\"\n\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define the set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        // Use a StringBuilder to build the result string without vowels\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\ng hjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + solution.below_threshold(list1, threshold1)); // Expected output: true\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + solution.below_threshold(list2, threshold2)); // Expected output: false\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(1, 2, 4, 9);\n        int threshold3 = 10;\n        System.out.println(\"Test Case 3: \" + solution.below_threshold(list3, threshold3)); // Expected output: true\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(15, 20, 25);\n        int threshold4 = 10;\n        System.out.println(\"Test Case 4: \" + solution.below_threshold(list4, threshold4)); // Expected output: false\n\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"Test Case 1: \" + (solution.add(2, 3) == 5 ? \"Passed\" : \"Failed\"));\n        System.out.println(\"Test Case 2: \" + (solution.add(5, 7) == 12 ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Use a set to store unique characters from both strings\n        Set<Character> charsSet = new HashSet<>();\n        \n        // Add all characters from the first string to the set\n        for (char c : s0.toCharArray()) {\n            charsSet.add(c);\n        }\n        \n        // Remove all characters that are also in the second string\n        for (char c : s1.toCharArray()) {\n            if (!charsSet.remove(c)) {\n                return false;  // If a character is not found, it means they don't have the same set of characters\n            }\n        }\n\n        // The set should be empty if both strings contain exactly the same unique characters\n        return charsSet.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"));  // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));                // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));               // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base cases: fib(0) = 0 and fib(1) = 1\n        \n        int a = 0, b = 1;\n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fib(10)); // Expected output: 55\n        System.out.println(solution.fib(1));  // Expected output: 1\n        System.out.println(solution.fib(8));  // Expected output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n                \n                // If at any point the balance is negative, return false\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // At the end, balance should be zero for all brackets to be correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.isEmpty() || l.size() == 1) return true; // An empty list or a single-element list is considered monotonic.\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing.\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the set back to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> result1 = solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121));\n        System.out.println(result1); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> result2 = solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2));\n        System.out.println(result2); // Expected: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     * >>> sum_to_n(30)\n     * 465\n     * >>> sum_to_n(100)\n     * 5050\n     * >>> sum_to_n(5)\n     * 15\n     * >>> sum_to_n(10)\n     * 55\n     * >>> sum_to_n(1)\n     * 1\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.sum_to_n(30)); // Expected output: 465\n        System.out.println(solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(solution.sum_to_n(5)); // Expected output: 15\n        System.out.println(solution.sum_to_n(10)); // Expected output: 55\n        System.out.println(solution.sum_to_n(1)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            // Increment balance for an open parenthesis\n            if (c == '(') {\n                balance++;\n            }\n            // Decrement balance for a close parenthesis\n            else if (c == ')') {\n                balance--;\n            }\n            \n            // If at any point the balance is negative, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n        \n        // At the end, balance should be zero to have correct bracketing\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // Expected output: false\n        System.out.println(solution.correct_bracketing(\"()\"));  // Expected output: true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\")(()\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Calculate the derivative coefficients\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected output: [1, 4, 12, 20]\n        \n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected output: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the n-th element of the fibfib number sequence.\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize an array to store computed values\n        int[] dp = new int[n + 1];\n        dp[0] = 0; // fibfib(0)\n        dp[1] = 0; // fibfib(1)\n        dp[2] = 1; // fibfib(2)\n\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fibfib(1)); // Expected output: 0\n        System.out.println(solution.fibfib(5)); // Expected output: 4\n        System.out.println(solution.fibfib(8)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     *\n     * @param s The input string to count vowels from.\n     * @return The number of vowels in the string.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int vowelCount = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) >= 0) {\n                vowelCount++;\n            } else if (c == 'y' && i == lowerCaseS.length() - 1) {\n                vowelCount++;\n            }\n        }\n\n        return vowelCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to easily manipulate its digits\n        String numStr = Integer.toString(x);\n        \n        // Calculate effective shift value considering the length of the number\n        int len = numStr.length();\n        if (shift >= len) {\n            // If shift is greater than or equal to the length, reverse the digits\n            return new StringBuilder(numStr).reverse().toString();\n        } else {\n            // Perform circular right shift\n            int effectiveShift = shift % len;\n            String shiftedPart = numStr.substring(len - effectiveShift);\n            String remainingPart = numStr.substring(0, len - effectiveShift);\n            \n            return shiftedPart + remainingPart;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.circular_shift(12, 1)); // Expected output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected output: \"12\" (no change)\n        System.out.println(solution.circular_shift(12345, 3)); // Expected output: \"34512\"\n        System.out.println(solution.circular_shift(12345, 6)); // Expected output: \"54321\" (reversed)\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only'\n     * ASCII codes.\n     *\n     * Examples:\n     *     digitSum(\"\") => 0\n     *     digitSum(\"abAB\") => 131\n     *     digitSum(\"abcCd\") => 67\n     *     digitSum(\"helloE\") => 69\n     *     digitSum(\"woArBld\") => 131\n     *     digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in the basket based on the total number of fruits,\n     * and the string representation of apples and oranges.\n     *\n     * @param s A string that represents the total number of apples and oranges.\n     * @param n An integer representing the total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the input string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEven = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEven) {\n                // If the current even number is smaller than the recorded one or equal but with a smaller index\n                smallestEven = value;\n                index = i;\n            }\n        }\n\n        if (index != -1) {\n            return Arrays.asList(smallestEven, index);\n        } else {\n            return new ArrayList<>();\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Expected: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Expected: [2, 1]\n        System.out.println(solution.pluck(new ArrayList<>()));       // Expected: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     */\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each element\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        // Iterate through the map to find the greatest integer that meets the condition\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        // Test case 3\n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        Collections.sort(lst); // Sort the list in ascending order\n        List<Integer> result = new ArrayList<>();\n        \n        int start = 0;\n        int end = lst.size() - 1;\n\n        while (start <= end) {\n            if (start == end) {\n                result.add(lst.get(start));\n            } else {\n                result.add(lst.get(start++)); // Add the minimum value\n                result.add(lst.get(end--));   // Add the maximum value\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(10, -1, 3, 7);\n        System.out.println(solution.strange_sort_list(test4)); // Expected: [-1, 10, 3, 7]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Round to 2 decimal points and return\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if an object q will fly based on its balance and weight.\n     *\n     * @param q A list of integers representing the object's structure.\n     * @param w The maximum possible weight for the object to fly.\n     * @return true if the object is balanced (palindromic) and its total weight is less than or equal to w, false otherwise.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int totalWeight = 0;\n        for (int weight : q) {\n            totalWeight += weight;\n        }\n\n        // Check if the object is balanced and within the maximum possible weight\n        return totalWeight <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed to make the array palindromic.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int changes = 0;\n        int left = 0;\n        int right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        // Calculate the total number of characters in each list.\n        int totalCharsList1 = lst1.stream().mapToInt(String::length).sum();\n        int totalCharsList2 = lst2.stream().mapToInt(String::length).sum();\n\n        // Compare and return the appropriate list based on the total character count.\n        if (totalCharsList1 < totalCharsList2) {\n            return lst1;\n        } else if (totalCharsList2 < totalCharsList1) {\n            return lst2;\n        } else {\n            return lst1; // Return the first list if both have the same number of characters.\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     * Knowing that the prime number is less than 100.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        int count = 0;\n        for (int p : primes) {\n            if (p > a / 2) break; // Optimization: stop checking when prime exceeds half of the number\n            while (a % p == 0 && count < 3) { // Check divisibility and limit to three factors\n                a /= p;\n                count++;\n            }\n        }\n\n        return a == 1 && count == 3; // Ensure exactly three prime factors and no remainder left\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) { // If not marked composite, it's a prime\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true; // Mark multiples of the prime as composite\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     *\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // If n is 1, then the only way x can be a simple power of n is if x itself is also 1\n        if (n == 1) return x == 1;\n        \n        double logResult = Math.log(x) / Math.log(n);\n        // Check if logResult is an integer by comparing it to its rounded value\n        return Math.abs(logResult - Math.round(logResult)) < 0.00001;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if an integer is a perfect cube of some integer number.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cbrt = Math.cbrt(absA);\n        long roundedCbrt = Math.round(cbrt);\n        \n        // Check if cubing the rounded value equals the original number\n        return absA == (int) (roundedCbrt * roundedCbrt * roundedCbrt);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.iscube(1));  // true\n        System.out.println(solution.iscube(2));  // false\n        System.out.println(solution.iscube(-1)); // true\n        System.out.println(solution.iscube(64)); // true\n        System.out.println(solution.iscube(0));  // true\n        System.out.println(solution.iscube(180));// false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    /**\n     * Counts the number of hexadecimal digits that are prime numbers in the given string.\n     */\n    public int hex_key(String num) {\n        // Define a set containing all hexadecimal digits that are prime numbers\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count and return the number of characters in the input string that are in the set of primes\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));       // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));    // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));     // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string.\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' prefix and suffix as required by the problem statement.\n        return \"db\" + binary + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string s is happy.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n     */\n    public boolean is_happy(String s) {\n        // Check if the string's length is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string to check for any three consecutive characters that are not distinct\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any of the three consecutive characters are not distinct\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If no issues found, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of GPAs into their corresponding letter grades.\n     *\n     * @param grades A List<Double> containing GPA values for students.\n     * @return A List<String> with the letter grade for each GPA value.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\"); // This case should not happen as GPA is non-negative.\n            }\n        }\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = solution.numerical_letter_grade(grades);\n\n        System.out.println(result); // Expected output: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        // Total number of n-digit numbers starting with 1\n        long countStartsWithOne = (long)Math.pow(10, n - 1);\n\n        // Total number of n-digit numbers ending with 1 but not necessarily starting with 1\n        long totalNumbersEndingWithOne = (9 * Math.pow(10, n - 1));\n\n        // Since we are counting those that start or end with 1, and there's an overlap,\n        // the formula simplifies to just adding the two counts as they don't double count.\n        return (int)(countStartsWithOne + totalNumbersEndingWithOne);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1));  // Expected output: 1\n        System.out.println(solution.starts_one_ends(2));  // Expected output: 18 (10, 11, ..., 19 and 21, 31, ..., 91)\n        System.out.println(solution.starts_one_ends(3));  // Expected output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n        \n        // Convert the sum into binary string and return it\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices.\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even.\n                sum += lst.get(i); // Add it to the sum if it's even.\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        assert solution.add(Arrays.asList(4, 2, 6, 7)) == 2 : \"Test case 1 failed\";\n        assert solution.add(Arrays.asList(1, 3, 5, 7, 9)) == 0 : \"Test case 2 failed\"; // No even elements at odd indices.\n        assert solution.add(Arrays.asList(2, 4, 6, 8, 10)) == 12 : \"Test case 3 failed\"; // Even numbers at all odd indices.\n        assert solution.add(Arrays.asList(-2, -5, -8, -7, -4)) == -5 : \"Test case 4 failed\"; // Negative even number.\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) return \"\";\n\n        StringBuilder result = new StringBuilder();\n        for (String word : s.split(\"\\\\s+\")) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            result.append(new String(chars));\n            result.append(\" \");\n        }\n\n        // Remove the trailing space\n        if (result.length() > 0) {\n            result.setLength(result.length() - 1);\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Should print \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Should print \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Should print \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the coordinates of found elements\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the nested list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinates to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the result by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1,2,3,4,5,6),\n            Arrays.asList(1,2,3,4,1,6),\n            Arrays.asList(1,2,3,4,5,1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        // Test case 2\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        // Test case 3\n        List<List<Integer>> lst3 = Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, just return a copy of it.\n        if (array.size() == 1) {\n            List<Integer> result = new ArrayList<>();\n            result.add(first);\n            return result;\n        }\n\n        // Get the last element\n        last = array.get(array.size() - 1);\n\n        // Determine sorting order based on sum of first and last elements\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        List<Integer> sortedArray = new ArrayList<>(array);\n        \n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places (i.e., 4 positions).\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element in the list.\n     * @param lst List of integers.\n     * @return Optional<Integer> containing the second smallest integer or empty if not available.\n     */\n    public static Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates and sort the list\n        Set<Integer> set = new TreeSet<>(lst);\n        List<Integer> sortedList = new ArrayList<>(set);\n\n        // Check if there are at least 2 distinct elements in the list\n        if (sortedList.size() < 2) {\n            return Optional.empty();\n        }\n\n        // Return the second smallest element\n        return Optional.of(sortedList.get(1));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));              // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));          // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence starting with \"I\".\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the input string into sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().toLowerCase().startsWith(\"i \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\"));  // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy. You are sad. Is it true? I think so!\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if one number is the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes a message by swapping case of all letters, replacing vowels with the letter that appears 2 places ahead.\n     */\n    public String encode(String message) {\n        // Define mappings for vowels and their replacements\n        Map<Character, Character> vowelMap = new HashMap<>();\n        vowelMap.put('a', 'c');\n        vowelMap.put('e', 'g');\n        vowelMap.put('i', 'k');\n        vowelMap.put('o', 'q');\n        vowelMap.put('u', 'w');\n        vowelMap.put('A', 'C');\n        vowelMap.put('E', 'G');\n        vowelMap.put('I', 'K');\n        vowelMap.put('O', 'Q');\n        vowelMap.put('U', 'W');\n\n        // Build the encoded message\n        StringBuilder encodedMessage = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {  // Check if character is a letter\n                char upperCaseC = Character.toUpperCase(c);\n                if (vowelMap.containsKey(upperCaseC)) {\n                    // Replace vowel with its mapped value and swap case\n                    encodedMessage.append(Character.isLowerCase(c) ? vowelMap.get(upperCaseC).toLowerCase() : vowelMap.get(upperCaseC));\n                } else {\n                    // Swap case for non-vowels\n                    if (Character.isUpperCase(c)) {\n                        encodedMessage.append(Character.toLowerCase(c));\n                    } else {\n                        encodedMessage.append(Character.toUpperCase(c));\n                    }\n                }\n            } else {\n                // Non-letter characters are not modified\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumOfLargestPrimeDigits(List<Integer> lst) {\n        // Find the largest prime number in the list\n        OptionalInt maxPrime = lst.stream()\n                .filter(Solution::isPrime)\n                .mapToInt(Integer::intValue)\n                .max();\n\n        if (!maxPrime.isPresent()) {\n            return 0; // Return 0 if there is no prime number in the list\n        }\n\n        int largestPrime = maxPrime.getAsInt();\n        \n        // Calculate and return the sum of digits of the largest prime number\n        return sumDigits(largestPrime);\n    }\n    \n    private static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    private static int sumDigits(int number) {\n        int sum = 0;\n        while (number > 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sumOfLargestPrimeDigits(Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3))); // Should print 10\n        System.out.println(solution.sumOfLargestPrimeDigits(Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1))); // Should print 25\n        System.out.println(solution.sumOfLargestPrimeDigits(Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3))); // Should print 13\n        System.out.println(solution.sumOfLargestPrimeDigits(Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6))); // Should print 11\n        System.out.println(solution.sumOfLargestPrimeDigits(Arrays.asList(0,81,12,3,1,21))); // Should print 3\n        System.out.println(solution.sumOfLargestPrimeDigits(Arrays.asList(0,8,1,2,1,7))); // Should print 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False if the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        String lowerCase = \"\";\n        String upperCase = \"\";\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;  // If any key is not a string, return False.\n            }\n            \n            String strKey = (String) key;\n\n            if (!lowerCase.isEmpty() && !upperCase.isEmpty()) {\n                return false;  // If we have already determined that keys are in both cases, return False.\n            }\n\n            if (strKey.equals(strKey.toLowerCase())) {\n                lowerCase = \"true\";\n            }\n            \n            if (strKey.equals(strKey.toUpperCase())) {\n                upperCase = \"true\";\n            }\n        }\n\n        return !(lowerCase.isEmpty() || upperCase.isEmpty());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\")));  // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\")));  // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\")));  // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\")));  // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\")));  // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Extracting the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Returning the product of the unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851));// Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            if (uppercaseVowels.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        double floorValue = Math.floor(num);\n        double ceilValue = Math.ceil(num);\n\n        // Check if number is equidistant between two integers\n        if (num - floorValue == 0.5 && ceilValue - num == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Expected output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Expected output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Expected output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Expected output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If n is even\n                currentStones += 2; // Next even number\n            } else { // If n is odd\n                currentStones += 2; // Next odd number\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(\"make_a_pile(3): \" + result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(\"make_a_pile(4): \" + result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a string into words based on commas and spaces.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List of strings, each representing a word from the input string.\n     */\n    public List<String> words_string(String s) {\n        // Split the string using regex that matches both commas and spaces\n        String[] splitArray = s.split(\"[ ,]+\");\n        \n        // Convert array to list for easier handling and return\n        return Arrays.asList(splitArray);\n    }\n\n    /**\n     * A simple test method to check if words_string works as expected.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1);  // Expected: [Hi, my, name, is, John]\n\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2);  // Expected: [One, two, three, four, five, six]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "class Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. \n     * If there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If y is smaller than x, return -1 as the range is invalid.\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) { // Check if the number is even\n                return i;     // Return the first even number found, which will be the largest in this range.\n            }\n        }\n\n        // If no even number was found within the range, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the function\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 7));   // Expected output: -1 (since 7 is odd)\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    public Object rounded_avg(int n, int m) {\n        if (n > m) return -1;\n\n        // Calculate the sum of integers from n to m using arithmetic series formula\n        long totalSum = ((long) m + n) * (m - n + 1) / 2;\n        \n        // Calculate the average and round it to the nearest integer\n        int roundedAvg = Math.round((float) totalSum / (m - n + 1));\n        \n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x, return a sorted list of all elements \n     * that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Filter out numbers with even digits\n        List<Integer> filteredList = new ArrayList<>();\n        for (Integer num : x) {\n            if (!hasEvenDigits(num)) {\n                filteredList.add(num);\n            }\n        }\n\n        // Sort the list in increasing order\n        Collections.sort(filteredList);\n\n        return filteredList;\n    }\n\n    /**\n     * Helper method to check if a number contains any even digit.\n     */\n    private boolean hasEvenDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) { // Check if it's an even digit\n                return true;\n            }\n            num /= 10; // Remove the last digit\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(list1)); // Expected: [1, 15, 33]\n\n        List<Integer> list2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(list2)); // Expected: []\n\n        List<Integer> list3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(list3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter out numbers not between 1 and 9 inclusive\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Step 2: Sort the filtered integers in ascending order\n        Collections.sort(filtered);\n\n        // Step 3: Reverse the sorted list of integers\n        List<Integer> reversed = new ArrayList<>(filtered.size());\n        for (int i = filtered.size() - 1; i >= 0; i--) {\n            reversed.add(filtered.get(i));\n        }\n\n        // Step 4: Convert each integer to its corresponding word representation\n        String[] numberWords = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        List<String> result = new ArrayList<>(reversed.size());\n        for (Integer num : reversed) {\n            result.add(numberWords[num - 1]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of i\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to i\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n\n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * calculateFactorial(n - 1);\n    }\n\n    private int calculateSum(int n) {\n        return (n * (n + 1)) / 2; // Using the formula for sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n        \n        result = solution.f(3);\n        System.out.println(result); // Expected output: [1, 2, 6]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0;\n        int right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Expected: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Expected: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) {\n                digit = -digit; // Make the first positive digit negative\n            }\n            sum += digit;\n            num /= 10;\n            isNegative &= (num < 0); // Continue marking as negative until all digits are processed\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(new ArrayList<>(Arrays.asList()))); // Expected output: 0\n        System.out.println(solution.count_nums(new ArrayList<>(Arrays.asList(-1, 11, -11)))); // Expected output: 1\n        System.out.println(solution.count_nums(new ArrayList<>(Arrays.asList(1, 1, 2)))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it's possible to sort the given list in non-decreasing order by performing right shift operations.\n     *\n     * @param arr The input list of integers.\n     * @return true if it is possible to achieve a sorted array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, it's trivially sorted.\n        if (arr.size() <= 1) return true;\n\n        int n = arr.size();\n        List<Integer> extendedArr = new ArrayList<>(arr);\n        \n        // Extend the array to simulate multiple right shifts\n        for (int i = 0; i < n - 1; ++i) {\n            extendedArr.add(arr.get(i));\n        }\n\n        // Check if there's a subarray of length 'n' that is sorted.\n        for (int start = 0; start <= n - 1; ++start) {\n            boolean isSorted = true;\n            for (int i = start + 1, j = start + n; i < j; ++i) {\n                if (extendedArr.get(i) > extendedArr.get(i + 1)) {\n                    isSorted = false;\n                    break;\n                }\n            }\n            if (isSorted) return true;\n        }\n\n        return false;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n        System.out.println(solution.move_one_ball(Arrays.asList()));               // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(1)));              // Expected: true\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether it is possible to exchange elements between two lists\n     * such that all elements of lst1 become even.\n     *\n     * @param lst1 The first list of integers.\n     * @param lst2 The second list of integers.\n     * @return \"YES\" if it's possible to make all elements in lst1 even by exchanging with lst2, otherwise \"NO\".\n     */\n    public String exchange(List<Integer> lst1, List<Integer) lst2) {\n        int oddCountInLst1 = 0;\n        boolean hasEvenInLst2 = false;\n\n        // Count the number of odd numbers in lst1 and check if there is at least one even number in lst2.\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                hasEvenInLst2 = true;\n                break;\n            }\n        }\n\n        // If there are no odd numbers in lst1, it's already possible to make all elements even.\n        if (oddCountInLst1 == 0) return \"YES\";\n\n        // If there is at least one even number in lst2 and the number of odd numbers in lst1\n        // does not exceed the total count of elements in lst2, then it's possible to exchange.\n        if (hasEvenInLst2 && oddCountInLst1 <= lst2.size()) return \"YES\";\n\n        return \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Should print YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Should print NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters,\n     * return a dictionary with the most repeated letter(s) and their counts.\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into an array of words\n        String[] words = test.split(\" \");\n        \n        // Create a map to store the count of each word\n        Map<String, Integer> countMap = new HashMap<>();\n        for (String word : words) {\n            if (!word.isEmpty()) {  // Ensure we're not counting empty strings\n                countMap.put(word, countMap.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Find the maximum value in the map\n        int maxCount = Collections.max(countMap.values());\n\n        // Create a result map to store words with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    // Test function to verify the correctness of the histogram method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left++) != resultString.charAt(right--)) {\n                isPalindrome = false;\n                break;\n            }\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n\n        return resultList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String str : lst) {\n            int countOdd = 0;\n            \n            // Counting odd digits\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    countOdd++;\n                }\n            }\n\n            // Constructing the result string based on the number of odd digits\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n\n        return result;\n    }\n    \n    // Test code to verify the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(sol.odd_count(test1));  // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(sol.odd_count(test2));  // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be empty or null\");\n        }\n\n        // Initialize variables to store the current and minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current min sum by either starting a new sub-array at nums[i]\n            // or continuing the previous one.\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            \n            // Update the global minimum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(2, 3, 4, 1, 2, 4);\n        System.out.println(solution.minSubArraySum(test1)); // Expected output: 1\n        \n        List<Integer> test2 = Arrays.asList(-1, -2, -3);\n        System.out.println(solution.minSubArraySum(test2)); // Expected output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of times buckets need to be lowered to empty all wells.\n     *\n     * @param grid A list of lists representing the grid of wells, where each 1 represents a unit of water.\n     * @param capacity The capacity of each bucket used to extract water from the wells.\n     * @return The total number of times buckets need to be lowered to empty all wells.\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Sum up the total amount of water in all wells\n        int totalWater = 0;\n        for (List<Integer> row : grid) {\n            for (int cell : row) {\n                totalWater += cell;\n            }\n        }\n\n        // Calculate how many times buckets need to be lowered\n        return (totalWater + capacity - 1) / capacity; // Equivalent to Math.ceil(totalWater / capacity)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example test cases\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Expected output: 6\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Expected output: 5\n\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort based on number of ones in binary representation and then by decimal value.\n        Collections.sort(arr, (a, b) -> {\n            int countA = Integer.bitCount(a);\n            int countB = Integer.bitCount(b);\n\n            if (countA == countB) {\n                return a - b;  // Sort based on decimal value for the same number of ones\n            }\n\n            return countA - countB;\n        });\n\n        return arr;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1)); // Expected: [1, 2, 4, 3, 5]\n        \n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2)); // Expected: [-4, -2, -6, -5, -3]\n        \n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3)); // Expected: [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        Set<Character> consonants = new HashSet<>(Arrays.asList('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'));\n        List<String> result = new ArrayList<>();\n        String[] words = s.split(\"\\\\s+\");\n\n        for (String word : words) {\n            int consonantCount = 0;\n            for (char c : word.toLowerCase().toCharArray()) {\n                if (consonants.contains(c)) {\n                    consonantCount++;\n                }\n            }\n\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the closest vowel that stands between two consonants from the right side of the word.\n     */\n    public String get_closest_vowel(String word) {\n        if (word == null || word.length() < 3) return \"\";\n\n        for (int i = word.length() - 2; i > 0; i--) {\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!isVowel(leftChar) && !isVowel(rightChar) && isVowel(middleChar)) {\n                return String.valueOf(middleChar);\n            }\n        }\n\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Output: u\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Output: U\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Output: \n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Output: \n\n        // Additional test cases\n        System.out.println(solution.get_closest_vowel(\"rhythm\")); // Output: y\n        System.out.println(solution.get_closest_vowel(\"crystal\")); // Output: a\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it is possible to concatenate two strings consisting only of '(' and ')' \n     * in some order such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each made up of '(' or ')'.\n     * @return \"Yes\" if there's a way to make a good string, otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < 2; i++) { // Only two ways to concatenate: s1 + s2 or s2 + s1\n            if (isBalanced(lst.get(i), lst.get(1 - i))) {\n                return \"Yes\";\n            }\n        }\n        return \"No\";\n    }\n\n    /**\n     * Helper method to check if a string of parentheses is balanced.\n     *\n     * @param str The string to be checked for balance.\n     * @return true if the string is balanced, false otherwise.\n     */\n    private boolean isBalanced(String str) {\n        int balance = 0;\n        for (char c : str.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            // If at any point the balance goes negative, it's unbalanced\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // The string is balanced only if the final count of '(' and ')' matches.\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));   // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"(\")));  // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a max heap to store elements from the array\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        \n        // Add all elements of the array into the max heap\n        for (int num : arr) {\n            maxHeap.add(num);\n        }\n        \n        // Extract the maximum k elements and add them to a min heap\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        while (k > 0 && !maxHeap.isEmpty()) {\n            int topElement = maxHeap.poll();\n            minHeap.add(topElement);\n            k--;\n        }\n\n        // Convert the min heap into a sorted list in ascending order\n        List<Integer> result = new ArrayList<>(minHeap.size());\n        while (!minHeap.isEmpty()) {\n            result.add(minHeap.poll());\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3)); // Expected: [-4, -3, 5]\n        \n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2)); // Expected: [4, 4]\n        \n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element at the current index is odd\n                sum += lst.get(i); // Add it to the sum\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(solution.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(solution.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(solution.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(arr1, k1)); // Expected output: 24\n        \n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(10, 20, 30);\n        int k2 = 3;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(arr2, k2)); // Expected output: 60\n        \n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1000, 100, 10, 1);\n        int k3 = 4;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(arr3, k3)); // Expected output: 11\n        \n        // Test case 4\n        List<Integer> arr4 = Arrays.asList(98, -27, 500, 1);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(arr4, k4)); // Expected output: 71\n        \n        // Test case 5\n        List<Integer> arr5 = Arrays.asList(99, -99);\n        int k5 = 2;\n        System.out.println(\"Test Case 5: \" + solution.add_elements(arr5, k5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddNumbers = new ArrayList<>();\n        \n        while (n != 1) {\n            if (n % 2 == 1) { // Check if the number is odd\n                oddNumbers.add(n);\n            }\n            // Generate next term in Collatz sequence\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n        }\n        \n        // Add 1 to the list as it's always part of the sequence and is odd.\n        oddNumbers.add(1);\n        \n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.get_odd_collatz(5);\n        System.out.println(result); // Expected output: [1, 5]\n        \n        List<Integer> result2 = solution.get_odd_collatz(7);\n        System.out.println(result2); // Expected output: [1, 7]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Validates a given date string.\n     *\n     * @param date The date string in mm-dd-yyyy format.\n     * @return true if the date is valid, otherwise false.\n     */\n    public boolean valid_date(String date) {\n        // Check for empty string\n        if (date == null || date.isEmpty()) return false;\n\n        // Split the date into components\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false; // Ensure there are exactly three parts\n\n        int month, day, year;\n        try {\n            month = Integer.parseInt(parts[0]);\n            day = Integer.parseInt(parts[1]);\n            year = Integer.parseInt(parts[2]);\n        } catch (NumberFormatException e) {\n            return false; // If any part is not a number\n        }\n\n        // Validate month\n        if (month < 1 || month > 12) return false;\n\n        // Validate day based on the month\n        int maxDay = getMaxDays(month, year);\n        if (day < 1 || day > maxDay) return false;\n\n        return true;\n    }\n\n    private int getMaxDays(int month, int year) {\n        if (month == 2) { // February\n            boolean isLeapYear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n            return isLeapYear ? 29 : 28;\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) { // April, June, September, November\n            return 30;\n        } else {\n            return 31; // January, March, May, July, August, October, December\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Split on whitespace first\n        String[] words = txt.split(\"\\\\s+\");\n        \n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n        \n        // If no whitespaces, try splitting on commas\n        words = txt.split(\",\");\n        \n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n        \n        // Count the number of lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\")); // Should print: 3\n        \n        // Additional test cases\n        System.out.println(solution.split_words(\"no spaces or commas\")); // Should print the count of odd letters\n        System.out.println(solution.split_words(\"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\")); // Should print 13\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n\n            // Check if the current number is greater than the previous one\n            if (i > 0 && lst.get(i - 1) >= lst.get(i)) {\n                return false;\n            }\n\n            // If any number appears more than twice, return false\n            if (countMap.get(num) > 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "class Solution {\n    /**\n     * Determines if the length of the intersection between two intervals is a prime number.\n     *\n     * @param interval1 The first interval as a List<Integer> where index 0 is start and index 1 is end.\n     * @param interval2 The second interval as a List<Integer> where index 0 is start and index 1 is end.\n     * @return \"YES\" if the length of intersection is prime, otherwise returns \"NO\".\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Determine the maximum start point\n        int maxStart = Math.max(interval1.get(0), interval2.get(0));\n        \n        // Determine the minimum end point\n        int minEnd = Math.min(interval1.get(1), interval2.get(1));\n\n        // Check if there is an intersection\n        if (maxStart > minEnd) {\n            return \"NO\";\n        }\n\n        // Calculate the length of the intersection\n        int lengthOfIntersection = minEnd - maxStart + 1;\n\n        // Check if the length of the intersection is a prime number\n        if (isPrime(lengthOfIntersection)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    /**\n     * Checks if a given number is prime.\n     *\n     * @param n The number to check for primality.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n\n    // Test cases to verify the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(sol.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(sol.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of magnitudes of integers multiplied by the product of all signs.\n     *\n     * @param arr List of integers.\n     * @return Optional<Integer> representing the result or None if the list is empty.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            // If any number is zero, the result will be zero.\n            if (num == 0) {\n                return Optional.of(0);\n            }\n            sumOfMagnitudes += Math.abs(num);\n\n            // Calculate the product of signs\n            if (num < 0) {\n                productOfSigns *= -1;\n            } else {\n                productOfSigns *= 1; // Positive number, keep sign as positive.\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        // Priority queue to store paths in lexicographical order.\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((a, b) -> {\n            for (int i = 0; i < Math.min(a.size(), b.size()); i++) {\n                if (!a.get(i).equals(b.get(i))) return a.get(i) - b.get(i);\n            }\n            return a.size() - b.size();\n        });\n\n        int N = grid.size();\n\n        // Directions for moving to adjacent cells.\n        int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n        // DFS function to explore all paths of length k starting from (x, y).\n        void dfs(int x, int y, List<Integer> path) {\n            if (path.size() == k) {\n                pq.offer(new ArrayList<>(path));\n                return;\n            }\n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                // Check boundaries.\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                    path.add(grid.get(nx).get(ny));\n                    dfs(nx, ny, path);\n                    path.remove(path.size() - 1); // Backtrack\n                }\n            }\n        }\n\n        // Start DFS from every cell.\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                List<Integer> initialPath = new ArrayList<>();\n                initialPath.add(grid.get(i).get(j));\n                dfs(i, j, initialPath);\n            }\n        }\n\n        // Return the lexicographically smallest path.\n        return pq.poll();\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Generates a list of the first n + 1 numbers of the custom Tribonacci sequence.\n     */\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>(); // Handle invalid input\n\n        List<Integer> tribonacci = new ArrayList<>();\n        \n        // Base cases\n        if (n >= 0) tribonacci.add(1); // tri(0)\n        if (n >= 1) tribonacci.add(3); // tri(1)\n\n        for (int i = 2; i <= n; i++) {\n            int nextValue;\n            if (i % 2 == 0) { // If even\n                nextValue = 1 + i / 2;\n            } else { // If odd, calculate based on previous values\n                nextValue = tribonacci.get(i - 1) + \n                            tribonacci.get(i - 2) + \n                            (i < tribonacci.size() ? tribonacci.get(i + 1) : tri(i + 1).get(0));\n            }\n            tribonacci.add(nextValue);\n        }\n\n        return tribonacci;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.tri(3)); // Expected output: [1, 3, 2, 8]\n        System.out.println(solution.tri(4)); // Expected output: [1, 3, 2, 8, 5]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if it's an odd digit\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if there is at least one nested bracket in the given string.\n     *\n     * @param string The input string containing only square brackets.\n     * @return true if there is at least one nested bracket, false otherwise.\n     */\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean hasNested = false;\n\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n                // If the balance is positive, it means there's a nested bracket.\n                if (balance > 0) hasNested = true;\n            }\n            // Early exit if we find a nested bracket.\n            if (hasNested && balance >= 0) return true;\n        }\n\n        // Ensure all brackets are closed properly.\n        return false; // If the function reaches here, there's no nesting or unbalanced brackets.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public static int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilNum = Math.ceil(num);\n            // Square and add to sum\n            sum += (int)(ceilNum * ceilNum);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Expected output: 14\n        \n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Expected output: 98\n        \n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Expected output: 84\n        \n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Expected output: 29\n        \n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character of a given string is an alphabetical character and is not part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * Examples:\n     * check_if_last_char_is_a_letter(\"apple pie\") -> false\n     * check_if_last_char_is_a_letter(\"apple pi e\") -> true\n     * check_if_last_char_is_a_letter(\"apple pi e \") -> false\n     * check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.trim().isEmpty()) {\n            return false;\n        }\n\n        // Trim the string to remove trailing spaces and get the last character.\n        String trimmedTxt = txt.trim();\n        char lastChar = trimmedTxt.charAt(trimmedTxt.length() - 1);\n\n        // Check if the last character is an alphabetical character.\n        if (!Character.isAlphabetic(lastChar)) {\n            return false;\n        }\n\n        // Check if there are no spaces before the last character, meaning it's not part of a word.\n        int lastIndex = txt.lastIndexOf(lastChar);\n        for (int i = lastIndex - 1; i >= 0; i--) {\n            char currentChar = txt.charAt(i);\n            if (Character.isAlphabetic(currentChar)) {\n                return false;\n            }\n            if (currentChar == ' ') {\n                break;\n            }\n        }\n\n        // If the last character is an alphabetical character and not part of a word, return true.\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));  // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // If the list is empty or has only one element, return -1 as there's no preceding element to compare.\n        if (arr.size() <= 1) {\n            return -1;\n        }\n\n        int index = -1; // Default value in case no such element exists.\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) { // Check if the current element is less than its preceding one.\n                index = i; // Update index to the current position as it's the first occurrence of such a case.\n            }\n        }\n\n        return index;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(solution.can_arrange(test1)); // Expected output: 3\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.can_arrange(test2)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!largestNegative.isPresent() || num > largestNegative.get())) {\n                largestNegative = Optional.of(num);\n            } else if (num > 0 && (!smallestPositive.isPresent() || num < smallestPositive.get())) {\n                smallestPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(test1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        List<Integer> test2 = Arrays.asList();\n        System.out.println(solution.largest_smallest_integers(test2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        List<Integer> test3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(test3)); // Expected: [Optional.empty(), Optional.empty()]\n\n        List<Integer> test4 = Arrays.asList(-5, -1, 2, 3, 6);\n        System.out.println(solution.largest_smallest_integers(test4)); // Expected: [Optional.of(-1), Optional.of(2)]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        // Convert both inputs to strings for easy comparison and handling of commas as decimal points.\n        String strA = convertToComparableString(a);\n        String strB = convertToComparableString(b);\n\n        if (strA.equals(strB)) {\n            return Optional.empty();\n        } else if (Double.parseDouble(strA) > Double.parseDouble(strB)) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private String convertToComparableString(Object obj) {\n        if (obj instanceof Integer) {\n            return ((Integer) obj).toString().replace(',', '.');\n        } else if (obj instanceof Double) {\n            return ((Double) obj).toString();\n        } else if (obj instanceof String) {\n            return ((String) obj).replace(',', '.');\n        }\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such a sum.\n        if (n < 8) return false;\n        \n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers can be represented this way due to the minimum value constraint.\n        // For example, 10 cannot be expressed as a sum of exactly four positive even numbers.\n        return n % 2 == 0 && (n - 8) % 4 <= 3;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected output: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n\n            if (c == ' ') {\n                spaceCount++;\n                continue;\n            }\n\n            // If more than two consecutive spaces, replace with '-'\n            if (spaceCount > 2) {\n                result.append('-');\n            } else {\n                for (int j = 0; j < spaceCount; j++) {\n                    result.append('_');\n                }\n            }\n\n            spaceCount = 0;\n            result.append(c);\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else {\n            for (int i = 0; i < spaceCount; i++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fix_spaces(\"Example\")); // Example\n        System.out.println(solution.fix_spaces(\"Example 1\")); // Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\")); // _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\")); // _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The string representing the file's name to be checked.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot in the file name\n        int dotCount = 0;\n        for (int i = 0; i < fileName.length(); i++) {\n            char c = fileName.charAt(i);\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n\n        if (dotCount != 1) return \"No\";\n\n        // Split the file name into two parts: before and after the dot\n        String[] parts = fileName.split(\"\\\\.\");\n        if (parts.length != 2 || parts[0].isEmpty()) return \"No\"; // Ensure there's exactly one part before the dot\n\n        // Check that the first character of the prefix is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Count digits in the file name\n        int digitCount = 0;\n        for (char c : fileName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n\n        if (digitCount > 3) return \"No\"; // Ensure there are no more than three digits\n\n        // Check the suffix is one of [\"txt\", \"exe\", \"dll\"]\n        String validSuffixes[] = {\"txt\", \"exe\", \"dll\"};\n        boolean isValidSuffix = false;\n        for (String suffix : validSuffixes) {\n            if (parts[1].equals(suffix)) {\n                isValidSuffix = true;\n                break;\n            }\n        }\n\n        return isValidSuffix ? \"Yes\" : \"No\";\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file.exe\"));     // Expected: Yes\n        System.out.println(solution.file_name_check(\"file.abc\"));     // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     */\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                sum += Math.pow(lst.get(i), 3);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sum_squares(lst1)); // Expected output: 6\n        \n        // Test case 2\n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(solution.sum_squares(lst2)); // Expected output: 0\n        \n        // Test case 3\n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(solution.sum_squares(lst3)); // Expected output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filters out words from the input sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n        System.out.println(solution.words_in_sentence(\"hello world and practice makes perfect and hello world again\")); // Output: \"world and practice makes and world\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse fractions from string representations\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Multiply the fractions\n        long resultNum = (long) numeratorX * numeratorN;\n        long resultDenom = (long) denominatorX * denominatorN;\n\n        // Check if the product is a whole number\n        return resultNum % resultDenom == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts a list of integers according to the sum of their digits.\n     * If multiple items have the same sum of digits, order them based on their index in the original list.\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a map to store each number with its digit sum\n        Map<Integer, Integer> digitSumMap = new HashMap<>();\n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums.get(i);\n            int sumOfDigits = getDigitSum(num);\n            digitSumMap.put(i, sumOfDigits); // Store index and its corresponding digit sum\n        }\n\n        // Sort the indices based on their digit sums (and original index if sums are equal)\n        List<Integer> sortedIndices = new ArrayList<>(digitSumMap.keySet());\n        Collections.sort(sortedIndices, Comparator.comparingInt(digitSumMap::get));\n\n        // Reorder the numbers according to the sorted indices\n        List<Integer> result = new ArrayList<>();\n        for (int index : sortedIndices) {\n            result.add(nums.get(index));\n        }\n\n        return result;\n    }\n\n    /**\n     * Helper method to calculate the sum of digits of an integer.\n     */\n    private int getDigitSum(int num) {\n        int sumOfDigits = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) {\n                digit *= -1; // Adjust positive digits to negative if the number was originally negative\n            }\n            sumOfDigits += Math.abs(digit); // Add absolute value of each digit to avoid subtracting when digit is negative\n            num /= 10;\n        }\n\n        return sumOfDigits;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(testList1)); // Expected: [-1, -11, 1, -12, 11]\n\n        List<Integer> testList2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(testList2)); // Expected: []\n\n        List<Integer> testList3 = Arrays.asList(10, 9, 8, 7);\n        System.out.println(solution.order_by_points(testList3)); // Expected: [7, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many triples satisfy the condition\n        return countTriples(a);\n    }\n\n    private int countTriples(int[] a) {\n        int count = 0;\n\n        // Iterate through all possible triples (i, j, k)\n        for (int i = 0; i < a.length - 2; i++) {\n            for (int j = i + 1; j < a.length - 1; j++) {\n                for (int k = j + 1; k < a.length; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5; // Example input\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    );\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) {\n            return Collections.emptyList();\n        }\n\n        // Ensure index1 < index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        \n        // Include the planet at index2 if it's not the same as index1\n        if (index1 != index2) {\n            result.add(PLANETS.get(index2));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Accepts a list of strings, deletes the strings that have odd lengths,\n     * and returns the resulted list sorted by ascending order of string length.\n     * If two words have the same length, sort them alphabetically.\n     */\n    public List<String> filterAndSort(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Sort the list by length, and alphabetically if lengths are equal\n        filteredList.sort((s1, s2) -> {\n            int lenDiff = Integer.compare(s1.length(), s2.length());\n            return (lenDiff != 0) ? lenDiff : s1.compareTo(s2);\n        });\n\n        return filteredList;\n    }\n\n    // Test code to verify the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.filterAndSort(test1));  // Expected: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.filterAndSort(test2));  // Expected: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false; // Numbers less than or equal to 1 are not prime\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(19, 20, 10)); // Should print 20\n        System.out.println(solution.x_or_y(21, 30, 40)); // Should print 40\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of objects (which can be assumed to contain only integers),\n     * return the sum of squares of the numbers in the list that are odd.\n     * Ignore negative numbers and non-integer values.\n     *\n     * @param lst List of Objects containing integer values\n     * @return Sum of squares of odd positive integers from the list\n     */\n    public int double_the_difference(List<Object> lst) {\n        return lst.stream()\n                .filter(item -> item instanceof Integer)\n                .mapToInt(item -> (Integer)item)\n                .filter(num -> num > 0 && num % 2 != 0)\n                .map(num -> num * num)\n                .sum();\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // Expected output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(new ArrayList<>())); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares the given game scores with the player's guesses.\n     *\n     * @param game  A List<Integer> containing the actual scores of matches.\n     * @param guess A List<Integer> containing the guessed scores for each match.\n     * @return A List<Integer> where each element represents how far off a guess was from the actual score.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Ensure both lists are of equal length\n        if (game.size() != guess.size()) {\n            throw new IllegalArgumentException(\"The size of game and guess must be the same.\");\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int scoreDifference = Math.abs(game.get(i) - guess.get(i));\n            result.add(scoreDifference);\n        }\n        return result;\n    }\n\n    // Test method to verify the correctness of the compare function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class name.\n     *\n     * @param class_name The name of the class to which extensions will be added.\n     * @param extensions A list of extension names.\n     * @return A string in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        // Initialize variables to track the strongest extension and its strength\n        String strongest_extension = \"\";\n        int max_strength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            // Calculate the strength of the current extension\n            int strength = calculateStrength(extension);\n\n            // Update the strongest extension if necessary\n            if (strength > max_strength || (strength == max_strength && strongest_extension.equals(\"\"))) {\n                strongest_extension = extension;\n                max_strength = strength;\n            }\n        }\n\n        return class_name + \".\" + strongest_extension;\n    }\n\n    /**\n     * Calculates the strength of an extension based on uppercase and lowercase letters.\n     *\n     * @param extension The name of the extension.\n     * @return The calculated strength as an integer (CAP - SM).\n     */\n    private int calculateStrength(String extension) {\n        int cap = 0;\n        int sm = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                cap++;\n            } else if (Character.isLowerCase(c)) {\n                sm++;\n            }\n        }\n\n        return cap - sm;\n    }\n\n    // Test cases to validate the Strongest_Extension method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Expected: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Expected: my_class.AA\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any rotation of b is a substring of a.\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the string 'a' with itself. This way we can check for rotations as substrings in one go.\n        String doubledA = a + a;\n        \n        // Check if the length of b is greater than a, if so, it's impossible for b to be a rotation of a substring\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Check if 'b' or any of its rotations are substrings of doubledA.\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *     even_odd_count(-12) ==> [1, 1]\n     *     even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Handle negative numbers by converting to positive\n        if (num < 0) {\n            num = -num;\n        }\n\n        int evenCount = 0;\n        int oddCount = 0;\n\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n\n            if (digit % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n\n            num /= 10; // Remove the last digit\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.even_odd_count(-12)); // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123)); // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        if (number < 1 || number > 1000) {\n            throw new IllegalArgumentException(\"Number must be between 1 and 1000\");\n        }\n\n        // Mapping of Roman numerals to their integer values.\n        Map<Integer, String> romanNumerals = new LinkedHashMap<>();\n        romanNumerals.put(1000, \"M\");\n        romanNumerals.put(900, \"CM\");\n        romanNumerals.put(500, \"D\");\n        romanNumerals.put(400, \"CD\");\n        romanNumerals.put(100, \"C\");\n        romanNumerals.put(90, \"XC\");\n        romanNumerals.put(50, \"L\");\n        romanNumerals.put(40, \"XL\");\n        romanNumerals.put(10, \"X\");\n        romanNumerals.put(9, \"IX\");\n        romanNumerals.put(5, \"V\");\n        romanNumerals.put(4, \"IV\");\n        romanNumerals.put(1, \"I\");\n\n        StringBuilder result = new StringBuilder();\n        \n        for (Map.Entry<Integer, String> entry : romanNumerals.entrySet()) {\n            while (number >= entry.getKey()) {\n                number -= entry.getKey();\n                result.append(entry.getValue());\n            }\n        }\n\n        return result.toString().toLowerCase();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));  // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152)); // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426)); // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is 90 degrees.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to make sure we are comparing the longest side with the sum of squares\n        int[] sides = new int[]{a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side is equal to the sum of squares of the other two sides\n        return Math.pow(sides[2], 2) == (Math.pow(sides[0], 2) + Math.pow(sides[1], 2));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected output: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected output: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected output: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected output: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If multiple words have the same number of unique characters,\n     * returns the one that comes first in lexicographical order.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list to ensure lexicographical order is maintained\n        Collections.sort(words);\n\n        String result = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                result = word;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Should print \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Should print \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))); // Should print \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that will be eaten\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate the number of carrots left after eating\n        int leftover = remaining - Math.min(need, remaining);\n\n        // Return a list containing the total number of carrots eaten and the number of carrots left\n        return Arrays.asList(totalEaten, leftover);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two lists operator, and operand. The first list has basic algebra operations,\n     * and the second list is a list of integers. Use the two given lists to build the algebraic\n     * expression and return the evaluation of this expression.\n     *\n     * @param operator List of strings representing algebraic operators: \"+\", \"-\", \"*\", \"/\", \"**\"\n     * @param operand  List of integers representing operands for the algebraic operations\n     * @return The result of evaluating the constructed algebraic expression\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a stack to hold intermediate results and operators\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n\n        for (int i = 0; i < operand.size(); i++) {\n            if (!operator.isEmpty() && i > 0) {\n                String opStr = operator.get(i - 1);\n                char opChar = switch (opStr) {\n                    case \"+\" -> '+';\n                    case \"-\" -> '-';\n                    case \"*\" -> '*';\n                    case \"/\" -> '/';\n                    case \"**\" -> '^'; // Using '^' to represent '**'\n                    default -> throw new IllegalArgumentException(\"Invalid operator: \" + opStr);\n                };\n                ops.push(opChar);\n\n                while (!ops.isEmpty() && precedence(ops.peek()) >= precedence(operator.get(i - 1))) {\n                    evaluate(values, ops);\n                }\n            }\n\n            values.push(operand.get(i));\n        }\n\n        // Evaluate remaining operations\n        while (!ops.isEmpty()) {\n            evaluate(values, ops);\n        }\n\n        return values.pop();\n    }\n\n    private int precedence(String op) {\n        switch (op) {\n            case \"**\":\n                return 4;\n            case \"*\":\n            case \"/\":\n                return 3;\n            case \"+\":\n            case \"-\":\n                return 2;\n            default:\n                throw new IllegalArgumentException(\"Invalid operator: \" + op);\n        }\n    }\n\n    private int precedence(char op) {\n        switch (op) {\n            case '^':\n                return 4;\n            case '*':\n            case '/':\n                return 3;\n            case '+':\n            case '-':\n                return 2;\n            default:\n                throw new IllegalArgumentException(\"Invalid operator: \" + op);\n        }\n    }\n\n    private void evaluate(Stack<Integer> values, Stack<Character> ops) {\n        int b = values.pop();\n        int a = values.pop();\n        char op = ops.pop();\n\n        switch (op) {\n            case '+':\n                values.push(a + b);\n                break;\n            case '-':\n                values.push(a - b);\n                break;\n            case '*':\n                values.push(a * b);\n                break;\n            case '/':\n                values.push(a / b); // Assuming integer division\n                break;\n            case '^':\n                values.push((int) Math.pow(a, b));\n                break;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> operators = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands = Arrays.asList(2, 3, 4, 5);\n        int result = solution.do_algebra(operators, operands);\n        System.out.println(\"Result: \" + result); // Expected output: Result: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reverses the case of letters in the string or reverses the entire string if no letters are present.\n     *\n     * @param s The input string to process.\n     * @return The processed string according to the rules described.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the entire string.\n        if (!hasLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\")); // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));   // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\")); // Expected: \"#A@c\"\n\n        // Additional test cases\n        System.out.println(solution.solve(\"\"));     // Expected: \"\"\n        System.out.println(solution.solve(\"123abc456ABC789\")); // Expected: \"123ABC456abc789\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        \n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add leading zeros to make sure hash is 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.string_to_md5(\"Hello world\"));  // Expected output: \"3e25960a79dbc69b674cd4ec67a72c62\"\n        System.out.println(solution.string_to_md5(\"\"));            // Expected output: Optional.empty()\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * @param a The starting integer (inclusive).\n     * @param b The ending integer (inclusive).\n     * @return A list of integers containing all even digits between a and b.\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that 'a' is less than or equal to 'b'\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> evenDigits = new ArrayList<>();\n        for (int i = Math.max(a, 2); i <= b; i++) {\n            // Check each digit of the number\n            while (i > 0) {\n                int digit = i % 10;\n                if (digit < 10 && digit % 2 == 0) {\n                    evenDigits.add(digit);\n                }\n                i /= 10; // Move to the next digit\n            }\n        }\n\n        // Remove duplicates and sort the list\n        Set<Integer> set = new LinkedHashSet<>(evenDigits); // Preserves insertion order\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.generate_integers(2, 8)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(result1); // Expected output: false\n        \n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(result2); // Expected output: true\n        \n        // Additional test case\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.8, 10.2, 11.5), 0.4);\n        System.out.println(result3); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String noSpaces = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < noSpaces.length(); i++) {\n            char c = noSpaces.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(noSpaces.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> groups = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : groups) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to verify the correctness of truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if a bank account's balance ever goes below zero.\n     *\n     * @param operations A list of integers representing deposit (+ve) and withdrawal (-ve) amounts.\n     * @return true if the balance falls below zero at any point, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Starting balance is zero\n\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance went below zero\n            }\n        }\n\n        return false; // No point where balance was below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Expected: false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty.\");\n        }\n\n        // Calculate the mean\n        double sum = 0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (Double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyListResult = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyListResult); // Should print []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyListResult = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyListResult); // Should print [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses separated by spaces.\n     * @return A list of integers representing the deepest level of nesting for each group in the input string.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    /**\n     * Test method for parse_nested_parens.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> expectedOutput = Arrays.asList(2, 3, 1, 3);\n        List<Integer> actualOutput = solution.parse_nested_parens(\"(()()) ((())) () ((())()())\");\n\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output:   \" + actualOutput);\n\n        // Verify the correctness of the output\n        if (expectedOutput.equals(actualOutput)) {\n            System.out.println(\"The function works correctly!\");\n        } else {\n            System.out.println(\"There is an error in the function.\");\n        }\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java Streams API to filter the list based on the presence of the substring\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Expected output: [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Expected output: [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     * >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n     * [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        // If the input is empty, return an empty string\n        if (string == null || string.length() == 0) {\n            return \"\";\n        }\n        \n        int n = string.length();\n        for (int i = n; i >= 0; i--) {\n            if (isPalindrome(string.substring(0, i))) {\n                // Found the longest palindromic prefix\n                String suffix = string.substring(i);\n                String prefix = string.substring(0, n - i);\n                return new StringBuilder(prefix).reverse().append(suffix).toString();\n            }\n        }\n        \n        // If no palindrome is found (should not happen for non-empty strings)\n        return \"\";\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two input strings consisting only of 1s and 0s.\n     * @param a The first binary string.\n     * @param b The second binary string.\n     * @return A string representing the result of the binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of equal length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        for (int i = 0; i < maxLength; i++) {\n            // XOR the bits and append to result\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append(\"0\");\n            } else {\n                result.append(\"1\");\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"111\", \"000\"));  // Expected output: \"111\"\n        System.out.println(solution.string_xor(\"101010\", \"111100\"));  // Expected output: \"010110\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.longest(new ArrayList<>())); // Expected output: Optional.empty\n\n        // Test case 2: Single element list\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected output: Optional[a]\n\n        // Test case 3: Multiple elements with different lengths\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected output: Optional[ccc]\n\n        // Test case 4: Multiple elements with the same length\n        System.out.println(solution.longest(Arrays.asList(\"abc\", \"def\", \"ghi\"))); // Expected output: Optional[abc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test class to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.greatest_common_divisor(3, 5));   // Expected output: 1\n        System.out.println(sol.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(sol.greatest_common_divisor(-60, 48)); // Expected output: 12\n        System.out.println(sol.greatest_common_divisor(0, 5));   // Expected output: 5 (since GCD(a, 0) = |a|)\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        prefixes = solution.all_prefixes(\"\");\n        System.out.println(prefixes);  // Expected output: []\n        \n        prefixes = solution.all_prefixes(\"hello\");\n        System.out.println(prefixes);  // Expected output: [h, he, hel, hell, hello]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"Hello, World!\")); // Expected output: 10\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format and returns a list of integers.\n     * Each integer corresponds to the number of beats each note lasts.\n     *\n     * Legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quarter note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        List<Integer> result = new ArrayList<>();\n        String[] notes = string.split(\" \");\n        \n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    result.add(4);\n                    break;\n                case \"o|\":\n                    result.add(2);\n                    break;\n                case \".|\":\n                    result.add(1);\n                    break;\n                default:\n                    // Handle unexpected input if necessary\n                    System.out.println(\"Unexpected note: \" + note);\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlaping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) return 0;\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Mapping of words to their numeric values\n        Map<String, Integer> wordToNum = new HashMap<>();\n        wordToNum.put(\"zero\", 0);\n        wordToNum.put(\"one\", 1);\n        wordToNum.put(\"two\", 2);\n        wordToNum.put(\"three\", 3);\n        wordToNum.put(\"four\", 4);\n        wordToNum.put(\"five\", 5);\n        wordToNum.put(\"six\", 6);\n        wordToNum.put(\"seven\", 7);\n        wordToNum.put(\"eight\", 8);\n        wordToNum.put(\"nine\", 9);\n\n        // Split the input string into an array of words\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its numeric value and sort them\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = wordToNum.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Reassemble the sorted numbers back into a string of words\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            for (Map.Entry<String, Integer> entry : wordToNum.entrySet()) {\n                if (entry.getValue().equals(num)) {\n                    if (result.length() > 0) {\n                        result.append(\" \");\n                    }\n                    result.append(entry.getKey());\n                    break;\n                }\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test the sort_numbers method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven\"));  // Expected: \"seven eight nine\"\n        System.out.println(solution.sort_numbers(\"zero four two\"));  // Expected: \"zero two four\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        List<Double> result = new ArrayList<>();\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n            \n            if (diff < minDiff) {\n                minDiff = diff;\n                result.clear();\n                result.add(numbers.get(i));\n                result.add(numbers.get(i + 1));\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> numbers1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(numbers1)); // Expected: [2.0, 2.2]\n\n        // Test case 2\n        List<Double> numbers2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(numbers2)); // Expected: [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all numbers are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or throw an exception depending on requirements\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Double> numbers1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(solution.rescale_to_unit(numbers1)); // Expected: [0.0, 0.25, 0.5, 0.75, 1.0]\n\n        // Test case 2\n        List<Double> numbers2 = Arrays.asList(3.0, -1.0, 4.0);\n        System.out.println(solution.rescale_to_unit(numbers2)); // Expected: [0.6875, 0.0, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> list1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(list1)); // Expected: [5]\n\n        List<Object> list2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(list2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "class Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "class Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go downwards to 1\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, which should not happen as 1 always divides any number.\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.factorize(8);\n        System.out.println(result1); // Expected: [2, 2, 2]\n        \n        List<Integer> result2 = solution.factorize(25);\n        System.out.println(result2); // Expected: [5, 5]\n        \n        List<Integer> result3 = solution.factorize(70);\n        System.out.println(result3); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        for (Integer number : numbers) {\n            countMap.put(number, countMap.getOrDefault(number, 0) + 1);\n        }\n        \n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> testList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(testList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n\n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenates list of strings into a single string.\n     *\n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder result = new StringBuilder();\n        for (String str : strings) {\n            result.append(str);\n        }\n        return result.toString();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(\"Test Case 1 (Empty List): \" + (solution.concatenate(emptyList).equals(\"\") ? \"Passed\" : \"Failed\"));\n\n        // Test case 2: Non-empty list with multiple elements\n        List<String> nonEmptyList = Arrays.asList(\"a\", \"b\", \"c\");\n        String expectedOutput = \"abc\";\n        System.out.println(\"Test Case 2 (Non-Empty List): \" + (solution.concatenate(nonEmptyList).equals(expectedOutput) ? \"Passed\" : \"Failed\"));\n\n        // Additional test case: Single element list\n        List<String> singleElementList = Arrays.asList(\"hello\");\n        expectedOutput = \"hello\";\n        System.out.println(\"Test Case 3 (Single Element List): \" + (solution.concatenate(singleElementList).equals(expectedOutput) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test method to demonstrate the functionality\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyListResult = solution.filter_by_prefix(new ArrayList<>(), \"a\");\n        System.out.println(emptyListResult); // Should print []\n\n        // Test case 2: List with some strings starting with the prefix\n        List<String> resultList = solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\");\n        System.out.println(resultList); // Should print [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(x -> x > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for numbers less than 2\n        if (n <= 1) return false;\n        \n        // Check for 2\n        if (n == 2) return true;\n\n        // Exclude even numbers greater than 2\n        if (n % 2 == 0) return false;\n\n        // Test only odd numbers up to the square root of n\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass TestSolution {\n    private Solution solution = new Solution();\n\n    @org.junit.jupiter.api.Test\n    void testPoly() {\n        // Test case 1: f(x) = 2 + 3x\n        List<Double> coefficients1 = Arrays.asList(2.0, 3.0);\n        assertEquals(5.0, solution.poly(coefficients1, 1), \"Test failed for x=1\");\n        \n        // Test case 2: f(x) = -4 + 5x^2\n        List<Double> coefficients2 = Arrays.asList(-4.0, 0.0, 5.0);\n        assertEquals(1.0, solution.poly(coefficients2, 1), \"Test failed for x=1\");\n        \n        // Test case 3: f(x) = -6 + 11x - 6x^2 + x^3\n        List<Double> coefficients3 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        assertEquals(0.0, solution.poly(coefficients3, 1), \"Test failed for x=1\");\n    }\n\n    @org.junit.jupiter.api.Test\n    void testFindZero() {\n        // Test case 1: f(x) = 1 + 2x\n        List<Double> coefficients1 = Arrays.asList(1.0, 2.0);\n        assertEquals(-0.5, solution.find_zero(coefficients1), \"Test failed for coefficients [1, 2]\");\n        \n        // Test case 2: f(x) = -6 + 11x - 6x^2 + x^3\n        List<Double> coefficients2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        assertEquals(1.0, solution.find_zero(coefficients2), \"Test failed for coefficients [-6, 11, -6, 1]\");\n        \n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indicies that are divisible by three are equal\n     * to the values of the corresponding indices of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 and sort them\n        List<Integer> divisibleByThree = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering 1-based index as per problem statement\n                divisibleByThree.add(l.get(i));\n            }\n        }\n        Collections.sort(divisibleByThree);\n\n        // Create a new list to store the result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        int sortIndex = 0;\n        for (int i = 2; i < l.size(); i += 3) { // Start from index 2 as per problem statement\n            sortedList.set(i, divisibleByThree.get(sortIndex++));\n        }\n\n        return sortedList;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(test1)); // Expected: [1, 2, 3]\n        \n        List<Integer> test2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(test2)); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order while removing duplicates\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back into a list and sort it\n        List<Integer> sortedList = new ArrayList<>(set);\n        Collections.sort(sortedList);\n\n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> inputList = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> resultList = solution.unique(inputList);\n\n        System.out.println(resultList); // Expected output: [0, 2, 3, 5, 9, 123]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0);\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in [1, 2, 3]: \" + solution.max_element(list1)); // Expected output: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]: \" + solution.max_element(list2)); // Expected output: 123\n        \n        // Test case with an empty list\n        List<Integer> listEmpty = new ArrayList<>();\n        try {\n            System.out.println(\"Max element in []: \" + solution.max_element(listEmpty));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected output: List must not be empty or null\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) { // Count occurrences of '7'\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50));  // Expected output: 0\n        System.out.println(solution.fizz_buzz(78));  // Expected output: 2\n        System.out.println(solution.fizz_buzz(79));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold all even-indexed elements\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract even-indexed elements and add them to 'evens'\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the extracted even-indexed elements\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> result = new ArrayList<>();\n        \n        // Initialize index for 'evens'\n        int evenIndex = 0;\n        \n        // Reconstruct the list with sorted even-indexed values and original odd-indexed values\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) { // Even index, use sorted value from 'evens'\n                result.add(evens.get(evenIndex++));\n            } else { // Odd index, keep original value\n                result.add(l.get(i));\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(1) + groups.get(i).charAt(2) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encodeCyclic(\"abc\"));  // Expected output: \"bca\"\n        System.out.println(solution.decode_cyclic(\"bca\")); // Expected output: \"abc\"\n\n        System.out.println(solution.encodeCyclic(\"abcd\")); // Expected output: \"bcda\"\n        System.out.println(solution.decode_cyclic(\"bcda\")); // Expected output: \"abcd\"\n\n        System.out.println(solution.encodeCyclic(\"abcdefg\")); // Expected output: \"bcaefdg\"\n        System.out.println(solution.decode_cyclic(\"bcaefdg\")); // Expected output: \"abcdefg\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * prime_fib returns the n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        int count = 0;\n\n        while (count < n) {\n            int nextFib = fib1 + fib2;\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n                count++;\n            }\n            fib1 = fib2;\n            fib2 = nextFib;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_fib(1)); // Output: 2\n        System.out.println(solution.prime_fib(2)); // Output: 3\n        System.out.println(solution.prime_fib(3)); // Output: 5\n        System.out.println(solution.prime_fib(4)); // Output: 13\n        System.out.println(solution.prime_fib(5)); // Output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars moving towards each other on an infinitely long straight road.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from one side will collide with a car from the opposite side,\n        // and there are 'n' cars on each side, the total number of collisions is 'n'.\n        return n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(0));  // Expected output: 0 (no cars, no collisions)\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1 (one car from each side collides once)\n        System.out.println(solution.car_race_collision(5));  // Expected output: 5 (five cars from each side collide five times)\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Method to test the functionality of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seen.contains(complement)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9.\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n\n        // Additional test cases\n        System.out.println(solution.change_base(9, 3)); // Expected output: \"100\"\n        System.out.println(solution.change_base(5, 5)); // Expected output: \"10\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double a, double h) {\n        // Area of a triangle formula: (1/2) * base * height\n        return 0.5 * a * h;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(8, 4);\n        System.out.println(\"Area of triangle with base=8 and height=4: \" + area2); // Expected output: 16.0\n        \n        // Test case 3\n        double area3 = solution.triangle_area(10, 5);\n        System.out.println(\"Area of triangle with base=10 and height=5: \" + area3); // Expected output: 25.0\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    /**\n     * Computes the n-th element of the Fib4 number sequence without using recursion.\n     *\n     * @param n The index of the sequence to compute.\n     * @return The n-th element of the Fib4 sequence.\n     */\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0 || n == 1 || n == 3) return 0;\n        if (n == 2) return 2;\n\n        // Initialize the first four elements of the sequence\n        int a = 0, b = 0, c = 2, d = 0; // fib4(0), fib4(1), fib4(2), fib4(3)\n        \n        // Compute the n-th element using a loop\n        for (int i = 4; i <= n; i++) {\n            int next = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next;\n        }\n\n        return d;\n    }\n    \n    // Test the function with some examples\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fib4(5));  // Expected output: 4\n        System.out.println(solution.fib4(6));  // Expected output: 8\n        System.out.println(solution.fib4(7));  // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list\n        Collections.sort(l);\n        \n        int n = l.size();\n        if (n % 2 == 1) { // If odd, return the middle element\n            return l.get(n / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get((n - 1) / 2) + l.get(n / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome.\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        // Base case: any number to the power of 0 is 1.\n        if (n == 0) return 1;\n\n        long result = 1;\n        long base = 2 % p; // To avoid overflow for large numbers\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by base\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));    // Expected output: 1\n        System.out.println(solution.modp(3, 11));     // Expected output: 8\n        System.out.println(solution.modp(100, 101));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "class Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char base = Character.isUpperCase(ch) ? 'A' : 'a';\n                sb.append((char) ((ch - base + 26 - 5) % 26 + base));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char base = Character.isUpperCase(ch) ? 'A' : 'a';\n                sb.append((char) ((ch - base + 26 + 5) % 26 + base));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"abc\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should print \"fgh\"\n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should print \"abc\"\n\n        String testString2 = \"Hello, World!\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Encoded string\n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should print \"Hello, World!\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define the set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                             'A', 'E', 'I', 'O', 'U'));\n        \n        // Use a StringBuilder to build the result string without vowels\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + solution.below_threshold(list1, threshold1)); // Expected output: true\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + solution.below_threshold(list2, threshold2)); // Expected output: false\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(1, 2, 4, 9);\n        int threshold3 = 10;\n        System.out.println(\"Test Case 3: \" + solution.below_threshold(list3, threshold3)); // Expected output: true\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(5, 6, 7, 8);\n        int threshold4 = 5;\n        System.out.println(\"Test Case 4: \" + solution.below_threshold(list4, threshold4)); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     * >>> add(2, 3)\n     * 5\n     * >>> add(5, 7)\n     * 12\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"Test Case 1: \" + (solution.add(2, 3) == 5 ? \"Passed\" : \"Failed\"));\n        System.out.println(\"Test Case 2: \" + (solution.add(5, 7) == 12 ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Use a HashSet to store unique characters from both strings\n        Set<Character> setS0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            setS0.add(c);\n        }\n\n        // Check if all characters in the second string are present in the first string's set\n        return s1.chars().allMatch(ch -> setS0.contains((char) ch));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = b;\n            b = a + b;\n            a = temp;\n        }\n        \n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib(10)); // Expected output: 55\n        System.out.println(solution.fib(1));  // Expected output: 1\n        System.out.println(solution.fib(8));  // Expected output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n                \n                // If balance is negative, there are more closing brackets than opening ones\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // If balance is zero, all opening brackets have corresponding closing brackets\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.isEmpty() || l.size() == 1) return true; // An empty list or a single-element list is considered monotonic.\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 0; i < l.size() - 1; i++) {\n            if (l.get(i) < l.get(i + 1)) {\n                increasing = true;\n            } else if (l.get(i) > l.get(i + 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing.\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Use a set to store the unique common elements\n        Set<Integer> commonElements = new HashSet<>();\n        \n        // Iterate through the first list and check if each element is in the second list\n        for (Integer num : l1) {\n            if (l2.contains(num)) {\n                commonElements.add(num);\n            }\n        }\n\n        // Convert the set to a sorted list\n        List<Integer> sortedCommon = new ArrayList<>(commonElements);\n        Collections.sort(sortedCommon);\n\n        return sortedCommon;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> result1 = solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121));\n        System.out.println(result1); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> result2 = solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2));\n        System.out.println(result2); // Expected: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // Use division operator instead of /= for clarity\n        }\n\n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n = n / i;\n            }\n        }\n\n        // If n is a prime number and greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the largest_prime_factor method\n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "class Solution {\n    /**\n     * Calculates the sum of all integers from 1 to n.\n     *\n     * @param n The upper limit integer (inclusive).\n     * @return The sum of all integers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sum_to_n(30)); // Expected output: 465\n        System.out.println(solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(solution.sum_to_n(5)); // Expected output: 15\n        System.out.println(solution.sum_to_n(10)); // Expected output: 55\n        System.out.println(solution.sum_to_n(1)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string of '(' and ')' is correctly bracketed.\n     *\n     * @param brackets A string containing only '(' and ')'.\n     * @return true if every opening bracket has a corresponding closing bracket, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            // If an open bracket is found\n            if (c == '(') {\n                balance++;\n            }\n            // If a close bracket is found and there's no corresponding open bracket\n            else if (balance <= 0) {\n                return false;\n            } \n            else {\n                balance--;\n            }\n        }\n\n        // If all brackets are balanced, return true. Otherwise, return false.\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // Expected output: false\n        System.out.println(solution.correct_bracketing(\"()\"));  // Expected output: true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\")(()\"));  // Expected output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative of a constant term is 0, so we skip it.\n        if (xs.size() <= 1) return Collections.emptyList();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            int coefficient = i * xs.get(i);\n            result.add(coefficient);\n        }\n        return result;\n    }\n\n    // Test code to verify the correctness of the derivative method.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        \n        // Compute the n-th element iteratively to avoid recursion overhead and stack overflow for large n.\n        for (int i = 3; i <= n; i++) {\n            int next = a + b + c;\n            a = b;\n            b = c;\n            c = next;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) >= 0 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to easily manipulate its digits\n        String numStr = Integer.toString(x);\n        \n        // Calculate effective shift value considering the length of the number\n        int len = numStr.length();\n        if (shift >= len) {\n            // If shift is greater than or equal to the length, reverse the string\n            return new StringBuilder(numStr).reverse().toString();\n        } else {\n            // Perform circular right shift by slicing and concatenating parts of the string\n            String shiftedPart = numStr.substring(len - shift);\n            String remainingPart = numStr.substring(0, len - shift);\n            return shiftedPart + remainingPart;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.circular_shift(12, 1)); // Expected output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected output: \"12\" (no change)\n        System.out.println(solution.circular_shift(12345, 3)); // Expected output: \"34512\"\n        System.out.println(solution.circular_shift(12345, 6)); // Expected output: \"54321\" (reversed)\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Extract the number of apples and oranges from the string.\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes by subtracting the number of apples\n        // and oranges from the total number of fruits.\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the smallest even value and its index.\n                if (value < smallestEvenValue || (value == smallestEvenValue && i < index)) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        // If no even number was found, return an empty list\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        \n        // Count the frequency of each integer\n        for (int num : lst) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Iterate through the map to find the greatest number that meets the condition\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        Collections.sort(lst); // Sort the list in ascending order\n        List<Integer> result = new ArrayList<>();\n        \n        int start = 0;\n        int end = lst.size() - 1;\n\n        while (start <= end) {\n            if (start == end) {\n                result.add(lst.get(start));\n            } else {\n                result.add(lst.get(start++)); // Add the minimum value\n                result.add(lst.get(end--));   // Add the maximum value\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(10, -1, 3, 9);\n        System.out.println(solution.strange_sort_list(test4)); // Expected: [-1, 10, 3, 9]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if an object represented by a list of integers will fly.\n     * The object will fly if it's balanced (palindromic) and its total weight is less than or equal to w.\n     *\n     * @param q A List<Integer> representing the object's structure.\n     * @param w An integer representing the maximum possible weight for the object to fly.\n     * @return true if the object will fly, false otherwise.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        boolean isBalanced = isPalindromic(q);\n        \n        // Calculate the sum of elements in the list\n        int totalWeight = 0;\n        for (int num : q) {\n            totalWeight += num;\n        }\n        \n        // Determine if it will fly based on balance and weight constraints\n        return isBalanced && totalWeight <= w;\n    }\n\n    /**\n     * Helper method to check if a list is palindromic.\n     *\n     * @param list A List<Integer> to be checked for being palindromic.\n     * @return true if the list is palindromic, false otherwise.\n     */\n    private boolean isPalindromic(List<Integer> list) {\n        int left = 0;\n        int right = list.size() - 1;\n        \n        while (left < right) {\n            if (!list.get(left).equals(list.get(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // Expected: true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic. A palindromic array is an array that reads the same backwards and forwards.\n     * In one change, you can change one element to any other element.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int changes = 0;\n        int left = 0;\n        int right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the list with fewer total characters. If both lists have the same number of characters,\n     * returns the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String str : lst1) {\n            count1 += str.length();\n        }\n\n        int count2 = 0;\n        for (String str : lst2) {\n            count2 += str.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        \n        List<String> result1 = solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"));\n        System.out.println(result1); // [hI, Hi]\n        \n        List<String> result2 = solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"));\n        System.out.println(result2); // [hi, admin]\n        \n        List<String> result3 = solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"));\n        System.out.println(result3); // [hI, hi, hi]\n        \n        List<String> result4 = solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"));\n        System.out.println(result4); // [4]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (a == p1 * p2 * p3)\n                        return true;\n                    \n                    if (p1 * p2 * p3 >= a || p1 * p2 > 100) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++)\n                    isComposite[i * j] = true;\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // If n is 1, then x must also be 1 for it to be a simple power\n        if (n == 1) return x == 1;\n        \n        double logResult = Math.log(x) / Math.log(n);\n        return logResult == (int)logResult;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if an integer is a perfect cube of some integer.\n     *\n     * @param a The integer to check.\n     * @return true if 'a' is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        // Calculate the cube root and round it to the nearest integer\n        int cubeRoot = (int)Math.round(Math.pow(a, 1.0 / 3.0));\n        \n        // Check if cubing this rounded value gives back the original number 'a'\n        return Math.pow(cubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n        \n        // Additional test cases for thoroughness\n        System.out.println(solution.iscube(-27)); // true\n        System.out.println(solution.iscube(125)); // true\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    /**\n     * Counts the number of prime hexadecimal digits in the provided string.\n     */\n    public int hex_key(String num) {\n        // Define a set containing all prime hexadecimal digits as characters.\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n\n        // Initialize a counter to keep track of the number of prime digits found.\n        int count = 0;\n\n        // Iterate through each character in the input string.\n        for (char c : num.toCharArray()) {\n            // If the current character is a prime digit, increment the counter.\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n\n        // Return the final count of prime hexadecimal digits.\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.hex_key(\"AB\"));          // Output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at the beginning and end of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A simple test method to check if the function works correctly.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given string is happy.\n     * A string is considered happy if its length is at least 3 and every set of three consecutive letters are distinct.\n     */\n    public boolean is_happy(String s) {\n        // Check if the string's length is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string to check for any three consecutive characters that are not distinct\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // If any three consecutive characters are the same, return false\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If no three consecutive characters were found to be not distinct, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of GPAs into their corresponding letter grades.\n     *\n     * @param grades A List<Double> containing student GPAs.\n     * @return A List<String> containing the letter grades for each GPA.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\"); // This case should not happen as GPA is non-negative.\n            }\n        }\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = solution.numerical_letter_grade(grades);\n        System.out.println(result); // Expected output: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a given string is a prime number.\n     *\n     * @param string The input string.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        return isPrime(len);\n    }\n\n    /**\n     * Helper function to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        // Count of numbers starting with 1\n        long countStartsWithOne = (long)Math.pow(10, n - 1);\n        \n        // Count of numbers ending with 1\n        long countEndsWithOne = (long)Math.pow(10, n - 1);\n\n        if (n > 1) {\n            // Count of numbers starting and ending with 1\n            long countStartsAndEndsWithOne = (long)Math.pow(8, n - 2);\n            \n            return (int)(countStartsWithOne + countEndsWithOne - countStartsAndEndsWithOne);\n        } else {\n            // For single-digit number, all numbers starting or ending with 1 are the same\n            return 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1)); // Expected output: 1\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 18 (10 + 10 - 1)\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 198 (100 + 100 - 2)\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example:\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     *      Constraints: 0 <= N <= 10000.\n     * Output:\n     *      a string of binary number\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n        \n        // Convert the sum into binary and return it as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current odd index is even\n                sum += lst.get(i); // Add it to the sum\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(4, 2, 6, 7);\n        System.out.println(solution.add(test1)); // Expected output: 2\n        \n        List<Integer> test2 = Arrays.asList(5, 8, 3, 2, 9);\n        System.out.println(solution.add(test2)); // Expected output: 0 (since there are no even elements at odd indices)\n        \n        List<Integer> test3 = Arrays.asList(1, 4, 6, 8, 10);\n        System.out.println(solution.add(test3)); // Expected output: 4 + 10 = 14\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string with each word's characters sorted.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words based on space delimiter\n        String[] words = s.split(\" \");\n        \n        // StringBuilder to build the final result\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                // Convert each character in the word to a char array, sort it, and then convert back to string\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                String sortedWord = new String(chars);\n\n                // Append the sorted word to the result with a space after (except for the last word)\n                result.append(sortedWord).append(\" \");\n            } else {\n                // If there's an empty string in the array, append a single space\n                result.append(\" \");\n            }\n        }\n\n        // Remove the trailing space if it exists\n        if (result.length() > 0) {\n            result.setLength(result.length() - 1);\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the anti_shuffle function\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the nested list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // For each element in the current row, check if it matches x\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinates to the result list\n                    List<Integer> coordinate = new ArrayList<>();\n                    coordinate.add(i);\n                    coordinate.add(j);\n                    result.add(coordinate);\n                }\n            }\n        }\n\n        // Sort the result by rows in ascending order and columns in descending order within each row\n        Collections.sort(result, (a, b) -> {\n            if (!a.get(0).equals(b.get(0))) {\n                return a.get(0) - b.get(0);\n            } else {\n                return b.get(1) - a.get(1); // Descending order for columns within the same row\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        // Test case 2\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        // Test case 3\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int first = array.get(0);\n        int last;\n        \n        // Handle single element case separately\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n        \n        boolean isOddSum = (first + last) % 2 != 0;\n\n        List<Integer> sortedList = new ArrayList<>(array); // Create a copy of the original list\n        if (isOddSum) {\n            Collections.sort(sortedList); // Sort in ascending order\n        } else {\n            sortedList.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedList;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places (i.e., 4 positions).\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element of the list.\n     * @param lst List of integers.\n     * @return Optional containing the second smallest integer, or empty if not applicable.\n     */\n    public static Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Integer firstMin = null;\n        Integer secondMin = null;\n\n        for (Integer num : lst) {\n            if (num != null && (firstMin == null || num <= firstMin)) {\n                secondMin = firstMin;\n                firstMin = num;\n            } else if (num != null && (secondMin == null || num < secondMin && num > firstMin)) {\n                secondMin = num;\n            }\n        }\n\n        return Optional.ofNullable(secondMin);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(next_smallest(Arrays.asList()));               // Expected: Optional.empty\n        System.out.println(next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are delimited by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int isBored(String S) {\n        // Split the text into sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.isBored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.isBored(\"The sky is blue. The sun is shining. I love this weather\"));  // Expected output: 1\n        System.out.println(solution.isBored(\"I am happy today. But tomorrow, I might not be.\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility).\n     * @param y Second number (Object type for flexibility).\n     * @param z Third number (Object type for flexibility).\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return (a == b + c || b == a + c || c == a + b);\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes a message by swapping case of all letters, replacing vowels with the letter that appears 2 places ahead.\n     */\n    public String encode(String message) {\n        // Define mappings for vowels and their replacements\n        Map<Character, Character> vowelMap = new HashMap<>();\n        vowelMap.put('a', 'c');\n        vowelMap.put('e', 'g');\n        vowelMap.put('i', 'k');\n        vowelMap.put('o', 'q');\n        vowelMap.put('u', 'w');\n        vowelMap.put('A', 'C');\n        vowelMap.put('E', 'G');\n        vowelMap.put('I', 'K');\n        vowelMap.put('O', 'Q');\n        vowelMap.put('U', 'W');\n\n        // Process each character in the message\n        StringBuilder encodedMessage = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {  // Check if it's a letter\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                if (vowelMap.containsKey(swappedCaseChar)) {\n                    encodedMessage.append(vowelMap.get(swappedCaseChar));\n                } else {\n                    encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are not modified\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encode(\"test\"));  // Expected output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected output: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime number in a list and returns the sum of its digits.\n     */\n    public int largestPrimeDigitSum(List<Integer> lst) {\n        return lst.stream()\n                .filter(this::isPrime)\n                .max(Integer::compare)\n                .map(num -> digitSum(num))\n                .orElse(0);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    private int digitSum(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Integer> test1 = Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3);\n        System.out.println(solution.largestPrimeDigitSum(test1)); // Expected output: 10\n\n        List<Integer> test2 = Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1);\n        System.out.println(solution.largestPrimeDigitSum(test2)); // Expected output: 25\n\n        List<Integer> test3 = Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3);\n        System.out.println(solution.largestPrimeDigitSum(test3)); // Expected output: 13\n\n        List<Integer> test4 = Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6);\n        System.out.println(solution.largestPrimeDigitSum(test4)); // Expected output: 11\n\n        List<Integer> test5 = Arrays.asList(0,81,12,3,1,21);\n        System.out.println(solution.largestPrimeDigitSum(test5)); // Expected output: 3\n\n        List<Integer> test6 = Arrays.asList(0,8,1,2,1,7);\n        System.out.println(solution.largestPrimeDigitSum(test6)); // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;  // If any key is not a string, return False\n            }\n            \n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n\n            if (!allLowerCase && !allUpperCase) {  // If keys are neither all lower nor upper case\n                return false;\n            }\n        }\n\n        return true;  // All keys are strings and either all in lower or upper case\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"a\", \"apple\");\n        map1.put(\"b\", \"banana\");\n\n        System.out.println(solution.check_dict_case(map1));  // Expected: true\n\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"a\", \"apple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n\n        System.out.println(solution.check_dict_case(map2));  // Expected: false\n\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"a\", \"apple\");\n        map3.put(8, \"banana\");  // Note that this is not a string key\n        map3.put(\"a\", \"apple\");\n\n        System.out.println(solution.check_dict_case(map3));  // Expected: false\n\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n\n        System.out.println(solution.check_dict_case(map4));  // Expected: false\n\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n\n        System.out.println(solution.check_dict_case(map5));  // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers by taking modulo 10\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        // Define a set of uppercase vowels for easy checking.\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        // Iterate through the string, considering only even indices (0-based).\n        for (int i = 1; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            if (uppercaseVowels.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\"));  // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n        System.out.println(solution.count_upper(\"AbEcIdOfOg\")); // Additional test case, expected output: 3\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * @param value String representation of a number.\n     * @return The closest integer to the given number, rounded away from zero if necessary.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        long floorValue = (long)Math.floor(num);\n        long ceilValue = (long)Math.ceil(num);\n\n        // Check if the number is equidistant between two integers\n        if ((num - floorValue) == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue - 1);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));     // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));   // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));   // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));  // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        // Initialize the result list with the first element being 'n'\n        List<Integer> pile = new ArrayList<>();\n        pile.add(n);\n\n        // Determine whether to add odd or even numbers next based on the parity of n\n        int increment = (n % 2 == 0) ? 2 : 1;\n\n        // Calculate the number of stones for each subsequent level and add it to the list\n        for (int i = 1; i < n; i++) {\n            pile.add(pile.get(i - 1) + increment);\n            // Toggle between odd and even increments after adding a new element\n            increment = (increment == 2) ? 1 : 2;\n        }\n\n        return pile;\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a string into words based on commas and spaces.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List of strings, each representing a word from the input string.\n     */\n    public List<String> words_string(String s) {\n        // Use regex to split the string at commas and spaces\n        String[] parts = s.split(\"[ ,]+\");\n        \n        // Convert array to list and return it\n        return Arrays.asList(parts);\n    }\n    \n    /**\n     * A simple test method to check if the function works as expected.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        String input1 = \"Hi, my name is John\";\n        List<String> expectedOutput1 = Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\");\n        System.out.println(solution.words_string(input1).equals(expectedOutput1) ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2\n        String input2 = \"One, two, three, four, five, six\";\n        List<String> expectedOutput2 = Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\");\n        System.out.println(solution.words_string(input2).equals(expectedOutput2) ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive.\n     * If there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        if (x > y) return -1; // If the range is invalid\n        \n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) { // Check if the number is even\n                return i;\n            }\n        }\n        \n        return -1; // If no even number found in the range\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    public Object rounded_avg(int n, int m) {\n        if (n > m) return -1;\n\n        // Calculate the sum of integers from n to m using arithmetic progression formula\n        long totalSum = ((long) m - n + 1) * (n + m) / 2;\n        \n        // Calculate the average and round it to the nearest integer\n        int roundedAvg = Math.round((float) totalSum / (m - n + 1));\n        \n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers, return a sorted list of all elements \n     * that do not contain any even digits.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Filter out numbers with even digits and sort the remaining\n        return x.stream()\n                .filter(this::hasNoEvenDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasNoEvenDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // No even digits found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter integers between 1 and 9\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Step 2: Sort the list in ascending order\n        Collections.sort(filtered);\n\n        // Step 3: Reverse the sorted list\n        List<Integer> reversed = new ArrayList<>(filtered.size());\n        for (int i = filtered.size() - 1; i >= 0; i--) {\n            reversed.add(filtered.get(i));\n        }\n\n        // Step 4: Convert each integer to its corresponding word representation\n        String[] numberWords = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        List<String> result = new ArrayList<>(reversed.size());\n        for (Integer num : reversed) {\n            result.add(numberWords[num - 1]);\n        }\n\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example test cases\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of i\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to i\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * calculateFactorial(n - 1);\n    }\n\n    private int calculateSum(int n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    private boolean isPalindrome(int number) {\n        int reversed = 0;\n        int original = number;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversed = reversed * 10 + digit;\n            number /= 10;\n        }\n        \n        return original == reversed;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> result1 = solution.even_odd_palindrome(3);\n        System.out.println(\"Test Case 1: \" + result1); // Expected output: [1, 2]\n\n        // Test case 2\n        List<Integer> result2 = solution.even_odd_palindrome(12);\n        System.out.println(\"Test Case 2: \" + result2); // Expected output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        int result = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                result++;\n            }\n        }\n        return result;\n    }\n\n    private int sumOfDigits(int number) {\n        boolean isNegative = number < 0;\n        int sum = 0;\n\n        while (number != 0) {\n            int digit = number % 10;\n            if (isNegative && number >= 0 || !isNegative && number < 0) {\n                digit *= -1; // Adjust the sign of the first digit\n            }\n            sum += digit;\n            number /= 10;\n\n            // Change sign for the next digit after encountering a non-negative digit in a negative number\n            if (number >= 0 && isNegative) {\n                isNegative = false;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it's possible to sort an array in non-decreasing order by performing right shift operations.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty, return true as per problem statement\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr);\n\n        for (int i = 0; i < n; i++) {\n            // Check if the current rotation matches the sorted array\n            boolean isSorted = true;\n            for (int j = 0; j < n - 1; j++) {\n                int nextIndex = (j + 1) % n;\n                if (arr.get(j) > arr.get(nextIndex)) {\n                    isSorted = false;\n                    break;\n                }\n            }\n\n            // If the current rotation matches, return true\n            if (isSorted && arr.equals(sortedArr)) {\n                return true;\n            }\n\n            // Perform a right shift operation for the next iteration\n            Collections.rotate(arr, 1);\n        }\n\n        // Return false if no valid rotation is found\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to exchange elements between two lists such that all elements in lst1 are even.\n     *\n     * @param lst1 The first list of integers.\n     * @param lst2 The second list of integers.\n     * @return \"YES\" if it's possible to make all elements in lst1 even through exchanges, otherwise returns \"NO\".\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count the number of odd numbers in lst1 and even numbers in lst2\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // If there are more odd numbers in lst1 than even numbers in lst2, it's impossible to make all elements of lst1 even\n        return oddCountInLst1 <= evenCountInLst2 ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(2, 4, 6, 8), Arrays.asList(1, 3, 5, 7))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string representing a space separated lowercase letters,\n     * return a dictionary of the letter with the most repetition and containing the corresponding count.\n     * If several letters have the same occurrence, return all of them.\n     *\n     * Example:\n     * histogram(\"a b c\") == {\"a\": 1, \"b\": 1, \"c\": 1}\n     * histogram(\"a b b a\") == {\"a\": 2, \"b\": 2}\n     * histogram(\"a b c a b\") == {\"a\": 2, \"b\": 2}\n     * histogram(\"b b b b a\") == {\"b\": 4}\n     * histogram(\"\") == {}\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into an array of letters\n        String[] letters = test.split(\" \");\n        \n        // Create a map to count occurrences of each letter\n        Map<String, Integer> counts = new HashMap<>();\n        for (String letter : letters) {\n            if (!letter.isEmpty()) {  // Ensure we're not counting empty strings\n                counts.put(letter, counts.getOrDefault(letter, 0) + 1);\n            }\n        }\n\n        // Find the maximum count of any letter\n        int maxCount = Collections.max(counts.values());\n\n        // Create a result map to store letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    // Test code to verify the correctness of the histogram method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set of characters to be removed for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in 'c'\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = isPalindrome(resultString);\n\n        // Return the result as a list containing the filtered string and the boolean value\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n\n        return resultList;\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> result1 = solution.reverse_delete(\"abcde\", \"ae\");\n        System.out.println(result1);  // Expected: [\"bcd\", false]\n\n        List<Object> result2 = solution.reverse_delete(\"abcdef\", \"b\");\n        System.out.println(result2);  // Expected: [\"acdef\", false]\n\n        List<Object> result3 = solution.reverse_delete(\"abcdedcba\", \"ab\");\n        System.out.println(result3);  // Expected: [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String str : lst) {\n            int countOdd = 0;\n            // Counting odd digits in the current string\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    countOdd++;\n                }\n            }\n            \n            // Constructing the result string with the number of odd digits\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0; // Edge case: empty list\n\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3))); // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList())); // Edge case with empty list\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Initialize a variable to keep track of the total number of bucket drops needed.\n        int totalDrops = 0;\n\n        // Iterate through each well (row in the grid).\n        for (List<Integer> row : grid) {\n            // Count the amount of water in the current well.\n            int waterUnits = 0;\n            for (int unit : row) {\n                if (unit == 1) {\n                    waterUnits++;\n                }\n            }\n\n            // Calculate how many times a bucket needs to be lowered for this well.\n            totalDrops += Math.ceilDiv(waterUnits, capacity);\n        }\n\n        return totalDrops;\n    }\n\n    /**\n     * Helper method to perform ceiling division (integer division rounded up).\n     */\n    private int ceilDiv(int dividend, int divisor) {\n        // Perform integer division and round up if there's a remainder.\n        return (dividend + divisor - 1) / divisor;\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation,\n     * and for similar counts, sorts based on decimal value.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Custom comparator that first compares by number of 1's in binary representation\n        // and then by decimal value if the number of 1's is equal.\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int count1 = Integer.bitCount(o1);\n                int count2 = Integer.bitCount(o2);\n\n                // Compare by number of ones first\n                if (count1 != count2) {\n                    return count1 - count2;\n                }\n\n                // If the number of ones is equal, compare by decimal value\n                return o1.compareTo(o2);\n            }\n        });\n\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1)); // Expected: [1, 2, 4, 3, 5]\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2)); // Expected: [-4, -2, -6, -5, -3]\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3)); // Expected: [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    private int countConsonants(String word) {\n        Set<Character> consonants = new HashSet<>(Arrays.asList(\n                'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',\n                'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'\n        ));\n        int count = 0;\n        for (char c : word.toLowerCase().toCharArray()) {\n            if (consonants.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the closest vowel that stands between two consonants from the right side of the word.\n     * Vowels in the beginning and ending don't count. Returns an empty string if no such vowel is found.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            if (!vowels.contains(word.charAt(i)) && \n                    vowels.contains(word.charAt(i + 1)) &&\n                    !vowels.contains(word.charAt(i - 1))) {\n                return String.valueOf(word.charAt(i));\n            }\n        }\n        \n        return \"\"; // Return empty string if no vowel meets the condition\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it is possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible combinations: str1 + str2 and str2 + str1\n        for (int i = 0; i < lst.size(); i++) {\n            if (isBalanced(lst.get(i), lst.get(1 - i))) {\n                return \"Yes\";\n            }\n        }\n        return \"No\";\n    }\n\n    /**\n     * Helper method to check if a string of parentheses is balanced.\n     *\n     * @param str The string to be checked for balance.\n     * @return true if the string is balanced, false otherwise.\n     */\n    private boolean isBalanced(String str) {\n        int balance = 0;\n        for (char c : str.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            // If at any point the balance goes negative, it's not balanced\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // The string is balanced only if the final balance is zero\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));   // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \"(\")));    // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min heap) to store the top k elements\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k);\n        \n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.offer(num);  // Add element to the heap if it's not full yet\n            } else if (num > pq.peek()) { \n                // If the current number is larger than the smallest in the heap, replace it\n                pq.poll();      // Remove the smallest element\n                pq.offer(num);  // Add the new number\n            }\n        }\n\n        // Convert the priority queue to a list and sort it (since we want ascending order)\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Output: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Output: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element at the current index is odd\n                sum += lst.get(i); // Add it to the sum\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     *\n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testArray1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(solution.add_elements(testArray1, k1)); // Expected output: 24\n\n        List<Integer> testArray2 = Arrays.asList(10, -1, 123, 456, 78, 90);\n        int k2 = 6;\n        System.out.println(solution.add_elements(testArray2, k2)); // Expected output: 10 + (-1) + 78 + 90 = 177\n\n        List<Integer> testArray3 = Arrays.asList(99, -99);\n        int k3 = 2;\n        System.out.println(solution.add_elements(testArray3, k3)); // Expected output: 99 + (-99) = 0\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> getOddCollatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        while (n != 1) {\n            if (n % 2 == 1) { // Check if the number is odd\n                result.add(n);\n            }\n            n = getNextCollatzNumber(n); // Get the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd\n        \n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    private int getNextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result = solution.getOddCollatz(5);\n        System.out.println(result); // Expected output: [1, 5]\n        \n        result = solution.getOddCollatz(7);\n        System.out.println(result); // Expected output: [1, 7]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the date pattern mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input matches the regular expression\n        boolean isMatch = date.matches(regex);\n        \n        if (!isMatch) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check the validity of the month\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Check the number of days in a given month and year\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n            return false;\n        } else if (month == 2) {\n            boolean isLeapYear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n            if (!isLeapYear && day > 28) {\n                return false;\n            } else if (isLeapYear && day > 29) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.valid_date(\"03-11-2000\"));  // Expected: true\n        System.out.println(solution.valid_date(\"15-01-2012\"));  // Expected: false\n        System.out.println(solution.valid_date(\"04-0-2040\"));   // Expected: false\n        System.out.println(solution.valid_date(\"06-04-2020\"));  // Expected: true\n        System.out.println(solution.valid_date(\"06/04/2020\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Split on whitespace first\n        String[] words = txt.split(\"\\\\s+\");\n        \n        // If there are no whitespaces, try splitting on commas\n        if (words.length == 1 && !txt.contains(\" \")) {\n            words = txt.split(\",\");\n        }\n        \n        // If the string is still a single element and contains only lowercase letters, count odd-positioned characters\n        if (words.length == 1 && !txt.contains(\" \") && !txt.contains(\",\")) {\n            return countOddPositionedLetters(txt);\n        }\n\n        // Return the list of words or the count as an Integer wrapped in Object\n        return Arrays.asList(words);\n    }\n    \n    private int countOddPositionedLetters(String txt) {\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int position = c - 'a';\n                if (position % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If any number appears more than twice, return false. Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (Integer currentNumber : lst) {\n            if (previousNumber != null && currentNumber < previousNumber) {\n                // If the list is not in ascending order, return false.\n                return false;\n            }\n\n            // Check if the current number is the same as the previous one\n            if (currentNumber.equals(previousNumber)) {\n                count++;\n                if (count > 2) {\n                    // If any number appears more than twice, return false.\n                    return false;\n                }\n            } else {\n                // Reset the count for a new number\n                count = 1;\n            }\n\n            previousNumber = currentNumber;\n        }\n\n        return true; // The list is sorted and no number appears more than twice.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // Expected: true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // Expected: true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // Expected: false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // Expected: true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // Expected: true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // Expected: false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // Expected: true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether the intersection of two intervals has a prime length.\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        // Calculate the intersection\n        int maxStart = Math.max(start1, start2);\n        int minEnd = Math.min(end1, end2);\n        \n        if (maxStart > minEnd) {\n            return \"NO\";  // No intersection\n        }\n        \n        int length = minEnd - maxStart + 1;\n        \n        // Check if the length is a prime number\n        if (!isPrime(length)) {\n            return \"NO\";\n        } else {\n            return \"YES\";\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of magnitudes of integers in the array,\n     * multiplied by the product of all signs (-1 for negative numbers,\n     * 1 for positive numbers, and 0 if any number is zero).\n     *\n     * @param arr List<Integer> - The input list of integers.\n     * @return Optional<Integer> - The result or None if the array is empty.\n     */\n    public static Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If any number is zero, the product of signs will be zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds the minimum path of length k in a grid.\n     *\n     * @param grid The N x N grid containing unique integers from 1 to N*N.\n     * @param k The length of the path to find.\n     * @return An ordered list of the values on the cells that the minimum path goes through.\n     */\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // Right, Down, Up, Left\n        PriorityQueue<PathNode> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.pathValue));\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                pq.offer(new PathNode(grid.get(i).get(j), i, j, k));\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            PathNode current = pq.poll();\n            if (current.pathLength == k) {\n                return current.path;\n            }\n            for (int[] dir : directions) {\n                int newRow = current.row + dir[0];\n                int newCol = current.col + dir[1];\n                if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                    pq.offer(new PathNode(current.path, grid.get(newRow).get(newCol), newRow, newCol, k));\n                }\n            }\n        }\n\n        return Collections.emptyList(); // This line should never be reached due to the problem constraints.\n    }\n\n    private class PathNode implements Comparable<PathNode> {\n        List<Integer> path;\n        int pathValue; // The lexicographical value of the current path\n        int row, col;\n        int pathLength;\n\n        public PathNode(int cellVal, int r, int c, int k) {\n            this.path = new ArrayList<>();\n            this.path.add(cellVal);\n            this.row = r;\n            this.col = c;\n            this.pathValue = cellVal; // Initialize with the current cell value\n            this.pathLength = 1;\n\n            while (this.path.size() < k && this.pathValue % N != 0) {\n                int nextRow = row + (pathValue / N);\n                int nextCol = col - (pathValue / N); // Adjust based on direction logic\n                path.add(grid.get(nextRow).get(nextCol));\n                this.pathValue *= 10;\n                this.pathValue += grid.get(nextRow).get(nextCol);\n                this.row = nextRow;\n                this.col = nextCol;\n                this.pathLength++;\n            }\n        }\n\n        public PathNode(List<Integer> path, int cellVal, int r, int c, int k) {\n            this.path = new ArrayList<>(path);\n            this.path.add(cellVal);\n            this.row = r;\n            this.col = c;\n            this.pathValue = calculatePathValue();\n            this.pathLength = path.size() + 1;\n\n            while (this.path.size() < k && this.pathValue % N != 0) {\n                int nextRow = row + (pathValue / N);\n                int nextCol = col - (pathValue / N); // Adjust based on direction logic\n                path.add(grid.get(nextRow).get(nextCol));\n                this.pathValue *= 10;\n                this.pathValue += grid.get(nextRow).get(nextCol);\n                this.row = nextRow;\n                this.col = nextCol;\n                this.pathLength++;\n            }\n        }\n\n        private int calculatePathValue() {\n            int value = path.get(0);\n            for (int i = 1; i < path.size(); i++) {\n                value *= 10;\n                value += path.get(i);\n            }\n            return value;\n        }\n\n        @Override\n        public int compareTo(PathNode other) {\n            return Integer.compare(this.pathValue, other.pathValue);\n        }\n    }\n\n    // Test cases to verify the solution.\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        System.out.println(sol.minPath(grid1, 3)); // Expected output: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        System.out.println(sol.minPath(grid2, 1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Custom Tribonacci-like sequence as defined in the problem statement.\n     */\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>(); // Handle invalid input\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            int value;\n            if (i == 1) {\n                value = 3; // Base case\n            } else if (i % 2 == 0) {\n                value = 1 + i / 2; // Even case\n            } else {\n                // Odd case, but we need to calculate the values for n-1 and n+1 first.\n                int prevPrevValue = result.get(i - 2); // tri(n-2)\n                int prevValue = (i == 3) ? 2 : result.get(i - 1); // tri(n-1), with special case for i=3\n                int nextValue = (i + 1 <= n) ? result.get(i) : 3; // tri(n+1), assuming it's the same as tri(1)\n                \n                value = prevPrevValue + prevValue + nextValue;\n            }\n            \n            result.add(value);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.tri(3));  // Expected output: [1, 3, 2, 8]\n        System.out.println(solution.tri(4));  // Expected output: [1, 3, 2, 8, 5]\n        System.out.println(solution.tri(0));  // Expected output: []\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean hasNested = false;\n\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n\n                // If the balance is positive, it means there's a nested bracket.\n                if (balance > 0) {\n                    hasNested = true;\n                }\n            }\n\n            // Early exit if we find a nested bracket\n            if (hasNested && balance >= 0) {\n                return true;\n            }\n\n            // If at any point the balance is negative, it means there's an unmatched closing bracket.\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // Return whether we found a nested bracket and the string was balanced overall\n        return hasNested && balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of squared numbers in the given list after rounding each element to the ceiling.\n     */\n    public int sum_squares(List<Double> lst) {\n        return lst.stream()\n                  .mapToDouble(x -> Math.ceil(x))\n                  .map(d -> d * d)\n                  .sum();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(test1)); // Expected output: 14\n\n        List<Double> test2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(test2)); // Expected output: 98\n\n        List<Double> test3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(test3)); // Expected output: 84\n\n        List<Double> test4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(test4)); // Expected output: 29\n\n        List<Double> test5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(test5)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character of a given string \n     * is an alphabetical character and is not part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Trim trailing spaces\n        String trimmed = txt.trim();\n        \n        // Check if the string is empty after trimming or has no letters\n        if (trimmed.isEmpty() || !Character.isLetter(trimmed.charAt(trimmed.length() - 1))) {\n            return false;\n        }\n        \n        // Check if there are any spaces before the last letter\n        int spaceBeforeLastChar = trimmed.lastIndexOf(' ');\n        if (spaceBeforeLastChar == -1) {\n            // No space in string, so it's part of a word\n            return false;\n        } else {\n            // Last character is an alphabetical character and not part of a word\n            return true;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));  // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the largest index of an element which is not greater than or equal \n     * to the element immediately preceding it. If no such element exists, returns -1.\n     */\n    public int can_arrange(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) return -1;\n\n        int largestIndex = -1;\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                largestIndex = i;\n            }\n        }\n\n        // If no such element was found, return -1\n        return largestIndex == -1 ? -1 : largestIndex - 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(solution.can_arrange(test1)); // Expected output: 3\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.can_arrange(test2)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!largestNegative.isPresent() || num > largestNegative.get())) {\n                largestNegative = Optional.of(num);\n            } else if (num > 0 && (!smallestPositive.isPresent() || num < smallestPositive.get())) {\n                smallestPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Additional test cases can be added here to further validate the solution.\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        // Convert both inputs to Double for comparison\n        double numA = convertToDouble(a);\n        double numB = convertToDouble(b);\n\n        if (numA == numB) {\n            return Optional.empty();\n        }\n\n        if (numA > numB) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private static double convertToDouble(Object obj) {\n        if (obj instanceof Double) {\n            return (double) obj;\n        } else if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        } else if (obj instanceof String) {\n            // Handle both '.' and ',' as decimal separators\n            String str = ((String) obj).replace(',', '.');\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + obj, e);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly 4 positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Therefore, any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // Any number greater than or equal to 8 and even can be written as a sum of four positive even numbers.\n        // For example: n = 10 -> 2 + 2 + 2 + 4\n        //              n = 12 -> 2 + 2 + 4 + 4\n        //              n = 14 -> 2 + 4 + 4 + 4\n        // The pattern continues for all even numbers greater than or equal to 8.\n        return n % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected output: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected output: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected output: true\n        System.out.println(solution.is_equal_to_sum_even(24)); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the Brazilian factorial of n.\n     *\n     * @param n The input integer for which to calculate the Brazilian factorial.\n     * @return The result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12 (since 3! * 2! * 1! = 6 * 2 * 1)\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560 (since 5! * 4! * 3! * 2! * 1!)\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        result = result.replaceAll(\" \", \"_\");\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));       // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));     // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));    // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));  // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The string representing the file's name.\n     * @return \"Yes\" if the file's name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot in the file name\n        int dotCount = 0;\n        for (int i = 0; i < fileName.length(); i++) {\n            char c = fileName.charAt(i);\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n\n        if (dotCount != 1) return \"No\";\n\n        // Split the file name into two parts: before and after the dot\n        String[] parts = fileName.split(\"\\\\.\");\n        if (parts.length != 2 || parts[0].isEmpty()) return \"No\"; // Ensure there's exactly one part before the dot\n\n        // Check if the first character of the file name is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Count digits in the file name\n        int digitCount = 0;\n        for (char c : fileName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n\n        if (digitCount > 3) return \"No\"; // Ensure there are no more than three digits\n\n        // Check the extension of the file name\n        String extension = parts[1];\n        List<String> validExtensions = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validExtensions.contains(extension)) {\n            return \"No\";\n        }\n\n        return \"Yes\"; // If all checks pass, the file name is valid\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 \n     * and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list \n     * whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     */\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                sum += lst.get(i); // Add the original value if index is not a multiple of 3 or 4\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sum_squares(list1)); // Expected output: 6\n        \n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.sum_squares(list2)); // Expected output: 0\n        \n        List<Integer> list3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(solution.sum_squares(list3)); // Expected output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns a string that contains the words from the original sentence,\n     * whose lengths are prime numbers, maintaining their original order.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the input sentence into an array of words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected: \"is\"\n        \n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the fraction strings into numerator and denominator integers.\n        int[] fractions = parseFractions(x, n);\n        \n        // Multiply the numerators together and denominators together.\n        long numeratorProduct = (long) fractions[0] * fractions[2];\n        long denominatorProduct = (long) fractions[1] * fractions[3];\n\n        // Check if the product is a whole number by seeing if the numerator\n        // is divisible by the denominator without any remainder.\n        return numeratorProduct % denominatorProduct == 0;\n    }\n\n    private int[] parseFractions(String x, String n) {\n        // Split each fraction string into its numerator and denominator parts.\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        // Parse the strings to integers.\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        return new int[]{xNumerator, xDenominator, nNumerator, nDenominator};\n    }\n\n    // Test code to verify the correctness of the simplify function.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.simplify(\"1/5\", \"5/1\"));  // Expected output: true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\"));  // Expected output: false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\"));  // Expected output: false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sorts the given list of integers in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * @param nums List of integers to sort\n     * @return Sorted list of integers based on the sum of their digits\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a comparator that sorts by the sum of digits and then by original index\n        Comparator<Integer> digitSumComparator = (a, b) -> {\n            int sumA = getDigitSum(a);\n            int sumB = getDigitSum(b);\n            if (sumA != sumB) return Integer.compare(sumA, sumB);\n            else return Integer.compare(nums.indexOf(a), nums.indexOf(b));\n        };\n\n        // Sort the list using the comparator\n        List<Integer> sortedList = new ArrayList<>(nums);\n        Collections.sort(sortedList, digitSumComparator);\n\n        return sortedList;\n    }\n\n    /**\n     * Calculates the sum of digits of an integer.\n     *\n     * @param num The integer to calculate the sum of digits for\n     * @return Sum of digits\n     */\n    private int getDigitSum(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) digit *= -1; // Adjust positive digits to negative\n            sum += digit;\n            num /= 10;\n            isNegative = num < 0; // Update the sign flag for next iteration\n        }\n\n        return sum;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(num);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, -73, 14, -15);\n        System.out.println(solution.specialFilter(test1)); // Expected output: 1\n\n        List<Integer> test2 = Arrays.asList(33, -2, -3, 45, 21, 109);\n        System.out.println(solution.specialFilter(test2)); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many triples satisfy the condition\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Test the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5; // Example input\n        System.out.println(\"Number of valid triples: \" + solution.get_max_triples(n));\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) {\n            return Collections.emptyList();\n        }\n\n        if (index1 > index2) {\n            // Ensure index1 is always less than index2\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Should print: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Should print: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Should print: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Accepts a list of strings, removes strings with odd lengths,\n     * sorts the remaining strings first by their length in ascending order,\n     * and then alphabetically if they have the same length.\n     */\n    public List<String> filterAndSort(List<String> lst) {\n\n        // Remove strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) { // Check if string length is even\n                filteredList.add(str);\n            }\n        }\n\n        // Sort the list by length, then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return Integer.compare(s1.length(), s2.length());\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return filteredList;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.filterAndSort(test1)); // Should print: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.filterAndSort(test2)); // Should print: [ab, cd]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     */\n    public int x_or_y(int n, int x, int y) {\n        // Check if n is a prime number using the helper method\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    /**\n     * Helper function to check if a number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false; // Numbers less than or equal to 1 are not prime\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(19, 20, 10)); // Should print 20\n        System.out.println(solution.x_or_y(20, 20, 10)); // Should print 10\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of objects (which should be integers), return the sum of squares of the numbers in the list that are odd.\n     * Ignore numbers that are negative or not integers.\n     *\n     * Examples:\n     * double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 = 10\n     * double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n     * double_the_difference(Arrays.asList(9, -2)) == 81\n     * double_the_difference(Arrays.asList(0)) == 0\n     *\n     * If the input list is empty, return 0.\n     */\n    public int sumOfSquaresForOdd(List<Object> lst) {\n        if (lst.isEmpty()) {\n            return 0;\n        }\n\n        int sum = 0;\n\n        for (Object obj : lst) {\n            if (obj instanceof Integer) { // Check if the object is an integer\n                int num = (Integer) obj; // Cast to integer\n\n                if (num > 0 && num % 2 != 0) { // Check if positive and odd\n                    sum += num * num; // Add square of number to sum\n                }\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sumOfSquaresForOdd(Arrays.asList(1, 3, 2, 0))); // Should print 10\n        System.out.println(solution.sumOfSquaresForOdd(Arrays.asList(-1, -2, 0))); // Should print 0\n        System.out.println(solution.sumOfSquaresForOdd(Arrays.asList(9, -2))); // Should print 81\n        System.out.println(solution.sumOfSquaresForOdd(Arrays.asList(0))); // Should print 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares the guesses with the actual scores in a series of matches.\n     *\n     * @param game  A List<Integer> representing the actual scores for each match.\n     * @param guess A List<Integer> representing the guessed scores for each match.\n     * @return A List<Integer> where each element represents how far off the corresponding guess was from the actual score. If the guess is correct, the value is 0; otherwise, it's the absolute difference between the guess and the actual score.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure both lists are of equal length\n        if (game.size() != guess.size()) {\n            throw new IllegalArgumentException(\"The size of game scores and guesses must be the same.\");\n        }\n        \n        for (int i = 0; i < game.size(); i++) {\n            int score = game.get(i);\n            int gues = guess.get(i);\n            \n            // Calculate the absolute difference\n            result.add(Math.abs(score - gues));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class name.\n     *\n     * @param class_name The name of the class to which extensions are being added.\n     * @param extensions A list of extension names.\n     * @return A string in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        // Initialize variables to track the strongest extension and its strength\n        String strongest_extension = \"\";\n        int max_strength = Integer.MIN_VALUE;\n\n        // Iterate through each extension to find the one with the highest strength\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > max_strength) {\n                max_strength = strength;\n                strongest_extension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongest_extension;\n    }\n\n    /**\n     * Calculates the strength of an extension based on uppercase and lowercase letters.\n     *\n     * @param extension The name of the extension.\n     * @return The calculated strength as an integer.\n     */\n    private int calculateStrength(String extension) {\n        int cap = 0, sm = 0;\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                cap++;\n            } else if (Character.isLowerCase(c)) {\n                sm++;\n            }\n        }\n        return cap - sm;\n    }\n\n    // Test the method with a sample input\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String class_name = \"Slices\";\n        List<String> extensions = Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\");\n        System.out.println(solution.Strongest_Extension(class_name, extensions));\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any rotation of b is a substring of a.\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the string 'a' with itself. If any rotation of 'b' is a substring\n        // of 'a', it will be a substring of this concatenated string.\n        String doubledA = a + a;\n        \n        // Check if 'b' or its rotations are substrings of the doubled string.\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a list containing two integers: \n     * the first one represents the number of even digits in the input number,\n     * and the second one represents the number of odd digits.\n     *\n     * Example:\n     *   evenOddCount(-12) ==> [1, 1]\n     *   evenOddCount(123) ==> [1, 2]\n     */\n    public List<Integer> evenOddCount(int num) {\n        // Make sure the number is positive to simplify digit extraction\n        int absNum = Math.abs(num);\n        \n        int evenCount = 0;\n        int oddCount = 0;\n\n        while (absNum > 0) {\n            int digit = absNum % 10; // Extract last digit\n            \n            if (digit % 2 == 0)\n                evenCount++;\n            else\n                oddCount++;\n\n            absNum /= 10; // Remove the last digit\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.evenOddCount(-12)); // Expected output: [1, 1]\n        System.out.println(solution.evenOddCount(123)); // Expected output: [1, 2]\n        System.out.println(solution.evenOddCount(0));   // Expected output: [1, 0] (since 0 is even)\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define arrays for roman numerals and their integer values.\n        String[] romans = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n        // Initialize the result string.\n        StringBuilder roman = new StringBuilder();\n\n        // Iterate through the values and append corresponding Roman numerals to the result.\n        for (int i = 0; i < values.length && number > 0; i++) {\n            while (number >= values[i]) {\n                number -= values[i];\n                roman.append(romans[i]);\n            }\n        }\n\n        return roman.toString();\n    }\n\n    // Test function to verify the correctness of int_to_mini_roman method.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.int_to_mini_roman(19));  // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152)); // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426)); // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Check if this word has more unique characters than the current max\n            // or is lexicographically smaller with the same number of unique characters\n            int uniqueCount = uniqueChars.size();\n            if (uniqueCount > maxUniqueChars || \n                (uniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\")));  // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\")));  // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));   // Output: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots to be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate the number of carrots left after eating.\n        int leftOver = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of carrots eaten and the number left over.\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two lists operator, and operand. The first list has basic algebra operations,\n     * and the second list is a list of integers. Use the two given lists to build the algebraic\n     * expression and return the evaluation of this expression.\n     *\n     * @param operator List of strings representing operators: \"+\", \"-\", \"*\", \"/\", \"**\"\n     * @param operand  List of integers representing operands\n     * @return The result of evaluating the algebraic expression\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a stack to hold numbers and another for operations.\n        Stack<Integer> nums = new Stack<>();\n        Stack<String> ops = new Stack<>();\n\n        // Add a dummy operation at the beginning to handle edge cases easily\n        ops.push(\"+\");\n\n        int i = 0;\n        while (i < operator.size()) {\n            String op = operator.get(i);\n\n            if (\"+\".equals(op) || \"-\".equals(op)) {\n                // Process all multiplications and divisions before adding or subtracting.\n                process(ops, nums, \"*\");\n                process(ops, nums, \"/\");\n                process(ops, nums, \"**\");\n\n                ops.push(op);\n            } else if (\"*\".equals(op) || \"/\".equals(op) || \"**\".equals(op)) {\n                // Process all exponentiations before multiplications and divisions.\n                process(ops, nums, \"**\");\n                ops.push(op);\n            }\n\n            i++;\n        }\n        \n        // Process any remaining operations\n        process(ops, nums, \"*\");\n        process(ops, nums, \"/\");\n        process(ops, nums, \"**\");\n\n        int result = 0;\n        while (!nums.isEmpty()) {\n            result += nums.pop();\n        }\n\n        return result;\n    }\n\n    private void process(Stack<String> ops, Stack<Integer> nums, String op) {\n        while (!ops.isEmpty() && (op.equals(\"**\") ? \"=\".equals(ops.peek().replaceAll(\"[^=]\", \"\")) : ops.peek().compareTo(op) <= 0)) {\n            int b = nums.pop();\n            int a = nums.pop();\n\n            switch (ops.pop()) {\n                case \"+\":\n                    nums.push(a + b);\n                    break;\n                case \"-\":\n                    nums.push(a - b);\n                    break;\n                case \"*\":\n                    nums.push(a * b);\n                    break;\n                case \"/\":\n                    nums.push(a / b); // Assuming integer division\n                    break;\n                case \"**\":\n                    nums.push((int) Math.pow(a, b));\n                    break;\n            }\n        }\n\n        if (op.equals(\"**\")) {\n            ops.push(op.replaceAll(\"[^=]\", \"=\")); // Mark processed exponentiation\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        \n        int result = solution.do_algebra(operator, operand);\n        System.out.println(\"Result: \" + result); // Expected output is 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * If s[i] is a letter, reverse its case from lower to upper or vice versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        boolean hasLetters = false;\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\")); // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));   // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\")); // Expected: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        \n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add leading zeros to make sure hash is 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: Optional[3e25960a79dbc69b674cd4ec67a72c62]\n        System.out.println(solution.string_to_md5(\"\"));           // Should print: Optional.empty\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that 'a' is less than or equal to 'b'\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        // Initialize the list of even digits\n        List<Integer> result = new ArrayList<>();\n\n        // Add all even numbers between a and b, including both endpoints\n        for (int i = a; i <= b; i++) {\n            if (i % 2 == 0 && i < 10) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.generate_integers(2, 8));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers that are closer to each other than a given threshold.\n     *\n     * @param numbers List<Double> - A list of floating-point numbers.\n     * @param threshold double - The minimum distance between any two elements for them not to be considered close.\n     * @return boolean - Returns true if there are at least two elements in the list that are closer than the threshold, otherwise false.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        boolean result1 = solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Test case 2\n        boolean result2 = solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        // Additional test cases\n        boolean result3 = solution.has_close_elements(Arrays.asList(10.0, 9.5, 8.7), 0.4);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Passed\" : \"Failed\")); // Expected output: Passed\n\n        boolean result4 = solution.has_close_elements(Arrays.asList(-2.0, -1.0, 0.5, 1.5), 0.6);\n        System.out.println(\"Test Case 4: \" + (result4 ? \"Passed\" : \"Failed\")); // Expected output: Failed\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses.\n     * Your goal is to separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * Example:\n     * >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n     * [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        List<String> result = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < cleanString.length(); i++) {\n            char c = cleanString.charAt(i);\n\n            if (c == '(') {\n                stack.push(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    int start = stack.pop();\n                    if (stack.isEmpty()) { // This means we have a complete group\n                        result.add(cleanString.substring(start, i + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String input = \"( ) (( )) (( )( ))\";\n        List<String> output = solution.separate_paren_groups(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Output: [\" + String.join(\", \", output) + \"]\");\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to check the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(123.456));  // Expected output: 0.456\n        System.out.println(solution.truncate_number(7.999999));  // Expected output: 0.999999\n        System.out.println(solution.truncate_number(0.123));  // Expected output: 0.123\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Detects if the bank account balance falls below zero given a list of deposit and withdrawal operations.\n     *\n     * @param operations List<Integer> representing deposit (positive) or withdrawal (negative) amounts.\n     * @return boolean indicating whether the balance goes negative at any point.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance has fallen below zero\n            }\n        }\n        return false; // No negative balance detected\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return false as the balance never goes below zero.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); \n        \n        // Test case 2: Should return true as after -4, the balance is negative.\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5)));\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List of numbers cannot be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean isFirstElement = true;\n\n        for (Integer number : numbers) {\n            if (!isFirstElement) {\n                result.add(delimiter);\n            } else {\n                isFirstElement = false;\n            }\n            result.add(number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<Integer> emptyList = solution.intersperse(new ArrayList<>(), 4);\n        System.out.println(emptyList); // Expected output: []\n\n        // Test case 2: Non-empty list with delimiter 4\n        List<Integer> nonEmptyList = solution.intersperse(Arrays.asList(1, 2, 3), 4);\n        System.out.println(nonEmptyList); // Expected output: [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, returns the deepest level of nesting of parentheses as an integer in a list.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A List<Integer> where each element represents the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    /**\n     * A test method to verify the correctness of parse_nested_parens function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result;\n\n        // Test case 1\n        String input1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput1 = Arrays.asList(2, 3, 1, 3);\n        result = solution.parse_nested_parens(input1);\n        System.out.println(\"Test Case 1: \" + (result.equals(expectedOutput1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        String input2 = \"() ()\";\n        List<Integer> expectedOutput2 = Arrays.asList(1, 1);\n        result = solution.parse_nested_parens(input2);\n        System.out.println(\"Test Case 2: \" + (result.equals(expectedOutput2) ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        String input3 = \"(())() ((()))\";\n        List<Integer> expectedOutput3 = Arrays.asList(2, 3);\n        result = solution.parse_nested_parens(input3);\n        System.out.println(\"Test Case 3: \" + (result.equals(expectedOutput3) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use Java 8 Streams API for filtering the list based on a condition.\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_substring(emptyList, \"a\")); // Should print []\n\n        // Test case 2: List with some strings containing the substring and others not.\n        List<String> stringList = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_substring(stringList, \"a\")); // Should print [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> emptyList = new ArrayList<>();\n        System.out.println(solution.sum_product(emptyList));  // Should print [0, 1]\n\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));    // Should print [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int number : numbers) {\n            maxSoFar = Math.max(maxSoFar, number);\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        \n        // Generate rolling max\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n        \n        // Verify correctness\n        if (expectedOutput.equals(output)) {\n            System.out.println(\"Test passed!\");\n        } else {\n            System.out.println(\"Test failed.\");\n        }\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        // If the input string is empty or already a palindrome, return it as is\n        if (string == null || string.isEmpty() || isPalindrome(string)) {\n            return string;\n        }\n\n        int len = string.length();\n        for (int i = 0; i < len; ++i) {\n            String suffix = string.substring(i);\n            if (isPalindrome(suffix)) {\n                // Reverse the prefix that comes before the palindromic suffix\n                String prefix = new StringBuilder(string.substring(0, i)).reverse().toString();\n                return prefix + string;\n            }\n        }\n\n        // Fallback case - should never reach here due to logic above.\n        return string; \n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two strings consisting only of 1s and 0s.\n     *\n     * @param a First input string.\n     * @param b Second input string.\n     * @return Resulting string after performing binary XOR operation.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        \n        // Ensure both strings are of the same length\n        int maxLength = Math.max(a.length(), b.length());\n        a = String.format(\"%\" + maxLength + \"s\", a).replace(' ', '0');\n        b = String.format(\"%\" + maxLength + \"s\", b).replace(' ', '0');\n\n        // Perform XOR operation character by character\n        for (int i = 0; i < maxLength; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n\n            if ((ca == '1' && cb == '0') || (ca == '0' && cb == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"11011\"));  // Expected output: \"01110\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\"));  // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\"));  // Expected output: \"0000\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of()));  // Expected: Optional.empty\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: Optional[a]\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));  // Expected: Optional[ccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.abs(a);\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(-9, -18)); // Expected output: 9\n        System.out.println(solution.greatest_common_divisor(0, 5)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test case\n        List<String> prefixes = solution.all_prefixes(\"abc\");\n        System.out.println(prefixes);  // Expected output: [a, ab, abc]\n        \n        // Additional test cases\n        List<String> emptyPrefixes = solution.all_prefixes(\"\");\n        System.out.println(emptyPrefixes);  // Expected output: []\n        \n        List<String> singleCharPrefixes = solution.all_prefixes(\"x\");\n        System.out.println(singleCharPrefixes);  // Expected output: [x]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_sequence(0)); // Expected output: \"0\"\n        System.out.println(solution.string_sequence(5)); // Expected output: \"0 1 2 3 4 5\"\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lowercase to ignore case differences and use a set to store unique characters\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        \n        return charSet.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\"));  // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"));  // Expected output: 26\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string containing musical notes in ASCII format and returns a list of integers indicating the number of beats for each note.\n     *\n     * Legend:\n     * \"o\" - whole note, lasts four beats\n     * \"o|\" - half note, lasts two beats\n     * \".|\" - quarter note, lasts one beat\n     */\n    public List<Integer> parse_music(String string) {\n        List<Integer> durations = new ArrayList<>();\n        String[] notes = string.split(\" \");\n        \n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    durations.add(4);\n                    break;\n                case \"o|\":\n                    durations.add(2);\n                    break;\n                case \".|\":\n                    durations.add(1);\n                    break;\n                default:\n                    // Handle unexpected input\n                    throw new IllegalArgumentException(\"Invalid note: \" + note);\n            }\n        }\n\n        return durations;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String testInput = \"o o| .| o| o| .| .| .| .| o o\";\n        List<Integer> expectedOutput = Arrays.asList(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4);\n        \n        List<Integer> actualOutput = solution.parse_music(testInput);\n        \n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output:   \" + actualOutput);\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));  // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Map each number word to its corresponding integer value.\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words.\n        String[] words = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its integer value and sort them.\n        Integer[] nums = new Integer[words.length];\n        for (int i = 0; i < words.length; i++) {\n            nums[i] = numMap.get(words[i]);\n        }\n        Arrays.sort(nums);\n\n        // Convert the sorted integers back into number words.\n        StringBuilder result = new StringBuilder();\n        for (Integer num : nums) {\n            String word = \"\";\n            for (String key : numMap.keySet()) {\n                if (numMap.get(key).equals(num)) {\n                    word = key;\n                    break;\n                }\n            }\n            result.append(word);\n            result.append(\" \");\n        }\n\n        // Remove the trailing space and return the result.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six\"));  // Expected output: \"six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding closest elements easier.\n        Collections.sort(numbers);\n        \n        double minDiff = Double.MAX_VALUE;\n        int index1 = -1, index2 = -1;\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = numbers.get(i + 1) - numbers.get(i);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                index1 = i;\n                index2 = i + 1;\n            }\n        }\n\n        return Arrays.asList(numbers.get(index1), numbers.get(index2));\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), applies a linear transform such that \n     * the smallest number will become 0 and the largest will become 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero in case all elements are the same\n        if (min == max) {\n            return Arrays.asList(0.0, 1.0); // or any other appropriate handling of this edge case\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledNumber = (number - min) / (max - min);\n            scaledNumbers.add(scaledNumber);\n        }\n        \n        return scaledNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Collections.emptyMap(), Collections.emptyList());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"strlen(\\\"\\\") should be 0: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"strlen(\\\"abc\\\") should be 3: \" + (solution.strlen(\"abc\") == 3));\n        System.out.println(\"strlen(\\\"hello world\\\") should be 11: \" + (solution.strlen(\"hello world\") == 11));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i > 0; i--) { // Start from half of n and go down to 1\n            if (n % i == 0) { // Check if i divides n evenly\n                return i; // Return the first divisor found, which is the largest one\n            }\n        }\n        return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is a prime number)\n        System.out.println(solution.largest_divisor(60)); // Expected output: 30\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 to get rid of all even factors\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now n must be odd, start checking from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving insertion order\n        for (int num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once and preserve the original order\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> inputList = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> resultList = solution.remove_duplicates(inputList);\n        \n        System.out.println(resultList); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     * >>> flip_case(\"Hello\")\n     * \"hELLO\"\n     */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(Character.toUpperCase(c));\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected output: \"hELLO\"\n        System.out.println(solution.flip_case(\"WorLD\"));  // Expected output: \"wORld\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected output: \"jAVA123\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     * \n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over the list and append each string to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.concatenate(new ArrayList<>())); // Expected output: \"\"\n\n        // Test case 2: List with multiple strings\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    // Test function to verify the correctness of the filter_by_prefix method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> emptyList = new ArrayList<>();\n        System.out.println(solution.filter_by_prefix(emptyList, \"a\")); // Should print: []\n\n        List<String> listWithPrefixes = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        System.out.println(solution.filter_by_prefix(listWithPrefixes, \"a\")); // Should print: [abc, array]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream().filter(i -> i > 0).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(testList1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(testList2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Check for edge cases: 1 and numbers less than 1 are not prime\n        if (n <= 1) return false;\n\n        // Check divisibility from 2 up to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_prime(6));   // Expected: false\n        System.out.println(solution.is_prime(101)); // Expected: true\n        System.out.println(solution.is_prime(11));  // Expected: true\n        System.out.println(solution.is_prime(13441));// Expected: true\n        System.out.println(solution.is_prime(61));  // Expected: true\n        System.out.println(solution.is_prime(4));   // Expected: false\n        System.out.println(solution.is_prime(1));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     * return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * Finds a zero of the polynomial defined by coefficients xs.\n     * Assumes xs has an even number of elements and the largest non-zero coefficient guarantees a solution.\n     */\n    public double find_zero(List<Double> xs) {\n        // Initial guess for root\n        double x = 0.5;\n        \n        // Tolerance level for convergence\n        final double tolerance = 1e-7;\n\n        // Maximum number of iterations to prevent infinite loops\n        int maxIterations = 1000;\n\n        for (int i = 0; i < maxIterations; i++) {\n            double y = poly(xs, x);\n            if (Math.abs(y) < tolerance) {\n                return x;\n            }\n            \n            // Derivative of the polynomial at point x\n            List<Double> derivativeCoefficients = new ArrayList<>();\n            for (int j = 1; j < xs.size(); j++) {\n                derivativeCoefficients.add(xs.get(j) * j);\n            }\n\n            double yPrime = poly(derivativeCoefficients, x);\n\n            if (yPrime == 0) {\n                throw new IllegalArgumentException(\"Derivative is zero. No solution found.\");\n            }\n            \n            // Newton-Raphson iteration\n            x -= y / yPrime;\n        }\n        \n        throw new RuntimeException(\"Failed to converge within \" + maxIterations + \" iterations\");\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Double> xs1 = Arrays.asList(1.0, 2.0);\n        System.out.println(sol.find_zero(xs1)); // Expected output: -0.5\n        \n        List<Double> xs2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        System.out.println(sol.find_zero(xs2)); // Expected output: 1.0\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n     * to the values of the corresponding indicies of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> indicesToSort = new ArrayList<>();\n        \n        // Collect elements at indices divisible by 3\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering 1-based index\n                indicesToSort.add(l.get(i));\n            }\n        }\n\n        // Sort the collected elements\n        Collections.sort(indicesToSort);\n\n        // Place sorted elements back at their original positions\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Considering 1-based index\n                result.set(i, indicesToSort.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(list1)); // Expected: [1, 2, 3]\n\n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(list2)); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list\n        List<Integer> result = new ArrayList<>(set);\n        \n        // Sort the list\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + testList1);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList1));\n        \n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(7, 8, 6, 5, 4, 3, 2, 1);\n        System.out.println(\"Original: \" + testList2);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList2));\n        \n        // Test case 3\n        List<Integer> testList3 = Arrays.asList(9, 7, 5, 3, 1);\n        System.out.println(\"Original: \" + testList3);\n        System.out.println(\"Unique Sorted: \" + solution.unique(testList3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        int max = l.get(0); // Assume the first element is the largest initially\n        \n        for (int i = 1; i < l.size(); i++) { // Start from the second element\n            if (l.get(i) > max) {\n                max = l.get(i);\n            }\n        }\n        \n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.max_element(list1)); // Expected output: 3\n        \n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.max_element(list2)); // Expected output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        \n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Expected output: 0\n        System.out.println(solution.fizz_buzz(78)); // Expected output: 2\n        System.out.println(solution.fizz_buzz(79)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Create a list to hold the elements at even indices\n        List<Integer> evens = new ArrayList<>();\n        \n        // Extract elements at even indices and add them to the 'evens' list\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n        \n        // Sort the 'evens' list\n        Collections.sort(evens);\n        \n        // Create a new list to hold the final result\n        List<Integer> sortedList = new ArrayList<>(l);\n        \n        // Replace elements at even indices in the original list with sorted values from 'evens'\n        for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n            sortedList.set(i, evens.get(j));\n        }\n        \n        return sortedList;\n    }\n\n    // Method to test the sort_even function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestSolution {\n    private Solution solution = new Solution();\n\n    @Test\n    public void testEncodeDecodeCyclic() {\n        String input1 = \"abc\";\n        String encoded1 = solution.encodeCyclic(input1);\n        String decoded1 = solution.decode_cyclic(encoded1);\n        assertEquals(\"Original: \" + input1, input1, decoded1);\n\n        String input2 = \"abcd\";\n        String encoded2 = solution.encodeCyclic(input2);\n        String decoded2 = solution.decode_cyclic(encoded2);\n        assertEquals(\"Original: \" + input2, input2.substring(0, 3), decoded2.substring(0, 3));\n        // The last character remains unchanged as it's not part of a group of three.\n\n        String input3 = \"abcdef\";\n        String encoded3 = solution.encodeCyclic(input3);\n        String decoded3 = solution.decode_cyclic(encoded3);\n        assertEquals(\"Original: \" + input3, input3, decoded3);\n\n        // Additional test cases can be added here\n    }\n\n    @Test\n    public void testDecodeCyclic() {\n        String encoded1 = \"bca\";\n        String decoded1 = solution.decode_cyclic(encoded1);\n        assertEquals(\"Decoded from bca\", \"abc\", decoded1);\n\n        String encoded2 = \"bcda\";\n        String decoded2 = solution.decode_cyclic(encoded2);\n        assertEquals(\"Decoded from bcda\", \"abcd\", decoded2.substring(0, 3));\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns n-th number that is both a Fibonacci number and prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n        }\n\n        return primes.get(primes.size() - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2 || num == 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list first for easier traversal\n        Collections.sort(l);\n        \n        int n = l.size();\n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars driving towards each other on a straight road.\n     *\n     * @param n The number of cars in each set (one set moving left to right, and one set moving right to left).\n     * @return The total number of collisions that occur.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from the left will collide with every car from the right,\n        // the total number of collisions is simply n (left cars) times n (right cars).\n        return n * n;\n    }\n\n    /**\n     * A simple test method to verify the correctness of the car_race_collision function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 4\n        System.out.println(solution.car_race_collision(3));  // Expected output: 9\n        System.out.println(solution.car_race_collision(5));  // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(n -> n + 1).collect(Collectors.toList());\n    }\n\n    // Test method to verify the correctness of incr_list\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected output: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero,\n     * and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seenNumbers = new HashSet<>();\n        \n        for (int num : l) {\n            int complement = -num;\n            if (seenNumbers.contains(complement)) {\n                return true;\n            }\n            seenNumbers.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        \n        return result.length() == 0 ? \"0\" : result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and high return area for a triangle.\n     * >>> triangle_area(5, 3)\n     * 7.5\n     */\n    public double triangle_area(double base, double height) {\n        // Area formula: (1/2) * base * height\n        return 0.5 * base * height;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        double area1 = solution.triangle_area(5, 3);\n        System.out.println(\"Area of triangle with base=5 and height=3: \" + area1); // Expected output: 7.5\n        \n        // Test case 2\n        double area2 = solution.triangle_area(10, 4);\n        System.out.println(\"Area of triangle with base=10 and height=4: \" + area2); // Expected output: 20.0\n        \n        // Test case 3 (with floating point numbers)\n        double area3 = solution.triangle_area(7.5, 2.5);\n        System.out.println(\"Area of triangle with base=7.5 and height=2.5: \" + area3); // Expected output: 9.375\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the n-th element of the fib4 number sequence.\n     *\n     * @param n The index in the sequence for which to compute the value.\n     * @return The n-th element of the fib4 sequence.\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1 || n == 3)\n            return 0;\n        \n        // Initialize base cases\n        int[] dp = new int[]{0, 0, 2, 0};\n        \n        // Compute the sequence iteratively for values greater than 3\n        for (int i = 4; i <= n; i++) {\n            int nextValue = dp[0] + dp[1] + dp[2] + dp[3];\n            // Shift elements to the left and update the last element\n            dp[0] = dp[1];\n            dp[1] = dp[2];\n            dp[2] = dp[3];\n            dp[3] = nextValue;\n        }\n        \n        return dp[n % 4 == 0 ? 3 : n % 4 == 1 ? 2 : n % 4 == 2 ? 1 : 0];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        // Sort the list first\n        Collections.sort(l);\n        \n        int size = l.size();\n        if (size % 2 == 1) { // If odd, return the middle element\n            return l.get(size / 2);\n        } else { // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median (Odd): \" + solution.median(list1)); // Expected output: 3\n\n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median (Even): \" + solution.median(list2)); // Expected output: 8.0\n\n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/48", "generation": "class Solution {\n    /**\n     * Checks if given string is a palindrome\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left++) != text.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Test cases using assertions\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        assert solution.is_palindrome(\"\") : \"Empty string should be a palindrome\";\n        assert solution.is_palindrome(\"aba\") : \"'aba' is a palindrome\";\n        assert solution.is_palindrome(\"aaaaa\") : \"'aaaaa' is a palindrome\";\n        assert !solution.is_palindrome(\"zbcd\") : \"'zbcd' is not a palindrome\";\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // 2^0 = 1 for any p\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base value\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.modp(3, 5)); // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101)); // Expected output: 1\n        System.out.println(solution.modp(3, 11)); // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) { // Ensure only letters are shifted\n                char baseChar = Character.isUpperCase(ch) ? 'A' : 'a';\n                int offset = ch - baseChar;\n                sb.append((char) ((baseChar + (offset - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-letter characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString1 = \"hello\";\n        String encoded1 = solution.encodeShift(testString1);\n        System.out.println(\"Encoded: \" + encoded1); // Should output \"mjqqt\"\n        \n        String decoded1 = solution.decode_shift(encoded1);\n        System.out.println(\"Decoded: \" + decoded1); // Should output \"hello\"\n\n        String testString2 = \"World\";\n        String encoded2 = solution.encodeShift(testString2);\n        System.out.println(\"Encoded: \" + encoded2); // Should output \"BTQYI\"\n        \n        String decoded2 = solution.decode_shift(encoded2);\n        System.out.println(\"Decoded: \" + decoded2); // Should output \"World\"\n\n        // Test with non-letter characters\n        String testString3 = \"abc123\";\n        String encoded3 = solution.encodeShift(testString3);\n        System.out.println(\"Encoded: \" + encoded3); // Should output \"fghi123\"\n        \n        String decoded3 = solution.decode_shift(encoded3);\n        System.out.println(\"Decoded: \" + decoded3); // Should output \"abc123\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                                                            'A', 'E', 'I', 'O', 'U'));\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string and append non-vowel characters to result\n        for (char c : text.toCharArray()) {\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\"));  // Expected: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\"));  // Expected: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\"));  // Expected: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\"));  // Expected: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\"));  // Expected: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + (solution.below_threshold(list1, threshold1) ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + (solution.below_threshold(list2, threshold2) ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"add(2, 3): \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7): \" + solution.add(5, 7)); // Expected output: 12\n\n        // Additional test cases for robustness\n        System.out.println(\"add(-10, 4): \" + solution.add(-10, 4)); // Expected output: -6\n        System.out.println(\"add(0, 0): \" + solution.add(0, 0));     // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Create a set to store unique characters from the first string\n        Set<Character> charSet = new HashSet<>();\n        \n        // Add all characters from the first string into the set\n        for (char c : s0.toCharArray()) {\n            charSet.add(c);\n        }\n        \n        // Check if every character in the second string is present in the set\n        for (char c : s1.toCharArray()) {\n            if (!charSet.contains(c)) {\n                return false;\n            }\n        }\n\n        // Create a set to store unique characters from the second string\n        Set<Character> charSet2 = new HashSet<>();\n        \n        // Add all characters from the second string into the set\n        for (char c : s1.toCharArray()) {\n            charSet2.add(c);\n        }\n        \n        // Check if every character in the first string is present in this new set\n        for (char c : s0.toCharArray()) {\n            if (!charSet2.contains(c)) {\n                return false;\n            }\n        }\n\n        // If all checks pass, both strings have the same kind of characters\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0) = 0, fib(1) = 1\n        \n        int a = 0;\n        int b = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        \n        return b;\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the number of open and close brackets\n\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n\n            // If at any point the number of closing brackets is more than opening ones, return false\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // At the end, there should be no unmatched open brackets left\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\")); // Expected output: false\n        System.out.println(solution.correct_bracketing(\"<>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // Expected output: true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() <= 1) return true; // A single element is trivially monotonic\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                increasing = true;\n            } else if (l.get(i) < l.get(i - 1)) {\n                decreasing = true;\n            }\n\n            // If both conditions are met, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n        \n        return true; // The list is either monotonically increasing or decreasing\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and then find the intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets (common elements)\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a list and sort it\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n\n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2; // equivalent to n >>= 1\n        }\n\n        // Now n must be odd, start from 3 and check for prime factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(\"Largest prime factor of 13195: \" + solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(\"Largest prime factor of 2048: \" + solution.largest_prime_factor(2048));   // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers: n*(n+1)/2\n        return (n * (n + 1)) / 2;\n    }\n\n    /**\n     * A method to test the correctness of the sum_to_n function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30));  // Expected output: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected output: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5));    // Expected output: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10));  // Expected output: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1));    // Expected output: 1\n        \n        // Additional test case to ensure correctness\n        System.out.println(\"sum_to_n(1000): \" + solution.sum_to_n(1000)); // Expected output: 500500\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // To keep track of the balance between '(' and ')'\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++; // Increment when an opening bracket is found\n            } else if (c == ')') {\n                balance--; // Decrement when a closing bracket is found\n                \n                // If at any point the balance goes negative, it means there are more closing brackets than opening ones.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The string has correct bracketing only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));   // false\n        System.out.println(solution.correct_bracketing(\"()\"));  // true\n        System.out.println(solution.correct_bracketing(\"(()())\")); // true\n        System.out.println(solution.correct_bracketing(\")(()\")); // false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // The derivative will have one less term than the original polynomial,\n        // unless it's a constant (degree 0), which has no terms after differentiation.\n        if (xs.size() <= 1) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n     * fibfib(0) == 0\n     * fibfib(1) == 0\n     * fibfib(2) == 1\n     * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize the base cases\n        int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n        int result = 0;\n\n        for (int i = 3; i <= n; i++) {\n            result = a + b + c;\n            // Shift the values\n            a = b;\n            b = c;\n            c = result;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.length() == 0) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to easily manipulate its digits\n        String numStr = Integer.toString(x);\n        \n        // Calculate effective shift considering the length of the number\n        int len = numStr.length();\n        if (shift >= len) {\n            // If shift is greater than or equal to the length, reverse the number\n            return new StringBuilder(numStr).reverse().toString();\n        } else {\n            // Perform circular shift by rotating the string\n            int effectiveShift = shift % len;\n            String shiftedPart = numStr.substring(len - effectiveShift);\n            String remainingPart = numStr.substring(0, len - effectiveShift);\n            \n            return shiftedPart + remainingPart;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.circular_shift(12, 1)); // Expected output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected output: \"12\"\n        System.out.println(solution.circular_shift(12345, 3)); // Expected output: \"34512\"\n        System.out.println(solution.circular_shift(12345, 6)); // Expected output: \"54321\" (reversed)\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only's ASCII codes.\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 (67)\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 (69)\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 (65 + 66)\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 (65 + 88)\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in a basket given the total number of apples and oranges,\n     * and the total number of fruits.\n     *\n     * @param s A string representing the count of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n The total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mango fruits\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int index = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEvenValue) {\n                // If the current even number is smaller than the recorded one, or\n                // it's equal but has a smaller index, update the record.\n                if (value < smallestEvenValue || i < index) {\n                    smallestEvenValue = value;\n                    index = i;\n                }\n            }\n        }\n\n        if (index == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(smallestEvenValue, index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each number in the list\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Populate the frequency map with counts for each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1; // Initialize result to -1\n        \n        // Iterate through the entries of the frequency map\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            \n            // Check if the number's frequency is greater than or equal to the number itself\n            if (num <= freq) {\n                result = Math.max(result, num); // Update result with the maximum value found\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Create a copy of the input list to avoid modifying it\n        List<Integer> sortedList = new ArrayList<>(lst);\n        Collections.sort(sortedList); // Sort in ascending order\n\n        List<Integer> result = new ArrayList<>();\n        int left = 0;\n        int right = sortedList.size() - 1;\n\n        while (left <= right) {\n            if (left == right) {\n                result.add(sortedList.get(left));\n            } else {\n                result.add(sortedList.get(left++)); // Add minimum\n                result.add(sortedList.get(right--)); // Add maximum\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(10, -1, 3, 9);\n        System.out.println(solution.strange_sort_list(test4)); // Expected: [-1, 10, 3, 9]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the given sides can form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter of the triangle\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to two decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.0\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the object q will fly, and false otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w and the list is a palindrome\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that need to be changed\n     * to make the array palindromic.\n     *\n     * @param arr List<Integer> representing the input array.\n     * @return int representing the minimum number of changes needed.\n     */\n    public int smallest_change(List<Integer> arr) {\n        int n = arr.size();\n        int changes = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            if (!arr.get(i).equals(arr.get(n - i - 1))) {\n                changes++;\n            }\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));   // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int sum1 = 0;\n        for (String s : lst1) {\n            sum1 += s.length();\n        }\n\n        int sum2 = 0;\n        for (String s : lst2) {\n            sum2 += s.length();\n        }\n\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n\n        // Additional test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList(\"a\", \"b\", \"c\"))); // []\n        System.out.println(solution.total_match(Arrays.asList(\"abc\", \"def\"), Arrays.asList(\"ghi\"))); // [\"ghi\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "class Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i = 0; i < primes.size(); i++) {\n            int p1 = primes.get(i);\n            \n            if (p1 * p1 * p1 > a) break;\n            \n            for (int j = i; j < primes.size(); j++) {\n                int p2 = primes.get(j);\n                \n                if (p1 * p2 * 2 > a) continue;\n                \n                for (int k = j; k < primes.size(); k++) {\n                    int p3 = primes.get(k);\n                    \n                    if (p1 * p2 * p3 == a) return true;\n                    \n                    if (p1 * p2 * p3 > a) break;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private List<Integer> generatePrimes(int maxPrime) {\n        boolean[] isComposite = new boolean[maxPrime + 1];\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i <= maxPrime; i++) {\n            if (!isComposite[i]) {\n                primes.add(i);\n                for (int j = i; j <= maxPrime / i; j++) {\n                    isComposite[i * j] = true;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     * \n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // Special case: any number to the power of 0 is 1\n        if (x == 1 && n > 1) return true;\n        \n        // If n is less than or equal to 1 and x is not 1, it's false\n        if (n <= 1 && x != 1) return false;\n\n        double logResult = Math.log(x) / Math.log(n);\n        int power = (int)logResult;\n\n        // Check if the result of log calculation is an integer\n        return logResult == power;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer is a perfect cube of some integer.\n     */\n    public boolean iscube(int a) {\n        // Check for negative numbers by converting them to positive\n        int absA = Math.abs(a);\n        \n        // Calculate the cube root and round it to the nearest integer\n        double cubeRoot = Math.cbrt(absA);\n        long roundedCubeRoot = Math.round(cubeRoot);\n\n        // Check if cubing the rounded value equals the original number\n        return roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == absA;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of iscube method\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Define a set of hexadecimal digits that are prime numbers.\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of characters in the input string that are prime hex digits.\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a given decimal number to its binary representation.\n     * The returned string includes 'db' at both ends of the binary sequence.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary format with 'db' prefix and suffix.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binary + \"db\";\n    }\n\n    /**\n     * A test method to check the correctness of the decimal_to_binary function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(7));   // Expected output: \"db111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the input string is a happy string.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if any two of the three consecutive characters are the same\n            if (firstChar == secondChar || secondChar == thirdChar || firstChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of GPA values into their corresponding letter grades.\n     *\n     * @param grades A List<Double> containing GPA values for students.\n     * @return A List<String> containing the letter grades for each GPA value.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa >= 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\"); // This case should never happen as GPA is non-negative.\n            }\n        }\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = solution.numerical_letter_grade(grades);\n        System.out.println(result); // Expected output: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a string is a prime number.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        \n        // Check for edge cases\n        if (len <= 1) return false;\n        if (len == 2) return true; // 2 is the only even prime number\n        \n        // Check divisibility by numbers up to sqrt(len)\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // If n is 1, there's only one such number: \"1\"\n            return 1;\n        }\n        \n        long countStartsWithOne = (long)Math.pow(9, n - 1);\n        long countEndsWithOne = (long)Math.pow(9, n - 1);\n        long countBothStartAndEndWithOne = (n > 2) ? (long)Math.pow(8, n - 2) : 0;\n        \n        // Total count is the sum of numbers starting or ending with one minus those that both start and end with one\n        return (int)((countStartsWithOne + countEndsWithOne - countBothStartAndEndWithOne));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.starts_one_ends(1));  // Expected output: 1\n        System.out.println(solution.starts_one_ends(2));  // Expected output: 18 (10, 11, ..., 19 and 21, 31, ..., 91)\n        System.out.println(solution.starts_one_ends(3));  // Expected output: 162\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * Example\n     * For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n     * For N = 150, the sum of digits will be 6 and the output should be \"110\".\n     * For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n     *\n     * Variables:\n     * @N integer\n     * Constraints: 0 <= N <= 10000.\n     * Output:\n     * a string of binary number\n     */\n    public String solve(int N) {\n        // Calculate the sum of digits of N\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n\n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *   add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n            if (lst.get(i) % 2 == 0) { // Check if the element at the current index is even\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(10, 5, 8, 3, 2, 9))); // Expected output: 5 (since only one even number at an odd index)\n        System.out.println(solution.add(Arrays.asList(1, 4, 6, 7, 8, 2))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Reorders each word in the input string such that characters are sorted in ascending ASCII order.\n     * The order of words and spaces is preserved.\n     *\n     * @param s Input string containing words separated by spaces.\n     * @return A new string where each word's characters are sorted alphabetically.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                \n                // Append sorted characters to the result, followed by a space\n                result.append(new String(chars));\n            }\n            \n            // Append a space after each non-empty word\n            result.append(\" \");\n        }\n\n        // Remove trailing space if present and return the result\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify correctness\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Create a list to store the result coordinates\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row in the 2D list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            \n            // Iterate through each element in the current row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinate to the result list\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates by rows in ascending order and columns in descending order\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) {\n                    return o2.get(1) - o1.get(1); // Descending order for columns within the same row\n                } else {\n                    return o1.get(0) - o2.get(0); // Ascending order for rows\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> lst1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // Expected: []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty list\n        if (array.isEmpty()) return new ArrayList<>();\n\n        int first = array.get(0);\n        int last;\n        \n        // If the list has only one element, it's both the first and last.\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        } else {\n            last = array.get(array.size() - 1);\n        }\n\n        boolean isOddSum = (first + last) % 2 != 0;\n\n        // Create a copy of the original list to sort\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (isOddSum) {\n            Collections.sort(sortedArray); // Sort in ascending order\n        } else {\n            sortedArray.sort(Collections.reverseOrder()); // Sort in descending order\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encrypts a given string by rotating each letter down by 4 places in the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                result.append((char)(base + offset));\n            } else {\n                // Non-alphabetic characters are not encrypted and remain the same.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test method to verify the correctness of the encrypt function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        Set<Integer> uniqueElements = new HashSet<>(lst);\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(uniqueElements);\n        Collections.sort(sortedList);\n\n        return Optional.of(sortedList.get(1));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms in a sentence.\n     * A boredom is defined as a sentence that starts with \"I\".\n     * Sentences are separated by '.', '?' or '!'.\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms (sentences starting with \"I\").\n     */\n    public int is_bored(String S) {\n        // Split the sentence into individual sentences based on delimiters\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_bored(\"Hello world\")); // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Expected output: 1\n        System.out.println(solution.is_bored(\"I am happy today. Are you? I think so!\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any integer equals the sum of the other two.\n     *\n     * @param x First number (Object type for flexibility)\n     * @param y Second number (Object type for flexibility)\n     * @param z Third number (Object type for flexibility)\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if any number is equal to the sum of the other two\n        return a == b + c || b == a + c || c == a + b;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (will be false because inputs are not all integers)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Encodes a message by swapping case of all letters, replacing vowels with the letter 2 places ahead.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) { // Check if character is a letter\n                char lowerCaseC = Character.toLowerCase(c);\n                \n                // Swap case\n                char swappedChar = Character.isLowerCase(lowerCaseC) ? Character.toUpperCase(lowerCaseC) : Character.toLowerCase(lowerCaseC);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                if (isVowel(swappedChar)) {\n                    swappedChar = replaceWithNextTwoLetters(swappedChar);\n                }\n                \n                encodedMessage.append(swappedChar);\n            } else {\n                // Non-letter characters are not modified\n                encodedMessage.append(c);\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    private boolean isVowel(char c) {\n        char lowerCaseC = Character.toLowerCase(c);\n        return \"aeiou\".indexOf(lowerCaseC) >= 0;\n    }\n\n    private char replaceWithNextTwoLetters(char vowel) {\n        int offset = (vowel == 'y' || vowel == 'Y') ? -4 : 2; // Special case for y/Y\n        return (char)((Character.toLowerCase(vowel) - 'a' + offset) % 26 + 'a');\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.encode(\"test\")); // Expected output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Expected output: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime number in the list and returns the sum of its digits.\n     */\n    public int findLargestPrimeDigitSum(List<Integer> lst) {\n        // Initialize a variable to store the largest prime found so far\n        Integer largestPrime = -1;\n\n        for (Integer num : lst) {\n            if (isPrime(num)) {\n                if (num > largestPrime) {\n                    largestPrime = num;\n                }\n            }\n        }\n\n        // If no prime number was found, return 0\n        if (largestPrime == -1) {\n            return 0;\n        }\n\n        // Calculate and return the sum of digits of the largest prime number\n        int sumOfDigits = 0;\n        while (largestPrime > 0) {\n            sumOfDigits += largestPrime % 10;\n            largestPrime /= 10;\n        }\n        return sumOfDigits;\n    }\n\n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> lst1 = Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3);\n        System.out.println(solution.findLargestPrimeDigitSum(lst1)); // Expected output: 10\n        \n        List<Integer> lst2 = Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1);\n        System.out.println(solution.findLargestPrimeDigitSum(lst2)); // Expected output: 25\n        \n        List<Integer> lst3 = Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3);\n        System.out.println(solution.findLargestPrimeDigitSum(lst3)); // Expected output: 13\n        \n        List<Integer> lst4 = Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6);\n        System.out.println(solution.findLargestPrimeDigitSum(lst4)); // Expected output: 11\n        \n        List<Integer> lst5 = Arrays.asList(0,81,12,3,1,21);\n        System.out.println(solution.findLargestPrimeDigitSum(lst5)); // Expected output: 3\n        \n        List<Integer> lst6 = Arrays.asList(0,8,1,2,1,7);\n        System.out.println(solution.findLargestPrimeDigitSum(lst6)); // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case,\n     * else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        String lowerCase = \"lower\";\n        String upperCase = \"upper\";\n\n        for (Object key : dict.keySet()) {\n            // Check if all keys are strings\n            if (!(key instanceof String)) {\n                return false;\n            }\n            \n            String strKey = (String) key;\n\n            // Determine the case of the first key to set a reference point\n            if (\"lower\".equals(lowerCase) || \"upper\".equals(upperCase)) {\n                lowerCase = strKey.equals(strKey.toLowerCase()) ? \"lower\" : \"upper\";\n                upperCase = strKey.equals(strKey.toUpperCase()) ? \"upper\" : \"lower\";\n            }\n\n            // Check the case of each key against the reference point\n            if (strKey.equals(strKey.toLowerCase())) {\n                if (!lowerCase.equals(\"lower\")) {\n                    return false;\n                }\n            } else if (strKey.equals(strKey.toUpperCase())) {\n                if (!upperCase.equals(\"upper\")) {\n                    return false;\n                }\n            } else {\n                // If a key is neither all lowercase nor all uppercase, return false\n                return false;\n            }\n        }\n\n        // If we reach here, the dictionary meets the criteria\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5)); // Expected: [2,3]\n        System.out.println(solution.count_up_to(11)); // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0)); // Expected: []\n        System.out.println(solution.count_up_to(20)); // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1)); // Expected: []\n        System.out.println(solution.count_up_to(18)); // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of their unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Should print 16\n        System.out.println(solution.multiply(19, 28));   // Should print 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print 0\n        System.out.println(solution.multiply(14, -15)); // Should print 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 1; i < s.length(); i += 2) { // Start from index 1 to check even indices only\n            char c = s.charAt(i);\n            if (\"AEIOU\".indexOf(c) != -1) { // Check if the character is an uppercase vowel\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_upper(\"aBCdEf\")); // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     *\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is negative or positive to determine rounding direction\n        if (num < 0) {\n            return (int)Math.ceil(num - 0.5); // Round towards more negative for negative numbers\n        } else {\n            return (int)Math.floor(num + 0.5); // Round towards more positive for non-negative numbers\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> levels = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            levels.add(currentStones);\n            if (n % 2 == 0) { // If the initial number of stones is even\n                currentStones += 2; // Next level will have an even number of stones\n            } else { // If the initial number of stones is odd\n                currentStones += 2; // Next level will have an odd number of stones\n            }\n        }\n\n        return levels;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> result1 = solution.make_a_pile(3);\n        System.out.println(result1); // Expected: [3, 5, 7]\n        \n        List<Integer> result2 = solution.make_a_pile(4);\n        System.out.println(result2); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits the given string into words separated by commas or spaces.\n     *\n     * @param s The input string to be split.\n     * @return A List of Strings containing each word from the input string.\n     */\n    public List<String> words_string(String s) {\n        // Replace all commas with spaces\n        String modifiedString = s.replaceAll(\",\", \" \");\n        \n        // Split the string by one or more consecutive spaces\n        String[] splitArray = modifiedString.split(\"\\\\s+\");\n        \n        // Convert array to list and return it\n        return Arrays.asList(splitArray);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1); // Expected: [Hi, my, name, is, John]\n        \n        // Test case 2\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2); // Expected: [One, two, three, four, five, six]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the biggest even integer number \n     * that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x <= y\n        if (y < x) {\n            return -1;\n        }\n\n        // Start from the end of the range and work backwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "class Solution {\n    /**\n     * Computes the rounded average of integers from n through m (inclusive) and returns its binary representation.\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return The binary string of the rounded average if valid, otherwise -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) return -1;\n\n        // Calculate the sum and count of numbers from n to m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute the average and round it to the nearest integer\n        double avg = (double) sum / count;\n        int roundedAvg = (int) Math.round(avg);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(roundedAvg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all elements that haven't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Helper method to check if an integer has only odd digits\n        return x.stream()\n                .filter(this::hasOnlyOddDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasOnlyOddDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true; // All digits are odd\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(7, 9, 11, 13);\n        System.out.println(solution.unique_digits(test3)); // Expected: [7, 9, 11, 13]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define an array of strings representing numbers from 1 to 9.\n        String[] numberNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        \n        // Filter the input list for integers between 1 and 9 inclusive.\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted() // Sort in ascending order\n                                        .collect(Collectors.toList());\n        \n        // Reverse the sorted list.\n        Collections.reverse(filteredList);\n        \n        // Convert each integer to its corresponding name and collect into a new list.\n        List<String> result = filteredList.stream()\n                                          .map(num -> numberNames[num - 1])\n                                          .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else { // If i is odd, calculate sum from 1 to i\n                result.add(sumToN(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    private int sumToN(int n) {\n        return (n * (n + 1)) / 2; // Sum of first n natural numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        int originalNumber = number, reversedNumber = 0;\n\n        while (number > 0) {\n            int digit = number % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            number /= 10;\n        }\n\n        return originalNumber == reversedNumber;\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) {\n                digit = -digit; // Make positive digits negative for the first occurrence\n            }\n            sum += digit;\n            num /= 10;\n            isNegative = false; // After processing the first digit, set to false\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(Arrays.asList())); // Expected output: 0\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11))); // Expected output: 1\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines if it is possible to get an array sorted in non-decreasing order by performing right shift operations.\n     *\n     * @param arr List of integers representing the array.\n     * @return true if it's possible to sort the array through right shifts, false otherwise.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the list is empty or has only one element, return true\n        if (arr.size() <= 1) {\n            return true;\n        }\n\n        int count = 0; // Count of rotations needed to get non-decreasing order\n\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element\n        if (arr.get(arr.size() - 1) > arr.get(0)) {\n            count++;\n        }\n\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether it is possible to exchange elements between two lists\n     * such that all elements in lst1 become even numbers.\n     *\n     * @param lst1 The first list of integers.\n     * @param lst2 The second list of integers.\n     * @return \"YES\" if it's possible to make all elements of lst1 even by exchanging,\n     *         otherwise returns \"NO\".\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        boolean hasEvenInLst2 = false;\n\n        // Count the number of odd numbers in lst1 and check if there is at least one even number in lst2\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                hasEvenInLst2 = true;\n                break;\n            }\n        }\n\n        // If there are no odd numbers in lst1, it's already possible to make all elements even\n        if (oddCountInLst1 == 0) return \"YES\";\n\n        // If there is at least one even number in lst2 and the count of odd numbers in lst1 does not exceed the total length of lst2,\n        // then it's possible to exchange.\n        if (hasEvenInLst2 && oddCountInLst1 <= lst2.size()) return \"YES\";\n\n        return \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(2, 4, 6, 8), Arrays.asList(1, 3, 5, 7))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(9, 11, 13, 15))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters,\n     * return a dictionary of the letter with the most repetition and containing the corresponding count.\n     * If several letters have the same occurrence, return all of them.\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into an array of words\n        String[] words = test.split(\" \");\n        \n        // Create a map to store each letter and its frequency\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String word : words) {\n            if (!word.isEmpty()) {  // Ensure we're not counting empty strings\n                frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Find the maximum frequency in the map\n        int maxFrequency = Collections.max(frequencyMap.values());\n\n        // Create a result map to store letters with the maximum frequency\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() == maxFrequency) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters present in c\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String resultString = filteredString.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left) != resultString.charAt(right)) {\n                isPalindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n\n        // Return the result as a list containing the filtered string and boolean\n        List<Object> result = new ArrayList<>();\n        result.add(resultString);\n        result.add(isPalindrome);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Should print: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));   // Should print: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Should print: [cdedc, true]\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int countOdd = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                    countOdd++;\n                }\n            }\n            String output = \"the number of odd elements \" + countOdd + \"n the str\" + countOdd + \"ng \" + countOdd + \" of the \" + countOdd + \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum at each step\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Calculate total amount of water in the grid.\n        int totalWater = 0;\n        for (List<Integer> row : grid) {\n            for (int cell : row) {\n                if (cell == 1) {\n                    totalWater++;\n                }\n            }\n        }\n\n        // Calculate how many times buckets need to be lowered.\n        return (totalWater + capacity - 1) / capacity;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example 1\n        List<List<Integer>> gridExample1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(gridExample1, 1)); // Expected output: 6\n\n        // Example 2\n        List<List<Integer>> gridExample2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(gridExample2, 2)); // Expected output: 5\n\n        // Example 3\n        List<List<Integer>> gridExample3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(gridExample3, 5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort the list using a custom comparator that first compares based on the number of 1s in binary representation,\n        // and then by decimal value if the number of 1s is equal.\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int count1 = Integer.bitCount(o1);\n                int count2 = Integer.bitCount(o2);\n\n                // Compare based on the number of ones in binary representation\n                if (count1 != count2) {\n                    return count1 - count2;\n                }\n\n                // If the number of ones is equal, compare by decimal value\n                return o1.compareTo(o2);\n            }\n        });\n\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1)); // Expected: [1, 2, 4, 3, 5]\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2)); // Expected: [-4, -2, -6, -5, -3]\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3)); // Expected: [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Define a method to count consonants in a word\n        java.util.function.Function<String, Integer> countConsonants = word -> {\n            int count = 0;\n            for (char c : word.toCharArray()) {\n                if (\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\".indexOf(c) >= 0) {\n                    count++;\n                }\n            }\n            return count;\n        };\n\n        // Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Filter and collect words with exactly n consonants\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (countConsonants.apply(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // Expected: [little]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // Expected: [Mary, lamb]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // Expected: []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // Expected: [world]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));             // Expected: [Uncle]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',\n                'A', 'E', 'I', 'O', 'U'));\n        \n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character\n            char leftChar = word.charAt(i - 1);\n            char middleChar = word.charAt(i);\n            char rightChar = word.charAt(i + 1);\n\n            if (!vowels.contains(leftChar) && !vowels.contains(rightChar) && vowels.contains(middleChar)) {\n                return String.valueOf(middleChar); // Found the vowel\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Should print \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Should print \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Should print \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * such that the resulting string is balanced.\n     *\n     * @param lst A list containing exactly two strings, each consisting only of '(' and ')'.\n     * @return \"Yes\" if there's a way to make a good string by concatenating the given strings,\n     *         otherwise returns \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Check all possible concatenations\n        for (int i = 0; i < lst.size(); i++) {\n            int balance = 0;\n            boolean isBalanced = true;\n\n            for (String s : lst) {\n                for (char c : s.toCharArray()) {\n                    if (c == '(') {\n                        balance++;\n                    } else {\n                        balance--;\n                    }\n                    // If at any point the balance goes negative, it's not balanced\n                    if (balance < 0) {\n                        isBalanced = false;\n                        break;\n                    }\n                }\n            }\n\n            // Swap the order of strings and check again if first attempt failed\n            if (!isBalanced && i == 0) {\n                Collections.swap(lst, 0, 1);\n                balance = 0;\n                for (String s : lst) {\n                    for (char c : s.toCharArray()) {\n                        if (c == '(') {\n                            balance++;\n                        } else {\n                            balance--;\n                        }\n                        // If at any point the balance goes negative, it's not balanced\n                        if (balance < 0) {\n                            isBalanced = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isBalanced && balance == 0) {\n                return \"Yes\";\n            }\n        }\n\n        // If no combination works, return \"No\"\n        return \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")(\", \"()\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue (min-heap)\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        // Add elements to the heap until it reaches size k\n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.add(num);\n            } else if (num > pq.peek()) {  // If current element is greater than the smallest in heap, replace it.\n                pq.poll();  // Remove the smallest element\n                pq.add(num);  // Add the new element\n            }\n        }\n\n        // Convert priority queue to list and sort it since we need ascending order\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Expected: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Expected: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) { // Iterate through even indices\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i); // Add to sum if it's an odd number in an even position\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Integer> list1 = Arrays.asList(5, 8, 7, 1);\n        System.out.println(sol.solution(list1)); // Expected output: 12\n\n        List<Integer> list2 = Arrays.asList(3, 3, 3, 3, 3);\n        System.out.println(sol.solution(list2)); // Expected output: 9\n\n        List<Integer> list3 = Arrays.asList(30, 13, 24, 321);\n        System.out.println(sol.solution(list3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k, return\n     * the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * Example:\n     * \n     * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     * Output: 24 # sum of 21 + 3\n     *\n     * Constraints:\n     * 1. 1 <= len(arr) <= 100\n     * 2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> testArr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr, k)); // Expected output is 24\n        \n        // Additional test case\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 3;\n        System.out.println(\"Test Case Output: \" + solution.add_elements(testArr2, k2)); // Expected output is 28\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = nextCollatzNumber(n); // Generate the next number in the sequence\n        }\n        result.add(1); // The Collatz sequence always ends with 1, which is odd.\n        \n        Collections.sort(result); // Ensure the list is sorted in increasing order\n        \n        return result;\n    }\n\n    private int nextCollatzNumber(int n) {\n        if (n % 2 == 0) { // If n is even\n            return n / 2;\n        } else { // If n is odd\n            return 3 * n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected output: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(1)); // Expected output: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Regular expression to match the required date format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\\\d{4})$\";\n        \n        // Check if the input string matches the regular expression\n        boolean isFormatValid = date.matches(regex);\n        \n        // If format is not valid, return false\n        if (!isFormatValid) {\n            return false;\n        }\n        \n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is between 1 and 12\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Determine the number of days in a given month\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        int maxDaysInMonth = getMaxDays(month, isLeapYear);\n\n        // Check if the day is within the valid range for the month\n        return day >= 1 && day <= maxDaysInMonth;\n    }\n\n    private int getMaxDays(int month, boolean isLeapYear) {\n        switch (month) {\n            case 2: return isLeapYear ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11: return 30;\n            default: return 31;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace and split if found\n        String[] words = txt.split(\"\\\\s+\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // If no whitespaces, check for commas and split if found\n        words = txt.split(\",\");\n        if (words.length > 1) {\n            return Arrays.asList(words);\n        }\n\n        // Count lowercase letters with odd order indices in the alphabet\n        int countOddOrderLetters = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    countOddOrderLetters++;\n                }\n            }\n        }\n\n        return countOddOrderLetters;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Should print: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Should print: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"NoSpacesHere\")); // Should print the number of odd-order lowercase letters\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"));\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If a number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.isEmpty() || lst.size() == 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of the occurrence of each number\n        Integer previousNumber = null;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (previousNumber != null && lst.get(i) < previousNumber) {\n                return false; // Not sorted in ascending order\n            }\n\n            if (i > 0 && lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false; // A number appears more than twice\n                }\n            } else {\n                count = 1;\n            }\n\n            previousNumber = lst.get(i);\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether the length of the intersection of two given closed intervals is a prime number.\n     *\n     * @param interval1 The first interval as a list containing start and end points.\n     * @param interval2 The second interval as a list containing start and end points.\n     * @return \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = Math.max(interval1.get(0), interval2.get(0));\n        int end1 = Math.min(interval1.get(1), interval2.get(1));\n\n        // If there is no intersection\n        if (start1 > end1) return \"NO\";\n\n        int lengthOfIntersection = end1 - start1 + 1;\n\n        // Check if the length of intersection is a prime number\n        return isPrime(lengthOfIntersection) ? \"YES\" : \"NO\";\n    }\n\n    /**\n     * Checks whether a given number is a prime number.\n     *\n     * @param n The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int signProduct = 1;\n        int magnitudeSum = 0;\n\n        for (int num : arr) {\n            if (num == 0) {\n                // If there's a zero, the product of signs is zero.\n                signProduct = 0;\n                break;\n            }\n            if (num < 0) {\n                signProduct *= -1;\n            }\n            magnitudeSum += Math.abs(num);\n        }\n\n        return Optional.of(signProduct * magnitudeSum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        // Initialize the answer with a large value to ensure any path will be smaller\n        List<Integer> ans = new ArrayList<>(Collections.nCopies(k, Integer.MAX_VALUE));\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start DFS from each cell to find the minimum path\n                dfs(grid, k, new ArrayList<>(), i, j, ans);\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(List<List<Integer>> grid, int k, List<Integer> path, int row, int col, List<Integer> ans) {\n        if (path.size() == k) {\n            // Update the answer with the lexicographically smaller path\n            if (isSmaller(path, ans)) {\n                ans.clear();\n                ans.addAll(path);\n            }\n            return;\n        }\n\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0], newCol = col + dir[1];\n            // Check bounds and add the next cell to the path\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid.get(0).size()) {\n                path.add(grid.get(newRow).get(newCol));\n                dfs(grid, k, path, newRow, newCol, ans);\n                // Backtrack to explore other paths\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        int size = Math.min(a.size(), b.size());\n        for (int i = 0; i < size; ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the first n+1 numbers of a custom Tribonacci sequence.\n     */\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>(); // Handle invalid input\n\n        List<Integer> result = new ArrayList<>();\n        \n        // Base case\n        if (n >= 1) result.add(3); // tri(1) = 3\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int value;\n            if (i % 2 == 0) { // Even index\n                value = 1 + i / 2;\n            } else { // Odd index, greater than 1\n                value = result.get(i - 2) + result.get(i - 3) + triHelper(i + 1);\n            }\n            result.add(value);\n        }\n\n        return result.subList(0, n + 1); // Return the first n+1 elements\n    }\n\n    private int triHelper(int n) {\n        if (n == 2) return 2; // tri(2) = 2 as per given rules\n        List<Integer> memo = new ArrayList<>(Collections.nCopies(n, null));\n        memo.set(0, 3); // tri(1)\n        memo.set(1, 2); // tri(2)\n\n        for (int i = 2; i < n; i++) {\n            if (i % 2 == 0) {\n                memo.set(i, 1 + i / 2);\n            } else {\n                int value = memo.get(i - 1) + memo.get(i - 2) + triHelper(i + 1);\n                memo.set(i, value);\n            }\n        }\n\n        return memo.get(n - 1); // Return the computed value for n\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.tri(3)); // Expected output: [3, 2, 8]\n        System.out.println(solution.tri(4)); // Expected output: [3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if there is at least one nested bracket in the given string.\n     *\n     * @param string A string containing only square brackets.\n     * @return true if there is at least one nested bracket, false otherwise.\n     */\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean hasNested = false;\n\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n                // If the balance is positive, it means there's a nested bracket.\n                if (balance > 0) hasNested = true;\n            }\n            // Early exit optimization\n            if (hasNested && balance < 0) return false; // Invalid sequence detected early\n        }\n\n        // The string must be balanced and have at least one nested bracket to be valid.\n        return hasNested && balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\"));       // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\"));      // false\n        System.out.println(solution.is_nested(\"[]\"));        // false\n        System.out.println(solution.is_nested(\"[[][]]\"));    // true\n        System.out.println(solution.is_nested(\"[[]][[\"));   // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of numbers.\n     * You need to return the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double ceilValue = Math.ceil(num);\n            // Square the rounded value and add it to the sum\n            sum += (int)Math.pow(ceilValue, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> lst1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(lst1)); // Output: 14\n\n        List<Double> lst2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(lst2)); // Output: 98\n\n        List<Double> lst3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(lst3)); // Output: 84\n\n        List<Double> lst4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(lst4)); // Output: 29\n\n        List<Double> lst5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(lst5)); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Trim the input to remove trailing spaces\n        String trimmedTxt = txt.trim();\n        \n        // Check if the string is empty after trimming\n        if (trimmedTxt.isEmpty()) {\n            return false;\n        }\n        \n        char lastChar = trimmedTxt.charAt(trimmedTxt.length() - 1);\n        \n        // Check if the last character is an alphabetical letter and not part of a word\n        boolean isLastCharLetter = Character.isAlphabetic(lastChar) && \n                                   (trimmedTxt.length() == 1 || !Character.isAlphabetic(trimmedTxt.charAt(trimmedTxt.length() - 2)));\n        \n        return isLastCharLetter;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));   // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\"));  // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\"));            // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(solution.can_arrange(test1)); // Expected output: 3\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.can_arrange(test2)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as Optional.empty().\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional.of(1)]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing real numbers,\n     * and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public static Optional<Object> compare_one(Object a, Object b) {\n        double numA = toDouble(a);\n        double numB = toDouble(b);\n\n        if (numA == numB) return Optional.empty();\n\n        if (numA > numB) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private static double toDouble(Object obj) {\n        if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(',', '.'); // Convert comma to dot for parsing\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        }\n\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        }\n\n        if (obj instanceof Float || obj instanceof Double) {\n            return ((Number) obj).doubleValue();\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(compare_one(1, \"2,3\")); // Optional[2,3]\n        System.out.println(compare_one(\"5,1\", \"6\")); // Optional[6]\n        System.out.println(compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Since we are looking for a sum of exactly four positive even numbers, \n        // the smallest possible sum is 2 + 2 + 2 + 2 = 8. Any number less than 8 cannot be expressed as such.\n        if (n < 8) return false;\n\n        // The sum of any four even numbers will always be an even number and divisible by 4.\n        // However, not all even numbers greater than or equal to 8 can be expressed this way,\n        // but we know that n - 8 must be expressible as a sum of three positive even numbers for n >= 12.\n        if (n % 2 == 0 && n >= 12) {\n            return true;\n        }\n\n        // For the edge case where n is between 8 and 11, we need to check manually:\n        int[] testCases = {8, 10};\n        for (int testCase : testCases) {\n            if (n == testCase) return true;\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_equal_to_sum_even(4)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(6)); // Expected: false\n        System.out.println(solution.is_equal_to_sum_even(8)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(10)); // Expected: true\n        System.out.println(solution.is_equal_to_sum_even(12)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the result of the Brazilian factorial calculation.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long product = 1;\n        for (int j = 2; j <= number; j++) {\n            product *= j;\n        }\n        return product;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     */\n    public String fix_spaces(String text) {\n        // Replace more than two consecutive spaces with '-'\n        String result = text.replaceAll(\" {3,}\", \"-\");\n        \n        // Replace remaining single or double spaces with '_'\n        return result.replaceAll(\" \", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fix_spaces(\"Example\"));          // Output: Example\n        System.out.println(solution.fix_spaces(\"Example 1\"));       // Output: Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\"));      // Output: _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\"));    // Output: _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a file name is valid based on specific criteria.\n     *\n     * @param fileName The file name to check.\n     * @return \"Yes\" if the file name is valid, otherwise returns \"No\".\n     */\n    public String file_name_check(String fileName) {\n        // Check for exactly one dot\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex == -1 || fileName.lastIndexOf('.') != dotIndex) {\n            return \"No\";\n        }\n\n        // Split the file name into two parts: before and after the dot\n        String baseName = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        // Check if the part before the dot is valid\n        if (!isValidBase(baseName)) {\n            return \"No\";\n        }\n\n        // Check if the part after the dot is a valid extension\n        if (!isValidExtension(extension)) {\n            return \"No\";\n        }\n\n        // Count digits in the base name and ensure there are no more than three\n        int digitCount = 0;\n        for (char c : baseName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n\n    private boolean isValidBase(String baseName) {\n        // Check that the base name starts with a letter and is not empty\n        if (baseName.isEmpty() || !Character.isLetter(baseName.charAt(0))) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isValidExtension(String extension) {\n        // Valid extensions are \"txt\", \"exe\", or \"dll\"\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        for (String ext : validExtensions) {\n            if (ext.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"file123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"file1234.txt\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n     * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n     */\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                sum += Math.pow(lst.get(i), 3);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> lst1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sum_squares(lst1)); // Expected output: 6\n        \n        // Test case 2\n        List<Integer> lst2 = new ArrayList<>();\n        System.out.println(solution.sum_squares(lst2)); // Expected output: 0\n        \n        // Test case 3\n        List<Integer> lst3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(solution.sum_squares(lst3)); // Expected output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "class Solution {\n    /**\n     * Checks if a given number is prime.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Test code to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        String test1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(test1));  // Expected output: \"is\"\n\n        String test2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(test2));  // Expected output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n and checks if it evaluates to a whole number.\n     *\n     * @param x The first fraction in string format \"<numerator>/<denominator>\".\n     * @param n The second fraction in string format \"<numerator>/<denominator>\".\n     * @return true if x * n is a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Calculate the product of the two fractions\n        long resultNumerator = (long) numeratorX * numeratorN;\n        long resultDenominator = (long) denominatorX * denominatorN;\n\n        // Check if the result is a whole number by seeing if the remainder is zero when dividing the numerator by the denominator.\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list to store pairs of (original index, number)\n        List<Pair<Integer, Integer>> indexedNums = new ArrayList<>();\n        \n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums.add(new Pair<>(i, nums.get(i)));\n        }\n        \n        // Sort the list based on custom comparator\n        Collections.sort(indexedNums, new Comparator<Pair<Integer, Integer>>() {\n            @Override\n            public int compare(Pair<Integer, Integer> o1, Pair<Integer, Integer> o2) {\n                int sum1 = digitSum(o1.getValue());\n                int sum2 = digitSum(o2.getValue());\n                \n                if (sum1 != sum2) {\n                    return sum1 - sum2;\n                } else {\n                    return o1.getKey() - o2.getKey();\n                }\n            }\n        });\n        \n        // Extract the sorted numbers from pairs\n        List<Integer> result = new ArrayList<>();\n        for (Pair<Integer, Integer> pair : indexedNums) {\n            result.add(pair.getValue());\n        }\n        \n        return result;\n    }\n\n    private int digitSum(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && digit > 0) {\n                digit *= -1; // Adjust positive digits to negative\n            }\n            sum += Math.abs(digit);\n            num /= 10;\n            \n            // If the number is still negative after processing a digit, adjust the next digit accordingly.\n            if (num < 0) {\n                int nextDigit = num % 10;\n                sum -= Math.abs(nextDigit); // Subtract the absolute value of the next digit\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(test1)); // Expected: [-1, -11, 1, -12, 11]\n        \n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(test2)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                         .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                         .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int number) {\n        String strNum = Integer.toString(number);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     */\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Count how many numbers in the array are congruent to each of 0, 1, and 2 modulo 3\n        int countMod0 = 0, countMod1 = 0, countMod2 = 0;\n\n        for (int num : a) {\n            if (num % 3 == 0) countMod0++;\n            else if (num % 3 == 1) countMod1++;\n            else countMod2++;\n        }\n\n        // Calculate the number of valid triples\n        int result = 0;\n        result += countMod0 * (countMod0 - 1) * (countMod0 - 2) / 6; // All three numbers are congruent to 0 mod 3\n        result += countMod1 * (countMod1 - 1) * (countMod1 - 2) / 6; // All three numbers are congruent to 1 mod 3\n        result += countMod2 * (countMod2 - 1) * (countMod2 - 2) / 6; // All three numbers are congruent to 2 mod 3\n        result += countMod0 * countMod1 * countMod2; // One number is congruent to each of 0, 1, and 2 mod 3\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    private static final List<String> PLANETS = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n    public List<String> bf(String planet1, String planet2) {\n        int index1 = PLANETS.indexOf(planet1);\n        int index2 = PLANETS.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) return Collections.emptyList();\n\n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = index1 + 1; i < index2; i++) {\n            result.add(PLANETS.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filters out strings of odd length from a list, sorts the rest by length,\n     * and alphabetically for equal lengths.\n     */\n    public List<String> filterAndSort(List<String> lst) {\n\n        // Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) { // Check if length is even\n                filteredList.add(str);\n            }\n        }\n\n        // Sort the list by string length, then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return Integer.compare(s1.length(), s2.length());\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return filteredList;\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.filterAndSort(test1)); // Expected: [\"aa\"]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.filterAndSort(test2)); // Expected: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print 5\n        System.out.println(solution.x_or_y(29, 100, 200)); // Should print 100\n        System.out.println(solution.x_or_y(4, 30, 60));   // Should print 60\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List of objects containing Integer values\n     * @return The sum of squares of positive odd integers from the list\n     */\n    public int sumOfSquaresOfOdd(List<Object> lst) {\n        return lst.stream()\n                .filter(obj -> obj instanceof Integer)\n                .mapToInt(Integer.class::cast)\n                .filter(num -> num > 0 && num % 2 != 0)\n                .map(num -> num * num)\n                .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(-1, -2, 0)));   // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(9, -2)));       // Expected output: 81\n        System.out.println(solution.sumOfSquaresOfOdd(Arrays.asList(0)));           // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdd(new ArrayList<>()));          // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares each element in the guess list to its corresponding element in the game list.\n     * Returns a new list where each element is 0 if the guess was correct, or the absolute difference otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> guess1 = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> guess2 = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class based on the provided list of extensions.\n     * The strength of an extension is calculated as CAP - SM, where CAP is the number of uppercase letters,\n     * and SM is the number of lowercase letters in the extension's name. If there are multiple extensions\n     * with the same strength, the first one in the list is chosen.\n     *\n     * @param class_name The name of the class to which the strongest extension will be attached.\n     * @param extensions A List containing names of possible extensions for the class.\n     * @return A string representing the class and its strongest extension in the format \"ClassName.Strongest_Extension\".\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) return class_name;\n\n        // Initialize variables to track the strongest extension\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String name) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : name.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if any rotation of b is a substring of a.\n     */\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the string 'a' with itself to handle rotations easily\n        String doubledA = a + a;\n        \n        // Check if 'b' or any of its rotations is a substring of the concatenated string\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a positive value and then to string for easy iteration\n        String strNum = Integer.toString(Math.abs(num));\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char c = strNum.charAt(i);\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not, it's odd\n                oddCount++;\n            }\n        }\n\n        // Return the counts as a list [even count, odd count]\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify correctness of the method\n        System.out.println(solution.even_odd_count(-12));  // Expected output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected output: [1, 2]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     */\n    public String int_to_mini_roman(int number) {\n        // Mapping of integers to Roman numerals (in lowercase)\n        String[] M = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] C = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] X = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] I = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Calculate the Roman numeral\n        return M[number / 1000] + C[(number % 1000) / 100] + X[(number % 100) / 10] + I[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));   // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        if (b > c) {\n            int temp = b;\n            b = c;\n            c = temp;\n        }\n\n        // Check Pythagorean theorem: a^2 + b^2 == c^2\n        return Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If there are multiple such words, returns the one that comes first lexicographically.\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) return \"\";\n\n        // Initialize variables to keep track of the result and its score\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Update the maximum if this word has more unique characters or is lexicographically smaller\n            int currentUniqueCount = uniqueChars.size();\n            if (currentUniqueCount > maxUniqueChars || \n                (currentUniqueCount == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = currentUniqueCount;\n            }\n        }\n\n        return maxWord;\n    }\n\n    // Test function to verify the correctness of find_max\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> words1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(words1));  // Expected: string\n\n        List<String> words2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(words2));  // Expected: enam\n\n        List<String> words3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(words3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots that can be eaten.\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Determine how many carrots are left after eating.\n        int leftoverCarrots = Math.max(remaining - need, 0);\n\n        // Return a list containing the total number of eaten carrots and the number of leftover carrots.\n        return new ArrayList<>(List.of(totalEaten, leftoverCarrots));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected output: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected output: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected output: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected output: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two lists operator, and operand. Use these to build an algebraic expression \n     * and return its evaluation.\n     *\n     * @param operator List of basic algebra operations: +, -, *, /, ** (exponentiation)\n     * @param operand  List of non-negative integers\n     * @return The result of the evaluated algebraic expression as an integer.\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Create a StringBuilder to build the expression string\n        StringBuilder expr = new StringBuilder();\n        \n        // Add operands and operators to form the expression\n        for (int i = 0; i < operand.size(); i++) {\n            if (i > 0) {\n                expr.append(operator.get(i - 1));\n            }\n            expr.append(operand.get(i));\n        }\n\n        // Evaluate the expression using a scripting engine\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n        \n        try {\n            return (int)engine.eval(expr.toString());\n        } catch (ScriptException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // Test method to check the correctness of do_algebra\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Expected output: 9\n\n        List<String> operators2 = Arrays.asList(\"**\", \"/\", \"+\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 8, 4);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     */\n    public String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        boolean hasLetters = false;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                // Reverse case\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If no letters were found, reverse the string\n        if (!hasLetters) {\n            return result.reverse().toString();\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = digest.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hash);\n        String hashtext = number.toString(16);\n\n        // Add leading zeros to make sure it's 32 chars long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that 'a' is less than or equal to 'b'\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> evenDigits = new ArrayList<>();\n        for (int i = a; i <= b; i++) {\n            // Check each digit of the number\n            while (i > 0) {\n                int digit = i % 10;\n                if (digit < 10 && digit % 2 == 0) {\n                    evenDigits.add(digit);\n                }\n                i /= 10; // Move to the next digit\n            }\n        }\n\n        // Remove duplicates and sort the list\n        Set<Integer> uniqueEvenDigits = new LinkedHashSet<>(evenDigits); // Preserves insertion order\n        List<Integer> sortedUniqueEvenDigits = new ArrayList<>(uniqueEvenDigits);\n        Collections.sort(sortedUniqueEvenDigits);\n\n        return sortedUniqueEvenDigits;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.generate_integers(2, 8)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
