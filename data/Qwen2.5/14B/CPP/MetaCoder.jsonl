{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list to check if any two consecutive elements are closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n", "py_code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n```\n\n", "py_summary": "The Python function `has_close_elements` checks whether any two numbers in a given list are closer to each other than a specified threshold. Here's an analysis of how it works:\n\n1. **Sorting**: The input list `numbers` is first sorted in ascending order using the `sort()` method. This ensures that adjacent elements in the sorted list will be the closest possible pairs.\n\n2. **Iteration and Comparison**:\n   - A loop iterates through each element in the sorted list, except for the last one.\n   - For each pair of consecutive elements `(numbers[i], numbers[i + 1])`, it calculates their absolute difference using `abs(numbers[i] - numbers[i + 1])`.\n   - If this difference is less than the given threshold, the function immediately returns `True`.\n\n3. **Return Value**:\n   - If no such pair of elements with a difference less than the threshold is found during the iteration, the function returns `False` after completing the loop.\n\nThis approach ensures that the function efficiently checks for any two numbers being closer to each other than the specified threshold by leveraging sorting and iterating through adjacent pairs in the sorted list."}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group = \"\";\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            balance++;\n            current_group += c;\n        } else if (c == ')') {\n            balance--;\n            current_group += c;\n\n            // When the group is balanced, add it to the result and reset current_group\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n\n        // If balance becomes negative, it means there's an unmatched closing parenthesis\n        if (balance < 0) {\n            throw runtime_error(\"Unbalanced parentheses\");\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = \"\"\n    \n    for char in paren_string.replace(\" \", \"\"):\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        elif char == \")\":\n            stack.pop()\n            current_group += char\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"\n                \n    return result\n```\n\n", "py_summary": "The Python code defines a function `separate_paren_groups` that takes a string containing multiple groups of nested parentheses and separates those groups into individual strings. The function returns a list of these separated groups.\n\n1. **Input Processing**: \n   - The input string is processed to remove any spaces using `paren_string.replace(\" \", \"\")`.\n\n2. **Initialization**:\n   - An empty list `result` is initialized to store the final separated groups.\n   - A stack is used to keep track of open parentheses and ensure that each group is balanced.\n   - A variable `current_group` is initialized as an empty string to build each group incrementally.\n\n3. **Iterating Through Characters**:\n   - The function iterates through each character in the processed input string.\n   - If the character is an opening parenthesis `(`, it is added to both the stack and `current_group`.\n\n4. **Handling Closing Parentheses**:\n   - When a closing parenthesis `)` is encountered, it is popped from the stack (indicating that the corresponding opening parenthesis has been matched) and also added to `current_group`.\n   - If the stack becomes empty after popping, it means that the current group of parentheses is complete. The completed group is then appended to the result list.\n\n5. **Returning Result**:\n   - After processing all characters in the input string, the function returns the list of separated groups stored in `result`.\n\nThis approach ensures that each balanced group of parentheses is correctly identified and separated from other groups without nesting or overlapping."}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n```\n", "py_summary": "The Python function `truncate_number` takes a floating-point number as input and returns its decimal part. Here's how it works:\n\n1. **Extract Integer Part**: The integer part of the number is obtained by converting the float to an integer using the `int()` function, which truncates the decimal places.\n2. **Calculate Decimal Part**: The decimal part is then calculated by subtracting the integer part from the original number.\n\nThe result is the fractional part of the input number that lies between 0 (inclusive) and 1 (exclusive).\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n```\n\n", "py_summary": "The Python function `below_zero` checks whether a bank account's balance falls below zero given a list of deposit and withdrawal operations. Here\u2019s an analysis of how it works:\n\n1. **Initialization**: The function starts by initializing the account balance to 0.\n2. **Iteration through Operations**: It iterates over each operation in the input list `operations`.\n3. **Update Balance**: For each operation, the current balance is updated by adding (for deposits) or subtracting (for withdrawals) the value of the operation.\n4. **Check for Negative Balance**: After updating the balance, it checks if the new balance is less than zero.\n5. **Return Result**: If at any point the balance falls below zero, the function immediately returns `True`. If no such point is found after processing all operations, the function returns `False`.\n\nThis approach ensures that the function efficiently detects whether the account balance goes negative during the sequence of transactions.\n\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f;\n    }\n    \n    // Calculate the mean value of the dataset\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean_value = sum / numbers.size();\n    \n    // Calculate the absolute differences from the mean and then their average\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean_value);\n    }\n    float mad = mad_sum / numbers.size();\n    \n    return mad;\n}\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean and then their average\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad\n```\n\n", "py_summary": "The Python code defines a function `mean_absolute_deviation` that calculates the Mean Absolute Deviation (MAD) of a given list of floating-point numbers. Here's a detailed breakdown of how it works:\n\n1. **Input Validation**: The function first checks if the input list is empty. If it is, the function returns 0.0 to avoid division by zero.\n\n2. **Calculate Mean**:\n   - It calculates the mean (average) value of the dataset using `sum(numbers) / len(numbers)`.\n\n3. **Calculate Absolute Differences and Average**:\n   - The function then computes the absolute differences between each element in the list and the calculated mean.\n   - These absolute differences are summed up, and their average is computed by dividing the sum by the number of elements in the dataset.\n\n4. **Return Result**: Finally, the function returns the calculated Mean Absolute Deviation (MAD).\n\nThis approach ensures that the MAD is accurately calculated as the average of the absolute deviations from the mean for all elements in the input list."}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0) {\n            result.push_back(delimiter);\n        }\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i > 0:\n            result.append(delimiter)\n        result.append(numbers[i])\n    return result\n```\n\n", "py_summary": "The Python function `intersperse` takes a list of integers (`numbers`) and an integer delimiter as input. The goal is to insert the delimiter between every two consecutive elements in the list.\n\nHere's a detailed analysis:\n\n1. **Initialization**: An empty list called `result` is initialized to store the final interspersed sequence.\n2. **Iteration**: A for loop iterates through each element of the `numbers` list using an index variable `i`.\n3. **Delimiter Insertion**: Inside the loop, if the current index `i` is greater than 0 (meaning it's not the first element), the delimiter is appended to `result`. This ensures that a delimiter is inserted between every pair of consecutive elements.\n4. **Appending Elements**: The current element from `numbers` at index `i` is then appended to `result`.\n5. **Return Result**: After iterating through all elements, the function returns the final list stored in `result`.\n\nThis approach ensures that the delimiter is correctly placed between each pair of consecutive elements without modifying the original input list.\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Define deepest_level function before parse_nested_parens\nint deepest_level(string group) {\n    int max_depth = 0;\n    int current_depth = 0;\n    \n    for (char c : group) {\n        if (c == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') {\n            current_depth--;\n        }\n    }\n    \n    return max_depth;\n}\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> results;\n\n    // Split the input string into groups based on spaces\n    size_t start = 0, end = 0;\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        start = end + 1;\n        results.push_back(deepest_level(group));\n    }\n\n    // Process the last group\n    results.push_back(deepest_level(paren_string.substr(start)));\n\n    return results;\n}\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    results = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        results.append(max_depth)\n    \n    return results\n```\n\n", "py_summary": "The Python function `parse_nested_parens` takes a string of nested parentheses groups separated by spaces and returns a list containing the deepest level of nesting for each group.\n\n1. **Splitting the Input String**: The input string is split into individual groups based on spaces using `split()`. Each group represents a separate sequence of nested parentheses.\n2. **Initializing Variables**: For each group, two variables are initialized: \n   - `max_depth` to keep track of the deepest level of nesting encountered in the current group.\n   - `current_depth` to maintain the current depth as we iterate through the characters of the group.\n3. **Iterating Through Characters**: The function iterates through each character in the group:\n   - If the character is an opening parenthesis '(', the `current_depth` is incremented by 1, and `max_depth` is updated if the new `current_depth` exceeds the current value of `max_depth`.\n   - If the character is a closing parenthesis ')', the `current_depth` is decremented by 1.\n4. **Appending Results**: After processing each group, the deepest level of nesting (`max_depth`) for that group is appended to the results list.\n5. **Returning Results**: Finally, the function returns the list containing the maximum depth of nesting for each group.\n\nThis approach ensures that we correctly track and determine the maximum depth of nested parentheses in each group efficiently."}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(substring) != string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "def filter_by_substring(strings, substring):\n    return [s for s in strings if substring in s]\n```\n\n", "py_summary": "The Python code defines a function `filter_by_substring` that takes two parameters: a list of strings (`strings`) and a substring (`substring`). The function returns a new list containing only those strings from the input list that contain the specified substring.\n\nHere's an analysis of how it works:\n1. **List Comprehension**: The function uses a list comprehension to iterate over each string `s` in the input list `strings`.\n2. **Substring Check**: For each string `s`, it checks if the substring is present using the `in` operator.\n3. **Result List**: If the substring is found within the string, that string is included in the resulting list.\n\nThis approach ensures that only strings containing the specified substring are returned, making the function efficient and concise.\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int total_sum = 0;\n    int total_product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int number : numbers) {\n        total_sum += number;\n        total_product *= number;\n    }\n\n    return {total_sum, total_product};\n}\n", "py_code": "from typing import List\n\ndef sum_product(numbers: List[int]) -> tuple:\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = 0\n    total_product = 1\n    \n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    \n    return (total_sum, total_product)\n```\n\n", "py_summary": "The Python code defines a function `sum_product` that takes a list of integers as input and returns a tuple containing the sum and product of all the integers in the list.\n\n1. **Check for Empty List**: The function first checks if the input list is empty. If it is, the function returns `(0, 1)` because the sum of an empty set is `0` and the product of an empty set is `1`.\n\n2. **Initialize Variables**: It initializes two variables: `total_sum` to `0` and `total_product` to `1`. These will be used to accumulate the sum and product of the elements in the list.\n\n3. **Iterate Through List**: The function then iterates through each integer in the input list:\n   - For each integer, it adds the integer to `total_sum`.\n   - It also multiplies the integer with `total_product`.\n\n4. **Return Result**: Finally, the function returns a tuple containing `total_sum` and `total_product`.\n\nThis approach ensures that the sum and product are correctly calculated for any given list of integers, including an empty list.\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    int max_so_far = INT_MIN;  // Initialize to the smallest possible integer value\n    vector<int> result;\n    \n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;\n        }\n        result.push_back(max_so_far);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float('-inf')\n    result = []\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `rolling_max` that takes a list of integers as input and returns a new list where each element is the maximum value encountered so far in the sequence.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - `max_so_far`: This variable keeps track of the highest number seen up to the current point in the iteration.\n   - `result`: An empty list that will store the rolling maximum values for each position in the input sequence.\n\n2. **Iteration through the Input List**:\n   - The function iterates over each element (`num`) in the input list `numbers`.\n   \n3. **Updating the Maximum Value**:\n   - For each number, it checks if this number is greater than the current value of `max_so_far`. If so, it updates `max_so_far` to this new number.\n   \n4. **Appending to Result List**:\n   - Regardless of whether an update occurred, the function appends the current value of `max_so_far` to the result list.\n\n5. **Returning the Result**:\n   - After iterating through all elements in the input list, the function returns the `result` list containing the rolling maximum values.\n\nThis approach ensures that for each element in the sequence, we have a record of the highest number seen up to that point, which is exactly what the problem requires."}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    Examples:\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    */\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix_to_reverse = str.substr(0, i);\n            return str + string(prefix_to_reverse.rbegin(), prefix_to_reverse.rend());\n        }\n    }\n    return str;\n}\n", "py_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef make_palindrome(str_input):\n    n = len(str_input)\n    for i in range(n):\n        if is_palindrome(str_input[i:]):\n            prefix_to_reverse = str_input[:i]\n            return str_input + prefix_to_reverse[::-1]\n```\n", "py_summary": "### Analysis of Python Code\n\nThe provided Python functions `is_palindrome` and `make_palindrome` work together to solve the problem of finding the shortest palindrome that begins with a supplied string.\n\n1. **Function: is_palindrome**\n   - This function checks if a given string `s` is a palindrome.\n   - It returns `True` if the string reads the same forwards and backwards, otherwise it returns `False`.\n   - The check is performed by comparing the original string to its reverse (`s[::-1]`).\n\n2. **Function: make_palindrome**\n   - This function aims to find the shortest palindrome that begins with a supplied string.\n   - It iterates through the input string and checks for the longest postfix (suffix) of the string that is a palindrome.\n   - For each suffix, it identifies the prefix before this palindromic suffix. If `str_input[i:]` is a palindrome, then `i` marks the start index where the non-palindromic part ends.\n   - It appends to the original string the reverse of the prefix that comes before the palindromic suffix (`str_input[:i]`).\n   - The function returns this new string which forms the shortest possible palindrome starting with the given input.\n\n### Summary\n- **is_palindrome(s)**: Checks if `s` is a palindrome.\n- **make_palindrome(str_input)**: Finds and constructs the shortest palindrome that starts with `str_input`.\n\nThe algorithm ensures that only the necessary part of the string needs to be reversed and appended, making it efficient in terms of both time and space complexity."}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR the bits and append to the result\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n", "py_code": "def string_xor(a: str, b: str) -> str:\n    result = \"\"\n    for i in range(len(a)):\n        # XOR the bits and append to the result\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n    return result\n```\n\n", "py_summary": "The Python function `string_xor` takes two string inputs `a` and `b`, both consisting of binary digits (1s and 0s). The function performs a bitwise XOR operation on these strings and returns the result as a new string.\n\nHere's a detailed breakdown:\n- **Initialization**: An empty string `result` is initialized to store the final output.\n- **Iteration**: A loop runs through each character in the input strings. Since both strings are of equal length (as implied by the problem statement), we iterate over one of them.\n  - For each position `i`, it compares the characters at that position in both strings (`a[i]` and `b[i]`).\n  - If the characters are the same, XOR operation results in '0', so '0' is appended to `result`.\n  - If the characters are different, XOR operation results in '1', so '1' is appended to `result`.\n- **Return**: After iterating through all positions, the function returns the constructed result string.\n\nThis approach ensures that each corresponding pair of bits from both strings undergoes an XOR operation and the resulting binary string is returned."}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::string(); // Return an empty string to represent None in C++\n    }\n    \n    size_t max_length = 0;\n    std::string longest_string = \"\";\n    \n    for (const auto& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            longest_string = str;\n        }\n    }\n    \n    return longest_string;\n}\n", "py_code": "from typing import List\n\ndef longest(strings: List[str]) -> str:\n    if not strings:\n        return None\n    \n    max_length = 0\n    longest_string = \"\"\n    \n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_string = string\n            \n    return longest_string\n```\n\n", "py_summary": "The Python code defines a function `longest` that takes a list of strings as input and returns the longest string in the list. If there are multiple strings with the same maximum length, it returns the first one encountered. If the input list is empty, it returns `None`.\n\nHere's a breakdown of how the function works:\n1. **Check for Empty List**: The function first checks if the input list `strings` is empty. If it is, the function immediately returns `None`.\n2. **Initialize Variables**: It initializes two variables: `max_length` to keep track of the length of the longest string found so far and `longest_string` to store the actual longest string.\n3. **Iterate Through Strings**: The function iterates through each string in the list. For each string, it checks if its length is greater than the current `max_length`.\n4. **Update Variables**: If a longer string is found, `max_length` and `longest_string` are updated accordingly.\n5. **Return Result**: After iterating through all strings, the function returns the longest string stored in `longest_string`.\n\nThis approach ensures that the first occurrence of the longest string is returned if there are multiple strings with the same maximum length.\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "py_code": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n", "py_summary": "The Python code defines a function `greatest_common_divisor` that calculates the greatest common divisor (GCD) of two integers `a` and `b`. The function uses the Euclidean algorithm to find the GCD.\n\nHere's a breakdown of how it works:\n1. **Initialization**: The function starts with the given integers `a` and `b`.\n2. **Loop until remainder is zero**: It enters a loop that continues as long as `b` is not zero.\n3. **Update values**: Inside the loop, the values of `a` and `b` are updated using the Euclidean algorithm:\n   - The new value of `a` becomes the current value of `b`.\n   - The new value of `b` becomes the remainder when `a` is divided by `b` (i.e., `a % b`).\n4. **Return result**: Once `b` becomes zero, the loop terminates and the function returns the value of `a`, which at this point is the GCD of the original values of `a` and `b`.\n\nThis approach ensures that the function efficiently computes the GCD using a well-known algorithm.\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n", "py_code": "def all_prefixes(str):\n    prefixes = []\n    for i in range(1, len(str) + 1):\n        prefixes.append(str[:i])\n    return prefixes\n```\n\n", "py_summary": "The Python function `all_prefixes` generates a list of all prefixes of the input string from shortest to longest. Here's a detailed breakdown:\n\n1. **Initialization**: An empty list called `prefixes` is initialized to store the resulting prefixes.\n2. **Loop through lengths**: A for loop runs from 1 to the length of the input string (`len(str) + 1`). This ensures that all possible prefix lengths are considered, starting from a single character up to the entire string.\n3. **Generate Prefixes**: Inside the loop, `str[:i]` is used to generate a substring (prefix) of the current length `i`. The slicing operation `str[:i]` extracts characters from the start of the string up to index `i`.\n4. **Append Prefix**: Each generated prefix is appended to the list `prefixes`.\n5. **Return Result**: After the loop completes, the function returns the list of prefixes.\n\nThis approach ensures that all possible prefixes are included in the output list, starting with the shortest (single character) and ending with the longest (the entire string).\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n", "py_code": "def string_sequence(n):\n    return \" \".join(map(str, range(n + 1)))\n```\n", "py_summary": "The Python function `string_sequence` takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to `n` inclusive.\n\nHere's how it works:\n1. **Range Generation**: The expression `range(n + 1)` generates a sequence of integers from 0 to `n`.\n2. **Mapping to Strings**: The function `map(str, range(n + 1))` converts each integer in the generated sequence to its string representation.\n3. **Joining with Spaces**: The `join` method is used to concatenate these string representations into a single string, separated by spaces.\n\nThe result is a string that looks like `\"0 1 2 ... n\"` for any given non-negative integer `n`.\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>  // For tolower function\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert all characters in the string to lowercase to ignore case sensitivity\n    for (char &ch : str) {\n        ch = tolower(ch);\n    }\n    \n    // Use a set to store unique characters\n    unordered_set<char> distinct_chars;\n    for (char ch : str) {\n        distinct_chars.insert(ch);\n    }\n\n    // Return the number of distinct characters\n    return distinct_chars.size();\n}\n", "py_code": "def count_distinct_characters(s):\n    # Convert all characters in the string to lowercase to ignore case sensitivity\n    s = s.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(s)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)\n```\n\n", "py_summary": "The Python code defines a function `count_distinct_characters` that takes a string as input and returns the number of distinct characters in the string, ignoring case sensitivity.\n\n1. **Convert to Lowercase**: The first line converts all characters in the string to lowercase using `s.lower()`. This ensures that character comparison is case-insensitive.\n2. **Store Unique Characters**: A set named `distinct_chars` is used to store unique characters from the string. Sets automatically handle duplicates, so only distinct characters are stored.\n3. **Return Length of Set**: The function returns the length of the set, which represents the number of distinct characters in the input string.\n\nThis approach ensures that all character comparisons are case-insensitive and efficiently counts the distinct characters using a set data structure.\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int i = 0;\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2);\n                i += 2;\n            } else {\n                beats.push_back(4);\n                i += 1;\n            }\n        } else if (music_string.substr(i, 2) == \".|\") {\n            beats.push_back(1);\n            i += 2;\n        }\n    }\n    return beats;\n}\n", "py_code": "def parse_music(music_string):\n    beats = []\n    i = 0\n    while i < len(music_string):\n        if music_string[i] == \"o\":\n            if i + 1 < len(music_string) and music_string[i+1] == \"|\":\n                beats.append(2)\n                i += 2\n            else:\n                beats.append(4)\n                i += 1\n        elif music_string[i:i+2] == \".|\":\n            beats.append(1)\n            i += 2\n    return beats\n```\n\n", "py_summary": "The Python function `parse_music` takes a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts.\n\nHere's an analysis of the code:\n\n1. **Initialization**:\n   - The function initializes an empty list called `beats` to store the number of beats for each note.\n   \n2. **Loop through the string**:\n   - A while loop is used to iterate through the characters in the input string `music_string`.\n   - The variable `i` keeps track of the current position in the string.\n\n3. **Check for whole notes (\"o\")**:\n   - If the character at index `i` is \"o\", it checks if the next character (at index `i+1`) is \"|\".\n     - If true, it appends 2 to the `beats` list and increments `i` by 2.\n     - Otherwise, it appends 4 to the `beats` list and increments `i` by 1.\n\n4. **Check for quarter notes (\".|\")**:\n   - The function checks if the substring from index `i` to `i+2` is \".|\" using slicing.\n   - If true, it appends 1 to the `beats` list and increments `i` by 2.\n\n5. **Return result**:\n   - After processing all characters in the string, the function returns the `beats` list containing the number of beats for each note.\n\nThis approach ensures that the function correctly parses the input string and maps each type of note to its corresponding number of beats as specified in the legend.\n\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t start = 0;\n\n    while (start <= str.length() - substring.length()) {\n        if (str.substr(start, substring.length()) == substring) {\n            count++;\n        }\n        start++;\n    }\n\n    return count;\n}\n", "py_code": "def how_many_times(str, substring):\n    count = 0\n    start = 0\n    \n    while start <= len(str) - len(substring):\n        if str[start:start+len(substring)] == substring:\n            count += 1\n        start += 1\n        \n    return count\n```\n\n", "py_summary": "The Python function `how_many_times` calculates how many times a given substring can be found within a string, including overlapping occurrences. Here's an analysis of the code:\n\n1. **Initialization**:\n   - `count`: A variable to keep track of the number of times the substring is found.\n   - `start`: An index that marks the starting position for searching the substring in the main string.\n\n2. **Loop through the String**:\n   - The loop runs while `start` is less than or equal to the length of the string minus the length of the substring (`len(str) - len(substring)`). This ensures that there are enough characters left in the string to check for the substring.\n   \n3. **Check Substring Occurrence**:\n   - For each position `start`, it checks if the substring starting at `str[start:start+len(substring)]` matches the given `substring`.\n   - If a match is found, it increments the count.\n\n4. **Move Start Position**:\n   - After checking for a match, the function moves the start index by 1 to check for overlapping occurrences of the substring.\n   \n5. **Return Result**:\n   - Finally, the function returns the total count of how many times the substring was found in the string.\n\nThis approach ensures that all possible starting positions are checked, including those where the substring overlaps with itself within the main string."}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n// Function to map number words to their integer values\nint word_to_num(const string& word) {\n    static const map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n    \n    return num_map.at(word);\n}\n\n// Function to map integers back to their string representation\nstring num_to_word(int num) {\n    static const map<int, string> num_map = {\n        {0, \"zero\"},\n        {1, \"one\"},\n        {2, \"two\"},\n        {3, \"three\"},\n        {4, \"four\"},\n        {5, \"five\"},\n        {6, \"six\"},\n        {7, \"seven\"},\n        {8, \"eight\"},\n        {9, \"nine\"}\n    };\n    \n    return num_map.at(num);\n}\n\nstring sort_numbers(string numbers) {\n    // Split the input string into individual number words\n    istringstream iss(numbers);\n    vector<string> words;\n    string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    \n    // Convert each word to its corresponding integer value and store in a vector\n    vector<int> nums;\n    for (const auto& w : words) {\n        nums.push_back(word_to_num(w));\n    }\n    \n    // Sort the integers\n    sort(nums.begin(), nums.end());\n    \n    // Convert each sorted integer back to its string representation\n    ostringstream oss;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        oss << num_to_word(nums[i]);\n    }\n    \n    return oss.str();\n}\n\n", "py_code": "def sort_numbers(numbers):\n    # Mapping from string representation of numbers to their integer values\n    num_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into individual number words and convert them to integers\n    num_list = [num_map[word] for word in numbers.split()]\n    \n    # Sort the list of integers\n    sorted_num_list = sorted(num_list)\n    \n    # Convert each integer back to its corresponding string representation\n    sorted_str_list = [str(num_map[num]) for num in sorted_num_list]\n    \n    # Join the sorted strings into a single space-delimited string\n    return ' '.join(sorted_str_list)\n```\n", "py_summary": "The Python code defines a function `sort_numbers` that takes a space-delimited string of number words (from \"zero\" to \"nine\") and returns a new string with these numbers sorted from smallest to largest.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Mapping Words to Integers**: A dictionary `num_map` is created to map each word representation of a number (\"zero\", \"one\", etc.) to its corresponding integer value (0, 1, etc.).\n\n2. **Splitting and Converting**: The input string `numbers` is split into individual words using the `split()` method. Each word is then converted to its corresponding integer value by looking up the dictionary `num_map`.\n\n3. **Sorting Integers**: The list of integers is sorted in ascending order using Python's built-in `sorted()` function.\n\n4. **Converting Back to Strings**: Each integer in the sorted list is mapped back to its string representation using the same `num_map` dictionary.\n\n5. **Joining Strings**: Finally, the list of strings is joined into a single space-delimited string using `' '.join(sorted_str_list)` and returned as the result.\n\nThis approach ensures that the input string is correctly parsed, sorted, and formatted according to the requirements."}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result;\n    \n    // Iterate through the sorted list to find the closest pair of elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result.first = numbers[i];\n            result.second = numbers[i + 1];\n        }\n    }\n    \n    // Return the closest pair in a vector\n    return {std::min(result.first, result.second), std::max(result.first, result.second)};\n}\n", "py_code": "from typing import List\n\ndef find_closest_elements(numbers: List[float]) -> tuple:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        \n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n            \n    return tuple(sorted(result))\n```\n\n", "py_summary": "The Python code defines a function `find_closest_elements` that takes a list of floating-point numbers and returns a tuple containing the two closest elements in ascending order. Here's a detailed breakdown of how it works:\n\n1. **Sorting the List**: The input list `numbers` is sorted in ascending order using `numbers.sort()`. This ensures that any two adjacent elements will be as close to each other as possible.\n\n2. **Initialization**:\n   - `min_diff` is initialized to positive infinity (`float('inf')`). This variable keeps track of the smallest difference found between any pair of consecutive elements.\n   - `result` is initialized to `(0, 0)`. This tuple will store the indices or values of the two closest elements.\n\n3. **Finding Closest Elements**:\n   - A loop iterates through each element in the sorted list up to the second-to-last element (`range(len(numbers) - 1)`).\n   - For each pair of consecutive elements, the difference `diff` is calculated.\n   - If this difference is smaller than the current minimum difference (`min_diff`), then `min_diff` and `result` are updated with the new closest pair.\n\n4. **Return Result**:\n   - The function returns a tuple containing the two closest elements in ascending order, which ensures that the smaller number comes first.\n   \nBy sorting the list initially, we ensure that finding the minimum difference between any two elements is straightforward by simply comparing adjacent pairs. This approach guarantees an efficient and correct solution to the problem.\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_num = *std::min_element(numbers.begin(), numbers.end());\n    float max_num = *std::max_element(numbers.begin(), numbers.end());\n\n    // Calculate the range of the numbers\n    float range_num = max_num - min_num;\n\n    // Rescale each number to be between 0 and 1\n    for (float& num : numbers) {\n        num = (num - min_num) / range_num;\n    }\n\n    return numbers;\n}\n", "py_code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_num = max_num - min_num\n    \n    scaled_numbers = [(num - min_num) / range_num for num in numbers]\n    \n    return scaled_numbers\n```\n\n", "py_summary": "The Python code defines a function `rescale_to_unit` that takes a list of floating-point numbers and rescales them such that the smallest number becomes 0 and the largest number becomes 1.\n\nHere's a breakdown of how the function works:\n\n1. **Find Min and Max Values**: The function first finds the minimum (`min_num`) and maximum (`max_num`) values in the input list `numbers`.\n\n2. **Calculate Range**: It calculates the range of the numbers, which is the difference between the maximum and minimum values (`range_num`).\n\n3. **Rescale Numbers**: For each number in the list, it applies a linear transformation to map the number to a value between 0 and 1:\n   \\[\n   \\text{scaled\\_value} = \\frac{\\text{num} - \\text{min\\_num}}{\\text{range\\_num}}\n   \\]\n   This formula ensures that the smallest number in the list is mapped to 0, and the largest number is mapped to 1.\n\n4. **Return Result**: The function returns a new list of scaled numbers.\n\nThis approach ensures that all values are linearly transformed within the unit interval [0, 1], maintaining their relative distances from each other.\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\nusing namespace std;\n\n// Define the type alias for clarity\ntypedef std::list<boost::any> list_any;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> filtered_values;\n    \n    for (auto value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            filtered_values.push_back(intValue);\n        }\n    }\n\n    return filtered_values;\n}\n\n", "py_code": "from typing import List\n\ndef filter_integers(values):\n    filtered_values = []\n    for value in values:\n        if isinstance(value, int):\n            filtered_values.append(value)\n    return filtered_values\n```\n\n", "py_summary": "The Python code defines a function `filter_integers` that takes a list of `boost::any` objects (represented as a generic iterable in Python for simplicity) and filters out only the integer values from it.\n\nHere's an analysis of how this works:\n\n1. **Initialization**: The function initializes an empty list called `filtered_values` to store the integers found in the input list.\n2. **Iteration**: It iterates through each element in the input iterable `values`.\n3. **Type Checking**: For each value, it checks if the type of the value is an integer using `isinstance(value, int)`.\n4. **Appending Integers**: If a value is determined to be an integer, it appends that value to the `filtered_values` list.\n5. **Return Result**: After iterating through all elements in the input iterable, the function returns the `filtered_values` list containing only integers.\n\nThis approach ensures that only integer values are retained and returned from the given mixed-type collection of values.\n\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n", "py_code": "def strlen(str):\n    return len(str)\n```\n\n", "py_summary": "The Python function `strlen` takes a string as input and returns its length using the built-in `len()` function. The `len()` function calculates the number of characters in the given string and returns this value.\n\nHere's a breakdown of how it works:\n1. **Input**: A string `str`.\n2. **Output**: The length of the string, which is an integer.\n3. **Functionality**: The `len()` function counts the total number of characters (including spaces and special characters) in the input string and returns this count.\n\nThis approach ensures that the function correctly handles strings of any length, including empty strings where it will return 0.\n\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // This line is technically not necessary as the loop will always find a divisor, but it's good practice to have a return statement outside the loop.\n    return -1; // In case no divisor is found, though this situation won't happen for n > 1\n}\n", "py_code": "def largest_divisor(n):\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n```\n", "py_summary": "The Python function `largest_divisor` takes an integer `n` as input and returns the largest divisor of `n` that is smaller than `n`. Here's a detailed analysis:\n\n1. **Function Definition**: The function `largest_divisor(n)` accepts one parameter, `n`, which is the number for which we need to find the largest divisor.\n\n2. **Loop Initialization**:\n   - A loop is initiated with `range(n - 1, 0, -1)`. This range starts from `n-1` and goes down to `1` (inclusive), decrementing by `-1` each step.\n   \n3. **Divisibility Check**:\n   - For each integer `i` in the loop, it checks if `n % i == 0`, which means checking whether `i` is a divisor of `n`.\n   \n4. **Return Statement**:\n   - As soon as a divisor is found (when `n % i == 0`), the function immediately returns this value `i`.\n\nThis approach ensures that the first divisor encountered in descending order from `n-1` to `1` will be the largest possible divisor of `n`, smaller than `n`. This method leverages the fact that if a number is divisible by another, and we start checking from the highest possible candidate downwards, the first valid divisor found will indeed be the largest one.\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor += 1;\n    }\n\n    return factors;\n}\n", "py_code": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    \n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    return factors\n```\n\n", "py_summary": "The Python function `factorize` takes an integer `n` and returns a list of its prime factors in ascending order. Here's a detailed breakdown:\n\n1. **Initialization**:\n   - `factors`: An empty list to store the prime factors.\n   - `divisor`: A variable initialized to 2, which is the smallest prime number.\n\n2. **Main Loop**:\n   - The outer `while` loop continues as long as `n > 1`, ensuring that we continue factoring until `n` is reduced to 1.\n   \n3. **Inner Loop**:\n   - The inner `while` loop checks if the current value of `divisor` is a factor of `n`. If it is, then `divisor` is added to the list of factors and `n` is divided by `divisor`.\n   - This process continues until `divisor` no longer divides `n`.\n\n4. **Incrementing Divisor**:\n   - After exiting the inner loop (i.e., when `divisor` is no longer a factor), the divisor is incremented to check for the next potential prime factor.\n\n5. **Return Value**:\n   - The function returns the list of factors, which contains each prime factor repeated according to its multiplicity in the factorization of `n`.\n\nThis approach ensures that all prime factors are found and listed correctly, with each factor appearing as many times as it divides `n`."}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> count;\n    vector<int> result;\n\n    for (int num : numbers) {\n        count[num]++;\n        if (count[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Remove elements that occur more than once\n    vector<int> filtered_result;\n    for (int num : result) {\n        if (count[num] <= 1) {\n            filtered_result.push_back(num);\n        }\n    }\n\n    return filtered_result;\n}\n", "py_code": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count = {}\n    result = []\n    \n    for num in numbers:\n        if num not in count:\n            count[num] = 1\n            result.append(num)\n        else:\n            count[num] += 1\n            if count[num] > 1 and num in result:\n                result.remove(num)\n                \n    return result\n```\n\n", "py_summary": "The Python code defines a function `remove_duplicates` that takes a list of integers as input and returns a new list with all elements that occur more than once removed, while preserving the order of the remaining elements.\n\nHere's a breakdown of how the function works:\n1. **Initialization**: \n   - A dictionary `count` is initialized to keep track of the frequency of each element.\n   - An empty list `result` is initialized to store the final result.\n\n2. **Iterate through the input list**:\n   - For each number in the input list, check if it exists in the `count` dictionary.\n   - If the number does not exist in the dictionary, add it to both the dictionary and the `result` list with a count of 1.\n   - If the number already exists in the dictionary, increment its count by 1.\n\n3. **Remove duplicates**:\n   - After updating the count for each element, if an element's count exceeds 1 and it is still present in the result list, remove that element from the `result` list to ensure only unique elements are kept.\n\n4. **Return the final result**:\n   - The function returns the `result` list which contains all unique elements in their original order from the input list.\n\nThis approach ensures that the order of elements is preserved and duplicates are removed efficiently by leveraging a dictionary for counting occurrences."}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For tolower and toupper functions\n\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";  // Initialize an empty string for the transformed characters\n    \n    for (char c : str) {  // Iterate through each character in the input string\n        if (islower(c)) {  // Check if the character is lowercase\n            result += toupper(c);  // Convert to uppercase and append to result\n        } else {\n            result += tolower(c);  // Convert to lowercase and append to result\n        }\n    }\n    \n    return result;  // Return the transformed string\n}\n\n", "py_code": "def flip_case(str):\n    result = \"\"\n    for char in str:\n        if char.islower():\n            result += char.upper()\n        else:\n            result += char.lower()\n    return result\n```\n", "py_summary": "The Python code defines a function `flip_case` that takes a string as input and returns a new string with all lowercase characters converted to uppercase and vice versa.\n\nHere's a breakdown of how it works:\n1. **Initialization**: An empty string `result` is initialized to store the transformed characters.\n2. **Iteration**: The function iterates through each character in the input string using a for loop.\n3. **Case Conversion**:\n   - For each character, the code checks if it is lowercase using the `islower()` method.\n   - If the character is lowercase, it converts it to uppercase using the `upper()` method and appends it to `result`.\n   - If the character is not lowercase (i.e., it's uppercase or a non-alphabetic character), it converts it to lowercase using the `lower()` method and appends it to `result`.\n4. **Return**: After iterating through all characters, the function returns the transformed string stored in `result`.\n\nThis approach ensures that each character in the input string is correctly flipped between upper and lower case as required.\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n```\n\n", "py_summary": "The Python code defines a function `concatenate` that takes a list of strings as input and returns a single concatenated string. The function uses the `join()` method to concatenate all the elements in the list into one continuous string.\n\nHere's a breakdown of how it works:\n1. **Input**: A vector (list) of strings called `strings`.\n2. **Processing**:\n   - The `join()` method is called on an empty string `''`, which acts as a separator between the elements.\n   - This method concatenates all the strings in the list without adding any additional characters between them.\n3. **Output**: A single concatenated string that combines all the input strings.\n\nThis approach ensures that the function efficiently concatenates all strings into one continuous string, returning an empty string if the input vector is empty.\n\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    for (const auto& s : strings) {\n        if (s.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered_strings.push_back(s);\n        }\n    }\n\n    return filtered_strings;\n}\n", "py_code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    filtered_strings = [s for s in strings if s.startswith(prefix)]\n    return filtered_strings\n```\n\n", "py_summary": "The Python code defines a function `filter_by_prefix` that takes two parameters: a list of strings (`strings`) and a prefix string (`prefix`). The function filters the input list to include only those strings that start with the given prefix.\n\nHere's an analysis of how it works:\n1. **List Comprehension**: A list comprehension is used to iterate over each string `s` in the input list `strings`.\n2. **startswith Method**: For each string, the method `s.startswith(prefix)` checks if the string starts with the specified prefix.\n3. **Filtered List**: If a string starts with the given prefix, it is included in the resulting filtered list (`filtered_strings`).\n4. **Return Statement**: The function returns the filtered list of strings.\n\nThis approach ensures that only strings starting with the specified prefix are returned, making it an efficient and concise way to filter the input list based on the prefix condition."}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef get_positive(l: List[float]) -> List[float]:\n    return [num for num in l if num > 0]\n```\n\n", "py_summary": "The Python code defines a function `get_positive` that takes a list of floating-point numbers as input and returns a new list containing only the positive numbers from the original list.\n\n- The function uses a list comprehension to iterate through each number in the input list `l`.\n- For each number, it checks if the number is greater than 0.\n- If the condition is true, the number is included in the resulting list.\n- Finally, the function returns the new list containing only positive numbers.\n\nThis approach ensures that all negative and zero values are filtered out, leaving only the positive numbers in the output."}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_prime` checks whether a given number `n` is prime or not and returns a boolean value (`True` if the number is prime, otherwise `False`). Here's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if `n` is less than or equal to 1. If so, it immediately returns `False`, since neither 0 nor 1 are considered prime numbers.\n\n2. **Loop for Divisibility Check**: The function then iterates from 2 up to the square root of `n` (inclusive). This loop checks if `n` is divisible by any number in this range:\n   - For each integer `i` in the range `[2, int(n**0.5) + 1]`, it checks whether `n % i == 0`.\n   - If `n` is divisible by any such `i`, then `n` is not a prime number and the function returns `False`.\n\n3. **Return True if No Divisors Found**: If the loop completes without finding any divisors, the function concludes that `n` is a prime number and returns `True`.\n\nThis approach ensures efficient checking of primality by reducing the number of iterations needed to verify divisibility up to the square root of `n`, which significantly optimizes performance for large numbers.\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n    \n    double left = -100.0;\n    double right = 100.0;\n\n    // Expand interval until opposite signs are found\n    while (poly(xs, left) * poly(xs, right) > 0) {\n        if (left < 0 && right > 0) {\n            left *= 2;\n            right *= 2;\n        } else if (right > 0) {\n            left -= 100.0;\n            right += 100.0;\n        } else {\n            left /= 2;\n            right /= 2;\n        }\n    }\n\n    // Bisection method to find the root\n    while ((right - left) >= pow(10, -6)) {\n        double mid = (left + right) / 2;\n\n        if (poly(xs, mid) == 0.0)\n            return mid; // Exact match\n\n        if (poly(xs, left) * poly(xs, mid) < 0) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n\n    return (left + right) / 2;\n}\n\n", "py_code": "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    \"\"\"\n    sum = 0.0\n    for i in range(len(xs)):\n        sum += xs[i] * math.pow(x, i)\n    return sum\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds the root of a polynomial with coefficients xs such that poly(x) = 0.\n    Returns only one zero point even if there are many.\n    Assumes xs has an even number of coefficients and the largest non-zero coefficient is included.\n    \"\"\"\n    # Implementing a simple bisection method to find a root\n    left, right = -100.0, 100.0\n    \n    while poly(xs, left) * poly(xs, right) > 0:\n        if poly(xs, left) == 0: return left\n        if poly(xs, right) == 0: return right\n        left -= 100.0\n        right += 100.0\n    \n    while (right - left) > 1e-6:\n        mid = (left + right) / 2.0\n        if poly(xs, mid) == 0:\n            return mid\n        elif poly(xs, left) * poly(xs, mid) < 0:\n            right = mid\n        else:\n            left = mid\n    \n    return (left + right) / 2.0\n```\n\n", "py_summary": "The Python code defines two functions: `poly` and `find_zero`.\n\n1. **Function `poly`:**\n   - This function evaluates a polynomial at a given point `x`.\n   - It takes a list of coefficients `xs` and a value `x`, and returns the value of the polynomial evaluated at `x`.\n   - The polynomial is defined as \\( P(x) = \\sum_{i=0}^{n} xs[i] \\cdot x^i \\).\n   - For example, if `xs = [1, 2]`, then the polynomial is \\( 1 + 2x \\).\n\n2. **Function `find_zero`:**\n   - This function finds a root of the polynomial defined by coefficients `xs` such that \\( P(x) = 0 \\).\n   - It uses a simple bisection method to find an approximate root within a specified tolerance.\n   - The initial interval for the bisection is set from `-100.0` to `100.0`.\n   - If the polynomial evaluated at both endpoints of this interval has the same sign, it expands the interval until it finds opposite signs (indicating a root exists within the interval).\n   - Once an interval with opposite signs is found, it repeatedly narrows down the interval by bisecting and checking the midpoint until the difference between `left` and `right` is less than \\(10^{-6}\\).\n\nThe bisection method ensures that if there is a root in the interval, it will converge to one of those roots. The function returns an approximation of this root.\n\n### Summary:\n- **poly(xs, x):** Evaluates the polynomial at point `x`.\n- **find_zero(xs):** Uses the bisection method to find a root of the polynomial within a specified tolerance and interval.\n\nThis approach ensures that we can accurately approximate one of the roots of the polynomial given its coefficients."}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3 (0-based index)\n    vector<int> third_indices_values;\n    for (int i = 2; i < l.size(); i += 3) {\n        third_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Create a new list to store the result\n    vector<int> l_prime;\n    \n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            // Replace with sorted value at index divisible by 3\n            l_prime.push_back(third_indices_values[sorted_index]);\n            sorted_index++;\n        } else {\n            // Keep the original value\n            l_prime.push_back(l[i]);\n        }\n    }\n\n    return l_prime;\n}\n", "py_code": "from typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    # Extract elements at indices divisible by 3\n    third_indices_values = [l[i] for i in range(len(l)) if (i + 1) % 3 == 0]\n    \n    # Sort the extracted values\n    sorted_third_indices_values = sorted(third_indices_values)\n    \n    # Create a new list to store the result\n    l_prime = []\n    \n    third_index = 0\n    for i in range(len(l)):\n        if (i + 1) % 3 == 0:\n            # Replace with sorted value at index divisible by 3\n            l_prime.append(sorted_third_indices_values[third_index])\n            third_index += 1\n        else:\n            # Keep the original value\n            l_prime.append(l[i])\n    \n    return l_prime\n```\n\n", "py_summary": "The Python code defines a function `sort_third` that takes a list `l` and returns a new list `l'`. The returned list `l'` is identical to `l` at indices that are not divisible by three, while the values at indices divisible by three are sorted in ascending order.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Extract Elements**: \n   - It first extracts elements from the input list `l` where the index (considering 1-based indexing) is divisible by 3. This is done using a list comprehension that iterates over the indices and checks if `(i + 1) % 3 == 0`.\n\n2. **Sort Extracted Values**:\n   - The extracted values are then sorted in ascending order.\n\n3. **Create Result List**:\n   - A new list `l_prime` is created to store the final result.\n   - It iterates through each index of the input list `l`. If the current index (1-based) is divisible by 3, it replaces the value at that position with the corresponding sorted value. Otherwise, it keeps the original value from `l`.\n\n4. **Return Result**:\n   - Finally, the function returns the modified list `l_prime`.\n\nThis approach ensures that only elements at indices divisible by three are rearranged while all other elements remain unchanged.\n\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to remove duplicates\n    set<int> s(l.begin(), l.end());\n    \n    // Convert the set back to a vector\n    vector<int> result(s.begin(), s.end());\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    # Convert list to a set to remove duplicates and then convert it back to a sorted list\n    return sorted(set(l))\n```\n\n", "py_summary": "The Python code defines a function `unique` that takes a list of integers as input and returns a new list containing only the unique elements from the original list, sorted in ascending order.\n\nHere's an analysis of how the function works:\n1. **Convert to Set**: The input list is converted into a set using `set(l)`. This removes any duplicate values because sets cannot contain duplicates.\n2. **Sort**: The set is then converted back into a list and sorted using `sorted(set(l))`. Sorting ensures that the unique elements are returned in ascending order.\n\nOverall, this approach leverages Python's built-in data structures to efficiently remove duplicates and sort the remaining elements.\n\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) return 0; // Handle empty vector case\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n", "py_code": "def max_element(l):\n    return max(l)\n```\n\n", "py_summary": "The Python code defines a function `max_element` that takes a list `l` as input and returns the maximum element in the list using the built-in `max()` function.\n\nHere's a breakdown of how it works:\n1. The function receives a list `l`.\n2. It uses the `max()` function to find and return the largest element in the list.\n\nThis approach leverages Python\u2019s standard library, which provides an efficient way to determine the maximum value in a collection like a list or vector."}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string num_str = std::to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n```\n\n", "py_summary": "The Python function `fizz_buzz` calculates and returns the number of times the digit '7' appears in integers less than `n` that are divisible by either 11 or 13. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `count` is initialized to zero to keep track of the total count of the digit '7'.\n\n2. **Loop through numbers**: A loop runs from 1 to `n-1`. For each integer `i` in this range:\n   - **Divisibility Check**: It checks if `i` is divisible by either 11 or 13 using the condition `if i % 11 == 0 or i % 13 == 0`.\n   - **Count '7' occurrences**: If the number `i` satisfies the divisibility condition, it converts `i` to a string and counts how many times the digit '7' appears in this string using `str(i).count('7')`. The count of '7's is then added to the cumulative count stored in `count`.\n\n3. **Return Result**: After iterating through all numbers less than `n`, the function returns the total count of occurrences of the digit '7'.\n\nThis approach ensures that only numbers divisible by 11 or 13 are considered, and within those numbers, it counts how many times the digit '7' appears.\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_indices_values;\n    \n    // Extract even indices values from the input vector.\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n    \n    // Sort the extracted even index values.\n    sort(even_indices_values.begin(), even_indices_values.end());\n    \n    // Create a result vector identical to input vector.\n    vector<float> result = l;\n    \n    size_t even_index = 0;\n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_indices_values[even_index++];\n    }\n    \n    return result;\n}\n\n", "py_code": "from typing import List\n\ndef sort_even(l: List[float]) -> List[float]:\n    even_indices_values = [l[i] for i in range(1, len(l), 2)]\n    sorted_even_indices_values = sorted(even_indices_values)\n    \n    result = l[:]\n    for i, value in zip(range(1, len(l), 2), sorted_even_indices_values):\n        result[i] = value\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `sort_even` that takes a list of floats and returns a new list where the values at odd indices remain unchanged, while the values at even indices are sorted in ascending order.\n\nHere's a breakdown of how the function works:\n\n1. **Extract Even Indices Values**: The first step is to extract all the elements from the input list `l` that are located at even indices (i.e., indices 1, 3, 5, etc.). This is done using a list comprehension:\n   ```python\n   even_indices_values = [l[i] for i in range(1, len(l), 2)]\n   ```\n\n2. **Sort the Extracted Values**: The extracted values are then sorted in ascending order:\n   ```python\n   sorted_even_indices_values = sorted(even_indices_values)\n   ```\n\n3. **Create Result List**: A copy of the original list `l` is made to ensure that the input list remains unchanged:\n   ```python\n   result = l[:]\n   ```\n\n4. **Replace Even Indices with Sorted Values**: The function then iterates over the even indices and replaces the values in the result list with the sorted values from the previous step:\n   ```python\n   for i, value in zip(range(1, len(l), 2), sorted_even_indices_values):\n       result[i] = value\n   ```\n\n5. **Return Result**: Finally, the modified list `result` is returned.\n\nThis approach ensures that the odd indices remain unchanged while the even indices are sorted as required by the problem statement.\n\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[1] + x[0] + x[2];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    string decoded_string = \"\";\n    for (int i = 0; i * 3 < s.length(); i++) {\n        string group = s.substr(i * 3, 3);\n        if (group.length() == 3) {\n            // Reverse the cyclic shift applied during encoding.\n            group = group[1] + group[0] + group[2];\n        } else {\n            // For remaining characters, reverse them as they are not part of a full group of three.\n            for (int j = 0; j < group.length(); j++) {\n                decoded_string += group[group.length() - 1 - j];\n            }\n        }\n        decoded_string += group;\n    }\n    return decoded_string;\n}\n", "py_code": "def decode_cyclic(s):\n    decoded_string = \"\"\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            # Decoding by reversing the cyclic shift applied during encoding.\n            group = group[1] + group[0:1] + group[2:]\n        else:\n            group = group[::-1]  # Reverse remaining characters\n        decoded_string += group\n    return decoded_string\n```\n\n", "py_summary": "The Python function `decode_cyclic` takes a string `s` as input and returns the original string before it was encoded using the cyclic shift method described in the problem statement.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The variable `decoded_string` is initialized to an empty string, which will store the final decoded result.\n2. **Loop through groups of three characters**:\n   - A loop runs from index 0 to the length of the string in steps of 3 (`for i in range(0, len(s), 3)`).\n   - For each iteration, a substring `group` of length 3 is extracted starting at position `i`.\n3. **Decoding logic**:\n   - If the group has exactly three characters (checked using `if len(group) == 3`):\n     - The cyclic shift applied during encoding is reversed by shifting the first character to the second position and keeping the rest of the characters in their original positions (`group = group[1] + group[0:1] + group[2:]`).\n   - If the group has fewer than three characters (remaining part of the string), it simply reverses the remaining characters (`else: group = group[::-1]`).\n4. **Appending to decoded result**:\n   - The processed `group` is appended to `decoded_string`.\n5. **Return the final decoded string**: After processing all groups, the function returns `decoded_string`.\n\nThis approach ensures that each group of three characters is correctly reversed according to the cyclic shift applied during encoding, and any remaining characters are also handled appropriately.\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int a = 0, b = 1; // First two Fibonacci numbers\n    int count = 0;    // Counter for prime Fibonacci numbers found\n\n    while (true) {\n        int fib_num = a + b;\n        if (is_prime(fib_num)) {\n            count++;\n            if (count == n) return fib_num;\n        }\n        a = b;\n        b = fib_num;\n    }\n\n    return -1; // This line is technically unreachable but included for completeness\n}\n\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n):\n    a, b = 0, 1\n    count = 0\n    while True:\n        fib_num = a + b\n        a, b = b, fib_num\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n```\n", "py_summary": "The Python code defines a function `prime_fib` that returns the n-th Fibonacci number which is also prime. The solution involves two main components: a helper function `is_prime` to check if a given number is prime and the main function `prime_fib`.\n\n1. **Helper Function (`is_prime`)**:\n   - This function takes an integer `num` as input.\n   - It returns `False` if `num` is less than or equal to 1, as these numbers are not considered prime.\n   - For all other values of `num`, it checks divisibility from 2 up to the square root of `num`. If any divisor is found, the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n2. **Main Function (`prime_fib`)**:\n   - The function initializes two variables `a` and `b` as 0 and 1 respectively, representing the first two Fibonacci numbers.\n   - It also initializes a counter variable `count` to keep track of how many prime Fibonacci numbers have been found so far.\n   - A while loop runs indefinitely until the n-th prime Fibonacci number is found:\n     - The next Fibonacci number (`fib_num`) is calculated as the sum of `a` and `b`.\n     - `a` and `b` are updated to continue generating the next Fibonacci numbers.\n     - If `fib_num` is a prime number (checked using the `is_prime` function), the counter `count` is incremented.\n     - Once `count` equals `n`, the loop breaks, and `fib_num` is returned as the n-th prime Fibonacci number.\n\nThis approach ensures that we efficiently generate Fibonacci numbers and check their primality until we find the desired one."}
{"task_id": "CPP/40", "generation": "#include <vector>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    n = len(l)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n```\n\n", "py_summary": "The Python function `triples_sum_to_zero` takes a list of integers as input and returns `True` if there are three distinct elements in the list that sum to zero, and `False` otherwise.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The function starts by determining the length of the input list `l`.\n\n2. **Nested Loops for Triplets**:\n   - The outermost loop iterates over each element in the list using index `i`.\n   - The middle loop iterates from the next element after `i` to the end of the list using index `j`.\n   - The innermost loop iterates from the next element after `j` to the end of the list using index `k`.\n\n3. **Sum Check**:\n   - For each combination of indices `(i, j, k)`, the function checks if the sum of the elements at these indices (`l[i] + l[j] + l[k]`) equals zero.\n   - If such a triplet is found where the sum is zero, the function immediately returns `True`.\n\n4. **Return False**:\n   - If no such triplet is found after checking all possible combinations, the function returns `False`.\n\nThis approach ensures that every possible combination of three distinct elements in the list is checked for a sum of zero.\n\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving towards each other and there is no avoidance,\n    // every left-to-right car will eventually collide with a right-to-left car.\n    return n;\n}\n", "py_code": "def car_race_collision(n):\n    # Since all cars are moving towards each other and there is no avoidance,\n    # every left-to-right car will eventually collide with a right-to-left car.\n    return n\n```\n\n", "py_summary": "The Python function `car_race_collision` calculates the number of collisions that occur when two sets of \\( n \\) cars each move towards each other on an infinitely long straight road.\n\n1. **Function Definition**: The function takes a single integer parameter `n`, which represents the number of cars in each set.\n2. **Collision Logic**: Since all cars are moving at the same speed and there is no avoidance mechanism, every car moving from left to right will eventually collide with exactly one car moving from right to left. Therefore, the total number of collisions will be equal to \\( n \\).\n3. **Return Statement**: The function simply returns `n`, which represents the total number of collisions.\n\nThis logic ensures that each car in one direction collides with exactly one car coming from the opposite direction, resulting in a total of \\( n \\) collisions.\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n", "py_code": "def incr_list(l):\n    return [x + 1 for x in l]\n```\n\n", "py_summary": "The Python code defines a function `incr_list` that takes a list of integers as input and returns a new list where each element is incremented by 1.\n\nHere's an analysis of how this function works:\n- The function uses a list comprehension to iterate over each element in the input list `l`.\n- For each element `x` in the list, it adds 1 to `x` and includes the result in the new list.\n- The resulting list is then returned.\n\nThis approach ensures that every element in the original list is incremented by 1, producing a new list with the updated values."}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen_numbers;\n    for (int number : l) {\n        if (seen_numbers.find(-number) != seen_numbers.end()) {\n            return true;\n        }\n        seen_numbers.insert(number);\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    seen_numbers = set()\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    return False\n```\n\n", "py_summary": "The Python function `pairs_sum_to_zero` checks whether there are two distinct elements in a given list that sum to zero. Here's an analysis of how it works:\n\n1. **Initialization**: A set called `seen_numbers` is initialized to keep track of numbers encountered so far.\n2. **Iteration through the List**: The function iterates through each element (`number`) in the input list `l`.\n3. **Check for Complement**: For each number, it checks if `-number` (the complement that would sum to zero) has already been seen by checking if `-number` is in the set `seen_numbers`.\n4. **Add Number to Set**: If the complement is not found, the current number is added to the set.\n5. **Return Result**: If a pair of numbers that sum to zero is found during iteration, the function returns `True`. If no such pair is found after iterating through all elements, it returns `False`.\n\nThis approach ensures efficient checking with an average time complexity of O(n) due to the use of a set for quick lookups."}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = to_string(digit) + result;\n        x /= base;\n    }\n\n    return result;\n}\n\n", "py_code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    \n    result = \"\"\n    while x > 0:\n        digit = x % base\n        result = str(digit) + result\n        x //= base\n    \n    return result\n```\n\n", "py_summary": "The Python function `change_base` converts a given integer `x` to its string representation in a specified base (which is less than 10). Here's an analysis of how it works:\n\n1. **Base Case Handling**: The function first checks if `x` is zero and returns \"0\" immediately since the base conversion for zero is always \"0\".\n\n2. **Initialization**: It initializes an empty string `result` to store the converted number.\n\n3. **Conversion Loop**:\n   - The loop continues as long as `x` is greater than 0.\n   - In each iteration, it calculates the remainder of `x` when divided by `base`, which gives the current digit in the new base representation.\n   - This digit is then prepended to the `result` string (by concatenating it with the existing result).\n   - The value of `x` is updated to the quotient of `x` divided by `base`.\n\n4. **Return Result**: Once the loop completes, the function returns the `result` string which contains the base-converted representation of `x`.\n\nThis approach ensures that each digit of the number in the new base is correctly calculated and placed in the correct position within the resulting string.\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n", "py_code": "def triangle_area(a: float, h: float) -> float:\n    return 0.5 * a * h\n```\n", "py_summary": "The Python function `triangle_area` calculates the area of a triangle given the base length (`a`) and height (`h`). The formula for the area of a triangle is:\n\n\\[ \\text{Area} = 0.5 \\times \\text{base} \\times \\text{height} \\]\n\nIn this code, the function takes two parameters: `a` (the base) and `h` (the height). It then computes the area by multiplying these values together and dividing by 2. The result is returned as a floating-point number.\n\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\n#include <iostream>\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else {\n        int a = 0, b = 0, c = 2, d = 0;\n        for (int i = 3; i <= n; ++i) {\n            int temp_d = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = temp_d;\n        }\n        return d;\n    }\n}\n\n", "py_code": "def fib4(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(3, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d\n```\n\n", "py_summary": "The Python function `fib4(n)` calculates the n-th element of the Fib4 sequence without using recursion. Here's a detailed analysis:\n\n1. **Base Cases**:\n   - If `n` is 0 or 1, the function returns 0.\n   - If `n` is 2, the function returns 2.\n\n2. **Initialization for Iterative Calculation**:\n   - For values of `n` greater than 2, the function initializes four variables: `a`, `b`, `c`, and `d`. These represent the first four elements of the sequence (0, 0, 2, 0) respectively.\n\n3. **Iterative Computation**:\n   - The function uses a loop to iteratively compute the values from the 4th element up to the n-th element.\n   - In each iteration, it updates the variables `a`, `b`, `c`, and `d` such that they represent the sequence elements shifted by one position. Specifically, `d` is updated to be the sum of the previous four elements (`a + b + c + d`).\n\n4. **Return Value**:\n   - After completing the loop, the function returns the value of `d`, which holds the n-th element of the Fib4 sequence.\n\nThis approach ensures that the computation is efficient and avoids the overhead associated with recursive calls. The time complexity is O(n), and the space complexity is O(1) since only a fixed number of variables are used regardless of the input size.\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n", "py_code": "from typing import List\n\ndef median(l: List[float]) -> float:\n    n = len(l)\n    l.sort()\n    \n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]\n```\n\n", "py_summary": "The Python code defines a function `median` that calculates and returns the median of elements in a given list `l`. Here's an analysis of how it works:\n\n1. **Sort the List**: The input list `l` is first sorted using `l.sort()`.\n2. **Determine Length**: The length of the list, `n`, is determined.\n3. **Check Even or Odd Length**:\n   - If the length `n` is even (i.e., `n % 2 == 0`), the median is calculated as the average of the two middle elements: `(l[n // 2 - 1] + l[n // 2]) / 2`.\n   - If the length `n` is odd, the median is simply the middle element: `l[n // 2]`.\n\nThis approach ensures that the function correctly handles both even and odd lengths of lists to find the median.\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Check if the string is equal to its reverse\n    return text == string(text.rbegin(), text.rend());\n}\n\n", "py_code": "def is_palindrome(text: str) -> bool:\n    return text == text[::-1]\n```\n\n", "py_summary": "The Python function `is_palindrome` checks if a given string is a palindrome. Here's an analysis of how it works:\n\n1. **Function Definition**: The function takes one parameter, `text`, which is the string to be checked.\n2. **Palindrome Check**: It returns whether the input string `text` is equal to its reverse (`text[::-1]`). \n   - `text[::-1]` creates a reversed version of the string by slicing it with a step of `-1`.\n3. **Return Value**: The function returns `True` if the string is a palindrome and `False` otherwise.\n\nThis approach leverages Python's slicing capabilities to efficiently check for palindromes without needing additional data structures or loops, making it concise and readable."}
{"task_id": "CPP/49", "generation": "#include <cmath>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Handle edge case where n is 0\n    if (n == 0) return 1 % p;\n    \n    long long result = 1;\n    long long base = 2;\n    \n    while (n > 0) {\n        if (n & 1) { // If the current power of 2 is odd, multiply by base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base for the next iteration\n        n >>= 1; // Right shift to get the next bit of exponent\n    }\n    \n    return static_cast<int>(result);\n}\n", "py_code": "def modp(n: int, p: int) -> int:\n    result = pow(2, n, p)\n    return result\n```\n\n", "py_summary": "The Python function `modp` calculates \\(2^n \\mod p\\) and returns the result. Here's a detailed breakdown of how it works:\n\n1. **Function Definition**: The function `modp` takes two integer arguments: `n` (the exponent) and `p` (the modulus).\n\n2. **Using Python's Built-in Function**:\n   - The built-in function `pow(base, exp, mod)` is used to compute \\(2^n \\mod p\\). This function efficiently calculates the power of a number modulo another number.\n   - In this case, `base` is 2, `exp` is `n`, and `mod` is `p`.\n\n3. **Return Statement**:\n   - The result of `pow(2, n, p)` is stored in the variable `result`.\n   - This value is then returned by the function.\n\nThis approach leverages Python's efficient modular exponentiation capabilities to ensure that large values of \\(n\\) can be handled without causing overflow issues or requiring excessive computation time."}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        if ('a' <= s[i] && s[i] <= 'z') { // Ensure character is within lowercase English alphabet\n            int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n            out += (char)w;\n        } else {\n            out += s[i]; // Append non-alphabetic characters as-is\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        if ('a' <= s[i] && s[i] <= 'z') { // Ensure character is within lowercase English alphabet\n            int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n            out += (char)w;\n        } else {\n            out += s[i]; // Append non-alphabetic characters as-is\n        }\n    }\n    return out;\n}\n", "py_code": "def encode_shift(s):\n    out = \"\"\n    for char in s:\n        shifted_char = chr((ord(char) + 5 - ord('a')) % 26 + ord('a'))\n        out += shifted_char\n    return out\n\ndef decode_shift(s):\n    out = \"\"\n    for char in s:\n        original_char = chr((ord(char) - 5 - ord('a') + 26) % 26 + ord('a'))\n        out += original_char\n    return out\n```\n\n", "py_summary": "### Analysis of Python Code:\n\n#### `encode_shift` Function:\nThe `encode_shift` function takes a string `s` as input and returns an encoded version of that string by shifting each character in the alphabet by 5 positions.\n\n1. **Initialization**:\n   - An empty string `out` is initialized to store the encoded result.\n   \n2. **Character Iteration**:\n   - The function iterates through each character `char` in the input string `s`.\n   \n3. **Shifting Logic**:\n   - For each character, it calculates its shifted position using the formula: \n     \\[\n     \\text{shifted\\_char} = (ord(\\text{char}) + 5 - ord('a')) \\% 26 + ord('a')\n     \\]\n   - This formula shifts the character by 5 positions in the alphabet and wraps around if necessary.\n   \n4. **Appending to Result**:\n   - The shifted character is converted back to a string using `chr` and appended to `out`.\n\n#### `decode_shift` Function:\nThe `decode_shift` function takes an encoded string `s` as input and returns the original string by reversing the shift operation.\n\n1. **Initialization**:\n   - An empty string `out` is initialized to store the decoded result.\n   \n2. **Character Iteration**:\n   - The function iterates through each character `char` in the input string `s`.\n   \n3. **Reversing Shift Logic**:\n   - For each character, it calculates its original position using the formula:\n     \\[\n     \\text{original\\_char} = (ord(\\text{char}) - 5 - ord('a') + 26) \\% 26 + ord('a')\n     \\]\n   - This formula reverses the shift by subtracting 5 positions and ensures wrapping around if necessary.\n   \n4. **Appending to Result**:\n   - The original character is converted back to a string using `chr` and appended to `out`.\n\n### Summary\n- Both functions handle characters within the lowercase English alphabet ('a' to 'z').\n- The encoding function shifts each character by 5 positions forward in the alphabet.\n- The decoding function reverses this shift by moving each character backward by 5 positions, ensuring correct wrapping around the end of the alphabet.\n\nThis approach ensures that both encoding and decoding operations are consistent and correctly handle all characters within the specified range."}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!isVowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])\n```\n\n", "py_summary": "The Python code defines a function `remove_vowels` that takes a string as input and returns a new string with all vowels removed. Here's a detailed breakdown of how it works:\n\n1. **Vowel Definition**: The variable `vowels` is defined to contain the set of vowel characters, both lowercase (`\"aeiou\"`) and uppercase (`\"AEIOU\"`).\n\n2. **List Comprehension**: A list comprehension is used to iterate over each character in the input string `text`. For each character, it checks if the character is not in the `vowels` set.\n\n3. **Join Operation**: The filtered characters (those that are not vowels) are joined together into a new string using `''.join()`.\n\n4. **Return Statement**: The resulting string without any vowels is returned as the output of the function.\n\nThis approach ensures that all vowels in the input text are removed, and the remaining characters are concatenated to form the final result string.\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int number : l) {\n        if (number >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def below_threshold(l: list, t: int) -> bool:\n    for number in l:\n        if number >= t:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `below_threshold` checks whether all numbers in a given list `l` are below a specified threshold `t`. Here's an analysis of how it works:\n\n1. **Function Definition**: The function takes two parameters: a list of integers `l` and an integer threshold `t`.\n2. **Iteration Through List**: A for loop iterates through each element in the list `l`.\n3. **Threshold Check**: For each number in the list, the function checks if it is greater than or equal to the threshold `t`. If any number meets this condition (i.e., `number >= t`), the function immediately returns `False`, indicating that not all numbers are below the threshold.\n4. **Return True**: If the loop completes without finding any number that is greater than or equal to the threshold, the function returns `True`, indicating that all numbers in the list are indeed below the threshold.\n\nThis approach ensures that the function efficiently determines whether all elements in the list meet the specified condition by breaking out of the loop as soon as a violation is found."}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x: int, y: int) -> int:\n    return x + y\n```\n\n", "py_summary": "The Python code defines a function `add` that takes two integer parameters, `x` and `y`, and returns their sum. The function simply uses the addition operator (`+`) to add the two numbers together and then returns the result.\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <set>\n#include <algorithm>\n\nbool same_chars(std::string s0, std::string s1) {\n    // Convert strings to sets of characters\n    std::set<char> set_s0(s0.begin(), s0.end());\n    std::set<char> set_s1(s1.begin(), s1.end());\n\n    // Check if both sets are equal\n    return set_s0 == set_s1;\n}\n", "py_code": "def same_chars(s0: str, s1: str) -> bool:\n    # Convert strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if both sets are equal after removing any character that is not in the intersection\n    return set_s0 == set_s1\n```\n\n", "py_summary": "The Python function `same_chars` checks whether two strings have the same set of characters. Here's a detailed analysis:\n\n1. **Convert Strings to Sets**: \n   - The function converts both input strings (`s0` and `s1`) into sets (`set_s0` and `set_s1`). This conversion removes any duplicate characters within each string, leaving only unique characters.\n   \n2. **Check Equality**:\n   - The function then checks if the two sets are equal using the equality operator (`==`). If both sets contain exactly the same unique characters (regardless of their frequency or order in the original strings), the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the two input strings have the same kind of characters without considering the number of occurrences of each character.\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n == 0) return 0;\n    else if (n == 1) return 1;\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = b;\n        b = a + b;\n        a = temp;\n    }\n    return b;\n}\n", "py_code": "def fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\n", "py_summary": "The Python function `fib(n)` calculates the nth Fibonacci number using an iterative approach. Here's a detailed analysis of how it works:\n\n1. **Base Cases**:\n   - If `n` is 0, the function returns 0.\n   - If `n` is 1, the function returns 1.\n\n2. **Iterative Calculation**:\n   - For values of `n` greater than 1, two variables `a` and `b` are initialized to represent the first two Fibonacci numbers (0 and 1).\n   - The function then iterates from 2 to `n`, updating `a` and `b` in each iteration. In each step:\n     - `a` is updated to the current value of `b`.\n     - `b` is updated to the sum of the previous values of `a` and `b`.\n\n3. **Return Result**:\n   - After completing the loop, the function returns the value of `b`, which holds the nth Fibonacci number.\n\nThis approach ensures that the function efficiently computes the nth Fibonacci number in O(n) time complexity with constant space usage (O(1)).\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance += 1;\n        } else if (c == '>') {\n            balance -= 1;\n        }\n        // If at any point the balance is negative, it means a closing bracket appears before an opening bracket.\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, the balance should be zero for all brackets to be correctly matched.\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for char in brackets:\n        if char == '<':\n            balance += 1\n        elif char == '>':\n            balance -= 1\n        # If at any point the balance is negative, it means a closing bracket appears before an opening bracket.\n        if balance < 0:\n            return False\n    # At the end, the balance should be zero for all brackets to be correctly matched.\n    return balance == 0\n```\n\n", "py_summary": "The Python function `correct_bracketing` checks if a string of '<' and '>' brackets is correctly balanced. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `balance` is initialized to 0. This variable keeps track of the balance between opening ('<') and closing ('>') brackets.\n\n2. **Iteration through Brackets**:\n   - For each character in the input string `brackets`, if the character is an opening bracket '<', the balance is incremented by 1.\n   - If the character is a closing bracket '>', the balance is decremented by 1.\n   \n3. **Checking Balance During Iteration**: \n   - After updating the balance for each character, the function checks if `balance` becomes negative. This indicates that there are more closing brackets than opening brackets at some point in the string, which means the string cannot be correctly balanced.\n\n4. **Final Check**:\n   - After iterating through all characters, the function returns True only if the final value of `balance` is 0, indicating that every opening bracket has a corresponding closing bracket and vice versa.\n\nThis approach ensures that the string is correctly balanced by maintaining a running count of unmatched brackets and ensuring no closing brackets appear before their matching opening brackets."}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\n\nbool monotonic(std::vector<float> l) {\n    if (l.empty()) {\n        return true;\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n", "py_code": "from typing import List\n\ndef monotonic(l: List[float]) -> bool:\n    if not l:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(l)):\n        if l[i] > l[i - 1]:\n            decreasing = False\n        elif l[i] < l[i - 1]:\n            increasing = False\n    \n    return increasing or decreasing\n```\n\n", "py_summary": "The Python code defines a function `monotonic` that checks if the elements in a given list are monotonically increasing or decreasing. Here's an analysis of how it works:\n\n1. **Initial Check for Empty List**: The function first checks if the input list is empty. If the list is empty, it returns `True`. An empty list can be considered both monotonically increasing and decreasing.\n\n2. **Initialization of Flags**:\n   - Two boolean flags are initialized: `increasing` and `decreasing`, both set to `True`.\n\n3. **Iterate Through List**: The function iterates through the list starting from the second element (index 1) to compare each element with its predecessor.\n   - If an element is greater than its predecessor, it sets `decreasing` to `False`.\n   - If an element is less than its predecessor, it sets `increasing` to `False`.\n\n4. **Return Result**: After the loop completes, the function returns `True` if either `increasing` or `decreasing` remains `True`. This means that the list is either monotonically increasing or decreasing.\n\nBy following these steps, the function correctly determines whether a given list of numbers is monotonic (either strictly increasing or strictly decreasing).\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert vectors to sets to find unique elements and then compute intersection\n    set<int> set_l1(l1.begin(), l1.end());\n    set<int> set_l2(l2.begin(), l2.end());\n\n    // Find the common elements between both sets\n    vector<int> common_elements;\n    set_intersection(set_l1.begin(), set_l1.end(), set_l2.begin(), set_l2.end(), back_inserter(common_elements));\n\n    return common_elements;\n}\n", "py_code": "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    # Convert lists to sets to find unique elements and then compute intersection\n    set_l1 = set(l1)\n    set_l2 = set(l2)\n    \n    # Find the common elements between both sets\n    common_elements = set_l1.intersection(set_l2)\n    \n    # Return a sorted list of the common elements\n    return sorted(common_elements)\n```\n\n", "py_summary": "The Python code defines a function `common` that takes two lists (`l1` and `l2`) as input and returns a sorted list of their unique common elements. Here's a detailed breakdown of how it works:\n\n1. **Convert Lists to Sets**: \n   - The function first converts the input lists `l1` and `l2` into sets (`set_l1` and `set_l2`). This step ensures that each set contains only unique elements, removing any duplicates from the original lists.\n\n2. **Find Common Elements**:\n   - It then computes the intersection of these two sets using the `.intersection()` method. The result is a new set containing only the elements that are present in both `set_l1` and `set_l2`.\n\n3. **Return Sorted List**:\n   - Finally, it converts this set back into a sorted list and returns it.\n\nThis approach ensures that the output contains unique common elements from both lists, and these elements are returned in ascending order.\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int i = 2;  // Start with the smallest prime number\n    int last_prime = -1;  // Variable to store the last prime factor found\n\n    while (i * i <= n) {  // Check up to the square root of n\n        if (n % i == 0) {\n            last_prime = i;  // Update last_prime with the current prime factor\n            while (n % i == 0) {\n                n /= i;  // Divide out all occurrences of this factor\n            }\n        }\n        i += 1;  // Move to the next potential factor\n    }\n\n    return (n > last_prime) ? n : last_prime;  // Return the largest prime factor found\n}\n\n", "py_code": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            last_prime = i\n            while n % i == 0:\n                n //= i\n        i += 1\n    return n if n > last_prime else last_prime\n```\n\n", "py_summary": "The Python function `largest_prime_factor` calculates and returns the largest prime factor of a given integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `i` is initialized to 2, which is the smallest prime number.\n2. **Loop through potential factors**: A while loop runs as long as `i * i <= n`, ensuring that we only check up to the square root of `n`. This optimization helps in reducing unnecessary checks for larger numbers.\n3. **Check divisibility and update `last_prime`**:\n   - If `n % i == 0`, it means `i` is a factor of `n`.\n   - The variable `last_prime` is set to the current value of `i`, which is the most recent prime factor found.\n4. **Divide out factors**: A nested while loop divides `n` by `i` as long as `i` remains a factor, effectively removing all occurrences of this factor from `n`.\n5. **Increment and continue checking**: After processing the current factor, `i` is incremented to check the next potential factor.\n6. **Return the largest prime factor**:\n   - If `n > last_prime`, it means that after dividing out all smaller factors, `n` itself has become a larger prime factor (which happens when `n` was initially a product of large primes).\n   - Otherwise, return `last_prime`.\n\nThis approach ensures that we efficiently find the largest prime factor by iteratively removing smaller factors and checking up to the square root of `n`."}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n", "py_code": "def sum_to_n(n):\n    return (n * (n + 1)) // 2\n```\n\n", "py_summary": "The Python function `sum_to_n` calculates the sum of all integers from 1 to a given integer \\( n \\). The formula used is derived from the arithmetic series sum formula:\n\n\\[ \\text{Sum} = \\frac{n \\times (n + 1)}{2} \\]\n\nThis formula efficiently computes the sum without needing to iterate through each number, making it very fast and simple. Here's a breakdown of how the function works:\n- The expression `n * (n + 1)` calculates the product of \\( n \\) and \\( n+1 \\).\n- This product is then divided by 2 using integer division (`//`), which ensures that the result is an integer.\n\nThis approach leverages mathematical properties to provide a direct solution, avoiding the need for loops or other iterative methods."}
{"task_id": "CPP/61", "generation": "#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance += 1;\n        } else if (c == ')') {\n            balance -= 1;\n        }\n        // If at any point the balance is negative, it means there are more closing brackets than opening ones.\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, the balance should be zero for all opening brackets to have corresponding closing brackets.\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        # If at any point the balance is negative, it means there are more closing brackets than opening ones.\n        if balance < 0:\n            return False\n    # At the end, the balance should be zero for all opening brackets to have corresponding closing brackets.\n    return balance == 0\n```\n\n", "py_summary": "The Python function `correct_bracketing` checks if a string of parentheses is correctly bracketed. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `balance` is initialized to 0. This variable keeps track of the balance between opening and closing brackets.\n\n2. **Iteration through the String**:\n   - For each character in the input string `brackets`, if the character is '(', the balance is incremented by 1.\n   - If the character is ')', the balance is decremented by 1.\n   \n3. **Checking for Imbalance**:\n   - During iteration, if at any point the balance becomes negative (`balance < 0`), it means there are more closing brackets than opening ones before this point, and thus the string cannot be correctly bracketed. The function returns `False`.\n\n4. **Final Check**:\n   - After iterating through all characters in the string, if the final value of `balance` is zero, then every opening bracket has a corresponding closing bracket, and the function returns `True`. If the balance is not zero, it means there are unmatched brackets, so the function implicitly returns `False`.\n\nThis approach ensures that the string is correctly bracketed by maintaining a running count of open and close parentheses and ensuring no closing parenthesis appears before its matching opening parenthesis.\n\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "def derivative(xs):\n    return [i * x for i, x in enumerate(xs) if i > 0]\n```\n", "py_summary": "The Python function `derivative` calculates the derivative of a polynomial represented by its coefficients. Here's an analysis of how it works:\n\n1. **Input**: The input is a list `xs`, where each element represents a coefficient of the polynomial. For example, if `xs = [3, 1, 2, 4, 5]`, it represents the polynomial \\(3 + x + 2x^2 + 4x^3 + 5x^4\\).\n\n2. **Derivative Calculation**: The derivative of a term \\(a_n x^n\\) is \\(n \\cdot a_n x^{n-1}\\). In other words, each coefficient in the resulting list is multiplied by its corresponding power (index) and then shifted down one position.\n\n3. **List Comprehension**:\n   - `enumerate(xs)` provides both the index (`i`) and value (`x`) of each element in the list.\n   - The condition `if i > 0` ensures that the constant term (coefficient at index 0) is ignored, as its derivative is zero.\n\n4. **Output**: The function returns a new list where each coefficient has been multiplied by its corresponding power and shifted down one position. For example, for `xs = [3, 1, 2, 4, 5]`, the output will be `[1*1, 2*2, 3*4, 4*5]` which simplifies to `[1, 4, 12, 20]`.\n\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    else if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n    \n    for (int i = 3; i <= n; ++i) {\n        int temp = a + b + c;\n        a = b;\n        b = c;\n        c = temp;\n    }\n\n    return c;\n}\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c\n```\n\n", "py_summary": "The Python function `fibfib(n)` computes the n-th element of the FibFib number sequence, which is defined as follows:\n- fibfib(0) == 0\n- fibfib(1) == 0\n- fibfib(2) == 1\n- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\nThe function uses a dynamic programming approach to efficiently compute the value:\n1. It handles base cases for `n = 0`, `n = 1`, and `n = 2` directly.\n2. For values of `n > 2`, it initializes three variables `a`, `b`, and `c` with the initial values corresponding to fibfib(0), fibfib(1), and fibfib(2) respectively: `a = 0`, `b = 0`, and `c = 1`.\n3. It then iterates from 3 up to `n`, updating these variables in each iteration according to the recurrence relation:\n   - `a` becomes the previous value of `b`\n   - `b` becomes the previous value of `c`\n   - `c` is updated as the sum of the previous values of `a`, `b`, and `c`.\n4. After completing the loop, it returns the value stored in `c`.\n\nThis approach ensures that each element is computed only once, making the function efficient with a time complexity of O(n).\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Define a set of vowels for easy lookup\n    string vowels = \"aeiou\";\n    \n    // Iterate through each character in the string\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != string::npos) {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' and treat it as a vowel if true\n    if (tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n\n", "py_code": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    \n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n            \n    # Check if the last character is 'y' and treat it as a vowel if true\n    if s[-1].lower() == 'y':\n        count += 1\n        \n    return count\n```\n\n", "py_summary": "The Python function `vowels_count` takes a string `s` as input and returns the number of vowels in the string. The vowels considered are 'a', 'e', 'i', 'o', and 'u'. Additionally, if the last character of the word is 'y', it is also treated as a vowel.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**:\n   - A set of vowels `vowels` containing 'a', 'e', 'i', 'o', and 'u' is defined.\n   - An integer variable `count` is initialized to 0 to keep track of the number of vowels.\n\n2. **Iterating through the string**:\n   - The function iterates over each character in the input string `s`.\n   - For each character, it checks if the lowercase version of the character is in the set of vowels.\n   - If the character is a vowel, the count is incremented by 1.\n\n3. **Checking for 'y' at the end**:\n   - After iterating through all characters, the function checks if the last character (accessed using `s[-1]`) is 'y'.\n   - If it is, and considering case insensitivity, the lowercase version of the last character is checked.\n   - If the condition is met, the count is incremented by 1.\n\n4. **Returning the result**:\n   - Finally, the function returns the total count of vowels found in the string.\n\nThis approach ensures that all standard vowels are counted and 'y' at the end of the word is treated as a vowel if applicable.\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine number of digits\n    int num_digits = num_str.length();\n    \n    // Handle case where shift is greater than or equal to the number of digits\n    if (shift >= num_digits) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Calculate effective shift\n    int effective_shift = shift % num_digits;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_digits - effective_shift) + num_str.substr(0, num_digits - effective_shift);\n    \n    return shifted_str;\n}\n", "py_code": "def circular_shift(x: int, shift: int) -> str:\n    num_str = str(x)\n    num_digits = len(num_str)\n    \n    if shift >= num_digits:\n        return num_str[::-1]\n    \n    effective_shift = shift % num_digits\n    shifted_str = num_str[-effective_shift:] + num_str[:-effective_shift]\n    return shifted_str\n```\n\n", "py_summary": "The Python function `circular_shift` takes an integer `x` and a shift value as input and returns a string representing the circularly shifted digits of `x`. Here's a detailed analysis:\n\n1. **Convert Integer to String**: The integer `x` is converted to its string representation `num_str`.\n\n2. **Determine Number of Digits**: The length of `num_str` (i.e., the number of digits in `x`) is stored in `num_digits`.\n\n3. **Handle Shift Greater Than or Equal to Number of Digits**:\n   - If `shift >= num_digits`, it means that shifting by `shift` positions would result in a full rotation or more, effectively reversing the digits.\n   - In this case, the function returns `num_str[::-1]`, which reverses the string.\n\n4. **Calculate Effective Shift**: The effective shift is calculated as `effective_shift = shift % num_digits`. This ensures that if `shift` is greater than `num_digits`, it wraps around to a valid position within the number of digits.\n\n5. **Perform Circular Shift**:\n   - The function constructs the shifted string by concatenating two parts: \n     - `num_str[-effective_shift:]`: The last `effective_shift` characters from the end.\n     - `num_str[:-effective_shift]`: All characters except the last `effective_shift` characters.\n\n6. **Return Result**: Finally, the function returns the resulting string after performing the circular shift.\n\nThis approach ensures that the digits are correctly shifted or reversed based on the given conditions.\n\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int result = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            result += static_cast<int>(c);\n        }\n    }\n    return result;\n}\n", "py_code": "def digitSum(s):\n    result = 0\n    for char in s:\n        if char.isupper():\n            result += ord(char)\n    return result\n```\n\n", "py_summary": "The Python function `digitSum` calculates the sum of the ASCII values of all uppercase characters in a given string `s`. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `result` is initialized to 0. This will store the cumulative sum of the ASCII values of uppercase characters.\n\n2. **Iteration through Characters**: A for loop iterates over each character in the input string `s`.\n\n3. **Check Uppercase Character**: For each character, the function checks if it is an uppercase letter using the `isupper()` method.\n\n4. **Add ASCII Value**: If the character is uppercase, its ASCII value (obtained using the `ord()` function) is added to `result`.\n\n5. **Return Result**: After iterating through all characters in the string, the function returns the accumulated sum stored in `result`.\n\nThis approach ensures that only uppercase letters are considered and their corresponding ASCII values are summed up correctly.\n\n"}
{"task_id": "CPP/67", "generation": "#include <string>\n#include <sstream>\n\nint fruit_distribution(std::string s, int n) {\n    // Extract numbers from the string using stringstream\n    std::istringstream iss(s);\n    int apples, oranges;\n    \n    // Read the number of apples\n    iss >> apples;\n    \n    // Skip \"apples and\"\n    std::string ignore1, ignore2;\n    iss >> ignore1 >> ignore1 >> oranges;\n\n    // Calculate the number of mangoes by subtracting the total number of apples and oranges from the total number of fruits\n    int mangoes = n - (apples + oranges);\n\n    return mangoes;\n}\n", "py_code": "def fruit_distribution(s: str, n: int) -> int:\n    # Extract numbers from the string using split and strip methods\n    parts = s.split()\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes by subtracting the total number of apples and oranges from the total number of fruits\n    mangoes = n - (apples + oranges)\n    \n    return mangoes\n```\n\n", "py_summary": "The Python function `fruit_distribution` takes a string `s` and an integer `n` as input. The string `s` represents the number of apples and oranges in the format \"X apples and Y oranges\", where X and Y are integers. The integer `n` represents the total number of fruits in the basket.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Splitting the String**: \n   - The string is split into parts using the `split()` method, which splits the string at each space character.\n   - This results in a list where the first element is the number of apples and the fourth element (index 3) is the number of oranges.\n\n2. **Extracting Numbers**:\n   - The function extracts the number of apples by converting the first part to an integer using `int(parts[0])`.\n   - Similarly, it extracts the number of oranges by converting the fourth part to an integer using `int(parts[3])`.\n\n3. **Calculating Mangoes**:\n   - The total number of mangoes is calculated by subtracting the sum of apples and oranges from the total number of fruits (`n`).\n\n4. **Returning Result**:\n   - Finally, the function returns the number of mangoes.\n\nThis approach ensures that the input string is correctly parsed to extract the relevant numbers and calculates the remaining fruits as mangoes based on the given constraints.\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = INT_MAX;\n    int index_of_smallest_even_value = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value || (arr[i] == smallest_even_value && i < index_of_smallest_even_value)) {\n                smallest_even_value = arr[i];\n                index_of_smallest_even_value = i;\n            }\n        }\n    }\n\n    if (smallest_even_value == INT_MAX) {\n        return {};\n    } else {\n        return {smallest_even_value, index_of_smallest_even_value};\n    }\n}\n", "py_code": "def pluck(arr):\n    smallest_even_value = float('inf')\n    index_of_smallest_even_value = -1\n    \n    for i, value in enumerate(arr):\n        if value % 2 == 0 and (value < smallest_even_value or (value == smallest_even_value and i < index_of_smallest_even_value)):\n            smallest_even_value = value\n            index_of_smallest_even_value = i\n            \n    if smallest_even_value == float('inf'):\n        return []\n    \n    return [smallest_even_value, index_of_smallest_even_value]\n```\n\n", "py_summary": "The Python function `pluck` is designed to find and return the node with the smallest even value from a given list of non-negative integers (representing nodes in a tree branch). If there are multiple nodes with the same smallest even value, it returns the one with the smallest index.\n\nHere's an analysis of how the code works:\n\n1. **Initialization**:\n   - `smallest_even_value` is initialized to infinity (`float('inf')`). This variable will store the smallest even value found in the list.\n   - `index_of_smallest_even_value` is initialized to `-1`. This variable will store the index of the smallest even value.\n\n2. **Iteration**:\n   - The function iterates through each element and its corresponding index in the input list using `enumerate(arr)`.\n   - For each element, it checks if the element is an even number (`value % 2 == 0`).\n   - If the current element is even and either smaller than the previously recorded smallest even value or equal to it but with a smaller index, the function updates `smallest_even_value` and `index_of_smallest_even_value`.\n\n3. **Result**:\n   - After iterating through all elements, if no even number was found (`smallest_even_value` remains infinity), the function returns an empty list `[]`.\n   - Otherwise, it returns a list containing the smallest even value and its index `[smallest_even_value, index_of_smallest_even_value]`.\n\nThis approach ensures that the function efficiently finds the desired node with minimal complexity."}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequency_dict;\n    \n    // Count the frequency of each integer in the list\n    for (const auto& num : lst) {\n        frequency_dict[num]++;\n    }\n    \n    int result = -1;\n    // Check each unique number to see if it meets the condition\n    for (const auto& entry : frequency_dict) {\n        int num = entry.first;\n        int freq = entry.second;\n        \n        if (num <= freq && num > result) {\n            result = num;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef search(lst: List[int]) -> int:\n    frequency_dict = {}\n    \n    # Count the frequency of each integer in the list\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    \n    result = -1\n    # Check each unique number to see if it meets the condition\n    for num, freq in frequency_dict.items():\n        if num <= freq and num > result:\n            result = num\n            \n    return result\n```\n\n", "py_summary": "The Python code defines a function `search` that takes a list of integers as input and returns the greatest integer with a frequency greater than or equal to its value. Here's an analysis of how it works:\n\n1. **Frequency Calculation**:\n   - A dictionary `frequency_dict` is used to store the frequency (count) of each unique number in the input list.\n   - The function iterates through the list and updates the count for each integer in the dictionary.\n\n2. **Finding the Result**:\n   - An initial result variable is set to `-1`, which will be returned if no valid integer is found.\n   - The function then iterates over the items in `frequency_dict`. For each unique number, it checks whether the frequency of that number is greater than or equal to the number itself.\n   - If a number meets this condition and is greater than the current result value, the result variable is updated with this number.\n\n3. **Return**:\n   - After checking all numbers in the dictionary, the function returns the highest valid integer found (or `-1` if no such integer exists).\n\nThis approach ensures that we efficiently find the required integer by leveraging a dictionary for quick frequency lookups and iterating through unique values to check the condition.\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    \n    while (!lst.empty()) {\n        // Append minimum value from remaining elements\n        if (!lst.empty()) {\n            result.push_back(lst.front());\n            lst.erase(lst.begin());\n        }\n        \n        // Append maximum value from remaining elements\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    \n    while sorted_lst:\n        # Append minimum value from remaining elements\n        if sorted_lst:\n            result.append(sorted_lst.pop(0))\n        \n        # Append maximum value from remaining elements\n        if sorted_lst:\n            result.append(sorted_lst.pop())\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `strange_sort_list` that takes a list of integers and returns a new list in \"strange order.\" Here's an analysis of how it works:\n\n1. **Sorting**: The input list is first sorted using `sorted(lst)`. This ensures that the elements are arranged in ascending order.\n\n2. **Initialization**: An empty list `result` is initialized to store the final output.\n\n3. **Main Loop**:\n   - The function enters a loop that continues until all elements from the sorted list have been processed.\n   - Inside the loop, it first checks if there are any remaining elements in `sorted_lst`. If so, it appends the smallest element (the first element of the list) to `result` and removes this element from `sorted_lst`.\n   - Next, it again checks for remaining elements. If there are still elements left, it appends the largest element (the last element of the list) to `result` and removes this element from `sorted_lst`.\n\n4. **Return**: Once all elements have been processed, the function returns the `result` list.\n\nThis approach ensures that the output alternates between the smallest remaining value and the largest remaining value until no more values are left in the input list.\n\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle using the triangle inequality theorem\n    if ((a + b > c) && (b + c > a) && (c + a > b)) {\n        // Calculate the semi-perimeter of the triangle\n        float s = (a + b + c) / 2;\n        \n        // Use Heron's formula to calculate the area\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to two decimal points\n        return round(area * 100) / 100;\n    } else {\n        // If the sides do not form a valid triangle, return -1\n        return -1;\n    }\n}\n\n", "py_code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter of the triangle\n        s = (a + b + c) / 2\n        # Use Heron's formula to calculate the area\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n```\n\n", "py_summary": "The Python function `triangle_area` calculates the area of a triangle given its three side lengths and returns the result rounded to two decimal points if the sides form a valid triangle. If the sides do not form a valid triangle, it returns -1.\n\nHere's an analysis of how the code works:\n\n1. **Validation Check**: The function first checks whether the given sides `a`, `b`, and `c` can form a valid triangle using the triangle inequality theorem. This theorem states that for any three lengths to be the sides of a triangle, the sum of any two sides must be greater than the third side.\n   - If `(a + b > c) and (b + c > a) and (c + a > b)` is true, then the sides form a valid triangle.\n\n2. **Semi-perimeter Calculation**: If the sides are valid, the function calculates the semi-perimeter `s` of the triangle using the formula:\n   \\[\n   s = \\frac{a + b + c}{2}\n   \\]\n\n3. **Area Calculation**: The area of the triangle is then calculated using Heron's formula:\n   \\[\n   \\text{area} = \\sqrt{s(s - a)(s - b)(s - c)}\n   \\]\n   This formula calculates the area based on the semi-perimeter and the side lengths.\n\n4. **Rounding**: The calculated area is rounded to two decimal points using `round(area, 2)`.\n\n5. **Return Value**: If the sides do not form a valid triangle (i.e., the validation check fails), the function returns -1.\n\nThis approach ensures that the function correctly handles both valid and invalid triangles by first validating the input and then calculating the area if the validation passes."}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    bool balanced = true;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            balanced = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int total_weight = 0;\n    for (int weight : q) {\n        total_weight += weight;\n    }\n\n    // Determine if the object can fly based on balance and weight condition\n    return balanced && total_weight <= w;\n}\n", "py_code": "def will_it_fly(q, w):\n    # Check if the vector is palindromic (balanced)\n    balanced = q == q[::-1]\n    \n    # Calculate the sum of elements in the vector\n    total_weight = sum(q)\n    \n    # Determine if the object can fly based on balance and weight condition\n    return balanced and total_weight <= w\n```\n\n", "py_summary": "The Python function `will_it_fly` checks whether an object represented by a vector `q` will fly given a maximum possible weight `w`. Here's a detailed analysis of how it works:\n\n1. **Check if the Vector is Palindromic (Balanced)**:\n   - The line `balanced = q == q[::-1]` checks if the vector `q` is palindromic, meaning it reads the same forwards and backwards.\n   - If `q` is a palindrome, `q[::-1]` will be identical to `q`, making `balanced` true. Otherwise, `balanced` will be false.\n\n2. **Calculate the Sum of Elements in the Vector**:\n   - The line `total_weight = sum(q)` calculates the total weight of all elements in the vector `q`.\n\n3. **Determine if the Object Can Fly Based on Balance and Weight Condition**:\n   - The function returns `True` if both conditions are met: \n     1. The vector is balanced (`balanced == True`).\n     2. The sum of the elements in the vector is less than or equal to the maximum possible weight `w`.\n   - If either condition fails, the function returns `False`.\n\nThis approach ensures that the object will only fly if it meets both criteria: being balanced and having a total weight within the allowed limit.\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n\nint smallest_change(std::vector<int>& arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n", "py_code": "def smallest_change(arr):\n    changes = 0\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n```\n\n", "py_summary": "The Python code defines a function `smallest_change` that takes a list of integers as input and returns the minimum number of changes required to make the list palindromic.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: \n   - The variable `changes` is initialized to 0, which will keep track of the total number of changes needed.\n   - Two pointers, `left` and `right`, are initialized to point to the start and end of the list respectively.\n\n2. **Loop through the List**:\n   - A while loop runs as long as `left` is less than `right`.\n   - Inside the loop, if the elements at positions `left` and `right` are not equal (`arr[left] != arr[right]`), it means a change is needed to make these two elements equal. Therefore, the `changes` counter is incremented by 1.\n   - The pointers `left` and `right` are then moved towards the center of the list: `left` is incremented (moved right) and `right` is decremented (moved left).\n\n3. **Return Result**:\n   - Once the loop completes, the function returns the total number of changes (`changes`) required to make the list palindromic.\n\nThis approach ensures that each pair of elements from opposite ends of the list is checked for equality, and if they are not equal, a change is counted. This continues until all pairs have been checked, ensuring the minimum number of changes needed is calculated accurately."}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint count_chars(const std::vector<std::string>& strings) {\n    int char_count = 0;\n    for (const auto& str : strings) {\n        char_count += str.length();\n    }\n    return char_count;\n}\n\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int char_count_lst1 = count_chars(lst1);\n    int char_count_lst2 = count_chars(lst2);\n\n    if (char_count_lst1 < char_count_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    def count_chars(strings):\n        return sum(len(s) for s in strings)\n    \n    char_count_lst1 = count_chars(lst1)\n    char_count_lst2 = count_chars(lst2)\n\n    if char_count_lst1 < char_count_lst2:\n        return lst1\n    else:\n        return lst2\n```\n\n", "py_summary": "The Python code defines a function `total_match` that takes two lists of strings (`lst1` and `lst2`) as input and returns one of them based on the total number of characters in each list. Here's an analysis of how it works:\n\n1. **Helper Function**: The function includes a nested helper function `count_chars` which calculates the total number of characters in a given list of strings.\n   - It uses a generator expression to calculate the length of each string and then sums these lengths.\n\n2. **Character Count Calculation**:\n   - `char_count_lst1` is calculated by calling `count_chars(lst1)`.\n   - Similarly, `char_count_lst2` is calculated by calling `count_chars(lst2)`.\n\n3. **Comparison and Return Value**:\n   - The function compares the total character counts of both lists.\n   - If `char_count_lst1` is less than `char_count_lst2`, it returns `lst1`.\n   - Otherwise, it returns `lst2`.\n\n4. **Edge Case Handling**: \n   - If the two lists have an equal number of characters, the function will return the first list (`lst1`) as specified in the problem statement.\n\nThis approach ensures that the correct list is returned based on the total character count while adhering to the requirement that if both lists have the same number of characters, the first list should be returned."}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nstd::vector<int> generate_primes() {\n    std::vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Main function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    std::vector<int> primes = generate_primes();\n    int count = 0; // Count of prime factors found\n    int product = 1; // Product of prime factors\n\n    for (int p : primes) {\n        while (a % p == 0 && count < 3) {\n            a /= p;\n            product *= p;\n            ++count;\n        }\n        if (count >= 3) break;\n    }\n\n    return (count == 3 && product == a);\n}\n\n", "py_code": "from math import sqrt\n\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    \n    count = 0\n    product = 1\n    \n    for prime in primes:\n        while a % prime == 0 and a > 1:\n            a //= prime\n            product *= prime\n            count += 1\n            \n        if count >= 3 and product == a:\n            return True\n        \n        if a == 1 or count >= 3:  # If we've already found three primes, no need to continue.\n            break\n    \n    return False\n```\n\n", "py_summary": "The Python code defines a function `is_multiply_prime` that checks if a given number is the product of exactly three prime numbers, with each prime number being less than 100.\n\nHere's an analysis of how the code works:\n\n1. **Prime Checking Function (`is_prime`)**:\n   - This helper function determines whether a given integer `n` is a prime number.\n   - It returns `False` if `n` is less than or equal to 1, as these are not considered prime numbers.\n   - For integers greater than 1, it checks divisibility from 2 up to the square root of `n`. If any divisor is found, the function returns `False`.\n   - Otherwise, it returns `True`.\n\n2. **Generating List of Primes**:\n   - The list comprehension `[i for i in range(2, 100) if is_prime(i)]` generates a list of all prime numbers less than 100.\n\n3. **Main Function (`is_multiply_prime`)**:\n   - It initializes `count` to keep track of the number of prime factors and `product` to store their product.\n   - The function iterates over each prime in the generated list of primes.\n   - For each prime, it checks if the given number `a` is divisible by that prime. If so, it divides `a` by the prime (updating `a`) and multiplies the prime into `product`.\n   - It increments the count for every division performed.\n   - Once a prime no longer divides `a`, or once three primes have been found (`count >= 3`), the function checks if `product` equals `a`. If so, it means that `a` is indeed the product of exactly three primes and returns `True`.\n   - The loop breaks early if `a` becomes 1 (indicating all factors are accounted for) or if at least three prime factors have been found.\n\n4. **Return Value**:\n   - The function returns `False` if it doesn't find that the number is a product of exactly three primes within the given constraints.\n\nThis approach ensures that the function efficiently checks whether the input number meets the criteria using precomputed prime numbers and divisibility checks."}
{"task_id": "CPP/76", "generation": "#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n\n    // Calculate the logarithm of x with base n\n    double log_result = std::log(x) / std::log(n);\n\n    // Check if the result is an integer by comparing it to its rounded value\n    return std::floor(log_result + 0.5) == log_result;\n}\n", "py_code": "import math\n\ndef is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    \n    # Calculate the logarithm of x with base n\n    log_result = math.log(x, n)\n    \n    # Check if the result is an integer by comparing it to its rounded value\n    return log_result.is_integer()\n```\n\n", "py_summary": "The Python function `is_simple_power` checks whether a given number \\( x \\) is a simple power of another number \\( n \\). Here's a detailed analysis:\n\n1. **Base Case Check**:\n   - The function first checks if \\( n \\) is 1. If \\( n = 1 \\), the only value of \\( x \\) that satisfies \\( 1^k = x \\) is \\( x = 1 \\). Therefore, it returns `True` if \\( x \\) is also 1 and `False` otherwise.\n\n2. **Logarithm Calculation**:\n   - For other values of \\( n \\), the function calculates the logarithm of \\( x \\) with base \\( n \\) using `math.log(x, n)`.\n\n3. **Integer Check**:\n   - The result of the logarithm calculation is stored in `log_result`. If \\( x \\) is a simple power of \\( n \\), then \\( \\log_n(x) \\) should be an integer.\n   - To verify if `log_result` is an integer, it checks whether `log_result.is_integer()` returns `True`.\n\n4. **Return Value**:\n   - The function returns `True` if the logarithm result is an integer, indicating that \\( x \\) is a simple power of \\( n \\). Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether \\( x \\) can be expressed as \\( n^k \\) for some integer \\( k \\).\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root and round it to the nearest integer\n    double root = cbrt(a);\n    int rounded_root = std::round(root);\n\n    // Check if the cube of the rounded value equals the original number\n    return pow(rounded_root, 3) == a;\n}\n", "py_code": "import math\n\ndef iscube(a):\n    if a < 0:\n        root = -((-a) ** (1/3))\n    else:\n        root = a ** (1/3)\n    \n    # Check if the cube of the rounded value equals the original number\n    return round(root) ** 3 == a\n```\n\n", "py_summary": "The Python function `iscube(a)` checks whether an integer `a` is a perfect cube of some other integer. Here's a detailed analysis:\n\n1. **Input Handling**: The function takes a single integer `a` as input.\n2. **Root Calculation**:\n   - If `a` is negative, the function calculates the cube root using `-((-a) ** (1/3))`. This ensures that the cube root of a negative number is also handled correctly.\n   - For non-negative values of `a`, it directly computes the cube root as `a ** (1/3)`.\n3. **Rounding**: The cube root value is rounded to the nearest integer using `round()`.\n4. **Verification**:\n   - It checks if raising this rounded integer to the power of 3 equals the original input `a`. If it does, then `a` is a perfect cube.\n5. **Return Value**: The function returns `True` if `a` is a perfect cube and `False` otherwise.\n\nThis approach ensures that both positive and negative integers are correctly evaluated for being a perfect cube."}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <vector>\n\nint hex_key(std::string num) {\n    // Set of prime hexadecimal digits\n    const std::vector<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char digit : num) {\n        // Check if the current digit is a prime hexadecimal digit\n        if (std::find(prime_hex_digits.begin(), prime_hex_digits.end(), digit) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n", "py_code": "def hex_key(num: str) -> int:\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python function `hex_key` takes a hexadecimal number as a string and counts how many of its digits are prime hexadecimal digits. Here's an analysis of the code:\n\n1. **Prime Hex Digits Set**: \n   - A set named `prime_hex_digits` is defined, containing the hexadecimal digits that represent prime numbers: '2', '3', '5', '7', 'B', and 'D'.\n\n2. **Initialization**:\n   - The variable `count` is initialized to 0 to keep track of the number of prime hexadecimal digits found in the input string.\n\n3. **Iteration Through Digits**:\n   - A for loop iterates through each character (digit) in the input string `num`.\n   \n4. **Check and Count Prime Hex Digits**:\n   - For each digit, it checks if the digit is present in the set of prime hexadecimal digits.\n   - If a digit is found to be in this set, the count is incremented by 1.\n\n5. **Return Result**:\n   - After iterating through all the digits, the function returns the final count of prime hexadecimal digits.\n\nThis approach ensures that each character in the input string is checked efficiently and only those characters that are prime hexadecimal digits contribute to the final count."}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset\n    string binary_str = bitset<32>(decimal).to_string();\n    \n    // Remove leading zeros\n    size_t start_pos = binary_str.find_first_not_of('0');\n    if (start_pos == string::npos) {\n        start_pos = 0;\n    }\n    binary_str = binary_str.substr(start_pos);\n\n    // Add \"db\" prefix and suffix\n    return \"db\" + binary_str + \"db\";\n}\n\n", "py_code": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # Convert decimal to binary and remove the '0b' prefix.\n    return f\"db{binary_str}db\"\n```\n\n", "py_summary": "The Python function `decimal_to_binary` converts a given decimal number to its binary representation and formats it according to the specified requirements. Here's an analysis of how the function works:\n\n1. **Convert Decimal to Binary**: The `bin()` function is used to convert the decimal number to its binary string representation. This function returns a string that starts with '0b' to indicate that it is a binary number.\n\n2. **Remove Prefix**: The `[2:]` slice operation removes the first two characters ('0b') from the binary string, leaving only the actual binary digits.\n\n3. **Format Output**: The formatted output is created by concatenating the prefix \"db\", the binary string, and the suffix \"db\". This ensures that the returned string has the required format with \"db\" at both ends.\n\n4. **Return Result**: Finally, the function returns the formatted binary string.\n\nThis approach ensures that the decimal number is correctly converted to a binary string and properly formatted as specified in the problem statement."}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through each character up to the third-to-last character\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // Check if any two of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no identical consecutive characters found, return true\n    return true;\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_happy(s)` checks if a given string `s` is happy according to the defined criteria. Here's an analysis of how it works:\n\n1. **Initial Length Check**: The function first checks if the length of the string `s` is less than 3. If so, it immediately returns `False`, as a happy string must have at least three characters.\n\n2. **Iterate Through String**: The function then iterates through each character in the string up to the third-to-last character (i.e., from index 0 to `len(s) - 3`). This is because we need to check every set of three consecutive characters, and checking beyond the third-to-last character would result in an out-of-bounds error.\n\n3. **Check Consecutive Characters**: For each position `i`, the function checks if any two of the three consecutive characters (`s[i]`, `s[i + 1]`, and `s[i + 2]`) are the same. If it finds that any two of these characters are equal, it returns `False`.\n\n4. **Return True**: If no such pair of identical characters is found in any set of three consecutive positions throughout the loop, the function returns `True` at the end.\n\nThis approach ensures that all conditions for a string to be considered happy (length \u2265 3 and every set of three consecutive letters being distinct) are thoroughly checked."}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n", "py_code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grades.append(\"A\")\n        elif gpa > 3.3:\n            letter_grades.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grades.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grades.append(\"B\")\n        elif gpa > 2.3:\n            letter_grades.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grades.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grades.append(\"C\")\n        elif gpa > 1.3:\n            letter_grades.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grades.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grades.append(\"D\")\n        elif gpa > 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades\n```\n\n", "py_summary": "The Python code defines a function `numerical_letter_grade` that takes a list of GPAs as input and returns a corresponding list of letter grades based on the provided grading scale. The function iterates through each GPA in the input list and uses a series of conditional statements to determine the appropriate letter grade for each GPA.\n\nHere's a breakdown of how the code works:\n1. **Initialization**: An empty list `letter_grades` is initialized to store the resulting letter grades.\n2. **Iteration**: The function iterates through each GPA in the input list `grades`.\n3. **Conditional Statements**:\n   - If the GPA is exactly 4.0, \"A+\" is appended to `letter_grades`.\n   - For other GPAs, a series of nested conditional statements checks if the GPA falls within specific ranges and appends the corresponding letter grade.\n   - The conditions are structured in descending order from highest to lowest GPA range.\n4. **Return**: After processing all GPAs, the function returns the `letter_grades` list.\n\nThis approach ensures that each GPA is accurately mapped to its corresponding letter grade based on the grading scale provided."}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Declare the is_prime function before defining prime_length\nbool is_prime(int n);\n\nbool prime_length(string str) {\n    // Get the length of the string\n    int length = str.length();\n\n    // Check if the length is a prime number using the helper function\n    return is_prime(length);\n}\n\n// Define the is_prime function\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n", "py_code": "def prime_length(s: str) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    length = len(s)\n    return is_prime(length)\n```\n\n", "py_summary": "The Python code defines a function `prime_length` that takes a string as input and returns `True` if the length of the string is a prime number, otherwise it returns `False`.\n\nHere's an analysis of how this works:\n\n1. **Helper Function (`is_prime`)**:\n   - The helper function `is_prime(n)` checks whether a given integer `n` is a prime number.\n   - It first handles edge cases where `n <= 1`, returning `False` because neither 0 nor 1 are considered prime numbers.\n   - For integers greater than 1, the function iterates from 2 to the square root of `n`. If any integer in this range divides `n` without a remainder (i.e., `n % i == 0`), then `n` is not a prime number and the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n2. **Main Function (`prime_length`)**:\n   - The main function calculates the length of the input string `s` using `len(s)`.\n   - It then calls the helper function `is_prime(length)` to determine if this length is a prime number.\n   - Finally, it returns the result from `is_prime`.\n\nThis approach ensures that the code efficiently checks whether the length of the given string is a prime number by leveraging an optimized primality test in the helper function.\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\n// Function declaration\nint starts_one_ends(int n);\n\n// Function definition\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Only one number, which is '1'\n    \n    int count = 0;\n    // Count numbers that start with 1\n    count += pow(10, n - 1);\n    \n    // Count numbers that end with 1 but do not start with 1\n    if (n > 1) {\n        count += pow(10, n - 2) * 8; // There are 8 possibilities for the second digit (2-9)\n    }\n    \n    return count;\n}\n\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    \n    # For n-digit numbers starting with 1: There is exactly one such number for each digit length.\n    start_with_1 = 1\n\n    # For n-digit numbers ending with 1: The first (n-1) digits can be anything from 0 to 9 except the case where it starts with 1, which we already counted separately.\n    end_with_1 = 9 * (10 ** (n - 2)) if n > 1 else 0\n\n    # For numbers that both start and end with 1: We need to subtract these cases as they are double-counted.\n    both_start_and_end_with_1 = starts_one_ends(n - 1)\n\n    return start_with_1 + end_with_1 + (both_start_and_end_with_1 if n > 2 else 0)\n```\n\n", "py_summary": "The Python function `starts_one_ends` calculates the count of n-digit positive integers that start or end with the digit 1. Here's a detailed breakdown:\n\n1. **Base Case**: If `n == 1`, there is only one such number (which is '1'). This directly returns 1.\n\n2. **Numbers Starting with 1**:\n   - For any n-digit number starting with 1, there is exactly one such number for each digit length.\n   - Therefore, the count of numbers starting with 1 is always 1 regardless of `n`.\n\n3. **Numbers Ending with 1**:\n   - For an n-digit number ending with 1, the first (n-1) digits can be any digit from 0 to 9 except for cases where these digits also start with 1.\n   - If `n > 1`, there are \\(9 \\times 10^{(n-2)}\\) such numbers because:\n     - The second digit has 9 choices (since it cannot be 1).\n     - Each subsequent digit can be any of the 10 digits.\n\n4. **Numbers Starting and Ending with 1**:\n   - For n-digit numbers that both start and end with 1, we need to subtract these cases as they are double-counted.\n   - The count of such numbers is equivalent to the count of (n-1)-digit numbers starting or ending with 1.\n\n5. **Combining Results**:\n   - Sum up the counts from steps 2, 3, and adjust for double-counting in step 4.\n\nThe function recursively calculates these values and returns the total count of n-digit positive integers that start or end with 1.\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nstring solve(int N) {\n    // Convert integer to string for easy digit access\n    stringstream ss;\n    ss << N;\n    string num_str = ss.str();\n\n    int digit_sum = 0;\n\n    // Iterate through each character in the string and convert it back to an integer to add to the sum\n    for (char c : num_str) {\n        digit_sum += c - '0';\n    }\n\n    // Convert the final sum into binary format as a string\n    return bitset<32>(digit_sum).to_string().substr(32 - __builtin_clz(digit_sum));\n}\n", "py_code": "def solve(N):\n    # Convert the integer to its string representation to easily access each digit\n    num_str = str(N)\n    \n    # Initialize a variable to store the sum of digits\n    digit_sum = 0\n    \n    # Iterate through each character in the string and convert it back to an integer to add to the sum\n    for char in num_str:\n        digit_sum += int(char)\n    \n    # Convert the final sum into binary format as a string\n    return bin(digit_sum)[2:]\n```\n", "py_summary": "The Python function `solve(N)` calculates the sum of the digits of a given integer `N` and returns this sum in binary form. Here's a detailed breakdown of how it works:\n\n1. **Convert to String**: The integer `N` is converted into its string representation (`num_str`). This allows easy iteration over each digit.\n2. **Initialize Sum Variable**: A variable `digit_sum` is initialized to 0, which will store the cumulative sum of the digits.\n3. **Sum Digits**: The function iterates through each character in `num_str`. For each character (which represents a digit), it converts the character back into an integer and adds this value to `digit_sum`.\n4. **Convert Sum to Binary**: After calculating the total sum of the digits, the function uses Python's built-in `bin()` function to convert `digit_sum` into its binary representation as a string. The `[2:]` slice is used to remove the '0b' prefix that `bin()` adds to indicate a binary number.\n5. **Return Result**: Finally, the binary string representing the sum of digits is returned.\n\nThis approach ensures that each digit in the integer `N` is processed correctly and the resulting sum is accurately converted into its binary form."}
{"task_id": "CPP/85", "generation": "#include <vector>\n\nint add(std::vector<int> lst) {\n    int result = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {  // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) {  // Check if the element at the odd index is even\n            result += lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def add(lst):\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2 (odd indices)\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            result += lst[i]\n    return result\n```\n\n", "py_summary": "The Python function `add` takes a list of integers as input and returns the sum of all even elements that are located at odd indices in the list.\n\n1. **Initialization**: The variable `result` is initialized to 0 to store the cumulative sum of the selected elements.\n2. **Iteration over Odd Indices**: A for loop iterates through the list starting from index 1 (the first odd index) and increments by 2, ensuring that only odd indices are processed.\n3. **Check Even Condition**: For each element at an odd index, it checks if the element is even using the condition `lst[i] % 2 == 0`.\n4. **Summation**: If the element is even, its value is added to `result`.\n5. **Return Result**: After iterating through all elements, the function returns the cumulative sum stored in `result`.\n\nThis approach ensures that only even numbers at odd indices are considered and summed up correctly.\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    int word_start = 0;\n    \n    for (int i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] == ' ') {\n            // Sort the current word\n            sort(s.begin() + word_start, s.begin() + i);\n            \n            // Append sorted word to result\n            result += s.substr(word_start, i - word_start);\n            \n            // If it's not the last character and there is a space, append the space\n            if (i < s.length()) {\n                result += ' ';\n            }\n            \n            // Move to the next word start\n            word_start = i + 1;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef anti_shuffle(s: str) -> str:\n    words = s.split()\n    result = []\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n    \n    return ' '.join(result)\n```\n\n", "py_summary": "The Python code defines a function `anti_shuffle` that takes a string `s` and returns an ordered version of it according to the problem statement. Here's a detailed analysis:\n\n1. **Splitting the String into Words**: The input string `s` is split into individual words using the `split()` method, which splits the string at each space character and returns a list of words.\n\n2. **Initializing Result List**: An empty list `result` is initialized to store the sorted versions of each word.\n\n3. **Sorting Each Word**:\n   - The function iterates through each word in the list of words.\n   - For each word, it uses the `sorted()` method to sort the characters of the word based on their ASCII values.\n   - The sorted characters are then joined back into a string using `''.join(sorted_word)` and appended to the `result` list.\n\n4. **Reconstructing the Ordered String**: After processing all words, the function joins the elements in the `result` list back into a single string with spaces between each word using `' '.join(result)`.\n\n5. **Returning the Result**: The final ordered version of the input string is returned.\n\nThis approach ensures that the order of words and blank spaces in the original sentence is preserved while sorting the characters within each word based on their ASCII values.\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<std::vector<int>> result;\n\n    // Iterate through each row in the nested vector\n    for (size_t row_index = 0; row_index < lst.size(); ++row_index) {\n        const auto& row = lst[row_index];\n        for (size_t col_index = 0; col_index < row.size(); ++col_index) {\n            if (row[col_index] == x) {\n                // Append the coordinates in the format {row, columns}\n                result.push_back({static_cast<int>(row_index), static_cast<int>(lst[row_index].size() - 1 - col_index)});\n            }\n        }\n    }\n\n    // Sort the result by rows in ascending order and columns in descending order\n    std::sort(result.begin(), result.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index in descending order within the same row\n        }\n        return a[0] < b[0]; // Sort by row index in ascending order\n    });\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append([row_index, len(row) - 1 - col_index])\n                \n    # Sort the result by rows in ascending order and columns in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `get_row` that takes a nested list `lst` and an integer `x`, and returns a list of coordinates where `x` is found in `lst`. The function works as follows:\n\n1. **Initialization**: An empty list `result` is initialized to store the coordinates of occurrences of `x`.\n\n2. **Iterate through rows and columns**:\n   - The function iterates over each row in `lst` using an index variable `row_index`.\n   - For each element in the current row, it checks if the value equals `x`. If a match is found, it appends the coordinates `[row_index, col_index]` to `result`, where `col_index` is adjusted to be from the end of the row by using `len(row) - 1 - col_index`.\n\n3. **Sorting**:\n   - After collecting all occurrences, the function sorts the list `result`. The sorting key is a tuple `(row_index, -col_index)` which ensures that coordinates are first sorted in ascending order by rows and then in descending order by columns within each row.\n\n4. **Return**: Finally, the function returns the sorted list of coordinates.\n\nThis approach ensures that all occurrences of `x` are found and their coordinates are returned in the specified order.\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_vector(vector<int> array) {\n    if (array.empty()) {\n        return {};\n    }\n\n    int first_value = array[0];\n    int last_value = array.size() > 1 ? array.back() : first_value;\n    \n    bool should_reverse = (first_value + last_value) % 2 == 0;\n\n    vector<int> sorted_array(array); // Copy the original array\n    sort(sorted_array.begin(), sorted_array.end()); // Sort in ascending order\n\n    if (should_reverse) {\n        reverse(sorted_array.begin(), sorted_array.end()); // Reverse for descending order\n    }\n\n    return sorted_array;\n}\n", "py_code": "from typing import List\n\ndef sort_vector(array: List[int]) -> List[int]:\n    if not array:\n        return []\n    \n    first_value = array[0]\n    last_value = array[-1] if len(array) > 1 else first_value\n    \n    sum_of_edges = first_value + last_value\n    \n    sorted_array = sorted(array)\n    \n    if sum_of_edges % 2 == 0:\n        sorted_array.reverse()\n    \n    return sorted_array\n```\n\n", "py_summary": "The Python code defines a function `sort_vector` that takes a list of non-negative integers and returns a new list based on specific sorting criteria:\n\n1. **Check for Empty List**: The function first checks if the input list is empty. If it is, an empty list is returned immediately.\n\n2. **Determine First and Last Values**:\n   - `first_value` is assigned the value at index 0 of the array.\n   - `last_value` is assigned the value at the last index of the array (or the first value if the array has only one element).\n\n3. **Calculate Sum of Edges**: The sum of `first_value` and `last_value` is calculated to determine whether the sorting should be in ascending or descending order.\n\n4. **Sort Array**:\n   - The input list is sorted in ascending order using Python's built-in `sorted()` function.\n   \n5. **Determine Sorting Order**:\n   - If the sum of the first and last values is even, the sorted array is reversed to sort it in descending order.\n   - If the sum is odd, the sorted array remains unchanged (already in ascending order).\n\n6. **Return Result**: The function returns the appropriately sorted list.\n\nThis approach ensures that the original input list is not modified and a new list with the correct sorting order based on the specified criteria is returned.\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if ('a' <= c && c <= 'z') {\n            // Calculate new character by shifting down by 4 places\n            char shifted_char = ((c - 'a' + (2 * 2)) % 26) + 'a';\n            encrypted += shifted_char;\n        } else {\n            // If the character is not a lowercase letter, keep it as is\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n", "py_code": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate new character by shifting down by 2 * 2 = 4 places\n            shifted_char = chr(((ord(char) - ord('a') + (2 * 2)) % 26) + ord('a'))\n            encrypted += shifted_char\n        else:\n            # If the character is not a lowercase letter, keep it as is\n            encrypted += char\n    return encrypted\n```\n\n", "py_summary": "The Python function `encrypt` takes a string `s` as an argument and returns an encrypted version of that string by rotating each lowercase letter in the alphabet down by 4 positions (since 2 * 2 = 4). Here's a detailed breakdown:\n\n1. **Initialization**: The variable `encrypted` is initialized to an empty string, which will store the final encrypted result.\n\n2. **Iteration through characters**: A loop iterates over each character in the input string `s`.\n\n3. **Character Check and Transformation**:\n   - For each character `char`, it checks if the character is a lowercase letter using the condition `'a' <= char <= 'z'`.\n   - If the character is a lowercase letter, it calculates the new character by shifting down by 4 positions.\n     - The ASCII value of the character is converted to its position in the alphabet (0-based index) with `ord(char) - ord('a')`.\n     - This position is then shifted down by 4: `(ord(char) - ord('a') + 4) % 26` ensures that if the shift goes beyond 'z', it wraps around to the beginning of the alphabet.\n     - The new character's ASCII value is calculated and converted back to a character using `chr()`.\n   - If the character is not a lowercase letter, it remains unchanged.\n\n4. **Appending to Result**: Each transformed or unchanged character is appended to the `encrypted` string.\n\n5. **Return Value**: Finally, the function returns the `encrypted` string containing the encrypted version of the input string.\n\nThis approach ensures that only lowercase letters are shifted and other characters remain as they are in the output string."}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Step 1: Check if there are at least two elements in the vector.\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 2: Use a set to remove duplicates and then convert it back to a sorted vector.\n    set<int> unique_elements(lst.begin(), lst.end());\n    vector<int> sorted_unique_elements(unique_elements.begin(), unique_elements.end());\n\n    // Step 3: Check if there are at least two unique elements in the sorted vector.\n    if (sorted_unique_elements.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 4: Return the second smallest element.\n    return sorted_unique_elements[1];\n}\n", "py_code": "from typing import List, Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = sorted(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    return unique_elements[1]\n```\n\n", "py_summary": "The Python function `next_smallest` is designed to find and return the second smallest element in a given list of integers. Here's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if the length of the input list `lst` is less than 2. If so, there cannot be a second smallest element, and the function returns `None`.\n\n2. **Remove Duplicates**: To ensure that we are working with unique elements, the function converts the list to a set (which removes duplicates) and then back to a sorted list (`unique_elements`). This step ensures that any repeated minimum values do not interfere with finding the second smallest element.\n\n3. **Check for Second Smallest Element**: After sorting the unique elements, the function checks if there are at least two distinct elements in `unique_elements`. If there are fewer than two unique elements, it returns `None`.\n\n4. **Return Second Smallest Element**: Finally, the function returns the second element (index 1) of the sorted list of unique elements.\n\nThis approach ensures that the function correctly handles cases with duplicates and empty lists while efficiently finding the second smallest distinct element in the input list.\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to split a string by a delimiter and return a vector of substrings\nvector<string> split(const string& str, char delimiter) {\n    vector<string> tokens;\n    size_t start = 0;\n    size_t end = 0;\n    while ((end = str.find(delimiter, start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n        start = end + 1;\n    }\n    tokens.push_back(str.substr(start));\n    return tokens;\n}\n\nint is_bored(string S) {\n    int boredom_count = 0;\n\n    // Split the input string by periods ('.')\n    vector<string> sentences = split(S, '.');\n\n    for (const auto& sentence : sentences) {\n        if (sentence.find('?') != string::npos || sentence.find('!') != string::npos) {\n            // Further split by '?' and check each part\n            vector<string> parts = split(sentence, '?');\n            for (const auto& part : parts) {\n                vector<string> sub_parts = split(part, '!');\n                for (const auto& sub_part : sub_parts) {\n                    if (!sub_part.empty() && sub_part.substr(0, 2) == \"I \") {\n                        boredom_count++;\n                    }\n                }\n            }\n        } else {\n            // Check the sentence directly\n            string trimmed_sentence = sentence;\n            size_t start_space = trimmed_sentence.find_first_not_of(\" \\t\");\n            if (start_space != string::npos && trimmed_sentence.substr(start_space, 2) == \"I \") {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n", "py_code": "def is_bored(S):\n    boredom_count = 0\n    sentences = S.split('.')\n    for sentence in sentences:\n        if '?' in sentence or '!' in sentence:\n            # Split by these delimiters and check each part separately\n            parts = sentence.split('?')\n            for part in parts:\n                sub_parts = part.split('!')\n                for sub_part in sub_parts:\n                    if sub_part.strip().startswith(\"I \"):\n                        boredom_count += 1\n        else:\n            if sentence.strip().startswith(\"I \"):\n                boredom_count += 1\n    \n    return boredom_count\n```\n\n", "py_summary": "The Python function `is_bored` takes a string `S` as input and returns an integer representing the number of sentences that start with the word \"I\". Here's a detailed breakdown of how it works:\n\n1. **Initialization**: The variable `boredom_count` is initialized to 0, which will keep track of the number of boredoms (sentences starting with \"I\").\n\n2. **Splitting Sentences**: The string `S` is split into sentences based on periods ('.') using `split('.')`. This creates a list of potential sentences.\n\n3. **Iterating Through Sentences**:\n   - For each sentence in the list, it checks if there are any '?' or '!' delimiters present.\n   - If either '?' or '!' is found within the sentence, the sentence is further split into parts using these delimiters.\n     - The sentence is first split by '?' to handle questions separately.\n     - Each part from splitting by '?' is then checked for sentences starting with \"I\".\n     - For each part, it splits again by '!' and checks if any resulting sub-part starts with \"I\".\n\n4. **Checking Sentence Start**:\n   - If the sentence does not contain '?' or '!', it directly checks if the sentence (after stripping leading/trailing whitespace) starts with \"I \".\n   - If a sentence or part of a sentence starts with \"I \", `boredom_count` is incremented.\n\n5. **Return Result**: Finally, the function returns the total count of sentences starting with \"I\".\n\nThis approach ensures that all possible delimiters are considered and each potential sentence is checked for boredom correctly.\n\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all inputs are integers by comparing them to their floor values\n    if (a != static_cast<int>(a) || b != static_cast<int>(b) || c != static_cast<int>(c)) {\n        return false;\n    }\n    \n    // Cast the floats to integers for further checks\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if one number is equal to the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n", "py_code": "def any_int(a, b, c):\n    # Check if all inputs are integers\n    if not (isinstance(a, int) and isinstance(b, int) and isinstance(c, int)):\n        return False\n    \n    # Check if one number is equal to the sum of the other two\n    return a == b + c or b == a + c or c == a + b\n```\n\n", "py_summary": "The Python function `any_int` takes three numbers as input and returns `True` if one of the numbers is equal to the sum of the other two, provided that all numbers are integers. Here's a detailed analysis:\n\n1. **Type Checking**:\n   - The function first checks whether all inputs (`a`, `b`, and `c`) are integers using the `isinstance()` function.\n   - If any of the inputs is not an integer, the function immediately returns `False`.\n\n2. **Sum Condition Check**:\n   - After ensuring that all inputs are integers, the function checks if one number is equal to the sum of the other two.\n   - It does this by evaluating three conditions:\n     - `a == b + c`\n     - `b == a + c`\n     - `c == a + b`\n   - If any of these conditions are true, the function returns `True`.\n   - If none of the conditions are met, the function implicitly returns `False`.\n\nThis approach ensures that the function only considers integer inputs and correctly identifies cases where one number is the sum of the other two.\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isalpha() and toupper/tolower functions\n\nusing namespace std;\n\n// Function to encode the message according to the given rules\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    char shifted_vowels[] = {'C', 'G', 'K', 'Q', 'W', 'C', 'G', 'K', 'Q', 'W'};\n    \n    // Mapping of vowels to their corresponding shifted values\n    for (int i = 0; i < message.length(); ++i) {\n        char& c = message[i];\n        \n        if (isalpha(c)) {\n            // Swap case\n            if (islower(c))\n                c = toupper(c);\n            else\n                c = tolower(c);\n\n            // Shift vowels\n            size_t vowel_index = vowels.find(c);\n            if (vowel_index != string::npos) {\n                c = shifted_vowels[vowel_index];\n            }\n        }\n    }\n\n    return message;\n}\n\n// Function to test the encode function with some examples\nvoid test_encode() {\n    cout << \"Encoded 'test': '\" << encode(\"test\") << \"'\" << endl; // Expected: \"TGST\"\n    cout << \"Encoded 'This is a message': '\" << encode(\"This is a message\") << \"'\" << endl; // Expected: \"tHKS KS C MGSSCGG\"\n}\n\n", "py_code": "def encode(message):\n    vowels = \"aeiouAEIOU\"\n    shifted_vowels = {\"a\": \"c\", \"e\": \"g\", \"i\": \"k\", \"o\": \"q\", \"u\": \"w\",\n                       \"A\": \"C\", \"E\": \"G\", \"I\": \"K\", \"O\": \"Q\", \"U\": \"W\"}\n    encoded_message = \"\"\n    \n    for char in message:\n        if char.isalpha():\n            # Swap case\n            new_char = char.swapcase()\n            \n            # Shift vowels\n            if new_char in vowels:\n                new_char = shifted_vowels[new_char]\n                \n            encoded_message += new_char\n        else:\n            encoded_message += char\n    \n    return encoded_message\n```\n\n", "py_summary": "The Python code defines a function `encode` that takes a string message as input and encodes it according to specific rules:\n\n1. **Swap Case**: The function iterates through each character in the message and swaps its case (lowercase to uppercase or vice versa) using the `swapcase()` method.\n2. **Shift Vowels**: For vowels, the function replaces them with the letter that appears two places ahead of it in the English alphabet. This is done by checking if the swapped character is a vowel and then mapping it to its corresponding shifted value using a predefined dictionary `shifted_vowels`.\n3. **Non-Alphabetic Characters**: If the character is not an alphabetic character, it remains unchanged.\n\nHere's a detailed breakdown of how the function works:\n\n- The function initializes an empty string `encoded_message` to store the result.\n- It iterates through each character in the input message:\n  - For each character, if it is an alphabetic letter (checked using `char.isalpha()`), its case is swapped using `char.swapcase()`.\n  - If the resulting character is a vowel, it is replaced with the corresponding shifted vowel from the `shifted_vowels` dictionary.\n- The modified character is then appended to `encoded_message`.\n- Non-alphabetic characters are directly added to `encoded_message` without any changes.\n\nFinally, the function returns the encoded message.\n\nThis approach ensures that all letters have their cases swapped and vowels are shifted as required."}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n\n    if (max_prime == -1) return 0;\n\n    return sum_of_digits(max_prime);\n}\n\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = -1\n    for num in lst:\n        if is_prime(num):\n            if num > max_prime:\n                max_prime = num\n    \n    if max_prime == -1:\n        return 0\n    \n    return sum_of_digits(max_prime)\n```\n\n", "py_summary": "The Python code defines a function `skjkasdkd` that takes a list of integers and returns the sum of the digits of the largest prime number in the list. Here's a detailed breakdown:\n\n1. **is_prime Function**:\n   - This helper function checks if a given integer `n` is a prime number.\n   - It first handles edge cases where `n` is less than or equal to 1, returning `False`.\n   - Then it iterates from 2 up to the square root of `n`. If any number in this range divides `n`, `n` is not a prime and the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n2. **sum_of_digits Function**:\n   - This helper function calculates the sum of the digits of an integer.\n   - It converts the integer to a string, iterates over each character (digit), converts it back to an integer, and sums these integers.\n\n3. **skjkasdkd Function**:\n   - The main function initializes `max_prime` to `-1`, which will store the largest prime number found in the list.\n   - It iterates through each element in the input list `lst`.\n   - For each element, it checks if the element is a prime using the `is_prime` function. If it is a prime and greater than the current value of `max_prime`, it updates `max_prime`.\n   - After iterating through all elements, if no prime number was found (`max_prime` remains `-1`), the function returns 0.\n   - Otherwise, it calculates the sum of the digits of `max_prime` using the `sum_of_digits` function and returns this value.\n\nThis approach ensures that we correctly identify the largest prime number in the list and compute the required digit sum efficiently."}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto &pair : dict) {\n        const std::string &key = pair.first;\n\n        // Check if the key is not entirely lowercase\n        if (!std::all_of(key.begin(), key.end(), ::islower)) {\n            all_lower = false;\n        }\n\n        // Check if the key is not entirely uppercase\n        if (!std::all_of(key.begin(), key.end(), ::isupper)) {\n            all_upper = false;\n        }\n\n        // If both flags are false, return false early\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys are lowercase or all keys are uppercase\n    return all_lower || all_upper;\n}\n", "py_code": "from typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    if not dict:\n        return False\n    \n    all_lower = True\n    all_upper = True\n    \n    for key in dict.keys():\n        if not key.islower():\n            all_lower = False\n        if not key.isupper():\n            all_upper = False\n        \n        if not all_lower and not all_upper:\n            return False\n    \n    return all_lower or all_upper\n```\n\n", "py_summary": "The Python code defines a function `check_dict_case` that takes a dictionary as input and checks whether all keys in the dictionary are either entirely lowercase or entirely uppercase. The function returns `True` if this condition is met and `False` otherwise.\n\nHere's an analysis of how the function works:\n\n1. **Check for Empty Dictionary**: \n   - If the dictionary is empty, the function immediately returns `False`.\n\n2. **Initialize Flags**:\n   - Two boolean flags, `all_lower` and `all_upper`, are initialized to `True`. These flags will be used to track whether all keys in the dictionary are lowercase or uppercase.\n\n3. **Iterate Through Keys**:\n   - The function iterates through each key in the dictionary.\n   - For each key, it checks if the key is not entirely lowercase (`key.islower()` returns `False`). If this condition is met, it sets `all_lower` to `False`.\n   - Similarly, for each key, it checks if the key is not entirely uppercase (`key.isupper()` returns `False`). If this condition is met, it sets `all_upper` to `False`.\n\n4. **Early Exit**:\n   - As soon as both flags are set to `False`, indicating that keys are neither all lowercase nor all uppercase, the function returns `False`.\n\n5. **Final Check and Return**:\n   - After iterating through all keys, if either `all_lower` or `all_upper` is still `True`, it means all keys in the dictionary are consistent in their case (either all lowercase or all uppercase), so the function returns `True`.\n\nThis approach ensures that the function efficiently checks the case consistency of the keys and handles edge cases such as an empty dictionary."}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to count up to n and return a vector of prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n", "py_code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for number in range(2, n):\n        if is_prime(number):\n            primes.append(number)\n    return primes\n```\n\n", "py_summary": "The Python code defines a function `count_up_to` that takes an integer `n` and returns a list of prime numbers less than `n`. The solution involves two main parts:\n\n1. **Prime Checking Function (`is_prime`)**:\n   - This helper function checks whether a given number is prime.\n   - It first handles the base cases where numbers less than or equal to 1 are not considered prime.\n   - Then, it iterates from 2 up to the square root of the number (inclusive) to check for any divisors. If any divisor is found, the function returns `False`. Otherwise, it returns `True`.\n\n2. **Main Function (`count_up_to`)**:\n   - This function initializes an empty list called `primes`.\n   - It iterates through all integers from 2 up to (but not including) `n`.\n   - For each integer, it calls the `is_prime` function to check if the number is prime.\n   - If a number is determined to be prime, it appends that number to the `primes` list.\n   - Finally, the function returns the list of primes.\n\nThis approach ensures that all numbers less than `n` are checked for primality and only those that pass the check are included in the result."}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers using modulo operation and absolute value\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Calculate the product of the unit digits\n    int result = unit_digit_a * unit_digit_b;\n\n    // Return the result\n    return result;\n}\n", "py_code": "def multiply(a: int, b: int) -> int:\n    # Extract the unit digit of both numbers\n    unit_digit_a = abs(a % 10)\n    unit_digit_b = abs(b % 10)\n    \n    # Calculate and return the product of the unit digits\n    return unit_digit_a * unit_digit_b\n```\n\n", "py_summary": "The Python function `multiply` takes two integers as input and returns the product of their unit digits. Here's a detailed analysis:\n\n1. **Extract Unit Digits**:\n   - The unit digit of an integer is obtained by taking the remainder when divided by 10 (`a % 10` for `a` and `b % 10` for `b`). \n   - To handle negative numbers correctly, we use the absolute value function `abs()` to ensure that the unit digits are always non-negative.\n\n2. **Calculate Product**:\n   - The product of the unit digits is computed by multiplying the two extracted unit digits (`unit_digit_a * unit_digit_b`).\n\n3. **Return Result**:\n   - The result, which is the product of the unit digits, is returned as an integer.\n\nThis approach ensures that the function works correctly for both positive and negative integers, as well as zero values, since `abs()` will handle all cases appropriately.\n\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n#include <algorithm>\n\nint count_upper(std::string s) {\n    // Define uppercase vowels\n    const std::string vowels = \"AEIOU\";\n    int count = 0;\n\n    // Iterate over even indices in the string\n    for (size_t i = 0; i < s.length(); i += 2) {\n        // Check if the character at index i is an uppercase vowel\n        if (vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    count = 0\n    for i in range(0, len(s), 2):  # Iterate over even indices\n        if s[i] in vowels:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python function `count_upper` is designed to count the number of uppercase vowels at even indices in a given string `s`. Here's an analysis of how it works:\n\n1. **Initialization**: \n   - The variable `vowels` is initialized with the string `\"AEIOU\"`, which contains all uppercase vowels.\n   - The variable `count` is initialized to 0, which will be used to keep track of the number of uppercase vowels found at even indices.\n\n2. **Iteration**:\n   - A for loop iterates over the string `s` with a step size of 2 (`range(0, len(s), 2)`). This ensures that only characters at even indices (considering the first index as 0) are processed.\n   \n3. **Condition Check and Count Update**:\n   - For each character at an even index, the function checks if it is one of the uppercase vowels by using `if s[i] in vowels`.\n   - If the condition is true, the count is incremented by 1.\n\n4. **Return Statement**:\n   - After iterating through all characters at even indices, the function returns the final count.\n\nThis approach ensures that only uppercase vowels at even indices are counted and returned as the result.\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nint closest_integer(std::string value) {\n    // Convert string to float\n    float num = std::stof(value);\n\n    // Determine floor and ceiling values\n    int floor_value = static_cast<int>(num);\n    int ceil_value;\n\n    if (num > 0) {\n        ceil_value = floor_value + 1;\n    } else {\n        ceil_value = floor_value - 1;\n    }\n\n    // Calculate differences between the number and its floor/ceiling values\n    float diff_floor = std::abs(num - floor_value);\n    float diff_ceil = std::abs(num - ceil_value);\n\n    // Determine closer value or round away from zero if equidistant\n    if (diff_floor < diff_ceil) {\n        return floor_value;\n    } else if (diff_ceil < diff_floor) {\n        return ceil_value;\n    } else {\n        // If both differences are equal, round away from zero\n        return num > 0 ? ceil_value : floor_value;\n    }\n}\n\n", "py_code": "def closest_integer(value):\n    num = float(value)\n    floor_value = int(num)\n    ceil_value = int(num) + 1 if num > 0 else int(num) - 1\n    \n    if abs(num - floor_value) < abs(num - ceil_value):\n        return floor_value\n    elif abs(num - floor_value) > abs(num - ceil_value):\n        return ceil_value\n    else:\n        return ceil_value if num > 0 else floor_value\n```\n\n", "py_summary": "The Python function `closest_integer` takes a string input representing a number and returns the closest integer to that number, rounding away from zero when necessary. Here's a detailed breakdown of how it works:\n\n1. **Convert the Input String to a Float**: The input string is converted to a floating-point number using `float(value)`.\n\n2. **Determine Floor and Ceiling Values**:\n   - The floor value (`floor_value`) is obtained by converting the float back to an integer with `int(num)`.\n   - The ceiling value (`ceil_value`) is determined based on whether the number is positive or negative:\n     - If the number is positive, the ceiling value is `int(num) + 1`.\n     - If the number is negative, the ceiling value is `int(num) - 1`.\n\n3. **Calculate Differences**:\n   - The function calculates the absolute differences between the float number and both the floor and ceiling values.\n   \n4. **Determine Closer Value**:\n   - If the difference between the number and its floor value is smaller than the difference with the ceiling value, return the floor value.\n   - If the difference between the number and its ceiling value is smaller, return the ceiling value.\n   - If both differences are equal (i.e., the number is equidistant from two integers), round away from zero:\n     - For positive numbers, return the ceiling value.\n     - For negative numbers, return the floor value.\n\nThis approach ensures that the function correctly rounds to the nearest integer and handles cases where rounding should be away from zero as specified."}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current_stones = n;\n\n    for (int level = 0; level < n; ++level) {\n        pile.push_back(current_stones);\n        \n        if (n % 2 == 0) {\n            // If n is even, add the next even number.\n            current_stones += 2;\n        } else {\n            // If n is odd, add the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n", "py_code": "def make_a_pile(n):\n    pile = []\n    current_stones = n\n    \n    for level in range(n):\n        pile.append(current_stones)\n        \n        if n % 2 == 0:\n            # If n is even, add the next even number.\n            current_stones += 2\n        else:\n            # If n is odd, add the next odd number.\n            current_stones += 2\n    \n    return pile\n```\n\n", "py_summary": "The Python function `make_a_pile` generates a vector representing the number of stones in each level of a pile with `n` levels. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - An empty list `pile` is created to store the number of stones at each level.\n   - The variable `current_stones` is initialized to `n`, representing the number of stones in the first level.\n\n2. **Loop through levels**:\n   - A loop runs from 0 to `n-1`, corresponding to each level of the pile (indexing starts from 0).\n   \n3. **Add current stones to pile**:\n   - For each iteration, the value of `current_stones` is appended to the list `pile`.\n\n4. **Determine next number of stones**:\n   - If `n` is even (`n % 2 == 0`), the function adds 2 to `current_stones` to get the next even number.\n   - If `n` is odd, it also adds 2 to `current_stones`, but since adding 2 to an odd number results in an even number, this correctly gives the next odd number after the current one.\n\n5. **Return result**:\n   - After completing all iterations, the function returns the list `pile`.\n\nThis approach ensures that each level has the correct number of stones based on whether `n` is initially even or odd and maintains the sequence of adding 2 to get the next required number for each subsequent level.\n\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces for uniformity in splitting\n    for (char& c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n\n    // Split the string by spaces and store the result in a vector of strings\n    istringstream iss(s);\n    vector<string> words;\n    string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n", "py_code": "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    # Replace commas with spaces for uniformity in splitting\n    s = s.replace(',', ' ')\n    # Split the string by spaces and return as a list of strings\n    return s.split()\n```\n\n", "py_summary": "The Python code defines a function `words_string` that takes a single string `s` as input and returns a vector (list in Python) of words extracted from the string. Here's a detailed analysis:\n\n1. **Replace Commas with Spaces**: The first line replaces all commas in the input string `s` with spaces to ensure uniformity when splitting the string.\n2. **Split the String**: The `split()` method is used to split the modified string into words based on whitespace characters (spaces, tabs, etc.). This method returns a list of substrings that were separated by whitespace.\n3. **Return Result**: Finally, the function returns the list of words.\n\nThis approach ensures that both commas and spaces are treated uniformly for splitting the input string into individual words.\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the larger number and move downwards\n    for (int num = y; num >= x; --num) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n\n    return -1;\n}\n", "py_code": "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    \n    # Start from the larger number and move downwards\n    for num in range(y, x-1, -1):\n        if num % 2 == 0:\n            return num\n    \n    return -1\n```\n\n", "py_summary": "The Python function `choose_num` takes two positive integers `x` and `y` as input and returns the largest even integer within the inclusive range `[x, y]`. If no such number exists in the given range, it returns `-1`.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initial Check**: The function first checks if `x` is greater than `y`. If this condition is true, it means there are no numbers between `x` and `y`, so it immediately returns `-1`.\n\n2. **Iterate in Reverse Order**: Starting from `y`, the function iterates downwards to `x` (inclusive). This ensures that we check the largest possible values first.\n\n3. **Check for Even Numbers**: For each number in this range, the function checks if the number is even by using the modulus operator (`num % 2 == 0`). If an even number is found, it returns that number immediately since it's the largest even number within the given range.\n\n4. **Return -1 if No Even Number Found**: If no even numbers are found in the range `[x, y]`, the function will return `-1`.\n\nThis approach ensures that the function efficiently finds and returns the largest even integer within the specified range or `-1` if no such number exists."}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m using arithmetic series formula\n    long total_sum = (m - n + 1) * (n + m) / 2;\n\n    // Calculate the average and round down to the nearest integer\n    int rounded_avg = total_sum / (m - n + 1);\n\n    // Convert the rounded average to binary\n    std::string binary_representation;\n    if (rounded_avg == 0) {\n        binary_representation = \"0\";\n    } else {\n        while (rounded_avg > 0) {\n            binary_representation = std::to_string(rounded_avg % 2) + binary_representation;\n            rounded_avg /= 2;\n        }\n    }\n\n    return binary_representation;\n}\n", "py_code": "def rounded_avg(n, m):\n    if n > m:\n        return \"-1\"\n    \n    # Calculate the sum of integers from n to m using arithmetic series formula\n    total_sum = (m - n + 1) * (n + m) // 2\n    \n    # Calculate the average and round down to the nearest integer\n    rounded_avg = total_sum // (m - n + 1)\n    \n    # Convert the rounded average to binary\n    return bin(rounded_avg)[2:]\n```\n\n", "py_summary": "The Python function `rounded_avg` calculates the average of integers from `n` to `m`, rounds it down to the nearest integer, and converts that integer to its binary representation. Here's a detailed breakdown:\n\n1. **Check if n is greater than m**: The function first checks whether `n > m`. If this condition is true, it returns \"-1\" as specified in the problem statement.\n\n2. **Calculate the sum of integers from n to m**:\n   - The formula for the sum of an arithmetic series is used: \n     \\[\n     \\text{Sum} = (m - n + 1) \\times \\frac{(n + m)}{2}\n     \\]\n   - This can be simplified in Python using integer division (`//`) to ensure that the result is an integer:\n     \\[\n     \\text{total_sum} = (m - n + 1) * (n + m) // 2\n     \\]\n\n3. **Calculate the average**:\n   - The average of the integers from `n` to `m` is given by dividing the total sum by the number of terms (`m - n + 1`):\n     \\[\n     \\text{rounded_avg} = \\text{total_sum} // (m - n + 1)\n     \\]\n   - The use of integer division (`//`) ensures that the result is rounded down to the nearest integer.\n\n4. **Convert the rounded average to binary**:\n   - The `bin` function in Python converts an integer to its binary representation as a string, prefixed with \"0b\". To remove this prefix and get just the binary digits, we use slicing (`[2:]`).\n\n5. **Return the result**: Finally, the function returns the binary representation of the rounded average.\n\nThis approach ensures that the solution is efficient and adheres to the problem requirements."}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number has no even digits\nbool has_no_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            return false;\n        }\n        n /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    // Filter out numbers that have no even digits\n    vector<int> result;\n    for (int num : x) {\n        if (has_no_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    def has_no_even_digit(n):\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return False\n            n //= 10\n        return True\n    \n    result = [num for num in x if has_no_even_digit(num)]\n    result.sort()\n    return result\n```\n\n", "py_summary": "The Python code defines a function `unique_digits` that takes a list of positive integers and returns a sorted list of all elements that do not contain any even digits.\n\n1. **Helper Function**: The helper function `has_no_even_digit` checks if a given number does not have any even digits.\n   - It iterates through each digit of the number by repeatedly taking the last digit (`n % 10`) and checking if it is odd (`digit % 2 != 0`).\n   - If an even digit is found, the function returns `False`.\n   - If no even digits are found after iterating through all digits, the function returns `True`.\n\n2. **Filtering**: The main function uses a list comprehension to filter out numbers from the input list that do not have any even digits using the helper function.\n   \n3. **Sorting**: After filtering, the resulting list is sorted in increasing order.\n\n4. **Return Result**: Finally, the sorted list is returned as the result.\n\nThis approach ensures that only numbers without any even digits are included in the final output and that these numbers are returned in a sorted manner.\n\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Mapping of digits to their corresponding names\n    map<int, string> digit_names = {\n        {1, \"One\"},\n        {2, \"Two\"},\n        {3, \"Three\"},\n        {4, \"Four\"},\n        {5, \"Five\"},\n        {6, \"Six\"},\n        {7, \"Seven\"},\n        {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array in ascending order\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each digit to its corresponding name\n    vector<string> result;\n    for (int num : filtered_arr) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def by_length(arr):\n    # Define a mapping from digits 1-9 to their corresponding names\n    digit_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter out numbers that are not between 1 and 9\n    filtered_arr = [x for x in arr if 1 <= x <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Convert each number to its corresponding name using the mapping\n    result = [digit_names[num] for num in reversed_arr if num in digit_names]\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `by_length` that processes an input list of integers and returns a new list where each integer between 1 and 9 is mapped to its corresponding word representation after sorting and reversing the filtered list. Here's a detailed breakdown:\n\n1. **Mapping Definition**: A dictionary `digit_names` maps integers from 1 to 9 to their respective string representations (\"One\", \"Two\", ..., \"Nine\").\n\n2. **Filtering**: The code filters out any numbers in the input array that are not between 1 and 9, using a list comprehension.\n\n3. **Sorting**: The filtered list is sorted in ascending order using Python's built-in `sorted` function.\n\n4. **Reversing**: The sorted list is reversed to get the desired order for mapping.\n\n5. **Mapping Conversion**: Each number in the reversed list is converted to its corresponding word representation by looking up the dictionary `digit_names`. This step ensures that only valid keys (1 through 9) are used, and any other numbers are ignored.\n\n6. **Return Result**: The function returns the resulting list of string representations.\n\nThis process effectively handles cases where the input list might be empty or contain invalid numbers outside the range [1, 9]."}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function to calculate factorial\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate sum of numbers from 1 to i\nint sum_of_numbers(int i) {\n    return (i * (i + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if (index % 2 == 0) {\n            result[i] = factorial(index);\n        } else {\n            result[i] = sum_of_numbers(index);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef factorial(i: int) -> int:\n    if i == 0 or i == 1:\n        return 1\n    result = 1\n    for j in range(2, i + 1):\n        result *= j\n    return result\n\ndef sum_of_numbers(i: int) -> int:\n    return (i * (i + 1)) // 2\n\ndef f(n: int) -> List[int]:\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_of_numbers(i))\n    return result\n```\n\n", "py_summary": "The Python code defines a function `f` that takes an integer `n` as input and returns a vector (list) of size `n`. The value at each index `i` in this list is determined based on whether `i` is even or odd:\n\n1. **Factorial Calculation**:\n   - A helper function `factorial(i)` calculates the factorial of an integer `i`, which is the product of all positive integers up to `i`.\n   - If `i` is 0 or 1, the factorial is defined as 1.\n   - For other values of `i`, a loop multiplies numbers from 2 to `i`.\n\n2. **Sum Calculation**:\n   - A helper function `sum_of_numbers(i)` calculates the sum of all integers from 1 to `i`.\n   - The formula used for this calculation is `(i * (i + 1)) // 2`, which is an efficient way to compute the sum.\n\n3. **Main Function `f`**:\n   - Initializes an empty list `result`.\n   - Iterates over a range from 1 to `n` inclusive.\n   - For each index `i`, checks if it is even or odd:\n     - If `i` is even, appends the factorial of `i` to `result`.\n     - If `i` is odd, appends the sum of numbers from 1 to `i` to `result`.\n\nThe function finally returns the list `result` containing the computed values for each index.\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str_num = std::to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n\n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return [even_count, odd_count]\n```\n\n", "py_summary": "The Python code defines a function `even_odd_palindrome` that takes an integer `n` and returns a list containing the counts of even and odd palindromic integers within the range from 1 to `n`, inclusive.\n\nHere's a detailed breakdown:\n\n1. **Helper Function (`is_palindrome`)**:\n   - This function checks if a given number is a palindrome.\n   - It converts the integer to a string, reverses it, and compares it with the original string representation of the number.\n\n2. **Main Function (`even_odd_palindrome`)**:\n   - Initializes two counters: `even_count` for even palindromic numbers and `odd_count` for odd palindromic numbers.\n   - Iterates through all integers from 1 to `n`.\n   - For each integer, it checks if the number is a palindrome using the `is_palindrome` function.\n   - If the number is a palindrome, it increments either `even_count` or `odd_count` based on whether the number is even or odd.\n\n3. **Return Statement**:\n   - Returns a list containing the counts of even and odd palindromic numbers in that order.\n\nThis approach ensures that all integers within the specified range are checked for being palindromes, and their parity (even/odd) is correctly counted.\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function declaration\nint sum_of_digits(int num);\n\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Helper function definition\nint sum_of_digits(int num) {\n    if (num == 0) return 0;\n    \n    bool is_negative = num < 0;\n    int digit_sum = 0;\n    \n    while (num != 0) {\n        int digit = abs(num % 10);\n        if (is_negative && (num / 10) != 0) {\n            digit *= -1;\n        }\n        digit_sum += digit;\n        num /= 10;  // Integer division to process the next digit\n    }\n    \n    return digit_sum;\n}\n", "py_code": "from typing import List\n\ndef count_nums(n: List[int]) -> int:\n    def sum_of_digits(num):\n        if num == 0:\n            return 0\n        is_negative = num < 0\n        digit_sum = 0\n        while num != 0:\n            digit = abs(num % 10)\n            if is_negative and (num // 10) != 0:\n                digit *= -1\n            digit_sum += digit\n            num //= 10\n        return digit_sum\n\n    count = 0\n    for number in n:\n        if sum_of_digits(number) > 0:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python code defines a function `count_nums` that takes a list of integers and returns the number of elements whose sum of digits is greater than zero. Here's a detailed breakdown:\n\n1. **Helper Function (`sum_of_digits`)**:\n   - This helper function calculates the sum of signed digits for a given integer.\n   - It first checks if the input number `num` is zero, in which case it returns 0 immediately since the sum of digits for zero is zero.\n   - The variable `is_negative` is set to True if the number is negative.\n   - A loop runs until all digits are processed. In each iteration:\n     - It calculates the absolute value of the last digit using `abs(num % 10)`.\n     - If the number is negative and not zero, it multiplies the digit by -1 to account for the signed nature of the first digit.\n     - The digit sum (`digit_sum`) is updated accordingly.\n     - The number is then divided by 10 (integer division) to process the next digit.\n\n2. **Main Function (`count_nums`)**:\n   - Initializes a counter `count` to zero.\n   - Iterates through each element in the input list `n`.\n   - For each number, it calls the helper function `sum_of_digits` and checks if the returned sum is greater than 0.\n   - If the condition is met, increments the count by one.\n\n3. **Return Statement**:\n   - Finally, returns the total count of numbers whose sum of digits is greater than zero.\n\nThis approach ensures that negative numbers are handled correctly by considering their signed digits and counting only those elements with a positive digit sum.\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Check if the vector is empty\n    if (arr.empty()) return true;\n    \n    int N = arr.size();\n    int start_index = -1;  // Initialize to indicate no out-of-order element found\n    \n    // Find the first index where an element is smaller than its preceding element\n    for (int i = 1; i < N; ++i) {\n        if (arr[i] < arr[i-1]) {\n            start_index = i;\n            break;\n        }\n    }\n\n    // If no out-of-order element found, the vector is already sorted\n    if (start_index == -1) return true;\n\n    // Verify that all subsequent elements are in non-decreasing order\n    for (int i = start_index + 1; i < N; ++i) {\n        if (arr[i] < arr[i-1]) return false;\n    }\n\n    // Check if rotating the vector starting from start_index results in a sorted vector\n    bool is_sorted = true;\n    for (int i = start_index, j = 0; j < N && is_sorted; ++j) {\n        int k = (i + j) % N;\n        if (j > 0 && arr[k] < arr[(k - 1 + N) % N]) is_sorted = false;\n    }\n\n    return is_sorted;\n}\n", "py_code": "def move_one_ball(arr):\n    if not arr:\n        return True\n    \n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            break\n    else:\n        # If no element is out of order, the array is already sorted.\n        return True\n\n    start_index = i\n    # Check if rotating from this index to the end and then back to the beginning results in a sorted array.\n    for j in range(start_index + 1, n):\n        if arr[j] < arr[j - 1]:\n            return False\n    \n    # Verify that the rotated array is non-decreasing by comparing the last element with the first element.\n    return arr[0] >= arr[-1]\n```\n\n", "py_summary": "The Python function `move_one_ball` checks if a given list of integers can be sorted in non-decreasing order by performing right shift operations. Here's a detailed analysis:\n\n1. **Check for Empty List**:\n   - If the input list is empty, the function immediately returns `True`. An empty list is considered to be trivially sortable.\n\n2. **Identify Out-of-Order Element**:\n   - The function iterates through the list starting from the second element (index 1) and checks if any element is smaller than its preceding element.\n   - If such an out-of-order element is found, it breaks the loop and stores the index of this element in `start_index`.\n\n3. **Check for Sorted Subsequent Elements**:\n   - After identifying the first out-of-order element at index `i`, the function checks if all subsequent elements are in non-decreasing order.\n   - If any element after `i` is found to be smaller than its preceding element, it returns `False` because a right shift operation cannot sort this list.\n\n4. **Verify Full Rotation**:\n   - After confirming that the subsequence from `start_index + 1` to the end of the list is non-decreasing, the function checks if rotating the entire list by starting at `start_index` and ending with the first element results in a sorted list.\n   - This check involves comparing the last element of the original list (which becomes the new first element after rotation) with the first element of the original list.\n\nIf all these conditions are satisfied, the function returns `True`, indicating that it is possible to sort the list by performing right shift operations. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether a given list can be sorted through rotations and handles edge cases such as empty lists or already sorted lists efficiently."}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string exchange(std::vector<int> lst1, std::vector<int> lst2) {\n    // Count odd numbers in lst1\n    int odd_count = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++odd_count;\n        }\n    }\n\n    // Count even numbers in lst2\n    int even_count = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++even_count;\n        }\n    }\n\n    // Check if it is possible to exchange elements\n    if (odd_count > even_count) {\n        return \"NO\";\n    } else {\n        return \"YES\";\n    }\n}\n", "py_code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    # Count odd numbers in lst1 and even numbers in lst2\n    odd_count = sum(1 for num in lst1 if num % 2 != 0)\n    even_count = sum(1 for num in lst2 if num % 2 == 0)\n\n    # If there are more odd numbers in lst1 than even numbers in lst2, return \"NO\"\n    if odd_count > even_count:\n        return \"NO\"\n\n    # Otherwise, it is possible to exchange elements to make all elements of lst1 even\n    return \"YES\"\n```\n\n", "py_summary": "The Python code defines a function `exchange` that takes two lists of integers (`lst1` and `lst2`) as input and determines whether it is possible to exchange elements between them such that all elements in `lst1` become even.\n\nHere's an analysis of the solution:\n\n1. **Count Odd Numbers in `lst1`:**\n   - The function iterates through `lst1` and counts how many odd numbers are present using a generator expression inside the `sum()` function.\n   \n2. **Count Even Numbers in `lst2`:**\n   - Similarly, it iterates through `lst2` to count how many even numbers are present.\n\n3. **Check Feasibility of Exchange:**\n   - If the number of odd numbers in `lst1` is greater than the number of even numbers in `lst2`, it is impossible to exchange elements such that all elements in `lst1` become even, and the function returns `\"NO\"`.\n   \n4. **Return \"YES\":**\n   - Otherwise, if there are enough even numbers in `lst2` to replace all odd numbers in `lst1`, the function returns `\"YES\"`.\n\nThis approach ensures that we can determine whether it is possible to make all elements of `lst1` even by exchanging with elements from `lst2`.\n\n"}
{"task_id": "CPP/111", "generation": "#include <string>\n#include <map>\n#include <vector>\n\nstd::map<char, int> histogram(std::string test) {\n    std::map<char, int> letter_count;\n    int max_count = 0;\n\n    // Iterate through each character in the string\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            letter_count[c]++;\n            max_count = std::max(max_count, letter_count[c]);\n        }\n    }\n\n    // Filter results to include only letters with the maximum count\n    std::map<char, int> result;\n    for (const auto& entry : letter_count) {\n        if (entry.second == max_count) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n", "py_code": "from collections import defaultdict\n\ndef histogram(test):\n    letter_count = defaultdict(int)\n    max_count = 0\n    \n    for char in test:\n        if char != ' ':  # Skip spaces\n            letter_count[char] += 1\n            max_count = max(max_count, letter_count[char])\n    \n    result = {letter: count for letter, count in letter_count.items() if count == max_count}\n    return result\n```\n\n", "py_summary": "The Python code defines a function `histogram` that takes a string as input and returns a dictionary containing the letters with the highest frequency along with their counts. Here's a detailed analysis of how it works:\n\n1. **Initialization**:\n   - A `defaultdict` named `letter_count` is initialized to keep track of the count of each letter.\n   - An integer variable `max_count` is initialized to 0 to store the maximum occurrence of any letter.\n\n2. **Iterate through the string**:\n   - The function iterates over each character in the input string `test`.\n   - If the character is not a space, it increments its count in `letter_count`.\n\n3. **Update max_count**:\n   - During each iteration, `max_count` is updated to be the maximum of itself and the current letter's count.\n\n4. **Filter results**:\n   - After counting all letters, a dictionary comprehension creates a new dictionary that includes only those letters whose counts match `max_count`.\n\n5. **Return result**:\n   - The function returns this filtered dictionary containing the most frequent letters and their counts.\n\nThis approach ensures that if multiple letters have the same highest frequency, they are all included in the final result. If no characters are present (i.e., the string is empty), an empty dictionary will be returned."}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome = true;\n    int left = 0, right = result.length() - 1;\n    while (left < right) {\n        if (result[left] != result[right]) {\n            is_palindrome = false;\n            break;\n        }\n        left++;\n        right--;\n    }\n\n    // Return the result string and whether it's a palindrome\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n", "py_code": "def reverse_delete(s: str, c: str) -> list:\n    # Remove all characters in s that are present in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return [result, \"True\" if is_palindrome else \"False\"]\n```\n\n", "py_summary": "The Python function `reverse_delete` takes two string parameters: `s` and `c`. The goal of this function is to remove all characters from `s` that are present in `c`, and then check if the resulting string is a palindrome.\n\nHere's a step-by-step breakdown of how the code works:\n\n1. **Remove Characters**: \n   - A list comprehension is used to iterate over each character in `s`.\n   - For each character, it checks whether the character is not present in `c` using the condition `char not in c`.\n   - If the character is not in `c`, it includes that character in the resulting string.\n   - The `join` method concatenates these characters to form the final string after removing unwanted characters.\n\n2. **Check Palindrome**:\n   - The function checks if the resulting string is a palindrome by comparing the string with its reverse (`result[::-1]`).\n   - If they are equal, it means the string is a palindrome and `\"True\"` is returned.\n   - Otherwise, `\"False\"` is returned.\n\n3. **Return Result**:\n   - Finally, the function returns a list containing two elements: the resulting string after removing characters and the boolean value indicating whether the result is a palindrome or not.\n\nThis approach ensures that all specified characters are removed from `s` and checks for palindromicity efficiently."}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int count_odd = 0;\n        \n        // Count the number of odd digits in the string\n        for (char digit : str) {\n            if ((digit - '0') % 2 != 0) {\n                count_odd++;\n            }\n        }\n\n        // Construct the output string based on the count of odd digits\n        std::string output_string = \"the number of odd elements \";\n        output_string += std::to_string(count_odd);\n        output_string += \"n the str\";\n        output_string += std::to_string(count_odd);\n        output_string += \"ng \";\n        output_string += std::to_string(count_odd);\n        output_string += \" of the \";\n        output_string += std::to_string(count_odd);\n        output_string += \"nput.\";\n        \n        // Append the constructed string to the result vector\n        result.push_back(output_string);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for string in lst:\n        count_odd = sum(1 for digit in string if int(digit) % 2 != 0)\n        output_string = f'the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.'\n        result.append(output_string)\n    return result\n```\n\n", "py_summary": "The Python function `odd_count` takes a list of strings as input and returns a new list of strings based on specific rules. Here's an analysis of how it works:\n\n1. **Initialization**: The function initializes an empty list called `result`, which will store the output strings.\n\n2. **Iterate through each string in the input list**:\n   - For each string in the input list, the function counts the number of odd digits.\n   - It uses a generator expression inside the `sum` function to iterate over each digit in the string and check if it is an odd number (i.e., `int(digit) % 2 != 0`). The sum of all such occurrences gives the count of odd digits.\n\n3. **Construct output strings**:\n   - For each input string, a new formatted string is created using f-strings.\n   - This formatted string follows a specific pattern: `\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\"`, where `{count_odd}` is replaced by the actual count of odd digits.\n\n4. **Append to result list**:\n   - The constructed string is appended to the `result` list.\n\n5. **Return the final result**:\n   - After processing all input strings, the function returns the `result` list containing the formatted output strings for each input string.\n\nThis approach ensures that the output strings are correctly generated based on the count of odd digits in each input string and follows the specified format.\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <limits>\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    long long current_min = std::numeric_limits<long long>::max();\n    long long temp_sum = 0;\n\n    for (auto num : nums) {\n        temp_sum += num;\n        \n        if (temp_sum < current_min) {\n            current_min = temp_sum;\n        }\n        \n        // If the temporary sum becomes positive, reset it to zero\n        if (temp_sum > 0) {\n            temp_sum = 0;\n        }\n    }\n\n    return current_min;\n}\n", "py_code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    current_min = float('inf')\n    temp_sum = 0\n    \n    for num in nums:\n        temp_sum += num\n        if temp_sum < current_min:\n            current_min = temp_sum\n        \n        # If the temporary sum becomes positive, reset it to zero since any subarray starting from this point will have a smaller or equal sum if we start fresh.\n        if temp_sum > 0:\n            temp_sum = 0\n    \n    return current_min\n```\n\n", "py_summary": "The Python code defines a function `minSubArraySum` that calculates the minimum sum of any non-empty sub-vector within a given list of integers (`nums`). Here's a detailed breakdown of how it works:\n\n1. **Initialization**:\n   - `current_min`: This variable is initialized to positive infinity (`float('inf')`) and will store the smallest sub-array sum found so far.\n   - `temp_sum`: This variable keeps track of the cumulative sum of elements in the current sub-vector being considered.\n\n2. **Iterate through the list**:\n   - For each element `num` in `nums`, add it to `temp_sum`.\n   \n3. **Update minimum sum**:\n   - If `temp_sum` is less than `current_min`, update `current_min` with `temp_sum`.\n\n4. **Reset temporary sum if positive**:\n   - If `temp_sum` becomes greater than 0, reset `temp_sum` to 0 because starting a new sub-vector from the current element will yield a smaller or equal cumulative sum.\n\n5. **Return result**:\n   - After iterating through all elements in `nums`, return `current_min`.\n\nThis approach ensures that we efficiently find the minimum possible sum of any non-empty sub-vector by leveraging Kadane's algorithm for finding the smallest sum subarray, which operates with linear time complexity \\(O(n)\\).\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_water_units = 0;\n\n    // Sum up all water units in the grid\n    for (const auto& row : grid) {\n        total_water_units += std::accumulate(row.begin(), row.end(), 0);\n    }\n\n    // Calculate the number of times buckets need to be lowered\n    return (total_water_units + capacity - 1) / capacity;\n}\n", "py_code": "def max_fill(grid, capacity):\n    total_water_units = sum(sum(row) for row in grid)\n    return (total_water_units + capacity - 1) // capacity\n```\n\n", "py_summary": "The Python function `max_fill` calculates the number of times buckets need to be lowered to empty all the wells given a grid and bucket capacity. Here's an analysis of how it works:\n\n1. **Summing Water Units**: The function first computes the total number of water units in the entire grid by summing up the values (which represent water units) across all rows.\n   ```python\n   total_water_units = sum(sum(row) for row in grid)\n   ```\n   This line iterates through each row and sums up the 1s (representing water units), then sums these totals to get `total_water_units`.\n\n2. **Calculating Bucket Operations**: The function calculates how many times buckets need to be lowered by dividing the total number of water units by the bucket capacity, rounding up if there is any remainder.\n   ```python\n   return (total_water_units + capacity - 1) // capacity\n   ```\n   This expression effectively performs integer division and rounds up. Adding `capacity - 1` ensures that any remaining fraction of a bucket gets rounded up to the next whole number.\n\nIn summary, this function efficiently computes the total water units in the grid and then determines how many times buckets need to be lowered based on the given capacity, ensuring all wells are emptied.\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of ones in the binary representation of an integer.\nint count_ones(int n) {\n    if (n >= 0) {\n        int count = 0;\n        for (; n > 0; n >>= 1) {\n            count += n & 1;\n        }\n        return count;\n    } else {\n        // For negative numbers, convert to positive equivalent and count ones.\n        unsigned int pos_n = -n - 1;\n        int count = 0;\n        for (; pos_n > 0; pos_n >>= 1) {\n            count += pos_n & 1;\n        }\n        return count;\n    }\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on a custom key that includes the number of ones and absolute value.\n    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n        \n        if (count_a == count_b) {\n            return abs(a) < abs(b);\n        }\n        \n        return count_a < count_b;\n    });\n    \n    return arr;\n}\n", "py_code": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    def count_ones(n):\n        # Count the number of ones in the binary representation of n.\n        return bin(n).count('1') if n >= 0 else bin(-n - 1).count('1')\n\n    arr.sort(key=lambda x: (count_ones(x), abs(x)))\n    return arr\n```\n\n", "py_summary": "The Python code defines a function `sort_array` that sorts an array of integers based on the number of ones in their binary representation and then by their decimal value if the number of ones is the same.\n\n1. **Counting Ones**: The helper function `count_ones(n)` calculates the number of ones in the binary representation of an integer `n`. For non-negative numbers, it uses `bin(n).count('1')` to count the ones directly. For negative numbers, it converts them to their positive equivalent using `-n - 1` (since Python's `bin()` function for negative integers includes a leading '-'), and then counts the ones.\n\n2. **Sorting**: The main function sorts the array using the `sort` method with a custom key. This key is a tuple `(count_ones(x), abs(x))`, where:\n   - `count_ones(x)` provides the number of ones in the binary representation.\n   - `abs(x)` ensures that if two numbers have the same number of ones, they are sorted by their absolute decimal values.\n\nThis approach ensures that the array is first sorted based on the number of ones and then by the magnitude of the numbers for those with an equal number of ones.\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    // Define vowels for reference\n    string vowels = \"aeiouAEIOU\";\n    \n    vector<string> words_with_n_consonants;\n    \n    // Split the input string into individual words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    \n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = 0;\n        for (char c : word) {\n            if (isalpha(c) && vowels.find(c) == string::npos) {\n                consonant_count++;\n            }\n        }\n        \n        // Check if the word has exactly n consonants and add it to the result vector\n        if (consonant_count == n) {\n            words_with_n_consonants.push_back(word);\n        }\n        \n        // Move to the next word\n        start = end + 1;\n        end = s.find(' ', start);\n    }\n    \n    // Check for the last word in the string\n    string last_word = s.substr(start, end - start);\n    int consonant_count_last = 0;\n    for (char c : last_word) {\n        if (isalpha(c) && vowels.find(c) == string::npos) {\n            consonant_count_last++;\n        }\n    }\n    \n    if (consonant_count_last == n) {\n        words_with_n_consonants.push_back(last_word);\n    }\n\n    return words_with_n_consonants;\n}\n", "py_code": "from typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    vowels = \"aeiouAEIOU\"\n    words_with_n_consonants = []\n    \n    for word in s.split():\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        \n        if consonant_count == n:\n            words_with_n_consonants.append(word)\n            \n    return words_with_n_consonants\n```\n\n", "py_summary": "The Python code defines a function `select_words` that takes a string `s` and an integer `n` as input and returns a list of words from the string `s` that contain exactly `n` consonants. Here's a detailed breakdown of how it works:\n\n1. **Initialization**:\n   - A set of vowels is defined to help identify consonants.\n   - An empty list `words_with_n_consonants` is initialized to store the words that meet the criteria.\n\n2. **Splitting the String into Words**:\n   - The input string `s` is split into individual words using the `split()` method, which splits the string at each space and returns a list of words.\n\n3. **Counting Consonants in Each Word**:\n   - For each word in the list, the function counts the number of consonants by iterating through each character.\n   - The condition `char.isalpha() and char not in vowels` checks if the character is an alphabet letter and not a vowel, thereby identifying it as a consonant.\n   - The `sum()` function calculates the total count of such characters for each word.\n\n4. **Filtering Words**:\n   - If the count of consonants in a word matches the given integer `n`, that word is added to the list `words_with_n_consonants`.\n\n5. **Returning the Result**:\n   - After processing all words, the function returns the list `words_with_n_consonants` containing only those words with exactly `n` consonants.\n\nThis approach ensures that the function accurately identifies and collects words based on their consonant count while maintaining the order in which they appear in the input string."}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    int closest_vowel_index = -1;\n    \n    for (int i = word.length() - 2; i > 0; --i) {  // Iterate from second last character to first character\n        if (vowels.find(word[i]) == vowels.end()) {  // Skip consonants\n            continue;\n        }\n        \n        bool left_consonant = (i > 0 && vowels.find(word[i-1]) == vowels.end());\n        bool right_consonant = (i < word.length() - 1 && vowels.find(word[i+1]) == vowels.end());\n        \n        if (left_consonant && right_consonant) {\n            closest_vowel_index = i;\n            break;\n        }\n    }\n    \n    return closest_vowel_index != -1 ? string(1, word[closest_vowel_index]) : \"\";\n}\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    closest_vowel_index = -1\n    \n    for i in range(len(word) - 2, 0, -1):  # Start from second last character and go to the first character\n        if word[i] not in vowels:\n            continue\n        \n        left_char = word[i-1]\n        right_char = word[i+1]\n        \n        if left_char not in vowels and right_char not in vowels:\n            closest_vowel_index = i\n            break\n    \n    return word[closest_vowel_index] if closest_vowel_index != -1 else \"\"\n```\n\n", "py_summary": "The Python function `get_closest_vowel` is designed to find the closest vowel that stands between two consonants from the right side of a given word. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - The set of vowels (`vowels`) includes both lowercase and uppercase English vowels.\n   - `closest_vowel_index` is initialized to `-1`, which will be used to store the index of the closest vowel that meets the condition.\n\n2. **Iterate from Right to Left**:\n   - The function iterates through the word starting from the second last character (index `len(word) - 2`) and moving towards the first character (index `1`).\n   - This ensures that we do not consider vowels at the beginning or end of the word.\n\n3. **Check for Vowel**:\n   - For each character in this range, it checks if the character is a vowel.\n   - If the character is a consonant, the loop continues to the next iteration.\n\n4. **Check Surrounding Characters**:\n   - Once a vowel is found, the function checks its neighboring characters (left and right).\n   - It verifies that both neighbors are consonants by checking if they are not in the `vowels` set.\n   \n5. **Store Closest Vowel Index**:\n   - If both neighbors of the current vowel are consonants, it sets `closest_vowel_index` to the index of this vowel and breaks out of the loop.\n\n6. **Return Result**:\n   - After exiting the loop, if a valid vowel was found (`closest_vowel_index != -1`), the function returns that vowel.\n   - If no such vowel is found, it returns an empty string.\n\nThis approach ensures that we find the closest vowel from the right side of the word that stands between two consonants."}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n\nbool is_balanced(const std::string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else if (c == ')') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string first_option = lst[0] + lst[1];\n    std::string second_option = lst[1] + lst[0];\n\n    if (is_balanced(first_option) || is_balanced(second_option)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "py_code": "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    def is_balanced(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    first_option = lst[0] + lst[1]\n    second_option = lst[1] + lst[0]\n\n    if is_balanced(first_option) or is_balanced(second_option):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "The Python code defines a function `match_parens` that takes a list of two strings as input and checks if it is possible to concatenate these strings in any order such that the resulting string has balanced parentheses.\n\n1. **Helper Function (`is_balanced`)**:\n   - This helper function checks whether a given string `s` has balanced parentheses.\n   - It initializes a balance counter to zero.\n   - For each character in the string, it increments the balance counter for an opening parenthesis '(' and decrements it for a closing parenthesis ')'.\n   - If at any point the balance counter becomes negative, it means there is a closing parenthesis without a matching opening parenthesis before it, so the function returns `False`.\n   - After processing all characters, if the balance counter is zero, the string has balanced parentheses, and the function returns `True`.\n\n2. **Main Function (`match_parens`)**:\n   - The main function takes a list of two strings as input.\n   - It generates both possible concatenations: `lst[0] + lst[1]` and `lst[1] + lst[0]`.\n   - It checks if either of these concatenated strings is balanced using the `is_balanced` helper function.\n   - If either concatenation results in a balanced string, it returns \"Yes\".\n   - If neither concatenation results in a balanced string, it returns \"No\".\n\nThis approach ensures that all possible ways to concatenate the two input strings are checked for balance."}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Change the parameter type from vector<int>& to const vector<int>&\nvector<int> maximum(const vector<int>& arr, int k) {\n    // Make a copy of the input vector since we need mutable iterators for sorting\n    vector<int> sorted_arr = arr;\n    \n    // Sort in descending order and take top k elements\n    sort(sorted_arr.begin(), sorted_arr.end(), greater<int>());\n    \n    // Take the first k elements from the sorted array\n    vector<int> top_k_elements(sorted_arr.begin(), sorted_arr.begin() + k);\n    \n    // Return these elements in ascending order\n    sort(top_k_elements.begin(), top_k_elements.end());\n    \n    return top_k_elements;\n}\n\n", "py_code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    # Sort the array in descending order and take the top k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return these elements in ascending order\n    return sorted(sorted_arr)\n```\n\n", "py_summary": "The Python code defines a function `maximum` that takes an array of integers and a positive integer `k`, and returns a sorted vector containing the maximum `k` numbers from the input array in ascending order.\n\n1. **Sorting in Descending Order**: The first step is to sort the entire array in descending order using `sorted(arr, reverse=True)`. This ensures that the largest elements are at the beginning of the sorted list.\n2. **Selecting Top k Elements**: After sorting, we take the top `k` elements from this sorted list using slicing `[:k]`.\n3. **Sorting Again for Ascending Order**: Finally, these `k` elements are sorted again in ascending order to meet the requirement of returning a vector with elements in ascending order.\n4. **Return Result**: The function returns the resulting vector.\n\nThis approach ensures that we get the maximum `k` numbers from the array and return them in the required format (ascending order)."}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\n// Change the parameter type to const reference\nint solution(const vector<int>& lst) {\n    int total_sum = 0;\n    \n    // Iterate through even indices (0-based)\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        // Check if the element at index i is odd\n        if (lst[i] % 2 != 0) {\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum;\n}\n\n", "py_code": "def solution(lst):\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate through even indices (0-based)\n        if lst[i] % 2 != 0:  # Check if the element at index i is odd\n            total_sum += lst[i]\n    return total_sum\n```\n\n", "py_summary": "The Python function `solution` takes a list of integers as input and returns the sum of all odd elements that are located at even positions (0-based indexing). Here's a detailed breakdown:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0, which will store the cumulative sum of the desired elements.\n\n2. **Iteration through Even Indices**:\n   - A for loop iterates over the indices of the list with a step size of 2 (`range(0, len(lst), 2)`). This ensures that only even positions (like index 0, 2, 4, etc.) are considered.\n   \n3. **Check for Odd Elements**:\n   - For each element at an even position, the code checks if it is odd using `lst[i] % 2 != 0`.\n   - If the condition is true, the element is added to `total_sum`.\n\n4. **Return Result**: After iterating through all relevant positions and summing up the odd elements, the function returns `total_sum`.\n\nThis approach ensures that only the required elements are considered and summed correctly.\n\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int total_sum = 0;\n    \n    // Iterate over the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        \n        // Check if the number has at most two digits\n        if (1 <= num && num < 100) {\n            total_sum += num;\n        }\n    }\n    \n    return total_sum;\n}\n", "py_code": "def add_elements(arr, k):\n    total_sum = 0\n    for num in arr[:k]:\n        if 1 <= num < 100:  # Check if the number has at most two digits\n            total_sum += num\n    return total_sum\n```\n\n", "py_summary": "The Python function `add_elements` is designed to calculate the sum of elements with at most two digits from the first `k` elements of a given list `arr`. Here's a detailed analysis:\n\n1. **Function Definition**: The function takes two parameters: `arr`, which is a list of integers, and `k`, an integer indicating how many elements from the start of the list to consider.\n\n2. **Initialization**: A variable `total_sum` is initialized to 0. This will store the cumulative sum of numbers that meet the criteria (having at most two digits).\n\n3. **Iteration**: The function iterates over the first `k` elements of `arr`. This is achieved using a slice `arr[:k]`, which extracts the sub-list containing the first `k` elements.\n\n4. **Condition Check**: For each element in this sub-list, the condition `1 <= num < 100` checks if the number has at most two digits (i.e., it lies between 1 and 99 inclusive).\n\n5. **Sum Calculation**: If a number meets the criteria, its value is added to `total_sum`.\n\n6. **Return Statement**: After iterating through all elements up to index `k`, the function returns the accumulated sum stored in `total_sum`.\n\nThis approach ensures that only numbers with at most two digits are included in the final sum, adhering to the problem constraints.\n\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            odd_numbers.push_back(n);\n        }\n        // Calculate the next term in the Collatz sequence\n        n = n / 2 + (n & 1) * (3 * n + 1);\n    }\n    \n    // Add the final value of 1 to the list\n    odd_numbers.push_back(1);\n\n    // Sort the vector in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n", "py_code": "from typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        n = n // 2 + (n & 1) * (3 * n + 1)\n    odd_numbers.append(1)  # The sequence always ends with 1\n    return sorted(odd_numbers)\n```\n\n", "py_summary": "The Python function `get_odd_collatz` takes a positive integer `n` and returns a sorted list of odd numbers in the Collatz sequence for that number.\n\n1. **Initialization**: The function initializes an empty list `odd_numbers` to store the odd numbers encountered during the generation of the Collatz sequence.\n2. **Loop until reaching 1**: A while loop runs as long as `n` is not equal to 1, which is the termination condition for the Collatz sequence.\n3. **Check if current number is odd**: Inside the loop, it checks whether the current value of `n` is odd using the expression `n % 2 == 1`. If true, the current value of `n` is appended to the list `odd_numbers`.\n4. **Generate next term in sequence**: The function calculates the next term in the Collatz sequence based on whether the current number is even or odd:\n   - For an even number: `n = n // 2`\n   - For an odd number: `n = (3 * n + 1)`\n   This can be combined into a single line using bitwise AND (`&`) to determine if `n` is odd and then applying the appropriate transformation.\n5. **Add 1 to list**: After exiting the loop, the function appends the final value of 1 to the list since every Collatz sequence ends with 1.\n6. **Return sorted list**: Finally, it returns the list of odd numbers sorted in increasing order.\n\nThis approach ensures that all odd numbers in the Collatz sequence are captured and returned in a sorted manner."}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <ctime>\n\nbool valid_date(std::string date) {\n    std::tm timeStruct = {};\n    char format[] = \"%m-%d-%Y\";\n    \n    // Attempt to parse the date string using strptime\n    if (std::sscanf(date.c_str(), format, &timeStruct) == 3) {\n        // Check if the parsed year is valid and within a reasonable range\n        int currentYear = std::tm().tm_year + 1900; // Current year in tm structure\n        timeStruct.tm_year -= 1900; // Adjust to years since 1900\n        \n        // Validate month, day, and year\n        if (timeStruct.tm_mon >= 1 && timeStruct.tm_mon <= 12 &&\n            timeStruct.tm_mday >= 1) {\n                int daysInMonth = 31;\n                switch(timeStruct.tm_mon) {\n                    case 4: case 6: case 9: case 11:\n                        daysInMonth = 30;\n                        break;\n                    case 2:\n                        if ((timeStruct.tm_year % 4 == 0 && timeStruct.tm_year % 100 != 0) || (timeStruct.tm_year % 400 == 0)) {\n                            daysInMonth = 29; // Leap year\n                        } else {\n                            daysInMonth = 28;\n                        }\n                        break;\n                }\n                \n                if (timeStruct.tm_mday <= daysInMonth && timeStruct.tm_year >= 1900) {\n                    return true;\n                }\n            }\n    }\n\n    return false;\n}\n", "py_code": "from datetime import datetime\n\ndef valid_date(date):\n    # Define the required format for the date string\n    date_format = \"%m-%d-%Y\"\n    \n    try:\n        # Try parsing the date using the specified format\n        parsed_date = datetime.strptime(date, date_format)\n        \n        # Extract month and day from the parsed date\n        month = parsed_date.month\n        day = parsed_date.day\n        \n        # Check if the number of days is valid for each month\n        if month in [1, 3, 5, 7, 8, 10, 12] and not (1 <= day <= 31):\n            return False\n        elif month in [4, 6, 9, 11] and not (1 <= day <= 30):\n            return False\n        elif month == 2 and not (1 <= day <= 29):\n            return False\n        \n        # If all checks pass, the date is valid\n        return True\n    \n    except ValueError:\n        # If parsing fails or any of the conditions are violated, the date is invalid\n        return False\n```\n\n", "py_summary": "The Python code defines a function `valid_date` that checks if a given date string is valid according to specific rules. Here's a detailed analysis of how the function works:\n\n1. **Date Format Validation**:\n   - The function starts by defining the required format for the date string using the constant `date_format = \"%m-%d-%Y\"`. This format specifies that the date should be in the form \"mm-dd-yyyy\".\n\n2. **Parsing the Date String**:\n   - The function attempts to parse the input date string using `datetime.strptime(date, date_format)`, which converts the string into a datetime object based on the specified format.\n   - If parsing fails (e.g., due to an incorrect format or invalid values), a `ValueError` is raised.\n\n3. **Month and Day Validation**:\n   - The function extracts the month (`month`) and day (`day`) from the parsed date using `parsed_date.month` and `parsed_date.day`.\n   - It then checks if the number of days is valid for each month:\n     - For months 1, 3, 5, 7, 8, 10, and 12 (months with 31 days), it ensures that the day is between 1 and 31.\n     - For months 4, 6, 9, and 11 (months with 30 days), it ensures that the day is between 1 and 30.\n     - For February (month 2), it ensures that the day is between 1 and 29.\n\n4. **Return Value**:\n   - If all checks pass without raising an exception, the function returns `True`, indicating that the date is valid.\n   - If parsing fails or any of the conditions are violated, a `ValueError` is caught, and the function returns `False`.\n\nThis approach ensures that the date string adheres to the specified format and rules for validity.\n\n### Summary\n- The function uses `datetime.strptime` to parse the date string according to the required format.\n- It then checks if the parsed month and day values are within valid ranges based on the specific rules provided.\n- If any validation fails, it returns `False`; otherwise, it returns `True`.\n\nThis ensures that the input date is correctly formatted and falls within acceptable date ranges for each month."}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> split_words(std::string txt) {\n    std::vector<std::string> words;\n    \n    // Split on whitespace first\n    std::istringstream iss(txt);\n    std::string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    \n    if (words.size() > 1) {\n        return words;\n    }\n\n    // If no whitespaces, try splitting on commas\n    size_t commaPos = txt.find(',');\n    if (commaPos != std::string::npos) {\n        std::istringstream commaIss(txt);\n        while (getline(commaIss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // If no commas, count the number of lowercase letters with odd order in the alphabet\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c) && ((c - 'a') % 2 == 1)) {\n            odd_count++;\n        }\n    }\n\n    // Return a vector with one element containing the count as a string\n    return {std::to_string(odd_count)};\n}\n", "py_code": "from typing import List\n\ndef split_words(txt: str) -> List[str]:\n    # Split on whitespace first\n    words = txt.split()\n    \n    if len(words) > 1:\n        return words\n    \n    # If no whitespaces, try splitting on commas\n    if ',' in txt:\n        words = txt.split(',')\n        return words\n    \n    # If no commas, count the number of lowercase letters with odd order in the alphabet\n    odd_count = sum(1 for char in txt if 'a' <= char <= 'z' and (ord(char) - ord('a')) % 2 == 1)\n    \n    return [str(odd_count)]\n```\n\n", "py_summary": "The Python function `split_words` processes a given string `txt` according to specific rules and returns a vector of words or a single element based on those rules:\n\n1. **Splitting on Whitespace**: The function first attempts to split the input string `txt` using whitespace as the delimiter. If this results in more than one word, it returns the list of words.\n\n2. **Splitting on Commas**: If splitting on whitespace does not yield multiple words (i.e., there are no whitespaces), the function checks if commas exist in the string. If commas are found, it splits the string using commas as delimiters and returns the resulting list of substrings.\n\n3. **Counting Odd-Order Lowercase Letters**: If neither whitespaces nor commas are present in the input string, the function counts the number of lowercase letters that have an odd order in the alphabet (where 'a' is 0, 'b' is 1, etc.). It then returns a vector containing this count as a single element.\n\nThe function uses Python's `split` method to handle splitting on whitespace and commas. For counting the odd-order lowercase letters, it iterates through each character in the string, checks if it is a lowercase letter with an odd order, and increments a counter accordingly. The final result is returned as a list containing either the split words or the count of such characters.\n\nThis approach ensures that the function handles different input cases appropriately and returns the correct output format based on the given rules."}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Dictionary to keep track of the frequency of each number\n    std::unordered_map<int, int> count;\n\n    // Iterate through the list\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // Check if the current element is less than the previous element\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        \n        // Update the frequency of each number\n        count[lst[i]]++;\n        count[lst[i - 1]]++;\n\n        // If any number appears more than twice, return false\n        if (count[lst[i]] > 2 || count[lst[i - 1]] > 2) {\n            return false;\n        }\n    }\n\n    // Check the first element separately since it's not compared in the loop\n    if (!lst.empty() && ++count[lst[0]] > 2) {\n        return false;\n    }\n\n    return true;\n}\n", "py_code": "def is_sorted(lst):\n    # Check if the list is sorted in ascending order and no number appears more than twice\n    count = {}\n    for i in range(len(lst)):\n        if i > 0 and lst[i] < lst[i - 1]:\n            return False\n        count[lst[i]] = count.get(lst[i], 0) + 1\n        if count[lst[i]] > 2:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_sorted` checks whether a given list of integers is sorted in ascending order and ensures that no integer appears more than twice. Here's a detailed breakdown of how it works:\n\n1. **Initialization**: \n   - A dictionary `count` is initialized to keep track of the frequency of each number in the list.\n\n2. **Iterating through the List**:\n   - The function iterates through each element in the list using an index-based loop.\n   - For each element, it checks if the current element is less than the previous element (`lst[i] < lst[i - 1]`). If this condition is true, it means the list is not sorted in ascending order, and the function returns `False`.\n\n3. **Counting Occurrences**:\n   - The frequency of each number is updated using a dictionary. For each number encountered, its count is incremented.\n   - If any number's count exceeds 2, the function immediately returns `False`, indicating that the list does not meet the criteria.\n\n4. **Return True if All Conditions are Met**:\n   - If the loop completes without returning `False`, it means the list is sorted in ascending order and no number appears more than twice, so the function returns `True`.\n\nThis approach ensures that both conditions (sorted in ascending order and no number appearing more than twice) are checked efficiently."}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int length = end_min - start_max + 1;\n    return is_prime(length) ? \"YES\" : \"NO\";\n}\n", "py_code": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n\n    if start_max > end_min:\n        return \"NO\"\n    \n    length = end_min - start_max + 1\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "The Python code defines a function `intersection` that takes two intervals as input and determines whether the length of their intersection is a prime number. Here's a detailed breakdown:\n\n1. **Helper Function (`is_prime`)**:\n   - The helper function `is_prime(n)` checks if a given integer `n` is a prime number.\n   - It returns `False` for numbers less than or equal to 1, as they are not considered prime.\n   - For other values of `n`, it iterates from 2 up to the square root of `n`. If any divisor is found within this range, it returns `False`.\n   - Otherwise, it returns `True`.\n\n2. **Main Function (`intersection`)**:\n   - The function takes two intervals as input: `interval1 = (start1, end1)` and `interval2 = (start2, end2)`.\n   - It calculates the maximum of the start points (`start_max`) to determine the starting point of the intersection.\n   - It also calculates the minimum of the end points (`end_min`) to determine the ending point of the intersection.\n   - If `start_max` is greater than `end_min`, it means there is no intersection, and the function returns `\"NO\"`.\n   - Otherwise, it computes the length of the intersection as `length = end_min - start_max + 1`.\n   - It then uses the helper function `is_prime(length)` to check if this length is a prime number.\n   - If the length is prime, the function returns `\"YES\"`. Otherwise, it returns `\"NO\"`.\n\nThis approach ensures that the intersection's length is correctly calculated and checked for primality."}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n\n    for (const auto& num : arr) {\n        if (num == 0) {\n            return 0;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        }\n        \n        sum_of_magnitudes += std::abs(num);\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n", "py_code": "from typing import List\n\ndef prod_signs(arr: List[int]) -> int:\n    if not arr:\n        return -32768\n    \n    product_of_signs = 1\n    sum_of_magnitudes = 0\n    \n    for num in arr:\n        if num == 0:\n            return 0\n        elif num < 0:\n            product_of_signs *= -1\n        else:\n            product_of_signs *= 1\n        \n        sum_of_magnitudes += abs(num)\n    \n    return sum_of_magnitudes * product_of_signs\n```\n\n", "py_summary": "The Python code defines a function `prod_signs` that takes a list of integers as input and returns an integer value based on specific rules:\n\n1. **Check for Empty List**: If the input list is empty, the function immediately returns `-32768`.\n\n2. **Initialize Variables**:\n   - `product_of_signs`: This variable keeps track of the product of signs (1 for positive, -1 for negative) of all numbers in the list.\n   - `sum_of_magnitudes`: This variable accumulates the sum of the absolute values of the integers in the list.\n\n3. **Iterate Through List**:\n   - For each number in the list, if it is zero (`0`), the function returns `0` immediately because any product involving zero will be zero.\n   - If the number is negative, the sign product is updated by multiplying with `-1`.\n   - If the number is positive or zero (handled separately above), the sign product remains unchanged and stays as `1`.\n\n4. **Calculate Final Result**:\n   - The function calculates the final result by multiplying the sum of magnitudes (`sum_of_magnitudes`) by the product of signs (`product_of_signs`).\n\nThis approach ensures that the function correctly handles all edge cases, such as an empty list or a list containing zero, and computes the desired value efficiently."}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\n#include <algorithm> // For lexicographical_compare\n\nusing namespace std;\n\ntypedef pair<vector<int>, pair<int, int>> PathInfo;\nstruct ComparePaths {\n    bool operator()(const PathInfo& a, const PathInfo& b) const {\n        return lexicographical_compare(a.first.begin(), a.first.end(), b.first.begin(), b.first.end());\n    }\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) { // Change to const reference\n    int N = grid.size();\n    \n    // Initialize a priority queue with all possible starting points and their paths.\n    priority_queue<PathInfo, vector<PathInfo>, ComparePaths> pq;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({{grid[i][j]}, {i, j}});\n        }\n    }\n\n    // Define possible directions\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    \n    while (!pq.empty()) {\n        auto [path, pos] = pq.top(); // Use structured binding here\n        pq.pop();\n\n        if (path.size() == k) {\n            return path;\n        }\n\n        int x = pos.first, y = pos.second;\n        for (auto& dir : directions) {\n            int nx = x + dir.first, ny = y + dir.second;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                vector<int> new_path(path);\n                new_path.push_back(grid[nx][ny]);\n                pq.push({new_path, {nx, ny}});\n            }\n        }\n    }\n\n    return {}; // In case no path is found (should not happen given the problem constraints)\n}\n", "py_code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    \n    # Initialize a priority queue with all possible starting points.\n    from heapq import heappush, heappop\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heappush(pq, (grid[i][j], [grid[i][j]], i, j))\n    \n    # Define the directions to move: up, down, left, right.\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    \n    while k > 0:\n        size = len(pq)\n        for _ in range(size):\n            val, path, x, y = heappop(pq)\n            \n            # Explore all possible moves from the current cell.\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    new_val = grid[nx][ny]\n                    heappush(pq, (new_val, path + [new_val], nx, ny))\n        \n        k -= 1\n    \n    # The first element in the priority queue will be the lexicographically smallest path.\n    return pq[0][1][:k]\n\n", "py_summary": "The Python code defines a function `minPath` that finds the minimum path of length `k` on an N x N grid where each cell contains a unique integer from 1 to N*N. The analysis is as follows:\n\n1. **Initialization**:\n   - Determine the size of the grid, `N`.\n   - Initialize a priority queue (`pq`) using a min-heap to store tuples containing the current value, path taken so far, and coordinates (x, y) of the cell.\n   - Populate the priority queue with all possible starting points in the grid.\n\n2. **Directions**:\n   - Define a list `directions` that contains tuples representing movement in four directions: right, down, left, up.\n\n3. **Main Loop**:\n   - The main loop runs until `k` steps have been taken.\n   - For each step, process all elements currently in the priority queue (which represents possible paths).\n   - For each cell `(x, y)` popped from the heap, explore its neighboring cells by moving in each of the four directions defined earlier. Ensure that the new coordinates are within grid boundaries.\n   - Push the value and updated path for each valid neighbor back into the priority queue.\n\n4. **Path Extraction**:\n   - After `k` steps, the first element in the priority queue will contain the lexicographically smallest path of length `k`.\n   - Return this path truncated to exactly `k` elements.\n\nThe use of a min-heap ensures that at each step, the algorithm always considers and expands upon the lexicographically smallest paths first. This guarantees that when `k` steps have been taken, the resulting path is indeed the minimum one according to the given criteria."}
{"task_id": "CPP/130", "generation": "#include <vector>\n\nstd::vector<int> tri(int n) {\n    if (n == 0) {\n        return {};\n    }\n    \n    std::vector<int> sequence = {1};  // Initialize with the base case\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {  // If i is even\n            int next_value = 1 + (i / 2);\n            sequence.push_back(next_value);\n        } else {  // If i is odd\n            int next_value = sequence[i - 1] + sequence[i - 2];\n            if ((i + 1) <= n) {\n                next_value += sequence[(i + 1)];\n            } else {\n                next_value += sequence.back();  // Handle the case where (i+1) is out of bounds\n            }\n            sequence.push_back(next_value);\n        }\n    }\n\n    return sequence;\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return []\n    \n    sequence = [1]  # tri(1) = 3 but we start with 1 as per the examples\n    \n    for i in range(1, n + 1):\n        if i % 2 == 0:  # If i is even\n            next_value = 1 + (i // 2)\n        else:  # If i is odd\n            next_value = sequence[i - 1] + sequence[i - 2] + sequence[(i + 1) % len(sequence)]\n        \n        sequence.append(next_value)\n    \n    return sequence\n```\n\n", "py_summary": "The Python function `tri(n)` generates the first `n+1` numbers of the Tribonacci sequence based on the given recurrence relations:\n\n- The base case initializes the sequence with `sequence[0] = 1`, which is a starting point for the sequence.\n- For each subsequent index `i` from 1 to `n`:\n  - If `i` is even, the value at that position in the sequence is calculated as `1 + (i // 2)`.\n  - If `i` is odd, the value is calculated using the recurrence relation `sequence[i] = sequence[i-1] + sequence[i-2] + sequence[(i+1) % len(sequence)]`. The term `(i+1) % len(sequence)` ensures that we handle the index out-of-bounds case by wrapping around to a valid position in the sequence.\n  \nThe function returns the generated Tribonacci sequence as a list.\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return has_odd_digit ? product : 0;\n}\n\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    \n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    \n    return product if has_odd_digit else 0\n```\n\n", "py_summary": "The Python function `digits(n)` calculates the product of all odd digits in a given positive integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - `product` is initialized to 1 because multiplying by 1 does not change the value.\n   - `has_odd_digit` is a boolean flag that tracks whether there is at least one odd digit in the number.\n\n2. **Extracting Digits and Processing**:\n   - The function enters a loop where it processes each digit of `n` from right to left (least significant to most significant).\n   - In each iteration, the last digit (`digit`) of `n` is extracted using `digit = n % 10`.\n   - If `digit` is odd (i.e., `digit % 2 != 0`), it multiplies this digit with `product`, and sets `has_odd_digit` to `True`.\n\n3. **Removing the Last Digit**:\n   - After processing a digit, the function removes that digit from `n` by performing integer division: `n //= 10`.\n\n4. **Final Check**:\n   - If there was at least one odd digit (`has_odd_digit` is `True`), it returns the product.\n   - Otherwise, if all digits were even, it returns 0.\n\nThis approach ensures that the function correctly computes the desired result based on the problem statement."}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets;\n    bool has_nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            brackets.push(c);\n        } else if (c == ']') {\n            if (!brackets.empty() && !has_nested && brackets.size() > 1) {\n                has_nested = true;\n            }\n            brackets.pop();\n        }\n    }\n\n    return has_nested && brackets.empty();\n}\n", "py_code": "def is_nested(str):\n    stack = []\n    has_nested = False\n    \n    for char in str:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 1:\n                has_nested = True\n            stack.pop()\n    \n    return has_nested and not stack\n```\n\n", "py_summary": "The Python function `is_nested` checks whether a given string of square brackets contains at least one nested bracket sequence. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - A stack is initialized to keep track of open brackets.\n   - A boolean variable `has_nested` is initialized to `False`. This will be used to determine if there is at least one nested bracket.\n\n2. **Iterate through the string**:\n   - For each character in the input string, the function checks whether it is an opening square bracket `[`.\n     - If it is an opening bracket, the character is pushed onto the stack.\n   - If the character is a closing square bracket `]`:\n     - The function checks if there are at least two brackets on the stack (i.e., `len(stack) > 1`). This condition ensures that there is at least one nested bracket sequence.\n       - If this condition is met, `has_nested` is set to `True`.\n     - The top element of the stack (the most recent opening bracket) is popped off.\n\n3. **Final check**:\n   - After iterating through all characters in the string, the function returns `True` if there was at least one nested sequence (`has_nested == True`) and the stack is empty (indicating that every open bracket has been properly closed).\n\nThis approach ensures that the function correctly identifies whether there is a valid subsequence of brackets where at least one bracket is nested.\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int total_sum = 0;\n    for (float num : lst) {\n        float ceiling_num = ceil(num);\n        int squared_num = static_cast<int>(ceiling_num * ceiling_num);\n        total_sum += squared_num;\n    }\n    return total_sum;\n}\n", "py_code": "from math import ceil\n\ndef sum_squares(lst):\n    total_sum = 0\n    for num in lst:\n        squared_num = ceil(num) ** 2\n        total_sum += squared_num\n    return total_sum\n```\n\n", "py_summary": "The Python function `sum_squares` takes a list of floating-point numbers as input and returns the sum of their ceiling-rounded values squared. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0. This will store the cumulative sum of the squared, rounded-up values.\n\n2. **Iteration through the List**: A loop iterates over each element in the input list `lst`.\n\n3. **Rounding and Squaring**:\n   - For each number `num`, it uses the `ceil` function from the math module to round up to the nearest integer.\n   - The rounded-up value is then squared.\n\n4. **Accumulating the Sum**: The squared, ceiling-rounded value of each element is added to `total_sum`.\n\n5. **Return Result**: After processing all elements in the list, the function returns the accumulated sum stored in `total_sum`.\n\nThis approach ensures that each number in the input list is processed individually, rounded up to the nearest integer, squared, and then summed together to produce the final result.\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Remove trailing spaces\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the last character is an alphabetical character and not part of a word\n    if (!txt.empty() && isalpha(txt.back()) && (txt.length() == 1 || !isalpha(txt[txt.length() - 2]))) {\n        return true;\n    }\n\n    return false;\n}\n\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    # Remove trailing spaces\n    while txt and txt[-1] == ' ':\n        txt = txt[:-1]\n    \n    # Check if last character is an alphabetical character\n    if len(txt) > 0 and txt[-1].isalpha() and (len(txt) == 1 or not txt[-2].isalpha()):\n        return True\n    \n    return False\n```\n\n", "py_summary": "The Python function `check_if_last_char_is_a_letter` checks if the last character of a given string is an alphabetical character and not part of a word. Here's a detailed breakdown:\n\n1. **Check for Empty String**: The function first checks if the input string `txt` is empty. If it is, the function returns `False`.\n\n2. **Remove Trailing Spaces**: A while loop removes any trailing spaces from the end of the string. This ensures that only the relevant part of the string is considered.\n\n3. **Check Last Character**:\n   - The function checks if the length of the modified string is greater than 0 and if the last character (`txt[-1]`) is an alphabetical character using `isalpha()`.\n   - Additionally, it verifies whether this last character is not part of a word by checking that either the entire string consists of only one character or the second-to-last character (`txt[-2]`) is not an alphabetical character.\n\n4. **Return Result**: If all conditions are met, the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the last character is indeed a standalone letter and not part of any word within the string."}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n", "py_code": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1\n```\n\n", "py_summary": "The Python function `can_arrange` takes a list of integers as input and returns the largest index where an element is smaller than its preceding element. If no such element exists, it returns `-1`.\n\nHere's a detailed breakdown:\n- The function iterates through the list starting from the second element (index 1).\n- For each element at index `i`, it checks if the current element (`arr[i]`) is less than the previous element (`arr[i - 1]`).\n- If such an element is found, the function immediately returns the index `i`.\n- If no such element is found after iterating through the entire list, the function returns `-1`.\n\nThis approach ensures that the function finds and returns the largest possible index where a violation of the non-decreasing order occurs."}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(std::vector<int> lst) {\n    int max_negative = INT_MIN;\n    int min_positive = INT_MAX;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no valid negative or positive integers were found, return {0, 0}\n    if (max_negative == INT_MIN || min_positive == INT_MAX) {\n        return {0, 0};\n    } else {\n        return {max_negative, min_positive};\n    }\n}\n", "py_code": "from typing import List\n\ndef largest_smallest_integers(lst: List[int]) -> List[int]:\n    max_negative = float('-inf')\n    min_positive = float('inf')\n\n    for num in lst:\n        if num < 0 and num > max_negative:\n            max_negative = num\n        elif num > 0 and num < min_positive:\n            min_positive = num\n\n    return [max_negative, min_positive] if max_negative != float('-inf') or min_positive != float('inf') else [0, 0]\n```\n\n", "py_summary": "The Python code defines a function `largest_smallest_integers` that takes a list of integers as input and returns a vector containing two elements: the largest negative integer and the smallest positive integer in the list. If there are no negative or positive integers in the list, it returns 0 for both values.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The variables `max_negative` and `min_positive` are initialized to `-inf` (negative infinity) and `inf` (positive infinity), respectively. This ensures that any valid integer value in the list will be larger than `max_negative` or smaller than `min_positive`.\n\n2. **Iteration through the List**:\n   - For each number in the input list, the function checks if it is negative.\n   - If a number is negative and greater than the current `max_negative`, it updates `max_negative`.\n   - Similarly, for positive numbers, if a number is smaller than the current `min_positive`, it updates `min_positive`.\n\n3. **Return Value**:\n   - After iterating through all elements in the list, the function checks whether any valid negative or positive integers were found.\n   - If either `max_negative` remains `-inf` or `min_positive` remains `inf`, it means no valid values were found, and the function returns `[0, 0]`.\n   - Otherwise, it returns a vector containing the largest negative integer and the smallest positive integer.\n\nThis approach ensures that the function correctly identifies the required integers while handling edge cases where there are no suitable elements in the list."}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n\n// Function to convert string with '.' or ',' to float\nfloat string_to_float(const std::string& str) {\n    size_t pos = str.find(',');\n    if (pos != std::string::npos) {\n        return std::stof(str.substr(0, pos) + \".\" + str.substr(pos + 1));\n    }\n    return std::stof(str);\n}\n\n// Function to compare two boost::any values\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(int)) {\n        int ia = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (ia == ib ? \"None\" : (ia > ib ? a : b));\n        } else if (b.type() == typeid(float)) {\n            float fb = boost::any_cast<float>(b);\n            return (static_cast<float>(ia) == fb ? \"None\" : (static_cast<float>(ia) > fb ? a : b));\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            float fb = string_to_float(sb);\n            return (static_cast<float>(ia) == fb ? \"None\" : (static_cast<float>(ia) > fb ? a : b));\n        }\n    } else if (a.type() == typeid(float)) {\n        float fa = boost::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (fa == static_cast<float>(ib) ? \"None\" : (fa > static_cast<float>(ib) ? a : b));\n        } else if (b.type() == typeid(float)) {\n            float fb = boost::any_cast<float>(b);\n            return (fa == fb ? \"None\" : (fa > fb ? a : b));\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            float fb = string_to_float(sb);\n            return (fa == fb ? \"None\" : (fa > fb ? a : b));\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string sa = boost::any_cast<std::string>(a);\n        float fa = string_to_float(sa);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (fa == static_cast<float>(ib) ? \"None\" : (fa > static_cast<float>(ib) ? a : b));\n        } else if (b.type() == typeid(float)) {\n            float fb = boost::any_cast<float>(b);\n            return (fa == fb ? \"None\" : (fa > fb ? a : b));\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            float fb = string_to_float(sb);\n            return (fa == fb ? \"None\" : (fa > fb ? a : b));\n        }\n    }\n\n    // If types are not compatible, return None\n    return \"None\";\n}\n\n", "py_code": "from typing import Any\n\ndef compare_one(a: Any, b: Any) -> Any:\n    # Convert inputs to floats if they are strings with decimal points\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n\n    # Compare the values and return the larger one or \"None\" if equal\n    if a == b:\n        return \"None\"\n    elif a > b:\n        return a\n    else:\n        return b\n```\n\n", "py_summary": "The Python function `compare_one` takes two inputs, `a` and `b`, which can be integers, floats, or strings representing real numbers. The function aims to determine and return the larger of the two values while preserving their original type (integer, float, or string). If the values are equal, it returns the string `\"None\"`.\n\nHere's a detailed breakdown of how the Python code works:\n\n1. **Type Conversion**:\n   - If `a` is a string, it converts the string to a floating-point number by replacing any commas with dots (to handle different decimal separators).\n   - Similarly, if `b` is a string, it performs the same conversion.\n\n2. **Comparison and Return Value**:\n   - The function compares the two values (`a` and `b`). If they are equal, it returns `\"None\"`.\n   - If `a` is greater than `b`, it returns `a`. This preserves the original type of `a`.\n   - If `b` is greater than `a`, it returns `b`. This preserves the original type of `b`.\n\nThis approach ensures that the function correctly handles different input types and formats, returning the appropriate larger value or `\"None\"` if they are equal.\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the number is at least 8 and even\n    return n >= 8 && n % 2 == 0;\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    # Since we need exactly 4 positive even numbers to sum up to n,\n    # the minimum possible sum of 4 positive even numbers is 2 + 4 + 6 + 8 = 20.\n    # However, a simpler approach is to note that any number can be expressed as a sum of four even numbers\n    # if and only if it is at least 8 (the smallest such sum) and itself is even.\n    \n    return n >= 8 and n % 2 == 0\n```\n\n", "py_summary": "The Python function `is_equal_to_sum_even(n)` evaluates whether a given integer `n` can be written as the sum of exactly four positive even numbers.\n\nHere's an analysis of how this function works:\n\n1. **Minimum Sum Requirement**: The smallest possible sum of four positive even numbers is \\(2 + 4 + 6 + 8 = 20\\). However, a simpler and more general approach is to recognize that any number can be expressed as the sum of four even numbers if it is at least 8 (the smallest such sum) and itself is an even number.\n\n2. **Conditions**:\n   - The function checks whether `n` is greater than or equal to 8.\n   - It also checks whether `n` is an even number (`n % 2 == 0`).\n\nIf both conditions are satisfied, the function returns `True`, indicating that `n` can be written as the sum of exactly four positive even numbers. Otherwise, it returns `False`.\n\nThis approach leverages the properties of even numbers and ensures that the given number meets the necessary criteria to be expressed as such a sum.\n\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n    if (n <= 0)\n        return 1;\n\n    long long result = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n\n    return result;\n}\n", "py_code": "def special_factorial(n):\n    if n <= 0:\n        return 1\n    \n    result = 1\n    for i in range(1, n + 1):\n        factorial = 1\n        for j in range(1, i + 1):\n            factorial *= j\n        result *= factorial\n    \n    return result\n```\n\n", "py_summary": "The Python function `special_factorial(n)` calculates the Brazilian factorial of a given integer \\( n \\). The Brazilian factorial is defined as the product of factorials from \\( 1! \\) to \\( n! \\).\n\nHere's an analysis of how the function works:\n\n1. **Base Case Check**: If \\( n \\leq 0 \\), the function returns 1, since the Brazilian factorial for non-positive integers is defined to be 1.\n\n2. **Initialization**: The variable `result` is initialized to 1. This will store the cumulative product of the factorials from \\( 1! \\) to \\( n! \\).\n\n3. **Outer Loop**: An outer loop runs from 1 to \\( n \\). For each iteration, it calculates the factorial of the current number (i.e., \\( i! \\)).\n\n4. **Inner Loop for Factorial Calculation**: Inside the outer loop, an inner loop calculates the factorial of the current number \\( i \\) by multiplying all integers from 1 to \\( i \\).\n\n5. **Multiplying Factorials**: The calculated factorial is then multiplied with `result`.\n\n6. **Return Result**: After completing the loops, the function returns the final value stored in `result`, which represents the Brazilian factorial of \\( n \\).\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n    \n    return result;\n}\n\n", "py_code": "def fix_spaces(text):\n    result = \"\"\n    space_count = 0\n    \n    for char in text:\n        if char == \" \":\n            space_count += 1\n        else:\n            if space_count > 2:\n                result += \"-\"\n            elif space_count > 0:\n                result += \"_\" * space_count\n            space_count = 0\n            result += char\n    \n    # Handle trailing spaces\n    if space_count > 2:\n        result += \"-\"\n    elif space_count > 0:\n        result += \"_\" * space_count\n    \n    return result\n```\n\n", "py_summary": "The Python function `fix_spaces` takes a string `text` as input and replaces spaces according to the specified rules:\n\n1. **Initialization**: The function initializes an empty string `result` to store the modified text and a counter `space_count` to keep track of consecutive spaces.\n\n2. **Iteration through characters**: It iterates through each character in the input string `text`.\n\n3. **Counting spaces**:\n   - If the current character is a space, it increments the `space_count`.\n   \n4. **Processing non-space characters**:\n   - When encountering a non-space character (i.e., any character other than a space), the function checks the value of `space_count` to determine how to handle the spaces before this character.\n     - If there are more than 2 consecutive spaces (`space_count > 2`), it appends a single hyphen `-` to `result`.\n     - Otherwise, if there is at least one space (`space_count > 0`), it appends underscores `_` corresponding to the number of spaces.\n   - After processing the spaces, it resets `space_count` to 0 and appends the non-space character to `result`.\n\n5. **Handling trailing spaces**: After exiting the loop, there might still be consecutive spaces at the end of the string that need to be processed. The function checks `space_count` again:\n   - If more than 2 consecutive spaces (`space_count > 2`), it appends a hyphen `-`.\n   - Otherwise, if any spaces are present (`space_count > 0`), it appends underscores `_`.\n\n6. **Return the result**: Finally, the function returns the modified string stored in `result`.\n\nThis approach ensures that all rules for replacing spaces with underscores and consecutive spaces with hyphens are correctly applied to the input text.\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <regex>\n#include <string>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^\\d]{0,2}\\d{0,3}\\.[txt|exe|dll]{3}$)\");\n\n    if (std::regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Examples\n", "py_code": "import re\n\ndef file_name_check(file_name):\n    # Regular expression pattern for validating the file name\n    pattern = r'^[a-zA-Z][^\\d]{0,2}\\d{0,3}\\.[txt|exe|dll]{3}$'\n    \n    if re.match(pattern, file_name):\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Examples\nprint(file_name_check(\"example.txt\"))  # Output: Yes\nprint(file_name_check(\"1example.dll\"))  # Output: No\n```\n\n", "py_summary": "The Python code defines a function `file_name_check` that takes a string representing a file's name and returns \"Yes\" if the file's name is valid according to specified conditions, otherwise it returns \"No\". Here\u2019s an analysis of how the function works:\n\n1. **Regular Expression Pattern**:\n   - The regular expression pattern used in the code is designed to match the criteria for a valid filename.\n   - `^[a-zA-Z]`: Ensures that the file name starts with a letter from the Latin alphabet ('a'-'z' or 'A'-'Z').\n   - `[^\\d]{0,2}\\d{0,3}`: Allows up to three digits in total (with at most two non-digit characters preceding them).\n   - `\\.[txt|exe|dll]{3}$`: Ensures that the file name contains exactly one dot followed by either \"txt\", \"exe\", or \"dll\".\n\n2. **Validation**:\n   - The function uses `re.match` to check if the input string matches the pattern.\n   - If a match is found, it returns \"Yes\".\n   - Otherwise, it returns \"No\".\n\n3. **Examples**:\n   - `file_name_check(\"example.txt\")`: Returns \"Yes\" because it meets all criteria.\n   - `file_name_check(\"1example.dll\")`: Returns \"No\" because the file name does not start with a letter from the Latin alphabet.\n\nThis approach ensures that the function accurately validates filenames based on the given conditions using regular expressions for pattern matching."}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nint sum_squares(std::vector<int> lst) {\n    int total_sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            total_sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            total_sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n    return total_sum;\n}\n", "py_code": "def sum_squares(lst):\n    total_sum = 0\n    for i in range(len(lst)):\n        if (i + 1) % 3 == 0:\n            total_sum += lst[i] ** 2\n        elif (i + 1) % 4 == 0:\n            total_sum += lst[i] ** 3\n    return total_sum\n```\n\n", "py_summary": "The Python function `sum_squares` takes a list of integers as input and returns the sum of squared or cubed values based on specific conditions for each index:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0 to keep track of the cumulative sum.\n\n2. **Iteration through the List**:\n   - The function iterates over the indices of the list using a loop.\n   - For each index `i`, it checks if `(i + 1)` (since indexing starts at 0) is a multiple of 3 or 4 to determine whether to square or cube the value.\n\n3. **Condition Checking**:\n   - If `(i + 1)` is a multiple of 3, the function squares `lst[i]` and adds it to `total_sum`.\n   - If `(i + 1)` is a multiple of 4 but not a multiple of 3 (checked by ensuring it's not already handled in the previous condition), the function cubes `lst[i]` and adds it to `total_sum`.\n\n4. **Return Statement**:\n   - After iterating through all elements, the function returns the total sum.\n\nThis approach ensures that only specific indices are modified according to the given rules, while others remain unchanged.\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::vector<std::string> words;\n    std::string word;\n\n    // Split the sentence into words\n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            words.push_back(word);\n        }\n    }\n\n    // Join the filtered words back into a string\n    std::ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        oss << words[i];\n    }\n\n    return oss.str();\n}\n\n", "py_code": "from math import sqrt\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    result = []\n    \n    for word in words:\n        if is_prime(len(word)):\n            result.append(word)\n    \n    return ' '.join(result)\n```\n\n", "py_summary": "The Python code defines a function `words_in_sentence` that takes a string sentence as input and returns a new string containing words whose lengths are prime numbers. Here's an analysis of how it works:\n\n1. **Prime Number Check Function (`is_prime`)**:\n   - The helper function `is_prime(n)` checks if a given number `n` is a prime number.\n   - It first handles the base case where `n < 2`, returning `False`.\n   - Then, it iterates from 2 to the square root of `n` (inclusive) and checks if any number in this range divides `n`. If such a divisor exists, `is_prime(n)` returns `False`; otherwise, it returns `True`.\n\n2. **Main Function (`words_in_sentence`)**:\n   - The function splits the input sentence into individual words using `sentence.split()`.\n   - It initializes an empty list `result` to store words whose lengths are prime numbers.\n   - For each word in the split sentence, it checks if the length of the word is a prime number using the `is_prime` helper function. If the condition is met, the word is appended to the `result` list.\n   - Finally, the function joins the words in the `result` list with spaces and returns the resulting string.\n\nThis approach ensures that only words whose lengths are prime numbers are included in the output, maintaining their original order from the input sentence."}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nbool simplify(std::string x, std::string n) {\n    // Function to parse a fraction string and return numerator and denominator as integers\n    auto parse_fraction = [](const std::string& frac_str) -> std::pair<int, int> {\n        size_t pos;\n        int numerator = std::stoi(frac_str.substr(0, frac_str.find('/')));\n        int denominator = std::stoi(frac_str.substr(frac_str.find('/') + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [x_numerator, x_denominator] = parse_fraction(x);\n    auto [n_numerator, n_denominator] = parse_fraction(n);\n\n    // Calculate the product of the two fractions\n    int result_numerator = x_numerator * n_numerator;\n    int result_denominator = x_denominator * n_denominator;\n\n    // Simplify the fraction to check if it is a whole number\n    bool is_whole_number = (result_numerator % result_denominator == 0);\n\n    return is_whole_number;\n}\n\n", "py_code": "from fractions import Fraction\n\ndef simplify(x: str, n: str) -> bool:\n    # Convert strings to Fraction objects\n    fraction_x = Fraction(x)\n    fraction_n = Fraction(n)\n\n    # Calculate x * n as a single fraction\n    result_fraction = fraction_x * fraction_n\n    \n    # Check if the resulting fraction is a whole number\n    return result_fraction.denominator == 1\n```\n\n", "py_summary": "The Python code defines a function `simplify` that takes two string arguments representing fractions and returns a boolean value indicating whether the product of these fractions is a whole number.\n\nHere's an analysis of how the function works:\n\n1. **Convert Strings to Fractions**: The input strings `x` and `n` are converted into `Fraction` objects using the `Fraction` class from Python\u2019s `fractions` module. This allows for precise arithmetic operations on rational numbers.\n   \n2. **Calculate Product**: The product of the two fractions is computed by multiplying the `Fraction` objects.\n\n3. **Check Whole Number Condition**: To determine if the resulting fraction is a whole number, the function checks whether the denominator of the result is 1. If the denominator is 1, it means that the numerator alone represents an integer value (i.e., the product is a whole number).\n\n4. **Return Result**: The function returns `True` if the product is a whole number and `False` otherwise.\n\nThis approach ensures accurate handling of rational numbers and provides a straightforward way to determine whether their product results in a whole number.\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to get individual digits of an integer, considering negative numbers.\nstd::vector<int> digit_sum(int n) {\n    if (n == 0) return {0};\n    bool is_negative = n < 0;\n    std::vector<int> digits;\n    while (n != 0) {\n        int digit = abs(n % 10);\n        if (is_negative && digits.empty()) digit *= -1; // First digit of negative number\n        digits.insert(digits.begin(), digit); // Insert at the beginning to maintain order\n        n /= 10;\n    }\n    return digits;\n}\n\n// Helper function to calculate the sum of digits.\nint sum_of_digits(int n) {\n    std::vector<int> digits = digit_sum(n);\n    int sum = 0;\n    for (int digit : digits) {\n        sum += abs(digit); // Sum of absolute values\n    }\n    return sum;\n}\n\n// Custom comparator function to sort based on the sum of digits and original index.\nstruct CompareSumAndIndex {\n    const std::vector<int>& nums;\n\n    CompareSumAndIndex(const std::vector<int>& nums) : nums(nums) {}\n\n    bool operator()(int i, int j) const {\n        int sum_i = sum_of_digits(nums[i]);\n        int sum_j = sum_of_digits(nums[j]);\n\n        if (sum_i == sum_j) return i < j; // Maintain original order\n        return sum_i < sum_j;\n    }\n};\n\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<int> indices(nums.size());\n    for (int i = 0; i < nums.size(); ++i) {\n        indices[i] = i;\n    }\n\n    // Sort the indices based on custom comparator\n    std::sort(indices.begin(), indices.end(), CompareSumAndIndex(nums));\n\n    // Reorder the original vector using sorted indices\n    std::vector<int> result(nums.size());\n    for (size_t i = 0; i < nums.size(); ++i) {\n        result[i] = nums[indices[i]];\n    }\n\n    return result;\n}\n\n", "py_code": "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def digit_sum(n):\n        if n == 0:\n            return [0]\n        is_negative = n < 0\n        digits = []\n        while n != 0:\n            digits.append(abs(n % 10))\n            n //= -10 if is_negative else 10\n        return digits\n\n    def sum_of_digits(n):\n        return sum(digit_sum(n))\n\n    # Create a list of tuples (sum of digits, original index, number)\n    indexed_nums = [(sum_of_digits(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort the list based on the custom criteria\n    sorted_list = sorted(indexed_nums)\n\n    # Extract only the numbers from the sorted list\n    result = [num for _, _, num in sorted_list]\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `order_by_points` that sorts a given vector of integers based on the sum of their digits and maintains their original order if the sums are equal.\n\n1. **digit_sum Function**:\n   - This helper function calculates the individual digits of an integer, taking into account whether the number is negative.\n   - It returns a list of digits for the input number `n`.\n\n2. **sum_of_digits Function**:\n   - This helper function computes the sum of the digits returned by `digit_sum`.\n   \n3. **Indexed_nums List Creation**:\n   - A list of tuples `(sum_of_digits(num), i, num)` is created where `i` is the original index of each number in the input vector.\n   - This ensures that if two numbers have the same sum of digits, their order based on their original indices will be preserved.\n\n4. **Sorting**:\n   - The list of tuples is sorted first by the sum of digits and then by the original index (if sums are equal).\n\n5. **Result Extraction**:\n   - After sorting, only the numbers from each tuple are extracted to form the final result vector.\n\nThis approach ensures that the integers are sorted according to their digit sums while maintaining stability based on their initial positions in case of ties.\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n#include <cmath>\n\nbool is_first_last_digit_odd(int number) {\n    std::string num_str = std::to_string(std::abs(number));\n    int first_digit = num_str[0] - '0';\n    int last_digit = num_str.back() - '0';\n\n    return (first_digit % 2 != 0 && last_digit % 2 != 0);\n}\n\nint specialFilter(std::vector<int> nums) {\n    int count = 0;\n    for (const auto& num : nums) {\n        if (num > 10 && is_first_last_digit_odd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def special_filter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and is_first_last_digit_odd(num):\n            count += 1\n    return count\n\ndef is_first_last_digit_odd(number):\n    number_str = str(abs(number))\n    first_digit = int(number_str[0])\n    last_digit = int(number_str[-1])\n    \n    return first_digit % 2 != 0 and last_digit % 2 != 0\n```\n\n", "py_summary": "The Python code defines a function `special_filter` that takes a list of integers as input and returns the count of elements in the list that are greater than 10 and have both their first and last digits odd.\n\nHere's a breakdown of how it works:\n\n1. **Main Function (`special_filter`)**:\n   - The function initializes a counter `count` to zero.\n   - It iterates through each number in the input list `nums`.\n   - For each number, it checks if the number is greater than 10 and if both its first and last digits are odd by calling the helper function `is_first_last_digit_odd`.\n   - If both conditions are met, it increments the counter.\n   - Finally, the function returns the count.\n\n2. **Helper Function (`is_first_last_digit_odd`)**:\n   - This function takes an integer as input and checks if its first and last digits are odd.\n   - It converts the absolute value of the number to a string to easily access individual digits.\n   - The first digit is obtained by converting the first character of the string to an integer, and the last digit is obtained by converting the last character of the string to an integer.\n   - It returns `True` if both the first and last digits are odd (i.e., not divisible by 2), otherwise it returns `False`.\n\nThis approach ensures that only numbers meeting all specified criteria are counted."}
{"task_id": "CPP/147", "generation": "#include <vector>\n\nint get_max_triples(int n) {\n    // Initialize vector a with values computed as i * i - i + 1 for each i from 0 to n-1\n    std::vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Iterate over all possible triples (a[i], a[j], a[k]) where i < j < k\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of a[i], a[j], and a[k] is divisible by 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    count = 0\n    for i in range(len(a) - 2):\n        for j in range(i + 1, len(a) - 1):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n```\n\n", "py_summary": "The Python code defines a function `get_max_triples` that takes an integer `n` as input and returns the number of valid triples `(a[i], a[j], a[k])` in the sequence `a`, where `i < j < k` and `a[i] + a[j] + a[k]` is a multiple of 3.\n\n1. **Initialization**: The function first initializes an integer vector `a` of length `n`. Each element `a[i]` (for `0 \u2264 i < n`) is computed as `i * i - i + 1`.\n\n2. **Triple Counting**: The function then uses three nested loops to iterate over all possible triples `(a[i], a[j], a[k])` where `i < j < k`. Specifically:\n   - The outer loop iterates from `0` to `len(a) - 3`.\n   - The middle loop iterates from `i + 1` to `len(a) - 2`.\n   - The inner loop iterates from `j + 1` to `len(a) - 1`.\n\n3. **Condition Check**: For each triple `(a[i], a[j], a[k])`, the function checks if their sum is divisible by 3 using the condition `(a[i] + a[j] + a[k]) % 3 == 0`. If this condition holds true, it increments the count.\n\n4. **Return Result**: Finally, the function returns the total count of such valid triples.\n\nThis approach ensures that all possible triples are checked and counted correctly based on the given conditions."}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> order_of_planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    if (find(order_of_planets.begin(), order_of_planets.end(), planet1) == order_of_planets.end() ||\n        find(order_of_planets.begin(), order_of_planets.end(), planet2) == order_of_planets.end()) {\n        return {};\n    }\n    \n    int index1 = find(order_of_planets.begin(), order_of_planets.end(), planet1) - order_of_planets.begin();\n    int index2 = find(order_of_planets.begin(), order_of_planets.end(), planet2) - order_of_planets.begin();\n    \n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(order_of_planets[i]);\n    }\n    \n    return result;\n}\n", "py_code": "def bf(planet1: str, planet2: str) -> list:\n    order_of_planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in order_of_planets or planet2 not in order_of_planets:\n        return []\n    \n    index1 = order_of_planets.index(planet1)\n    index2 = order_of_planets.index(planet2)\n    \n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    return order_of_planets[index1 + 1:index2]\n```\n\n", "py_summary": "The Python function `bf` takes two planet names as input and returns a list of planets whose orbits are located between the given two planets, sorted by their proximity to the Sun. Here's an analysis of how the function works:\n\n1. **Initialization**: The function starts by defining a list `order_of_planets` that contains the names of all eight planets in order from closest to farthest from the Sun.\n\n2. **Validation**: It checks if both input planet names (`planet1` and `planet2`) are present in the `order_of_planets` list. If either of them is not found, it returns an empty list immediately since invalid inputs should result in no output.\n\n3. **Index Calculation**: The function determines the indices of `planet1` and `planet2` within the `order_of_planets` list using the `index()` method. This gives us their positions relative to each other.\n\n4. **Order Adjustment**: If `planet1` is farther from the Sun than `planet2`, it swaps their indices so that `planet1` always comes before `planet2` in terms of proximity to the Sun.\n\n5. **Result Construction**: Finally, the function returns a sublist of `order_of_planets` starting right after `planet1` and ending just before `planet2`. This sublist contains all planets whose orbits are between those of `planet1` and `planet2`.\n\nThis approach ensures that the returned list is always sorted by proximity to the Sun and correctly handles cases where either input planet name is invalid."}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string>& lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the list by length, and then alphabetically for strings of the same length\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n", "py_code": "from typing import List\n\ndef vector_sort(lst: List[str]) -> List[str]:\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for strings of the same length\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings\n```\n\n", "py_summary": "The Python code defines a function `vector_sort` that takes a list of strings as input and returns a sorted list according to specific criteria:\n\n1. **Remove Strings with Odd Lengths**: The function first filters out all strings from the input list that have odd lengths, keeping only those with even lengths.\n2. **Sort by Length and Alphabetically**: It then sorts the remaining strings based on their length in ascending order. If two strings have the same length, it further sorts them alphabetically.\n\nHere's a breakdown of how this is achieved:\n- A list comprehension `[s for s in lst if len(s) % 2 == 0]` filters out all strings with odd lengths.\n- The `sort()` method is used on the filtered list. The `key=lambda x: (len(x), x)` ensures that sorting happens first by length and then alphabetically when lengths are equal.\n\nThis approach ensures that the returned list meets the requirements of having only even-length strings, sorted primarily by their length and secondarily alphabetically for ties in length."}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function that returns x if n is prime, otherwise y\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n", "py_code": "def x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "The Python code defines a function `x_or_y` that takes three integers as input: `n`, `x`, and `y`. The function checks if `n` is a prime number using another helper function called `is_prime`.\n\nHere's an analysis of each part:\n\n1. **Function Definition**:\n   - `def x_or_y(n, x, y)`: This defines the main function that takes three integer arguments: `n`, `x`, and `y`.\n   \n2. **Prime Check Function**:\n   - `def is_prime(num)`: This helper function checks if a given number `num` is prime.\n     - If `num <= 1`, it returns `False` because neither 0 nor 1 are considered prime numbers.\n     - It then iterates from 2 to the square root of `num` (inclusive). For each integer in this range, it checks if `num` is divisible by that integer. If any such divisor exists, it means `num` is not a prime number and the function returns `False`.\n     - If no divisors are found within the loop, the function returns `True`, indicating that `num` is a prime number.\n\n3. **Main Function Logic**:\n   - The main function calls `is_prime(n)` to determine if `n` is a prime number.\n   - If `n` is prime (`is_prime(n) == True`), it returns the value of `x`.\n   - Otherwise, it returns the value of `y`.\n\nThis approach ensures that the correct value is returned based on whether `n` is a prime number or not."}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum_of_squares += std::pow(static_cast<int>(num), 2);\n        }\n    }\n    return sum_of_squares;\n}\n", "py_code": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    sum_of_squares = 0\n    for num in lst:\n        if num > 0 and num == int(num):  # Check if number is positive and an integer\n            if num % 2 != 0:  # Check if the number is odd\n                sum_of_squares += num ** 2\n    return sum_of_squares\n```\n\n", "py_summary": "The Python function `double_the_difference` takes a list of floating-point numbers as input and returns the sum of squares of the odd positive integers in the list. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `sum_of_squares` is initialized to 0, which will store the cumulative sum of squares of the qualifying numbers.\n\n2. **Iteration through the List**: A loop iterates over each element `num` in the input list `lst`.\n\n3. **Condition Checks**:\n   - **Positive and Integer Check**: The condition `if num > 0 and num == int(num)` ensures that only positive integers are considered.\n     - `num > 0`: Ensures the number is positive.\n     - `num == int(num)`: Converts the float to an integer and checks if it's equal, ensuring the number is a whole number (integer).\n   - **Odd Number Check**: The condition `if num % 2 != 0` ensures that only odd numbers are considered.\n\n4. **Sum of Squares Calculation**: If all conditions are met, the square of the number (`num ** 2`) is added to `sum_of_squares`.\n\n5. **Return Result**: After iterating through all elements in the list, the function returns the value stored in `sum_of_squares`.\n\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int difference = std::abs(game[i] - guess[i]);\n        result.push_back(difference);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    result = []\n    for i in range(len(game)):\n        difference = abs(game[i] - guess[i])\n        result.append(difference)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `compare` that takes two lists of integers (`game` and `guess`) as input and returns a list indicating how far off each guess was from the actual game scores.\n\n1. **Initialization**: An empty list `result` is initialized to store the differences.\n2. **Iteration**: A loop iterates through each index in the length of the `game` list (which is assumed to be equal to the length of the `guess` list).\n3. **Difference Calculation**: For each index, it calculates the absolute difference between the corresponding elements in the `game` and `guess` lists.\n4. **Appending Result**: The calculated difference is appended to the `result` list.\n5. **Return**: Finally, the function returns the `result` list containing all the differences.\n\nThis approach ensures that each guess is compared with its corresponding score from the game, and the absolute difference between them is recorded in the result vector."}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension = \"\";\n    \n    for (const auto& extension : extensions) {\n        int cap_count = 0;\n        int sm_count = 0;\n        \n        for (char c : extension) {\n            if (isupper(c)) {\n                cap_count++;\n            } else if (islower(c)) {\n                sm_count++;\n            }\n        }\n        \n        int strength = cap_count - sm_count;\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() > 0 && extensions[extensions.size()-1] != strongest_extension)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n", "py_code": "def strongest_extension(class_name, extensions):\n    max_strength = float('-inf')\n    strongest_extension = \"\"\n    \n    for extension in extensions:\n        cap_count = sum(1 for c in extension if c.isupper())\n        sm_count = sum(1 for c in extension if c.islower())\n        strength = cap_count - sm_count\n        \n        if strength > max_strength or (strength == max_strength and extensions.index(extension) < extensions.index(strongest_extension)):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\"\n```\n\n", "py_summary": "The Python function `strongest_extension` is designed to determine the strongest extension for a given class based on the provided extensions and their calculated strengths. Here's an analysis of how it works:\n\n1. **Initialization**: The function initializes `max_strength` to negative infinity (`float('-inf')`) to ensure any strength value will be greater than this initial value. It also initializes `strongest_extension` as an empty string.\n\n2. **Loop Through Extensions**: The function iterates through each extension in the list of extensions.\n   - For each extension, it calculates the number of uppercase letters (`cap_count`) and lowercase letters (`sm_count`) using generator expressions inside the `sum()` function.\n   - It then computes the strength of the extension as `cap_count - sm_count`.\n\n3. **Update Strongest Extension**: The function checks if the current extension's strength is greater than the maximum strength found so far (`max_strength`). If it is, or if there is a tie and the current extension appears before the previously strongest extension in the list (using `extensions.index(extension)`), then:\n   - It updates `max_strength` to the current extension's strength.\n   - It sets `strongest_extension` to the current extension.\n\n4. **Return Result**: After iterating through all extensions, the function returns a string formatted as `\"ClassName.StrongestExtensionName\"` using an f-string.\n\nThis approach ensures that the strongest extension is correctly identified based on the given criteria and returned in the specified format."}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the string 'a' with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n", "py_code": "def cycpattern_check(a: str, b: str) -> bool:\n    # Concatenate the string 'a' with itself\n    doubled_a = a + a\n    \n    # Check if 'b' is a substring of the concatenated string\n    return b in doubled_a\n```\n\n", "py_summary": "The Python function `cycpattern_check` checks whether the second word or any of its rotations is a substring of the first word. Here's an analysis of how it works:\n\n1. **Concatenate the First Word with Itself**: \n   - The function concatenates the string `a` with itself to form `doubled_a`. This step ensures that all possible rotations of `b` are covered within this concatenated string.\n   \n2. **Check for Substring**:\n   - The function then checks if `b` is a substring of `doubled_a`. If it is, the function returns `True`, indicating that some rotation of `b` is indeed a substring of `a`.\n   - If `b` is not found as a substring in `doubled_a`, the function returns `False`.\n\nBy concatenating `a` with itself, we effectively create a circular representation of all possible rotations of `a`. This allows us to check for any rotation of `b` within this extended string.\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def even_odd_count(num):\n    # Convert the number to a string to easily iterate over each digit\n    str_num = str(abs(num))\n    even_count = 0\n    odd_count = 0\n    \n    for digit in str_num:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    return [even_count, odd_count]\n```\n\n", "py_summary": "The Python function `even_odd_count` takes an integer `num` as input and returns a list containing the counts of even and odd digits in that number.\n\n1. **Convert to String**: The absolute value of the input number is converted to a string (`str(abs(num))`). This allows easy iteration over each digit.\n2. **Initialize Counts**: Two counters, `even_count` and `odd_count`, are initialized to zero to keep track of even and odd digits respectively.\n3. **Iterate Over Digits**: The function iterates through each character in the string representation of the number. Each character is converted back to an integer (`int(digit)`) to check if it is even or odd using the modulus operator `%`.\n4. **Update Counts**: If a digit is even (i.e., `digit % 2 == 0`), the `even_count` is incremented; otherwise, the `odd_count` is incremented.\n5. **Return Result**: Finally, the function returns a list containing the counts of even and odd digits.\n\nThis approach ensures that all digits are processed correctly regardless of whether the input number is positive or negative."}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the mapping of integers to Roman numerals\n    vector<pair<int, char>> roman_map = {\n        {1000, 'm'}, {900, 'cm'}, {500, 'd'}, {400, 'cd'},\n        {100, 'c'},  {90, 'xc'},  {50, 'l'},  {40, 'xl'},\n        {10, 'x'},   {9, 'ix'},   {5, 'v'},   {4, 'iv'}, {1, 'i'}\n    };\n\n    string roman_numeral = \"\";\n\n    // Convert the integer to a Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n", "py_code": "def int_to_mini_roman(number):\n    # Define the mapping of integers to Roman numerals\n    roman_map = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    \n    roman_numeral = ''\n    \n    # Convert the integer to a Roman numeral\n    for value, symbol in roman_map:\n        while number >= value:\n            roman_numeral += symbol\n            number -= value\n    \n    return roman_numeral\n```\n\n", "py_summary": "The Python function `int_to_mini_roman` converts a given integer to its Roman numeral equivalent and returns it in lowercase. Here's an analysis of how the function works:\n\n1. **Mapping Definition**: The function starts by defining a list called `roman_map`, which contains tuples representing the values and corresponding Roman numeral symbols for numbers from 1000 down to 1.\n\n2. **Initialization**: An empty string `roman_numeral` is initialized to store the resulting Roman numeral.\n\n3. **Conversion Loop**: A loop iterates over each tuple in `roman_map`. For each tuple `(value, symbol)`, the function checks if the input number is greater than or equal to `value`.\n\n4. **Appending Symbols**: If the condition is true, the corresponding Roman numeral symbol is appended to `roman_numeral` and the value of `number` is reduced by `value`. This process continues until `number` becomes less than `value`, ensuring that the largest possible Roman numeral symbols are used first.\n\n5. **Return Result**: Once all values in `roman_map` have been processed, the function returns the constructed `roman_numeral`.\n\nThis approach ensures that the integer is converted to its minimal form of Roman numerals by using the largest available symbol as often as possible before moving on to smaller symbols.\n\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Store the sides in an array to sort them easily\n    float sides[3] = {a, b, c};\n    \n    // Sort the sides to ensure the longest side is last\n    for (int i = 0; i < 2; ++i) {\n        if (sides[i] > sides[i + 1]) {\n            float temp = sides[i];\n            sides[i] = sides[i + 1];\n            sides[i + 1] = temp;\n        }\n    }\n\n    // Check the Pythagorean theorem with a tolerance to handle floating-point precision\n    const float epsilon = 1e-6; // Small value for comparison tolerance\n    if (fabs(sides[2] * sides[2] - (sides[0] * sides[0] + sides[1] * sides[1])) < epsilon) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "py_code": "import math\n\ndef right_angle_triangle(a, b, c):\n    # Sort the sides to ensure the longest side is last\n    sides = sorted([a, b, c])\n    \n    # Check if the square of the longest side equals the sum of squares of the other two sides\n    return math.isclose(sides[2] ** 2, sides[0] ** 2 + sides[1] ** 2)\n```\n\n", "py_summary": "The Python function `right_angle_triangle` checks if three given side lengths can form a right-angled triangle. Here's an analysis of how it works:\n\n1. **Sorting the Sides**: The sides are sorted in ascending order to ensure that the longest side is always the last element (`sides[2]`). This helps in easily identifying which side could be the hypotenuse.\n\n2. **Pythagorean Theorem Check**: According to the Pythagorean theorem, for a right-angled triangle with sides `a`, `b`, and hypotenuse `c` (where `c` is the longest side), the relationship `c^2 = a^2 + b^2` must hold true. In this function, the condition `sides[2] ** 2 == sides[0] ** 2 + sides[1] ** 2` checks if the square of the longest side equals the sum of squares of the other two sides.\n\n3. **Floating-Point Precision**: Since floating-point arithmetic can introduce small errors, the function uses `math.isclose()` to check for approximate equality rather than exact equality. This ensures that minor numerical inaccuracies do not affect the result.\n\n4. **Return Value**: The function returns `True` if the condition is met (indicating a right-angled triangle) and `False` otherwise.\n\nThis approach ensures accurate determination of whether the given sides can form a right-angled triangle, accounting for potential floating-point precision issues."}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result_word = \"\";\n    int max_unique_chars = 0;\n    \n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end());\n        int current_unique_chars = unique_chars.size();\n        \n        if (current_unique_chars > max_unique_chars || \n            (current_unique_chars == max_unique_chars && word < result_word)) {\n            max_unique_chars = current_unique_chars;\n            result_word = word;\n        }\n    }\n    \n    return result_word;\n}\n", "py_code": "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    max_unique_chars = 0\n    result_word = \"\"\n    \n    for word in words:\n        unique_chars = len(set(word))\n        \n        if unique_chars > max_unique_chars or (unique_chars == max_unique_chars and word < result_word):\n            max_unique_chars = unique_chars\n            result_word = word\n            \n    return result_word\n```\n\n", "py_summary": "The Python code defines a function `find_max` that takes a list of strings as input and returns the string with the maximum number of unique characters. If multiple strings have the same number of unique characters, it returns the one that comes first in lexicographical order.\n\nHere's a breakdown of how the function works:\n\n1. **Initialization**: \n   - `max_unique_chars` is initialized to 0 to keep track of the highest number of unique characters found so far.\n   - `result_word` is initialized as an empty string to store the word with the maximum number of unique characters.\n\n2. **Iterate through each word**:\n   - For each word in the list, it calculates the number of unique characters using `len(set(word))`. The `set()` function removes duplicate characters and `len()` returns the count of unique characters.\n   \n3. **Update result if necessary**:\n   - If the current word has more unique characters than `max_unique_chars`, or if it has the same number but comes before the current `result_word` in lexicographical order, then update `max_unique_chars` and set `result_word` to the current word.\n\n4. **Return result**:\n   - After iterating through all words, return the `result_word`.\n\nThis approach ensures that the function correctly identifies the word with the maximum number of unique characters while also considering lexicographical order in case of ties.\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after meals\n    int total_eaten = number + std::min(need, remaining);\n\n    // Calculate the number of remaining carrots left after eating\n    int carrots_left = std::max(0, remaining - need);\n\n    // Return a vector containing the total number of eaten carrots and the number of carrots left\n    return {total_eaten, carrots_left};\n}\n", "py_code": "def eat(number: int, need: int, remaining: int) -> list:\n    total_eaten = number + min(need, remaining)\n    carrots_left = max(0, remaining - need)\n    return [total_eaten, carrots_left]\n```\n\n", "py_summary": "The Python function `eat` takes three integer parameters: `number`, `need`, and `remaining`. These represent the number of carrots already eaten, the number of additional carrots needed to be eaten, and the number of remaining carrots available in stock, respectively.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Calculate Total Eaten Carrots**:\n   - The total number of carrots eaten after the meals is calculated as `number + min(need, remaining)`. This means that you add the minimum value between the required `need` and the available `remaining` to the already eaten `number`.\n\n2. **Calculate Remaining Carrots**:\n   - The number of remaining carrots left after eating is determined by subtracting the needed amount from the remaining stock: `max(0, remaining - need)`. This ensures that if there are not enough remaining carrots to meet the requirement (`need`), you eat all available remaining carrots and set the leftover to 0.\n\n3. **Return Result**:\n   - The function returns a list containing two elements: \n     - The total number of carrots eaten.\n     - The number of carrots left after eating.\n\nThis approach ensures that if there are not enough remaining carrots, you will eat all available ones but still be hungry (indicated by the leftover being 0).\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    std::stringstream expression;\n    \n    // Initialize the expression with the first operand\n    expression << operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        // Append operator and next operand to the expression string\n        expression << \" \" << operators[i] << \" \" << operands[i + 1];\n    }\n    \n    // Evaluate the constructed expression using std::stringstream's str() method\n    std::string expr_str = expression.str();\n    std::istringstream iss(expr_str);\n    int result;\n    iss >> std::boolalpha >> result;  // This line is incorrect for evaluation, we need to use eval equivalent\n    \n    // Since C++ does not have an eval function like Python, we will evaluate the expression manually\n    int current_value = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            current_value += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            current_value -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            current_value *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            current_value /= operands[i + 1]; // Note: This will perform integer division\n        } else if (operators[i] == \"**\") {\n            int power = operands[i + 1];\n            for (int j = 0; j < power - 1; ++j) {\n                current_value *= operands[i + 1];\n            }\n        }\n    }\n\n    return current_value;\n}\n", "py_code": "def do_algebra(operators: list[str], operands: list[int]) -> int:\n    expression = str(operands[0])\n    \n    for i in range(len(operators)):\n        operator = operators[i]\n        operand = operands[i + 1]\n        \n        if operator == '+':\n            expression += f\" + {operand}\"\n        elif operator == '-':\n            expression += f\" - {operand}\"\n        elif operator == '*':\n            expression += f\" * {operand}\"\n        elif operator == '//':\n            expression += f\" // {operand}\"\n        elif operator == '**':\n            expression += f\" ** {operand}\"\n    \n    return eval(expression)\n```\n\n", "py_summary": "The Python function `do_algebra` takes two parameters: a list of strings representing algebraic operators (`operators`) and a list of integers representing operands (`operands`). The goal is to construct an arithmetic expression from these inputs and evaluate it.\n\n1. **Initialization**: \n   - Start by initializing the string `expression` with the first operand in the `operands` list.\n   \n2. **Expression Construction**:\n   - Iterate through each operator in the `operators` list.\n   - For each operator, append the corresponding operator symbol (e.g., '+', '-', '*', '//', '**') and the next operand from the `operands` list to the `expression` string.\n\n3. **Evaluation**:\n   - After constructing the expression as a string, use Python's built-in `eval()` function to evaluate this arithmetic expression and return the result.\n\nThis approach ensures that the algebraic expression is correctly formed based on the provided operators and operands, and then evaluated to produce the final numerical result.\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isalpha(), islower(), toupper(), tolower()\n\nstd::string solve(std::string s) {\n    std::string result = \"\";\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            // Reverse case of letter\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            // Keep non-letter characters as they are\n            result += c;\n        }\n    }\n\n    // If no letters are present, reverse the string\n    bool contains_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            contains_letter = true;\n            break;\n        }\n    }\n\n    if (!contains_letter) {\n        return std::string(result.rbegin(), result.rend());\n    }\n\n    return result;\n}\n", "py_code": "def solve(s):\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Reverse case of letter\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    \n    # If no letters are present, reverse the string\n    if all(not c.isalpha() for c in s):\n        return ''.join(result)[::-1]\n    \n    return ''.join(result)\n```\n\n", "py_summary": "The Python function `solve` processes a given string `s` according to specific rules and returns the modified string. Here's an analysis of how it works:\n\n1. **Initialization**: An empty list called `result` is initialized to store characters as they are processed.\n\n2. **Iteration through Characters**:\n   - The function iterates over each character in the input string `s`.\n   - For each character, it checks if the character is an alphabetic letter using `char.isalpha()`.\n\n3. **Case Reversal for Letters**:\n   - If the character is a letter (`isalpha` returns True), the function further checks whether the letter is lowercase or uppercase.\n     - If the letter is lowercase (`char.islower()` returns True), it converts the letter to uppercase using `char.upper()` and appends the result to `result`.\n     - If the letter is uppercase, it converts the letter to lowercase using `char.lower()` and appends the result to `result`.\n\n4. **Preserve Non-Letter Characters**:\n   - If the character is not a letter (i.e., it's a digit or symbol), it is appended to `result` as-is.\n\n5. **Check for No Letters**:\n   - After processing all characters, the function checks if there were any letters in the original string using `all(not c.isalpha() for c in s)`.\n   - If no letters are present (`all` returns True), it reverses the entire list of processed characters and joins them into a single string.\n\n6. **Return Result**:\n   - Finally, the function joins all elements in `result` to form the final modified string and returns it.\n\nThis approach ensures that the input string is transformed according to the specified rules: reversing case for letters and reversing the entire string if no letters are present."}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function to convert byte array to hexadecimal string\nstring bytes_to_hex(const unsigned char* digest, size_t len) {\n    static const char hex_digits[] = \"0123456789abcdef\";\n    string hex;\n    for (size_t i = 0; i < len; ++i) {\n        hex += hex_digits[(digest[i] >> 4) & 0x0F];\n        hex += hex_digits[digest[i] & 0x0F];\n    }\n    return hex;\n}\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode('utf-8'))\n    return md5_hash.hexdigest()\n```\n", "py_summary": "The Python code defines a function `string_to_md5` that takes a string `text` as input and returns its MD5 hash equivalent if the string is not empty. Here's a breakdown of how it works:\n\n1. **Check for Empty String**: The function first checks if the input string `text` is empty using `if not text:`. If `text` is an empty string, the function returns `None`.\n\n2. **Initialize MD5 Hash Object**: If the string is not empty, the function initializes an MD5 hash object using `hashlib.md5()`.\n\n3. **Update Hash with Input String**: The input string `text` is encoded to bytes using UTF-8 encoding and then passed to the update method of the MD5 hash object: `md5_hash.update(text.encode('utf-8'))`.\n\n4. **Generate Hex Digest**: Finally, the function returns the hexadecimal representation of the computed MD5 hash by calling `md5_hash.hexdigest()`.\n\nThis approach ensures that the input string is properly hashed and returned in a consistent format if it is not empty. If the input is an empty string, the function adheres to the requirement by returning `None`.\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure a is less than or equal to b for simplicity\n    int start = min(a, b);\n    int end = max(a, b);\n\n    vector<int> even_digits;\n    \n    // Iterate through the range from start to end (inclusive)\n    for (int num = start; num <= end; ++num) {\n        // Check if the number is less than 10 and even\n        if (num < 10 && num % 2 == 0) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n", "py_code": "def generate_integers(a: int, b: int):\n    # Ensure a is less than or equal to b for simplicity\n    start = min(a, b)\n    end = max(a, b)\n    \n    even_digits = []\n    for num in range(start, end + 1):\n        if num % 2 == 0 and num < 10:\n            even_digits.append(num)\n    \n    return sorted(even_digits)\n```\n\n", "py_summary": "The Python function `generate_integers(a: int, b: int)` is designed to generate a list of even digits between two given integers `a` and `b`, inclusive, in ascending order. Here's a detailed breakdown of how it works:\n\n1. **Ensure Order**: The function first ensures that `start` is the smaller of the two input integers (`a` and `b`) and `end` is the larger one. This step simplifies the logic for iterating through the range.\n\n2. **Initialize List**: An empty list `even_digits` is initialized to store the even digits found within the specified range.\n\n3. **Iterate Through Range**: The function iterates through all integers from `start` to `end`, inclusive, using a for loop.\n\n4. **Check Even Digits**: For each integer in this range, it checks if the number is less than 10 and even (i.e., divisible by 2). If both conditions are met, the number is added to the list `even_digits`.\n\n5. **Return Result**: Finally, the function returns the sorted list of even digits. Since the numbers are already in ascending order due to the range iteration, sorting is not strictly necessary here but ensures clarity and correctness.\n\nThis approach guarantees that all even digits between `a` and `b` (inclusive) are captured and returned in ascending order if they exist within the specified constraints.\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements\n    std::sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list and check if any two adjacent elements are closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true;\n        }\n    }\n    \n    // If no close elements found, return false\n    return false;\n}\n", "py_code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i+1] - numbers[i]) < threshold:\n            return True\n    return False\n```\n\n", "py_summary": "The Python code defines a function `has_close_elements` that takes a list of floating-point numbers and a threshold value as input. The function checks if there are any two numbers in the list that are closer to each other than the given threshold.\n\nHere's a step-by-step analysis:\n\n1. **Sorting the List**: \n   - The input list `numbers` is sorted in ascending order using `numbers.sort()`. Sorting helps in easily comparing adjacent elements, which simplifies finding the closest pair of numbers.\n\n2. **Iterating Through the Sorted List**:\n   - A loop iterates through each element in the sorted list except for the last one.\n   - For each element at index `i`, it compares the difference between `numbers[i+1]` and `numbers[i]`.\n\n3. **Checking the Threshold Condition**:\n   - The function calculates the absolute difference between adjacent elements using `abs(numbers[i+1] - numbers[i])`.\n   - If this difference is less than the threshold, the function immediately returns `True`, indicating that there are two numbers closer to each other than the threshold.\n\n4. **Returning False if No Close Elements Found**:\n   - If no such pair of elements is found after iterating through the entire list, the function returns `False`.\n\nThis approach ensures an efficient way to check for close elements by leveraging sorting and a single pass through the sorted list, making it O(n log n) due to the sort operation.\n\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    stack<char> s;\n    string current_group = \"\";\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            s.pop();\n            current_group += c;\n            if (s.empty()) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = \"\"\n    \n    for char in paren_string.replace(\" \", \"\"):\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        elif char == \")\":\n            stack.pop()\n            current_group += char\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"\n                \n    return result\n```\n\n", "py_summary": "The Python code defines a function `separate_paren_groups` that takes a string containing multiple groups of nested parentheses and separates those groups into separate strings, returning them in a list. Here's an analysis of how it works:\n\n1. **Input Processing**: The input string is processed to remove any spaces using the `replace(\" \", \"\")` method.\n\n2. **Initialization**:\n   - `result`: A list to store the separated groups.\n   - `stack`: A stack used to keep track of open parentheses and ensure balanced groups.\n   - `current_group`: A string that accumulates characters for the current group being processed.\n\n3. **Iteration through Characters**: The function iterates through each character in the input string:\n   - If the character is an opening parenthesis `(`, it is added to both the stack and `current_group`.\n   - If the character is a closing parenthesis `)`, it is also added to `current_group`. Additionally, the corresponding opening parenthesis is popped from the stack.\n   \n4. **Balanced Group Detection**: When the stack becomes empty (indicating that all open parentheses have been closed), the current group is considered complete and is appended to the result list.\n\n5. **Return Result**: Finally, the function returns the `result` list containing all separated groups of balanced parentheses.\n\nThis approach ensures that each group of nested parentheses is properly identified and separated without nesting within other groups."}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n```\n", "py_summary": "The Python function `truncate_number` takes a floating-point number as input and returns its decimal part. Here's how it works:\n\n1. **Extract Integer Part**: The integer part of the number is obtained by converting the float to an integer using the `int()` function, which truncates the decimal part.\n2. **Calculate Decimal Part**: The decimal part is then calculated by subtracting the integer part from the original number.\n\nThe result is a floating-point value representing only the fractional part of the input number, ensuring that it lies between 0 (inclusive) and 1 (exclusive).\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n```\n\n", "py_summary": "The Python function `below_zero` checks whether a bank account's balance falls below zero given a list of deposit and withdrawal operations. Here\u2019s an analysis of how it works:\n\n1. **Initialization**: The function starts by initializing the account balance to 0.\n2. **Iteration through Operations**: It iterates through each operation in the input list `operations`.\n3. **Update Balance**: For each operation, it updates the balance by adding the value of the current operation (which can be positive for deposits or negative for withdrawals).\n4. **Check Condition**: After updating the balance, it checks if the balance is less than zero.\n5. **Return Result**: If at any point the balance falls below zero, the function immediately returns `True`. If no such condition is met after processing all operations, the function returns `False`.\n\nThis approach ensures that the function efficiently detects when the account balance goes negative by keeping track of the cumulative sum and checking for a negative value during each iteration.\n\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f;\n    }\n    \n    // Calculate the mean value of the dataset\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean_value = sum / numbers.size();\n    \n    // Calculate the absolute differences from the mean and then their average\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean_value);\n    }\n    float mad = mad_sum / numbers.size();\n    \n    return mad;\n}\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean and then their average\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad\n```\n\n", "py_summary": "The Python code defines a function `mean_absolute_deviation` that calculates the Mean Absolute Deviation (MAD) of a given list of floating-point numbers. Here's a detailed breakdown of how it works:\n\n1. **Input Validation**: The function first checks if the input list is empty. If it is, the function returns 0.0 to avoid division by zero errors.\n\n2. **Calculate Mean**:\n   - It calculates the mean (average) value of the dataset using `sum(numbers) / len(numbers)`.\n\n3. **Calculate Absolute Differences and Average**:\n   - The function then computes the absolute differences between each element in the list and the calculated mean.\n   - These absolute differences are summed up, and their average is computed by dividing the sum by the number of elements in the dataset.\n\n4. **Return Result**: Finally, the function returns the calculated Mean Absolute Deviation (MAD).\n\nThis approach ensures that the MAD is accurately computed as the average of the absolute deviations from the mean for all elements in the input list."}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0) {\n            result.push_back(delimiter);\n        }\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i > 0:\n            result.append(delimiter)\n        result.extend([numbers[i]])\n    return result\n```\n\n", "py_summary": "The Python code defines a function `intersperse` that takes a list of integers (`numbers`) and an integer delimiter as input. The function inserts the delimiter between every two consecutive elements in the list and returns the modified list.\n\nHere's a breakdown of how the function works:\n1. **Initialization**: An empty list `result` is initialized to store the final output.\n2. **Iteration through the List**: A loop iterates over each element in the input list `numbers`.\n   - If the current index (`i`) is greater than 0, it means there are preceding elements and a delimiter should be inserted before the current element. Therefore, the delimiter is appended to `result`.\n   - The current element from `numbers` is then added to `result`.\n3. **Return Result**: After iterating through all elements in `numbers`, the function returns the modified list stored in `result`.\n\nThis approach ensures that the delimiter is inserted between every pair of consecutive elements, and no delimiter is added before the first element or after the last element.\n\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> results;\n    \n    // Split the input string into groups based on spaces\n    size_t start = 0, end = 0;\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        start = end + 1;\n        \n        // Process each group to find the maximum depth of nesting\n        int max_depth = 0;\n        int current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        // Append the maximum depth of the current group to results\n        results.push_back(max_depth);\n    }\n\n    // Process the last group in the string\n    string last_group = paren_string.substr(start);\n    int max_depth = 0;\n    int current_depth = 0;\n    for (char c : last_group) {\n        if (c == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') {\n            current_depth--;\n        }\n    }\n    \n    results.push_back(max_depth);\n\n    return results;\n}\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    results = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        results.append(max_depth)\n    \n    return results\n```\n\n", "py_summary": "The Python function `parse_nested_parens` takes a string of nested parentheses groups separated by spaces and returns a list containing the deepest level of nesting for each group.\n\n1. **Splitting the Input String**: The input string is split into individual groups based on spaces using `split()`. Each group represents a separate sequence of nested parentheses.\n2. **Initializing Variables**: For each group, two variables are initialized:\n   - `max_depth` to keep track of the deepest level of nesting encountered in the current group.\n   - `current_depth` to keep track of the current depth as we iterate through the characters in the group.\n3. **Iterating Through Characters**: The function iterates through each character in the group:\n   - If the character is an opening parenthesis '(', the `current_depth` is incremented by 1, and `max_depth` is updated to be the maximum of its current value and `current_depth`.\n   - If the character is a closing parenthesis ')', the `current_depth` is decremented by 1.\n4. **Appending Results**: After processing each group, the deepest level of nesting (`max_depth`) for that group is appended to the results list.\n5. **Returning Results**: Finally, the function returns the list containing the maximum depth for each group.\n\nThis approach ensures that we correctly track and determine the deepest level of nesting in each group of parentheses."}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    for (const auto& s : strings) {\n        if (s.find(substring) != string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n\n    return filtered_strings;\n}\n", "py_code": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = [s for s in strings if substring in s]\n    return filtered_strings\n```\n\n", "py_summary": "The Python code defines a function `filter_by_substring` that takes two parameters: a list of strings (`strings`) and a substring (`substring`). The function filters the input list to include only those strings that contain the specified substring.\n\nHere's an analysis of how it works:\n1. **List Comprehension**: A list comprehension is used to iterate through each string in `strings`.\n2. **Substring Check**: For each string, the code checks if the given `substring` is present within the string using the `in` operator.\n3. **Filtered List**: If a string contains the substring, it is included in the resulting filtered list (`filtered_strings`).\n4. **Return Value**: The function returns the filtered list of strings.\n\nThis approach ensures that only strings containing the specified substring are returned, effectively filtering out all other strings from the input list.\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    \n    int total_sum = 0;\n    int total_product = 1;\n\n    for (int number : numbers) {\n        total_sum += number;\n        total_product *= number;\n    }\n\n    return {total_sum, total_product};\n}\n", "py_code": "from typing import List\n\ndef sum_product(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return [0, 1]\n    \n    total_sum = 0\n    total_product = 1\n    \n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    \n    return [total_sum, total_product]\n```\n\n", "py_summary": "The Python code defines a function `sum_product` that takes a list of integers as input and returns a list containing the sum and product of all the integers in the list.\n\n1. **Initial Check for Empty List**:\n   - The function first checks if the input list is empty (`if not numbers:`). If it is, the function returns `[0, 1]` because the sum of an empty set is `0` and the product is `1`.\n\n2. **Initialization**:\n   - Two variables are initialized: `total_sum` to `0` and `total_product` to `1`. These will be used to accumulate the sum and product of the numbers in the list.\n\n3. **Iteration and Accumulation**:\n   - The function iterates through each number in the input list.\n   - For each number, it adds the number to `total_sum`.\n   - It also multiplies the current number with `total_product` to update the cumulative product.\n\n4. **Return Result**:\n   - After iterating through all numbers, the function returns a list containing `total_sum` and `total_product`.\n\nThis approach ensures that both sum and product are calculated correctly for any given list of integers, including handling the special case of an empty list."}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    int max_so_far = INT_MIN;  // Initialize to the smallest possible integer value\n    std::vector<int> result;\n    \n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;\n        }\n        result.push_back(max_so_far);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float('-inf')\n    result = []\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `rolling_max` that takes a list of integers as input and returns a new list where each element is the maximum value encountered so far in the sequence up to that point.\n\nHere's a breakdown of how the function works:\n\n1. **Initialization**:\n   - `max_so_far` is initialized to negative infinity (`float('-inf')`). This ensures that any number from the input list will be greater than this initial value.\n   - An empty list `result` is created to store the rolling maximum values.\n\n2. **Iteration through the Input List**:\n   - The function iterates through each element in the input list using a for loop.\n   - For each element (`num`) in the list, it checks if `num` is greater than the current value of `max_so_far`.\n   - If `num` is greater, `max_so_far` is updated to `num`.\n\n3. **Appending Rolling Maximum**:\n   - Regardless of whether `max_so_far` was updated or not, the function appends the current value of `max_so_far` to the `result` list.\n\n4. **Return Result**:\n   - After iterating through all elements in the input list, the function returns the `result` list containing the rolling maximum values.\n\nThis approach ensures that for each element in the input list, the corresponding element in the output list is the highest value encountered up to that point in the sequence.\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\"\n    */\n    if (str.empty()) {\n        return \"\";\n    }\n    \n    for (int i = str.size(); i >= 0; --i) {\n        string prefix = str.substr(i);\n        if (is_palindrome(prefix)) {\n            string non_palindromic_prefix = str.substr(0, i);\n            return str + string(non_palindromic_prefix.rbegin(), non_palindromic_prefix.rend());\n        }\n    }\n\n    // In case no palindromic suffix is found, which should not happen for any input\n    return str;\n}\n", "py_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef make_palindrome(str_input):\n    if not str_input:\n        return \"\"\n    \n    for i in range(len(str_input), -1, -1):\n        if is_palindrome(str_input[:i]):\n            prefix = str_input[i:]\n            break\n    \n    return str_input + prefix[::-1]\n```\n\n", "py_summary": "The Python code defines two functions: `is_palindrome` and `make_palindrome`.\n\n1. **is_palindrome(s)**:\n   - This function checks if a given string `s` is a palindrome.\n   - It returns `True` if the string reads the same forwards and backwards, otherwise it returns `False`.\n   - The check is performed by comparing the string to its reverse (`s[::-1]`).\n\n2. **make_palindrome(str_input)**:\n   - This function finds the shortest palindrome that begins with a supplied string.\n   - It first checks if the input string is empty and returns an empty string if it is.\n   - The function then iterates through all possible prefixes of `str_input`, checking each prefix to see if its suffix (the remaining part of the string) is a palindrome using the `is_palindrome` function.\n   - Once it finds the longest palindromic suffix, it determines the non-palindromic prefix that precedes this suffix.\n   - It appends the reverse of this prefix to the end of the original string to form the shortest possible palindrome.\n\n### Summary:\n- The `is_palindrome` function checks if a given string is a palindrome by comparing it with its reversed version.\n- The `make_palindrome` function finds the longest palindromic suffix in the input string and appends the reverse of the non-palindromic prefix to form the shortest possible palindrome.\n\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR operation between corresponding bits of a and b\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n", "py_code": "def string_xor(a: str, b: str) -> str:\n    result = \"\"\n    for i in range(len(a)):\n        # XOR operation between corresponding bits of a and b\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n```\n\n", "py_summary": "The Python function `string_xor` takes two string inputs `a` and `b`, both consisting of binary digits (1s and 0s). The function performs a bitwise XOR operation on these strings and returns the result as a new string.\n\nHere's a detailed breakdown:\n1. **Initialization**: An empty string `result` is initialized to store the final output.\n2. **Iteration**: A loop runs through each character of the input strings (assuming both strings are of equal length).\n3. **XOR Operation**: For each pair of corresponding characters from `a` and `b`, the function checks if they are the same:\n   - If the characters are the same (`a[i] == b[i]`), it appends '0' to the result string.\n   - If the characters are different, it appends '1' to the result string.\n4. **Return**: After iterating through all characters, the function returns the `result` string.\n\nThis approach ensures that each corresponding pair of bits from the two strings is processed correctly according to the XOR logic (0 if both bits are the same, 1 otherwise).\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::string(); // Return an empty string to represent None in C++\n    }\n    \n    size_t max_length = 0;\n    std::string longest_string = \"\";\n    \n    for (const auto& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            longest_string = str;\n        }\n    }\n    \n    return longest_string;\n}\n", "py_code": "from typing import List\n\ndef longest(strings: List[str]) -> str:\n    if not strings:\n        return None\n    \n    max_length = 0\n    longest_string = \"\"\n    \n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_string = string\n            \n    return longest_string\n```\n\n", "py_summary": "The Python code defines a function `longest` that takes a list of strings as input and returns the longest string in the list. If there are multiple strings with the same maximum length, it returns the first one encountered. If the input list is empty, it returns `None`.\n\nHere's a breakdown of how the function works:\n1. **Check for an Empty List**: The function first checks if the input list `strings` is empty. If it is, the function immediately returns `None`.\n2. **Initialize Variables**: It initializes two variables: `max_length` to keep track of the length of the longest string found so far and `longest_string` to store the actual longest string.\n3. **Iterate Through Strings**: The function iterates through each string in the list. For each string, it checks if its length is greater than the current `max_length`.\n4. **Update Variables**: If a longer string is found, `max_length` and `longest_string` are updated to reflect this new longest string.\n5. **Return Result**: After iterating through all strings, the function returns the value of `longest_string`.\n\nThis approach ensures that the first occurrence of the longest string is returned in case there are multiple strings with the same maximum length.\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "py_code": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n", "py_summary": "The Python code defines a function `greatest_common_divisor` that calculates the greatest common divisor (GCD) of two integers `a` and `b`. The function uses the Euclidean algorithm to find the GCD:\n\n1. **Initialization**: Start with the given integers `a` and `b`.\n2. **Iteration**: Use a while loop to repeatedly apply the Euclidean algorithm:\n   - Replace `a` with `b`.\n   - Replace `b` with the remainder of `a % b`.\n3. **Termination**: The loop continues until `b` becomes 0.\n4. **Result**: When `b` is 0, `a` contains the GCD of the original values of `a` and `b`.\n\nThe function returns the value of `a`, which at this point is the greatest common divisor.\n\nThis approach leverages the property that the GCD of two numbers also divides their difference. The Euclidean algorithm efficiently reduces the problem size until it finds the GCD by repeatedly applying this principle."}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n", "py_code": "def all_prefixes(str):\n    prefixes = []\n    for i in range(1, len(str) + 1):\n        prefixes.append(str[:i])\n    return prefixes\n```\n\n", "py_summary": "The Python code defines a function `all_prefixes` that takes a string as input and returns a list of all its prefixes from shortest to longest.\n\n1. **Initialization**: An empty list `prefixes` is initialized to store the resulting prefixes.\n2. **Loop through lengths**: A loop runs from 1 to the length of the input string (`len(str) + 1`). This ensures that every possible prefix length is considered, starting from a single character up to the entire string.\n3. **Generate Prefixes**: For each iteration `i`, the function generates a substring from the start of the string up to index `i` using slicing (`str[:i]`) and appends it to the list `prefixes`.\n4. **Return Result**: After the loop completes, the function returns the list of prefixes.\n\nThis approach ensures that all possible prefixes are generated in order from shortest to longest.\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n", "py_code": "def string_sequence(n):\n    return ' '.join(map(str, range(n + 1)))\n```\n", "py_summary": "The Python function `string_sequence` takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to `n` inclusive.\n\nHere's a breakdown of how it works:\n1. **Range Generation**: The expression `range(n + 1)` generates a sequence of integers from 0 to `n`.\n2. **Mapping to Strings**: The `map(str, range(n + 1))` part converts each integer in the generated sequence to its string representation.\n3. **Joining with Spaces**: `' '.join(...)` joins these string representations together into a single string, separated by spaces.\n\nThe function effectively constructs and returns a string that represents the sequence of numbers from 0 to `n`, inclusive, with each number separated by a space.\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>  // For std::tolower\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert all characters to lowercase and insert into a set to remove duplicates\n    string lower_str = str;\n    for (char &ch : lower_str) {\n        ch = tolower(ch);\n    }\n    \n    unordered_set<char> distinct_chars(lower_str.begin(), lower_str.end());\n    \n    return distinct_chars.size();\n}\n\n", "py_code": "def count_distinct_characters(s):\n    # Convert all characters in the string to lowercase and then to a set to remove duplicates\n    distinct_chars = set(char.lower() for char in s)\n    return len(distinct_chars)\n```\n\n", "py_summary": "The Python code defines a function `count_distinct_characters` that takes a string `s` as input and returns the number of distinct characters in the string, ignoring case differences.\n\n1. **Convert to Lowercase**: The function first converts each character in the string to its lowercase equivalent using `char.lower()`. This ensures that uppercase and lowercase versions of the same letter are treated as identical.\n2. **Use a Set**: It then creates a set from these lowercase characters. A set inherently removes duplicate values, so this step effectively filters out any repeated characters while preserving distinct ones.\n3. **Return Length of Set**: Finally, the function returns the length of this set, which represents the number of unique characters in the string.\n\nThis approach ensures that all character comparisons are case-insensitive and efficiently counts the distinct characters using Python's built-in data structures.\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n\nstd::vector<int> parse_music(std::string music_string) {\n    // Dictionary mapping ASCII note representations to their corresponding beats\n    std::unordered_map<std::string, int> notes = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n\n    std::vector<int> beats;\n    size_t i = 0;\n\n    while (i < music_string.length()) {\n        if (music_string.substr(i, 1) == \"o\") {\n            // Check for whole note\n            beats.push_back(notes[\"o\"]);\n            i += 1;\n        } else if (notes.find(music_string.substr(i, 3)) != notes.end()) {\n            // Check for half or quarter note\n            beats.push_back(notes[music_string.substr(i, 3)]);\n            i += 3;\n        }\n    }\n\n    return beats;\n}\n", "py_code": "def parse_music(music_string):\n    notes = {\n        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1\n    }\n    \n    beats = []\n    i = 0\n    while i < len(music_string):\n        if music_string[i:i+2] == \"o\":\n            beats.append(notes[\"o\"])\n            i += 1\n        elif music_string[i:i+3] in notes:\n            beats.append(notes[music_string[i:i+3]])\n            i += 3\n    return beats\n```\n\n", "py_summary": "The Python code defines a function `parse_music` that takes a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts.\n\n1. **Dictionary Initialization**: A dictionary named `notes` is initialized with keys as the ASCII representations of different types of notes (\"o\", \"o|\", \".|\") and their respective values are set to the number of beats they last (4, 2, 1).\n\n2. **List Initialization**: An empty list `beats` is created to store the number of beats for each note.\n\n3. **String Parsing Loop**:\n   - A loop iterates through the input string `music_string`.\n   - The code checks if the current character and the next character form a whole note (\"o\"). If so, it appends the corresponding value from the dictionary (`notes[\"o\"]`) to the `beats` list and increments the index by 1.\n   - Otherwise, it checks for half notes (\"o|\") or quarter notes (\".|\"), each of which spans three characters. If a valid note is found, its corresponding value from the dictionary is appended to the `beats` list, and the index is incremented by 3.\n\n4. **Return Result**: The function returns the `beats` list containing the number of beats for each note in the input string.\n\nThis approach ensures that all possible notes are correctly identified and their corresponding durations are added to the output list."}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>  // For std::min\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t start = 0;  // Use size_t to ensure it works with string indices\n    \n    while (start <= str.length() - substring.length()) {\n        size_t pos = str.find(substring, start);\n        \n        if (pos != string::npos) {  // Check if the substring was found\n            count++;\n            start = pos + 1;  // Move to the next character after the current match\n        } else {\n            break;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def how_many_times(str, substring):\n    count = 0\n    start = 0\n    \n    while start <= len(str) - len(substring):\n        pos = str.find(substring, start)\n        if pos != -1:\n            count += 1\n            start = pos + 1\n        else:\n            break\n    \n    return count\n```\n\n", "py_summary": "The Python function `how_many_times` calculates how many times a given substring can be found within an original string, including overlapping cases. Here's a detailed analysis of the code:\n\n1. **Initialization**:\n   - `count`: A variable to keep track of the number of occurrences of the substring.\n   - `start`: An index that marks the starting position for searching the substring in the main string.\n\n2. **Loop through the String**:\n   - The loop continues as long as the starting position is within the bounds where the substring can still fit into the original string (`start <= len(str) - len(substring)`).\n   \n3. **Finding Substring Position**:\n   - `pos = str.find(substring, start)`: This line searches for the first occurrence of the substring in the main string starting from the current `start` position.\n   - If `pos != -1`, it means the substring was found at some position within the main string.\n\n4. **Update Count and Start Position**:\n   - If a match is found, increment the count by 1 (`count += 1`) and move the start position one character forward from where the current match ends (`start = pos + 1`).\n   \n5. **Break Condition**:\n   - If `pos == -1`, it means no more occurrences of the substring are found in the remaining part of the string, so the loop breaks.\n\n6. **Return Result**:\n   - Finally, return the count which represents the number of times the substring was found within the main string, including overlapping cases.\n\nThis approach ensures that all possible overlapping instances of the substring are counted correctly."}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string representation of numbers to their integer values\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into individual number words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n\n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Convert the list of words to integers and sort them\n    vector<int> num_list;\n    for (const auto& w : num_words) {\n        num_list.push_back(num_map[w]);\n    }\n    sort(num_list.begin(), num_list.end());\n\n    // Convert the sorted integer list back to their corresponding words\n    stringstream result;\n    for (int num : num_list) {\n        for (const auto& entry : num_map) {\n            if (entry.second == num) {\n                result << entry.first << \" \";\n                break;\n            }\n        }\n    }\n\n    // Remove the trailing space and return the sorted string\n    string sorted_numbers = result.str();\n    if (!sorted_numbers.empty()) {\n        sorted_numbers.pop_back();  // Remove the last space character\n    }\n\n    return sorted_numbers;\n}\n\n", "py_code": "def sort_numbers(numbers):\n    # Mapping from string representation of numbers to their integer values\n    num_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into individual number words and convert them to integers\n    num_list = [num_map[word] for word in numbers.split()]\n    \n    # Sort the list of integers\n    sorted_num_list = sorted(num_list)\n    \n    # Convert the sorted integer list back to strings\n    sorted_str_list = [str(sorted_num_list[i]) if i == 0 else str(i) for i in sorted_num_list]\n    \n    # Join the sorted string representations back into a single space-delimited string\n    return ' '.join([num_map.keys()[num_map.values().index(int(num))] for num in sorted_str_list])\n```\n\n", "py_summary": "The Python code defines a function `sort_numbers` that takes a space-delimited string of number words and returns them sorted from smallest to largest. Here's an analysis of how it works:\n\n1. **Mapping Words to Integers**: \n   - A dictionary (`num_map`) is created to map each word representation of numbers (\"zero\" through \"nine\") to their corresponding integer values (0 through 9).\n\n2. **Splitting and Converting**:\n   - The input string `numbers` is split into individual words using the `split()` method.\n   - Each word in the list is then converted to its corresponding integer value by looking up the dictionary (`num_map`).\n\n3. **Sorting Integers**:\n   - The list of integers is sorted using Python's built-in `sorted()` function.\n\n4. **Converting Back to Words**:\n   - The sorted list of integers is converted back into their word representations.\n   - This step involves looking up the dictionary again, but in reverse (from integer to string).\n\n5. **Joining and Returning**:\n   - Finally, the list of words is joined back together with spaces between them using `join()`, and the resulting string is returned.\n\nHere's a more refined version of the code for clarity:\n\n```python\ndef sort_numbers(numbers):\n    # Mapping from string representation of numbers to their integer values\n    num_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into individual number words and convert them to integers\n    num_list = [num_map[word] for word in numbers.split()]\n    \n    # Sort the list of integers\n    sorted_num_list = sorted(num_list)\n    \n    # Convert the sorted integer list back to their corresponding words\n    sorted_str_list = [str(num) for num in sorted_num_list]\n    sorted_word_list = [list(num_map.keys())[list(num_map.values()).index(int(num))] for num in sorted_str_list]\n\n    # Join the sorted word representations back into a single space-delimited string\n    return ' '.join(sorted_word_list)\n```\n\nThis refined version ensures that each step is clear and avoids unnecessary complexity."}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result;\n    \n    // Iterate through the sorted list to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    // Return the closest pair in a vector\n    return {result.first, result.second};\n}\n", "py_code": "from typing import List\n\ndef find_closest_elements(numbers: List[float]) -> List[float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i+1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i+1])\n    \n    return [result[0], result[1]]\n```\n\n", "py_summary": "The Python code defines a function `find_closest_elements` that takes a list of floating-point numbers and returns two numbers from this list that are closest to each other in ascending order.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Sorting**: The input list `numbers` is sorted in ascending order using `numbers.sort()`. This ensures that any two adjacent elements will be as close as possible compared to non-adjacent elements, simplifying the process of finding the closest pair.\n\n2. **Initialization**: Two variables are initialized:\n   - `min_diff`: Set to positive infinity (`float('inf')`) to keep track of the minimum difference between any two numbers found so far.\n   - `result`: Initialized as a tuple `(0, 0)` to store the indices of the closest pair.\n\n3. **Finding Closest Pair**: A loop iterates through each element in the sorted list (except for the last one) and calculates the absolute difference between it and its next adjacent element:\n   ```python\n   diff = abs(numbers[i+1] - numbers[i])\n   ```\n   If this difference is smaller than `min_diff`, then `min_diff` is updated to this new value, and `result` is updated to store these two elements.\n\n4. **Return Result**: After the loop completes, the function returns a list containing the closest pair of numbers in ascending order:\n   ```python\n   return [result[0], result[1]]\n   ```\n\nThis approach ensures that we efficiently find the closest pair by leveraging sorting and iterating through adjacent pairs only once.\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>  // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() <= 1) {\n        return numbers;  // Return the original vector if it has less than two elements\n    }\n\n    float min_num = *min_element(numbers.begin(), numbers.end());\n    float max_num = *max_element(numbers.begin(), numbers.end());\n\n    float range_num = max_num - min_num;\n\n    if (range_num == 0) {\n        return vector<float>(numbers.size(), 0.0);  // Return a vector filled with zeros\n    }\n\n    for (float& num : numbers) {\n        num = (num - min_num) / range_num;\n    }\n\n    return numbers;\n}\n", "py_code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_num = max_num - min_num\n    \n    if range_num == 0:\n        return [0.0] * len(numbers)  # Avoid division by zero if all numbers are the same\n    \n    rescaled_numbers = [(num - min_num) / range_num for num in numbers]\n    \n    return rescaled_numbers\n```\n\n", "py_summary": "The Python code defines a function `rescale_to_unit` that takes a list of floating-point numbers and applies a linear transformation to scale all values such that the smallest number becomes 0 and the largest number becomes 1.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Find Minimum and Maximum Values**:\n   - The function first finds the minimum (`min_num`) and maximum (`max_num`) values in the input list `numbers`.\n\n2. **Calculate Range**:\n   - It calculates the range of the numbers, which is the difference between the maximum and minimum values (`range_num`).\n\n3. **Handle Edge Case**:\n   - If all numbers are identical (i.e., the range is zero), it returns a list filled with zeros to avoid division by zero.\n\n4. **Rescale Numbers**:\n   - For each number in the input list, it applies the linear transformation formula `(num - min_num) / range_num` to scale the value between 0 and 1.\n   \n5. **Return Rescaled List**:\n   - The function returns a new list containing the rescaled values.\n\nThis approach ensures that the smallest number is mapped to 0 and the largest number is mapped to 1, with all other numbers scaled proportionally in between.\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> filtered_values;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            filtered_values.push_back(intValue);\n        }\n    }\n    return filtered_values;\n}\n", "py_code": "from typing import List\n\ndef filter_integers(values):\n    filtered_values = []\n    for value in values:\n        if isinstance(value, int):\n            filtered_values.append(value)\n    return filtered_values\n```\n\n", "py_summary": "The Python code defines a function `filter_integers` that takes a list of `boost::any` objects (represented as a generic iterable in Python) and filters out only the integer values from it. Here's an analysis of how this works:\n\n1. **Initialization**: The function initializes an empty list called `filtered_values` to store the integers found in the input list.\n\n2. **Iteration**: It iterates through each element in the input list `values`.\n\n3. **Type Checking**: For each value, it checks if the type of the value is an integer using the `isinstance()` function.\n\n4. **Appending Integers**: If a value is determined to be an integer, it appends that value to the `filtered_values` list.\n\n5. **Return Result**: After iterating through all elements in the input list, the function returns the `filtered_values` list containing only integers.\n\nThis approach ensures that only integer values are included in the final result, effectively filtering out any non-integer types present in the original list.\n\n"}
{"task_id": "CPP/23", "generation": "#include <string>\n\nint strlen(std::string str) {\n    return str.length();\n}\n", "py_code": "def strlen(str):\n    return len(str)\n```\n\n", "py_summary": "The Python function `strlen` takes a string as input and returns its length using the built-in `len()` function. The `len()` function calculates the number of characters in the string, including any whitespace or special characters.\n\nHere's a breakdown of how it works:\n1. **Input**: A string `str`.\n2. **Output**: The length of the string.\n3. **Functionality**:\n   - The `len()` function returns an integer representing the number of characters in the input string.\n4. **Edge Cases**:\n   - If the input string is empty, `len(str)` will return 0.\n\nThis simple and efficient approach leverages Python's built-in capabilities to determine the length of a given string.\n\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // This line is technically not necessary as the loop will always find a divisor, but it's good practice to have a return statement outside the loop.\n    return -1; \n}\n", "py_code": "def largest_divisor(n):\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n```\n", "py_summary": "The Python function `largest_divisor` takes an integer `n` as input and returns the largest divisor of `n` that is smaller than `n`. Here's a detailed analysis:\n\n1. **Function Definition**: The function `largest_divisor(n)` accepts one parameter, `n`, which represents the number for which we need to find the largest divisor.\n\n2. **Loop Initialization**:\n   - A loop is initiated with `range(n - 1, 0, -1)`. This range starts from `n-1` and goes down to `1` (inclusive), decrementing by `1` each time.\n   \n3. **Divisibility Check**:\n   - Inside the loop, the condition `if n % i == 0:` checks if `i` is a divisor of `n`. The expression `n % i` computes the remainder when `n` is divided by `i`.\n   - If `n % i` equals `0`, it means that `i` divides `n` evenly.\n\n4. **Return Statement**:\n   - As soon as a divisor is found, the function immediately returns this value using `return i`. This ensures that the first (and hence largest) divisor encountered in the loop is returned.\n\nBy iterating from `n-1` down to `1`, the function guarantees that it finds and returns the largest divisor of `n`.\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    int i = 2;\n\n    while (i * i <= n) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        } else {\n            ++i;\n        }\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n", "py_code": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            factors.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n```\n\n", "py_summary": "The Python code defines a function `factorize` that takes an integer `n` and returns a list of its prime factors in ascending order. The function works as follows:\n\n1. **Initialization**: An empty list `factors` is initialized to store the prime factors.\n2. **Loop through potential divisors**: A loop starts with `i = 2`, which is the smallest prime number, and continues until `i * i > n`. This ensures that we only check up to the square root of `n`.\n3. **Check divisibility**: Inside the loop, it checks if `n` is divisible by `i` (the current potential factor).\n   - If `n % i == 0`, then `i` is a prime factor of `n`. The function appends `i` to the list of factors and divides `n` by `i`.\n   - If `n % i != 0`, it increments `i` to check the next potential divisor.\n4. **Handle remaining large prime**: After exiting the loop, if there is any remaining value in `n` greater than 1 (which means `n` itself is a prime number), it appends this remaining value to the list of factors.\n\nThe function returns the list of prime factors, ensuring that each factor appears as many times as it divides `n`.\n\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> count_map;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur exactly once\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_map = {}\n    result = []\n    \n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 0\n        count_map[num] += 1\n    \n    for num in numbers:\n        if count_map[num] == 1:\n            result.append(num)\n            \n    return result\n```\n\n", "py_summary": "The Python code defines a function `remove_duplicates` that takes a list of integers and returns a new list with all elements that occur more than once removed while preserving the order of the remaining elements.\n\n1. **Counting Occurrences**: \n   - A dictionary `count_map` is used to keep track of how many times each element appears in the input list.\n   - The function iterates through the input list and updates the count for each element in `count_map`.\n\n2. **Filtering Elements**:\n   - Another loop iterates through the original input list again, but this time it checks if an element's count is exactly 1 (i.e., it appears only once).\n   - If an element meets this condition, it is added to the result list.\n\n3. **Returning Result**:\n   - The function returns the `result` list which contains all elements that occur exactly once in their original order from the input list.\n\nThis approach ensures that the order of unique elements is preserved and duplicates are removed efficiently."}
{"task_id": "CPP/27", "generation": "#include <string>\n#include <cctype> // For islower, toupper, tolower\n\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\"; // Initialize an empty string for the result\n    \n    for (char c : str) { // Iterate through each character in the input string\n        if (islower(c)) { // Check if the character is lowercase\n            result += toupper(c); // Convert to uppercase and append to result\n        } else {\n            result += tolower(c); // Otherwise, convert to lowercase and append to result\n        }\n    }\n    \n    return result; // Return the transformed string\n}\n", "py_code": "def flip_case(str):\n    result = \"\"\n    for char in str:\n        if char.islower():\n            result += char.upper()\n        else:\n            result += char.lower()\n    return result\n```\n\n", "py_summary": "The Python code defines a function `flip_case` that takes a string as input and returns a new string with all lowercase characters converted to uppercase and all uppercase characters converted to lowercase.\n\nHere's a breakdown of how it works:\n1. **Initialization**: An empty string `result` is initialized to store the transformed string.\n2. **Iteration through Characters**: The function iterates over each character in the input string using a for loop.\n3. **Case Conversion**:\n   - For each character, the code checks if it is lowercase using the `islower()` method.\n   - If the character is lowercase, it converts it to uppercase using the `upper()` method and appends it to `result`.\n   - If the character is not lowercase (i.e., it is uppercase or neither), it converts it to lowercase using the `lower()` method and appends it to `result`.\n4. **Return Result**: After processing all characters, the function returns the transformed string stored in `result`.\n\nThis approach ensures that each character in the input string is flipped from its current case (uppercase to lowercase or vice versa) and constructs a new string with these transformations.\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result = \"\";\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = \"\"\n    for string in strings:\n        result += string\n    return result\n```\n\n", "py_summary": "The Python code defines a function `concatenate` that takes a list of strings as input and returns a single concatenated string. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `result` is initialized to an empty string.\n2. **Iteration**: A for loop iterates through each string in the input list `strings`.\n3. **Concatenation**: For each string, the function appends (concatenates) that string to the `result` variable.\n4. **Return**: After all strings have been processed and concatenated into `result`, the function returns this single combined string.\n\nThis approach ensures that all strings in the input list are joined together in order without any additional characters or delimiters between them.\n\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    filtered_strings = [s for s in strings if s.startswith(prefix)]\n    return filtered_strings\n```\n\n", "py_summary": "The Python code defines a function `filter_by_prefix` that takes two parameters: a list of strings (`strings`) and a prefix string (`prefix`). The function returns a new list containing only those strings from the input list that start with the given prefix.\n\nHere's a breakdown of how it works:\n1. **List Comprehension**: A list comprehension is used to iterate over each string `s` in the input list `strings`.\n2. **startswith Method**: For each string, the `startswith(prefix)` method checks if the string begins with the specified prefix.\n3. **Filtered List**: Only strings that start with the given prefix are included in the resulting list.\n\nThe function then returns this filtered list of strings.\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef get_positive(l: List[float]) -> List[float]:\n    return [num for num in l if num > 0]\n```\n\n", "py_summary": "The Python code defines a function `get_positive` that takes a list of floating-point numbers as input and returns a new list containing only the positive numbers from the original list.\n\nHere's an analysis of how this function works:\n1. **List Comprehension**: The function uses a list comprehension to iterate through each element in the input list `l`.\n2. **Condition Check**: For each element, it checks if the number is greater than 0.\n3. **Filtering Positive Numbers**: If the condition is true (i.e., the number is positive), it includes that number in the new list.\n4. **Return Result**: Finally, the function returns the filtered list containing only positive numbers.\n\nThis approach ensures that all negative and zero values are excluded from the output, leaving only the positive numbers.\n\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_prime` checks whether a given number `n` is prime or not and returns a boolean value (`True` if the number is prime, otherwise `False`). Here's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if `n` is less than or equal to 1. Since neither 0 nor 1 are considered prime numbers, the function immediately returns `False`.\n\n2. **Loop for Divisors**: If `n` is greater than 1, the function enters a loop that iterates from 2 up to and including the square root of `n`. This is because if `n` has any divisors other than 1 and itself, at least one must be less than or equal to the square root of `n`.\n\n3. **Divisibility Check**: For each integer `i` in this range, the function checks whether `n` is divisible by `i`. If it finds such an `i`, then `n` is not a prime number and the function returns `False`.\n\n4. **Return True**: If no divisors are found within the loop, the function concludes that `n` is a prime number and returns `True`.\n\nThis approach ensures efficient checking of primality by minimizing the number of necessary divisibility checks.\n\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    >>> round(find_zero({1, 2}), 2); // f(x) = 1 + 2x \n    -0.5\n    >>> round(find_zero({-6, 11, -6, 1}), 2); // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    double left = -1000.0;\n    double right = 1000.0;\n    double mid;\n\n    while ((right - left) > 1e-9) {\n        mid = (left + right) / 2.0;\n        \n        if (poly(xs, mid) == 0) {\n            return mid;\n        } else if (poly(xs, left) * poly(xs, mid) < 0) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n\n    return (left + right) / 2.0;\n}\n", "py_code": "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    \"\"\"\n    sum = 0.0\n    for i in range(len(xs)):\n        sum += xs[i] * (x ** i)\n    return sum\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds the root of a polynomial with coefficients xs such that poly(x) = 0.\n    Returns only one zero point, even if there are many.\n    Assumes xs has an even number of coefficients and the largest non-zero coefficient is included.\n    \"\"\"\n    # Use binary search to find the root\n    left, right = -1000.0, 1000.0\n    \n    while right - left > 1e-9:\n        mid = (left + right) / 2\n        if poly(xs, mid) == 0:\n            return mid\n        elif poly(xs, left) * poly(xs, mid) < 0:\n            right = mid\n        else:\n            left = mid\n    \n    return (left + right) / 2\n```\n\n", "py_summary": "The Python code defines two functions: `poly` and `find_zero`.\n\n1. **Function `poly`:**\n   - This function evaluates a polynomial with given coefficients at a specific point.\n   - It takes a list of coefficients `xs` and a value `x`.\n   - The function iterates through the list of coefficients, calculating the value of each term in the polynomial (i.e., `xs[i] * x^i`) and summing these values to get the final result.\n\n2. **Function `find_zero`:**\n   - This function finds a root of the polynomial defined by the coefficients `xs` such that `poly(x) = 0`.\n   - It uses binary search to find an approximate value for `x` where the polynomial evaluates to zero.\n   - The function initializes the search range with `left = -1000.0` and `right = 1000.0`, which are reasonable bounds for finding a root of a polynomial.\n   - It iterates until the difference between `right` and `left` is smaller than `1e-9`.\n   - During each iteration, it calculates the midpoint `mid` and checks if `poly(xs, mid)` is zero or if the product of `poly(xs, left)` and `poly(xs, mid)` is negative (indicating a sign change), which implies that there is a root in this interval.\n   - The function narrows down the search range based on these conditions until it finds an approximate root.\n\nThe binary search approach ensures that the solution converges to a value where the polynomial evaluates to zero within a specified tolerance level. This method is efficient and works well for polynomials with real roots, especially when the coefficients are known and the polynomial has guaranteed properties (e.g., having an even number of coefficients)."}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices_values;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted values\n    sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Create a new list to store the result\n    vector<int> l_prime = l;\n\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l_prime[i] = third_indices_values[sorted_index];\n            sorted_index++;\n        }\n    }\n\n    return l_prime;\n}\n", "py_code": "from typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    # Extract elements at indices divisible by 3\n    third_indices_values = [l[i] for i in range(len(l)) if (i + 1) % 3 == 0]\n    \n    # Sort the extracted values\n    sorted_third_indices_values = sorted(third_indices_values)\n    \n    # Create a new list to store the result\n    l_prime = []\n    \n    third_index = 0\n    for i in range(len(l)):\n        if (i + 1) % 3 == 0:\n            l_prime.append(sorted_third_indices_values[third_index])\n            third_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime\n```\n\n", "py_summary": "The Python code defines a function `sort_third` that takes a list of integers and returns a new list where elements at indices divisible by 3 are sorted in ascending order, while all other elements remain unchanged.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Extract Elements at Indices Divisible by 3**:\n   - The code uses a list comprehension to extract elements from the input list `l` that are located at indices divisible by 3 (i.e., positions 0, 3, 6, etc.). This is done using the condition `(i + 1) % 3 == 0`.\n\n2. **Sort the Extracted Values**:\n   - The extracted values are stored in `third_indices_values` and then sorted to produce `sorted_third_indices_values`.\n\n3. **Create a New List for the Result**:\n   - A new list `l_prime` is initialized to store the final result.\n\n4. **Construct the Final List**:\n   - The function iterates through each index of the input list `l`. If an index is divisible by 3, it appends the corresponding sorted value from `sorted_third_indices_values` to `l_prime`.\n   - For all other indices, it simply copies the original element from `l`.\n\n5. **Return the Result**:\n   - The function returns the constructed list `l_prime`, which contains the elements of `l` with only those at indices divisible by 3 sorted.\n\nThis approach ensures that the overall structure and order of non-divisible-by-3 indices remain unchanged, while the specified subset is properly sorted."}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Remove duplicates by inserting elements into a set (which automatically removes duplicates)\n    set<int> s(l.begin(), l.end());\n    \n    // Convert the set back to a vector\n    vector<int> result(s.begin(), s.end());\n    \n    return result;\n}\n", "py_code": "def unique(l):\n    return sorted(set(l))\n```\n\n", "py_summary": "The Python code defines a function `unique` that takes a list of integers as input and returns a new list containing only the unique elements from the original list, sorted in ascending order.\n\nHere's a breakdown of how the function works:\n1. **Convert to Set**: The set data structure is used to eliminate duplicate elements because sets do not allow duplicates.\n2. **Sort the Set**: The `sorted` function converts the set back into a list and sorts it in ascending order.\n3. **Return Result**: The sorted, unique list is returned as the result.\n\nThis approach ensures that the output contains only distinct values from the input list and these values are ordered correctly.\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nfloat max_element(std::vector<float> l) {\n    if (l.empty()) return 0; // Handle empty vector case, though not necessary based on problem constraints.\n    return *std::max_element(l.begin(), l.end());\n}\n", "py_code": "from typing import List\n\ndef max_element(l: List[float]) -> float:\n    return max(l)\n```\n\n", "py_summary": "The Python code defines a function `max_element` that takes a list of floats as input and returns the maximum element in the list. The function uses the built-in `max()` function to find and return the largest value in the provided list.\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Test cases\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n```\n\n", "py_summary": "The Python function `fizz_buzz` calculates the number of times the digit '7' appears in integers less than `n` that are divisible by either 11 or 13. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `count` is initialized to zero, which will keep track of how many times the digit '7' appears.\n\n2. **Loop through numbers**: A loop runs from 1 to `n-1`. For each integer `i` in this range:\n   - It checks if `i` is divisible by either 11 or 13 using the condition `if i % 11 == 0 or i % 13 == 0`.\n   \n3. **Count occurrences of '7'**: If `i` satisfies the divisibility condition, it converts `i` to a string and counts how many times the digit '7' appears in this number using `str(i).count('7')`. The count is then added to the cumulative total stored in `count`.\n\n4. **Return result**: After iterating through all numbers less than `n`, the function returns the final value of `count`.\n\nThis approach ensures that only numbers divisible by 11 or 13 are considered, and within those numbers, it counts how many times '7' appears.\n\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract values at even indices (0-based indexing)\n    vector<float> even_indices_values;\n    for (int i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to ensure modifications do not affect input\n    vector<float> result = l;\n\n    // Update even indices with sorted values\n    int sorted_index = 0;\n    for (int i = 1; i < result.size(); i += 2) {\n        if (sorted_index < even_indices_values.size()) {\n            result[i] = even_indices_values[sorted_index++];\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef sort_even(l: List[float]) -> List[float]:\n    even_indices_values = [l[i] for i in range(1, len(l), 2)]\n    sorted_even_indices_values = sorted(even_indices_values)\n    \n    result = l[:]\n    for i, value in zip(range(1, len(l), 2), sorted_even_indices_values):\n        result[i] = value\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `sort_even` that takes a list `l` and returns a new list `l'`. The returned list `l'` is identical to `l` at odd indices but has its even indices sorted.\n\nHere's a step-by-step breakdown of the solution:\n\n1. **Extract Even Indices Values**: \n   - A list comprehension `[l[i] for i in range(1, len(l), 2)]` extracts values from the input list `l` that are located at even indices (0-based indexing).\n\n2. **Sort Extracted Values**:\n   - The extracted values are sorted using Python's built-in `sorted()` function and stored in `sorted_even_indices_values`.\n\n3. **Create Result List**:\n   - A copy of the original list `l` is created to ensure that modifications do not affect the input list.\n   \n4. **Update Even Indices**:\n   - The values at even indices in the result list are updated with the sorted values from `sorted_even_indices_values`.\n\n5. **Return Result List**:\n   - Finally, the modified list `result` is returned.\n\nThis approach ensures that the odd-indexed elements remain unchanged while the even-indexed elements are sorted as required by the problem statement."}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1, 1) + x.substr(0, 1) + x.substr(2, 1);\n        }\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    string decoded_string;\n    for (int i = 0; i * 3 < s.length(); i++) {\n        string group = s.substr(i * 3, 3);\n        if (group.length() == 3) {\n            // Decycle elements in each group of length 3.\n            group = group[1] + group[0] + group[2];\n        } else {\n            // If the group has fewer than 3 characters, it remains unchanged.\n            group = s.substr(i * 3, group.length());\n        }\n        decoded_string += group;\n    }\n    return decoded_string;\n}\n\n", "py_code": "def decode_cyclic(s):\n    decoded_string = \"\"\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            # Decycle elements in each group of length 3.\n            group = group[1] + group[:1] + group[2:]\n        else:\n            # If the group has fewer than 3 characters, it remains unchanged.\n            group = s[i:i+len(group)]\n        decoded_string += group\n    return decoded_string\n```\n\n", "py_summary": "The Python function `decode_cyclic` takes a string `s` as input and returns the original string before it was encoded using the `encode_cyclic` function. Here's an analysis of how the function works:\n\n1. **Initialization**: The function initializes an empty string `decoded_string` to store the decoded result.\n\n2. **Loop through groups of three characters**:\n   - A loop is used to iterate over the input string in steps of 3 characters.\n   - For each iteration, a substring `group` of length 3 (or less if there are fewer than 3 characters left) is extracted from the input string.\n\n3. **Decoding logic**:\n   - If the group has exactly 3 characters, it was previously encoded by shifting the first character to the end and moving the second character to the beginning.\n     - To decode this, the function shifts the characters back to their original positions: `group[1]` (second character) becomes the first character, `group[:1]` (first character) moves to the middle position, and `group[2:]` (third character) remains in its place.\n   - If the group has fewer than 3 characters, it is left unchanged as no encoding was applied.\n\n4. **Appending decoded groups**:\n   - The decoded group is appended to `decoded_string`.\n\n5. **Return result**: After processing all parts of the input string, the function returns the fully decoded string stored in `decoded_string`.\n\nThis approach ensures that each group of characters (or remaining characters if fewer than 3) are correctly reversed from their encoded form back to their original order.\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int a = 0, b = 1;\n    int count = 0;\n\n    while (true) {\n        int fib_num = a + b;\n        a = b;\n        b = fib_num;\n\n        if (is_prime(fib_num)) {\n            count++;\n            if (count == n) return fib_num;\n        }\n    }\n\n    // The loop is theoretically infinite, but the function will exit when it finds the nth prime Fibonacci number\n}\n\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n):\n    a, b = 0, 1\n    count = 0\n    while True:\n        fib_num = a + b\n        a, b = b, fib_num\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n```\n", "py_summary": "The Python code defines a function `prime_fib` that returns the n-th Fibonacci number which is also prime. The solution involves two main parts: checking for primality and generating Fibonacci numbers.\n\n1. **is_prime Function**:\n   - This helper function checks if a given number `num` is prime.\n   - It first handles edge cases where `num <= 1`, returning `False`.\n   - Then, it iterates from 2 to the square root of `num` (inclusive) and checks for divisibility. If any divisor is found, it returns `False`. Otherwise, it returns `True`.\n\n2. **prime_fib Function**:\n   - This function initializes two variables `a` and `b` as the first two Fibonacci numbers.\n   - It also initializes a counter `count` to keep track of how many prime Fibonacci numbers have been found.\n   - The function enters an infinite loop where it generates the next Fibonacci number by summing `a` and `b`.\n   - After generating each new Fibonacci number, it updates `a` and `b` to continue the sequence.\n   - It then checks if the generated Fibonacci number is prime using the `is_prime` function.\n   - If a prime Fibonacci number is found, it increments the counter. When the counter reaches `n`, the function returns the current Fibonacci number.\n\nThis approach ensures that we efficiently generate and check each Fibonacci number until we find the n-th one that meets the criteria of being prime."}
{"task_id": "CPP/40", "generation": "#include <vector>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    n = len(l)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n```\n\n", "py_summary": "The Python function `triples_sum_to_zero` takes a list of integers as input and returns `True` if there are three distinct elements in the list that sum to zero, and `False` otherwise.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The function starts by determining the length of the input list `l`.\n\n2. **Nested Loops for Triplets**:\n   - The outermost loop iterates over each element in the list using index `i`.\n   - The middle loop iterates from the next element after `i` to the end of the list, using index `j`. This ensures that we are considering distinct elements.\n   - The innermost loop iterates from the next element after `j` to the end of the list, using index `k`. Again, this ensures that all three indices (`i`, `j`, and `k`) refer to distinct elements.\n\n3. **Sum Check**:\n   - For each combination of indices `(i, j, k)`, the function checks if the sum of the corresponding elements in the list is zero.\n   - If a triplet with a sum of zero is found, the function immediately returns `True`.\n\n4. **Return False**:\n   - If no such triplet is found after checking all possible combinations, the function returns `False`.\n\nThis approach ensures that every possible combination of three distinct elements from the input list is checked for a sum of zero.\n\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving towards each other at the same speed and there is an equal number of cars on both sides,\n    // every left-to-right car will eventually collide with a right-to-left car.\n    return n;\n}\n", "py_code": "def car_race_collision(n):\n    # Since all cars are moving towards each other at the same speed and there is an equal number of cars on both sides,\n    # every left-to-right car will eventually collide with a right-to-left car.\n    return n\n```\n\n", "py_summary": "The Python function `car_race_collision` takes an integer `n` as input and returns the number of collisions that occur in the described scenario.\n\nHere's the analysis:\n\n1. **Input**: The function receives a single parameter `n`, which represents the number of cars moving from left to right and also the number of cars moving from right to left.\n2. **Logic**:\n   - Since all cars are moving towards each other at the same speed, every car moving from left to right will eventually collide with exactly one car moving from right to left.\n   - Given that there are `n` cars on each side and they all move at the same speed, each of the `n` left-to-right cars will collide with a corresponding right-to-left car. Therefore, the total number of collisions is equal to `n`.\n3. **Output**: The function returns the integer value `n`, which represents the total number of collisions.\n\nThis simple logic ensures that the function correctly calculates the number of collisions based on the given conditions.\n\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int& x : l) {\n        x += 1;\n    }\n    return l;\n}\n", "py_code": "def incr_list(l):\n    return [x + 1 for x in l]\n```\n\n", "py_summary": "The Python code defines a function `incr_list` that takes a list of integers as input and returns a new list where each element is incremented by 1.\n\nHere's an analysis of how this function works:\n- The function uses a list comprehension to iterate over each element in the input list `l`.\n- For each element `x` in the list, it adds 1 to `x` and includes the result in the new list.\n- The resulting list is then returned.\n\nThis approach ensures that every element in the original list is incremented by 1, producing a new list with the updated values."}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen_numbers;\n    for (int number : l) {\n        if (seen_numbers.find(-number) != seen_numbers.end()) {\n            return true;\n        }\n        seen_numbers.insert(number);\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    seen_numbers = set()\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    return False\n```\n\n", "py_summary": "The Python function `pairs_sum_to_zero` checks whether there are two distinct elements in a given list that sum to zero. Here's an analysis of how it works:\n\n1. **Initialization**: A set called `seen_numbers` is initialized to keep track of numbers encountered so far.\n2. **Iteration**: The function iterates through each number in the input list `l`.\n3. **Check for Complement**: For each number, it checks if its negation (`-number`) has already been seen (i.e., exists in the set `seen_numbers`).\n   - If `-number` is found in `seen_numbers`, it means there is another element in the list that sums to zero with the current number. The function returns `True`.\n4. **Add Number**: If the negation of the current number is not in `seen_numbers`, the current number itself is added to the set.\n5. **Return Result**: After iterating through all elements, if no such pair is found, the function returns `False`.\n\nThis approach ensures that each element is processed only once and leverages the efficiency of set operations for quick lookups.\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = to_string(digit) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n\n", "py_code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    \n    result = \"\"\n    while x > 0:\n        digit = x % base\n        result = str(digit) + result\n        x //= base\n    \n    return result\n```\n\n", "py_summary": "The Python function `change_base` converts a given integer `x` to its string representation in a specified base (which is less than 10). Here's an analysis of how it works:\n\n1. **Base Case Handling**: The function first checks if `x` is zero and returns \"0\" immediately, as the base conversion for zero is always \"0\".\n\n2. **Initialization**: An empty string `result` is initialized to store the resulting converted number.\n\n3. **Conversion Loop**:\n   - A loop runs while `x` is greater than 0.\n   - In each iteration, the remainder of `x` divided by `base` (i.e., `x % base`) gives the current digit in the new base representation.\n   - This digit is converted to a string and prepended to `result`.\n   - The value of `x` is then updated to `x // base`, effectively reducing it for the next iteration.\n\n4. **Return Result**: Once the loop completes, the function returns the accumulated string `result`.\n\nThis approach ensures that each digit of the number in the new base is correctly computed and placed in the correct order (from least significant to most significant) by prepending each digit to the result string during each iteration."}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n", "py_code": "def triangle_area(a: float, h: float) -> float:\n    return 0.5 * a * h\n```\n", "py_summary": "The Python function `triangle_area` calculates the area of a triangle given the base length (`a`) and height (`h`). The formula for the area of a triangle is:\n\n\\[ \\text{Area} = 0.5 \\times \\text{base} \\times \\text{height} \\]\n\nIn this code, the function takes two parameters: `a` (the base) and `h` (the height). It then returns the computed area by multiplying the base length with the height and dividing the result by 2.\n\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else {\n        int a = 0, b = 0, c = 2, d = 0;\n        for (int i = 3; i <= n; ++i) {\n            int temp_d = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = temp_d;\n        }\n        return d;\n    }\n}\n", "py_code": "def fib4(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(3, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d\n```\n\n", "py_summary": "The Python function `fib4(n)` computes the n-th element of the Fib4 sequence without using recursion. Here's a detailed analysis:\n\n1. **Base Cases**:\n   - If `n` is 0 or 1, the function returns 0.\n   - If `n` is 2, the function returns 2.\n\n2. **Initialization for Iterative Calculation**:\n   - For values of `n` greater than 2, the function initializes four variables: `a`, `b`, `c`, and `d`. These represent the first four elements of the sequence (fib4(0), fib4(1), fib4(2), fib4(3)) respectively.\n     - `a = 0`\n     - `b = 0`\n     - `c = 2`\n     - `d = 0`\n\n3. **Iterative Calculation**:\n   - The function uses a loop to iteratively calculate the values for subsequent elements of the sequence up to `n`.\n   - For each iteration, it updates the variables as follows:\n     - `a` takes the value of `b`\n     - `b` takes the value of `c`\n     - `c` takes the value of `d`\n     - `d` is updated to be the sum of the previous four elements (`a + b + c + d`)\n   - This loop runs from 3 up to and including `n`.\n\n4. **Return Value**:\n   - After completing the iterations, the function returns the value stored in `d`, which represents fib4(n).\n\nThis approach ensures that each element is computed only once, making it efficient with a time complexity of O(n) and space complexity of O(1), excluding the input parameter.\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    float median_value;\n    \n    // Step 2: Determine if the number of elements is even or odd\n    if (n % 2 == 0) {\n        // If even, return the average of the two middle elements\n        median_value = (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd, return the middle element\n        median_value = l[n / 2];\n    }\n    \n    return median_value;\n}\n", "py_code": "from typing import List\n\ndef median(l: List[float]) -> float:\n    n = len(l)\n    l.sort()\n    \n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]\n```\n\n", "py_summary": "The Python code defines a function `median` that calculates and returns the median of elements in a given list `l`. Here's a detailed analysis:\n\n1. **Sorting the List**: The first step is to sort the list `l` using `l.sort()`. Sorting ensures that the elements are arranged in ascending order, which is necessary for finding the median.\n\n2. **Determining the Length of the List**: The length of the list `n` is calculated using `len(l)`. This helps determine whether the number of elements is even or odd.\n\n3. **Calculating the Median**:\n   - If the length of the list `n` is even (i.e., `n % 2 == 0`), the median is the average of the two middle elements: `(l[n // 2 - 1] + l[n // 2]) / 2`.\n   - If the length of the list `n` is odd, the median is simply the middle element: `l[n // 2]`.\n\nThis approach ensures that the function correctly handles both even and odd lengths of lists to find the median.\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Check if the string is equal to its reverse\n    return text == string(text.rbegin(), text.rend());\n}\n\n", "py_code": "def is_palindrome(text: str) -> bool:\n    return text == text[::-1]\n```\n\n", "py_summary": "The Python function `is_palindrome` checks if a given string is a palindrome. Here's an analysis of how it works:\n\n- The function takes a single parameter `text`, which is the input string to be checked.\n- It returns a boolean value indicating whether the input string is a palindrome or not.\n\nThe core logic of the function is:\n```python\nreturn text == text[::-1]\n```\n- `text[::-1]` creates a reversed version of the input string. The slicing operation with `::-1` means \"start from the end and move backwards to the beginning\".\n- The expression `text == text[::-1]` compares the original string with its reversed version.\n- If both are identical, it returns `True`, indicating that the string is a palindrome. Otherwise, it returns `False`.\n\nThis approach is efficient and straightforward for checking palindromes in Python.\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <cmath>\n\nint modp(int n, int p) {\n    // Calculate 2^n % p using pow and modulo operations\n    long long base = 2;\n    long long result = 1;\n\n    while (n > 0) {\n        if (n & 1)\n            result = (result * base) % p;\n        n >>= 1;\n        base = (base * base) % p;\n    }\n\n    return static_cast<int>(result);\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(modp(3, 5) == 3);\n    assert(modp(1101, 101) == 2);\n    assert(modp(0, 101) == 1);\n    assert(modp(3, 11) == 8);\n    assert(modp(100, 101) == 1);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n", "py_code": "def modp(n: int, p: int) -> int:\n    result = pow(2, n, p)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `modp` that calculates \\(2^n \\mod p\\). The function uses the built-in `pow` function with three arguments: `pow(base, exp, mod)`, which efficiently computes \\((base^{exp}) \\mod mod\\).\n\nHere's a breakdown of how it works:\n1. **Function Definition**: The function `modp(n, p)` takes two integer parameters, `n` and `p`.\n2. **Using `pow` Function**: The `pow(2, n, p)` call computes \\(2^n \\mod p\\). This is a highly optimized way to handle large exponentiations modulo a number.\n3. **Return Statement**: The result of the computation is returned directly.\n\nThis approach ensures that the calculation is performed efficiently and avoids potential issues with very large numbers by using modular arithmetic properties.\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        if ('a' <= s[i] && s[i] <= 'z') { // Ensure character is within lowercase range\n            int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n            out += (char)w;\n        } else {\n            out += s[i]; // Append non-alphabetic characters as-is\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        if ('a' <= s[i] && s[i] <= 'z') { // Ensure character is within lowercase range\n            int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n            out += (char)w;\n        } else {\n            out += s[i]; // Append non-alphabetic characters as-is\n        }\n    }\n    return out;\n}\n", "py_code": "def encode_shift(s):\n    out = \"\"\n    for char in s:\n        w = ((ord(char) + 5 - ord('a')) % 26) + ord('a')\n        out += chr(w)\n    return out\n\ndef decode_shift(s):\n    out = \"\"\n    for char in s:\n        w = ((ord(char) - 5 - ord('a') + 26) % 26) + ord('a')\n        out += chr(w)\n    return out\n```\n\n", "py_summary": "### Analysis of Python Code:\n\n#### `encode_shift` Function:\nThe `encode_shift` function takes a string `s` as input and returns an encoded version of that string by shifting each character in the alphabet by 5 positions.\n\n1. **Initialization**:\n   - An empty string `out` is initialized to store the encoded result.\n   \n2. **Character Iteration**:\n   - The function iterates through each character `char` in the input string `s`.\n   \n3. **Encoding Calculation**:\n   - For each character, it calculates its new position by shifting it 5 positions forward in the alphabet using the formula: \n     \\[\n     w = ((\\text{ord(char)} + 5 - \\text{ord('a')}) \\% 26) + \\text{ord('a')}\n     \\]\n   - This ensures that if a character goes beyond 'z', it wraps around to the beginning of the alphabet.\n   \n4. **Appending Encoded Character**:\n   - The encoded character is appended to `out`.\n   \n5. **Return Result**:\n   - After processing all characters, the function returns the encoded string stored in `out`.\n\n#### `decode_shift` Function:\nThe `decode_shift` function takes an encoded string `s` as input and returns the original string by reversing the shift operation.\n\n1. **Initialization**:\n   - An empty string `out` is initialized to store the decoded result.\n   \n2. **Character Iteration**:\n   - The function iterates through each character `char` in the input string `s`.\n   \n3. **Decoding Calculation**:\n   - For each character, it calculates its original position by shifting it 5 positions backward in the alphabet using the formula:\n     \\[\n     w = ((\\text{ord(char)} - 5 - \\text{ord('a')} + 26) \\% 26) + \\text{ord('a')}\n     \\]\n   - The addition of `26` ensures that if a character goes below 'a', it wraps around to the end of the alphabet.\n   \n4. **Appending Decoded Character**:\n   - The decoded character is appended to `out`.\n   \n5. **Return Result**:\n   - After processing all characters, the function returns the decoded string stored in `out`.\n\nThese functions ensure that encoding and decoding are consistent and wrap around the alphabet correctly."}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    \n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result\n```\n\n", "py_summary": "The Python function `remove_vowels` takes a string `text` as input and returns a new string with all vowels removed. Here's a detailed analysis of how it works:\n\n1. **Initialization**:\n   - The list of vowels is defined: `vowels = \"aeiouAEIOU\"`.\n   \n2. **Result Initialization**:\n   - An empty string `result` is initialized to store the characters that are not vowels.\n\n3. **Iteration and Filtering**:\n   - A loop iterates through each character in the input string `text`.\n   - For each character, it checks if the character is not present in the `vowels` list.\n   - If the character is not a vowel, it appends the character to the `result` string.\n\n4. **Return**:\n   - After iterating through all characters, the function returns the `result` string which contains only the non-vowel characters from the input string.\n\nThis approach ensures that all vowels are removed while preserving the order and case of the remaining characters in the original string.\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def below_threshold(l, t):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `below_threshold` checks whether all numbers in a given list `l` are below a specified threshold `t`. Here's an analysis of how it works:\n\n1. **Function Definition**: The function takes two parameters: `l`, which is a list of integers, and `t`, which is the threshold integer.\n2. **Iteration Through List**: A for loop iterates through each element in the list `l`.\n3. **Condition Check**: For each number in the list, it checks if the number is greater than or equal to the threshold `t`.\n4. **Return False on Violation**: If any number in the list meets or exceeds the threshold, the function immediately returns `False`, indicating that not all numbers are below the threshold.\n5. **Return True After Loop Completion**: If the loop completes without finding any number that is greater than or equal to the threshold, the function returns `True`, indicating that all numbers in the list are indeed below the threshold.\n\nThis approach ensures efficient checking by returning as soon as a violation of the condition is found, avoiding unnecessary checks once the result is determined."}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x: int, y: int) -> int:\n    return x + y\n```\n\n", "py_summary": "The Python code defines a function `add` that takes two integer parameters, `x` and `y`, and returns their sum. The function simply uses the addition operator (`+`) to add the two numbers together and then returns the result.\n\nHere's a breakdown of what happens in the function:\n1. **Parameters**: The function accepts two integer parameters, `x` and `y`.\n2. **Addition**: It adds these two integers using the `+` operator.\n3. **Return Value**: The sum is returned as an integer.\n\nThis straightforward implementation ensures that the function correctly performs addition for any pair of integers provided to it.\n\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <unordered_set>  // For using unordered_set\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Convert strings to sets of characters\n    unordered_set<char> set_s0(s0.begin(), s0.end());\n    unordered_set<char> set_s1(s1.begin(), s1.end());\n\n    // Check if both sets are equal\n    return set_s0 == set_s1;\n}\n", "py_code": "def same_chars(s0: str, s1: str) -> bool:\n    # Convert strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Check if both sets are equal\n    return set_s0 == set_s1\n```\n\n", "py_summary": "The Python function `same_chars` checks whether two strings have the same set of characters. Here's a detailed analysis:\n\n1. **Convert Strings to Sets**: \n   - The function converts each string (`s0` and `s1`) into sets (`set_s0` and `set_s1`). This conversion removes any duplicate characters within each string, leaving only unique characters.\n   \n2. **Check Equality of Sets**:\n   - The function then checks if the two resulting sets are equal using the equality operator (`==`). If both sets contain exactly the same set of characters (regardless of their order or frequency), the condition returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the two strings have identical character compositions without considering the frequency or position of each character.\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = b;\n            b = a + b;\n            a = temp;\n        }\n        return b;\n    }\n}\n", "py_code": "def fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\n", "py_summary": "The Python function `fib(n)` calculates the nth Fibonacci number using an iterative approach. Here's a detailed analysis of how it works:\n\n1. **Base Cases**:\n   - If `n` is less than or equal to 0, the function returns 0.\n   - If `n` is exactly 1, the function returns 1.\n\n2. **Iterative Calculation**:\n   - For values of `n` greater than 1, two variables `a` and `b` are initialized to represent the first two Fibonacci numbers: `a = 0` (Fibonacci number at index 0) and `b = 1` (Fibonacci number at index 1).\n   - The function then iterates from 2 up to `n`. In each iteration, it updates `a` and `b` such that:\n     - `a` takes the value of `b`.\n     - `b` is updated to be the sum of the previous values of `a` and `b`.\n   - After completing the loop, `b` will hold the nth Fibonacci number.\n\nThis approach ensures efficient computation with a time complexity of O(n) and constant space usage (O(1)).\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;  // Stack to keep track of opening brackets\n\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            s.push(bracket);  // Push opening bracket onto the stack\n        } else if (bracket == '>') {\n            if (s.empty()) {\n                return false;  // No matching opening bracket found\n            }\n            s.pop();  // Pop the matching opening bracket from the stack\n        }\n    }\n\n    return s.empty();  // Check if all brackets are matched\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append('<')\n        elif bracket == '>':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n```\n\n", "py_summary": "The Python function `correct_bracketing` checks whether a given string of '<' and '>' brackets is correctly bracketed. Here's an analysis of how it works:\n\n1. **Initialization**: An empty stack is initialized to keep track of opening brackets.\n2. **Iteration through the string**: The function iterates over each character in the input string `brackets`.\n   - If the current character is '<', it means an opening bracket, so this character is pushed onto the stack.\n   - If the current character is '>', it means a closing bracket:\n     - If the stack is empty (i.e., there are no unmatched opening brackets), the function returns `False` because the string cannot be correctly bracketed.\n     - Otherwise, the top element of the stack (an opening '<' bracket) is popped off to indicate that this pair of brackets is matched.\n3. **Final check**: After iterating through all characters in the input string, if there are any remaining unmatched opening brackets left in the stack, the function returns `False`. If the stack is empty, it means every opening bracket has a corresponding closing bracket and the function returns `True`.\n\nThis approach ensures that each '<' character is matched with exactly one '>' character, maintaining proper nesting and order of brackets."}
{"task_id": "CPP/57", "generation": "#include <vector>\n\nbool monotonic(std::vector<float> l) {\n    if (l.empty()) {\n        return true;\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n", "py_code": "from typing import List\n\ndef monotonic(l: List[float]) -> bool:\n    if not l:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(l)):\n        if l[i] > l[i - 1]:\n            decreasing = False\n        elif l[i] < l[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing\n```\n\n", "py_summary": "The Python function `monotonic` checks if a list of floating-point numbers is either monotonically increasing or decreasing.\n\nHere's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if the input list `l` is empty. If it is, the function returns `True`. An empty list can be considered both monotonically increasing and decreasing by definition.\n   \n2. **Initialization**: Two boolean variables, `increasing` and `decreasing`, are initialized to `True`. These will track whether the sequence is strictly increasing or decreasing.\n\n3. **Iteration**: The function iterates through the list starting from the second element (index 1). For each pair of consecutive elements:\n   - If the current element (`l[i]`) is greater than the previous element (`l[i-1]`), it sets `decreasing` to `False`. This means that if any increasing condition is found, the sequence cannot be monotonically decreasing.\n   - Similarly, if the current element (`l[i]`) is less than the previous element (`l[i-1]`), it sets `increasing` to `False`. This means that if any decreasing condition is found, the sequence cannot be monotonically increasing.\n\n4. **Final Check**: After iterating through all elements, the function returns `True` if either `increasing` or `decreasing` remains `True`, indicating that the list is monotonic (either strictly increasing or strictly decreasing). If both are `False`, it means the sequence does not meet the criteria for being monotonically increasing or decreasing.\n\nThis approach ensures that the function correctly identifies whether a given list of numbers is either monotonically increasing, monotonically decreasing, or neither."}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert vectors to sets for finding unique common elements\n    set<int> set_l1(l1.begin(), l1.end());\n    set<int> set_l2(l2.begin(), l2.end());\n\n    // Find the intersection of both sets\n    vector<int> common_elements;\n    set_intersection(set_l1.begin(), set_l1.end(), set_l2.begin(), set_l2.end(), back_inserter(common_elements));\n\n    return common_elements;\n}\n", "py_code": "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    # Convert lists to sets for finding unique common elements\n    set_l1 = set(l1)\n    set_l2 = set(l2)\n\n    # Find the intersection of both sets\n    common_elements = set_l1.intersection(set_l2)\n\n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))\n```\n\n", "py_summary": "The Python code defines a function `common` that takes two lists of integers as input and returns a sorted list of unique common elements between them.\n\n1. **Convert Lists to Sets**: The function first converts both input lists (`l1` and `l2`) into sets (`set_l1` and `set_l2`). This step removes any duplicate values within each list, ensuring that only unique elements are considered for the intersection operation.\n   \n2. **Find Intersection**: It then finds the intersection of these two sets using the `.intersection()` method. The result is a set containing all unique elements that appear in both input lists.\n\n3. **Convert to Sorted List**: Finally, it converts this set back into a list and sorts it before returning. This ensures that the output contains only unique common elements and they are returned in sorted order.\n\nThis approach leverages Python's built-in set operations for efficiency and simplicity, ensuring that the function is both concise and effective at finding the desired result.\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int factor = 2;  // Initialize the smallest prime factor\n    int last_factor = 1;  // Keep track of the last prime factor found\n    \n    while (n > 1) {\n        if (n % factor == 0) {\n            last_factor = factor;\n            n /= factor;  // Divide n by factor to reduce it\n        } else {\n            factor += 1;  // Move to the next potential factor\n        }\n    }\n    \n    return last_factor;\n}\n\n", "py_code": "import math\n\ndef largest_prime_factor(n):\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    \n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n            \n    return last_factor\n```\n\n", "py_summary": "The Python function `largest_prime_factor` calculates and returns the largest prime factor of a given integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**: The smallest possible prime factor is initialized to 2 (`factor = 2`). Additionally, `last_factor` is set to 1 to keep track of the last prime factor found.\n\n2. **Loop through potential factors**: A while loop runs as long as `n > 1`. This ensures that we continue dividing `n` by its smallest prime factors until it cannot be divided further (i.e., when `n` becomes a prime number).\n\n3. **Check divisibility and update factor**:\n   - If `n % factor == 0`, it means the current value of `factor` is a divisor of `n`. In this case, we update `last_factor` to be the current `factor` (since it's a prime factor), and then divide `n` by `factor`.\n   - If `n % factor != 0`, increment `factor` by 1 to check the next potential factor.\n\n4. **Return result**: Once the loop exits, `last_factor` will hold the largest prime factor of `n`.\n\nThis approach ensures that we efficiently find and update the largest prime factor as we iterate through possible divisors, starting from the smallest (2) and moving upwards.\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n", "py_code": "def sum_to_n(n):\n    return (n * (n + 1)) // 2\n```\n\n", "py_summary": "The Python function `sum_to_n` calculates the sum of all integers from 1 to `n`. The formula used is `(n * (n + 1)) // 2`, which is a well-known mathematical formula for finding the sum of the first `n` natural numbers.\n\nHere's a breakdown of how it works:\n- The function takes an integer `n` as input.\n- It uses the formula `(n * (n + 1)) // 2` to compute the sum. This formula is derived from the arithmetic series sum formula, which states that the sum of the first `n` natural numbers is equal to `n/2 * (first term + last term)`. For the sequence starting at 1 and ending at `n`, this simplifies to `(n * (n + 1)) // 2`.\n- The result is returned as an integer.\n\nThis approach ensures that the function efficiently computes the sum without needing to iterate through all numbers from 1 to `n`.\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance += 1;\n        } else if (c == ')') {\n            balance -= 1;\n        }\n        // If at any point the balance is negative, it means there are more closing brackets than opening ones.\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, if balance is zero, all opening brackets have corresponding closing brackets.\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        # If at any point the balance is negative, it means there are more closing brackets than opening ones.\n        if balance < 0:\n            return False\n    \n    # At the end, if balance is zero, all opening brackets have corresponding closing brackets.\n    return balance == 0\n```\n\n", "py_summary": "The Python function `correct_bracketing` checks whether a given string of parentheses is correctly bracketed. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `balance` is initialized to 0. This variable keeps track of the balance between opening and closing brackets.\n\n2. **Iteration through the String**:\n   - For each character in the input string `brackets`, if the character is '(', the balance is incremented by 1.\n   - If the character is ')', the balance is decremented by 1.\n   \n3. **Checking Balance**:\n   - During iteration, if at any point the balance becomes negative (`balance < 0`), it means there are more closing brackets than opening ones before this point, making the string incorrectly bracketed. The function immediately returns `False`.\n\n4. **Final Check**:\n   - After iterating through all characters in the string, if the final value of `balance` is zero, it indicates that every opening bracket has a corresponding closing bracket and the string is correctly bracketed. In this case, the function returns `True`.\n   \n5. **Return Statement**: If no imbalance occurs during iteration and the balance ends at 0, the function returns `True`. Otherwise, if an imbalance is detected or the final balance is not zero, it returns `False`.\n\nThis approach ensures that the string of parentheses is correctly bracketed by maintaining a running count of open and close brackets."}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "def derivative(xs):\n    return [i * x for i, x in enumerate(xs) if i > 0]\n```\n\n", "py_summary": "The Python function `derivative` calculates the derivative of a polynomial represented by its coefficients. Here's an analysis of how it works:\n\n1. **Input**: The input is a list `xs`, where each element represents the coefficient of the corresponding power of \\( x \\) in the polynomial. For example, if `xs = [3, 1, 2, 4, 5]`, it represents the polynomial \\( 3 + 1x + 2x^2 + 4x^3 + 5x^4 \\).\n\n2. **Derivative Calculation**: The derivative of a term \\( c_i x^i \\) in the polynomial is given by \\( i \\cdot c_i \\cdot x^{i-1} \\). This means that for each coefficient at index `i` (where `i > 0`), the corresponding term's derivative is `i * xs[i]`.\n\n3. **List Comprehension**: The function uses a list comprehension to iterate over the indices and values of the input list `xs`. It skips the first element (`i == 0`) because the derivative of the constant term (coefficient at index 0) is zero, which would not contribute to the resulting polynomial.\n\n4. **Output**: The output is a new list where each element represents the coefficient of the corresponding power of \\( x \\) in the derived polynomial. For example, for `xs = [3, 1, 2, 4, 5]`, the derivative is `[1*1, 2*2, 3*4, 4*5]` which simplifies to `[1, 4, 12, 20]`.\n\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1;\n    for (int i = 3; i <= n; ++i) {\n        int temp = c;\n        c = a + b + c;\n        a = b;\n        b = temp;\n    }\n    return c;\n}\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for i in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c\n```\n\n", "py_summary": "The Python function `fibfib(n)` calculates the n-th element of the FibFib sequence, which is defined as follows:\n- fibfib(0) == 0\n- fibfib(1) == 0\n- fibfib(2) == 1\n- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\nThe function uses a dynamic programming approach to efficiently compute the value:\n1. It first handles the base cases where `n` is 0, 1, or 2.\n2. For values of `n` greater than 2, it initializes three variables (`a`, `b`, and `c`) representing the last three elements in the sequence: fibfib(n-3), fibfib(n-2), and fibfib(n-1) respectively.\n3. It then iterates from 3 to n, updating these variables at each step according to the recurrence relation:\n   - `a` becomes `b`\n   - `b` becomes `c`\n   - `c` is updated as `a + b + c`\n4. Finally, it returns the value of `c`, which represents fibfib(n).\n\nThis approach ensures that the function computes each element only once and avoids the exponential time complexity associated with a naive recursive solution.\n\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    string vowels = \"aeiou\";\n    \n    // Convert input string to lowercase for case-insensitive comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Count the number of standard vowels in the string\n    for (char c : s) {\n        if (vowels.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    // Check if 'y' is at the end and treat it as a vowel\n    if (!s.empty() && s.back() == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n", "py_code": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    \n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n            \n    # Check if 'y' is at the end and treat it as a vowel\n    if s[-1].lower() == 'y':\n        count += 1\n        \n    return count\n```\n\n", "py_summary": "The Python function `vowels_count` takes a string `s` as input and returns the number of vowels in the string. The vowels considered are 'a', 'e', 'i', 'o', and 'u'. Additionally, if the last character of the string is 'y' (case-insensitive), it is also counted as a vowel.\n\nHere's a breakdown of how the function works:\n\n1. **Initialization**:\n   - `vowels` is initialized to a string containing all the vowels.\n   - `count` is initialized to 0, which will keep track of the number of vowels found in the string.\n\n2. **Counting Vowels**:\n   - The function iterates through each character in the input string `s`.\n   - For each character, it checks if the lowercase version of the character is in the `vowels` string.\n   - If the character is a vowel, it increments the `count`.\n\n3. **Special Case for 'y'**:\n   - After counting all other vowels, the function checks if the last character of the string (accessed using `s[-1]`) is 'y'.\n   - If the last character is 'y', it increments the `count` by 1.\n\n4. **Return Result**:\n   - The function returns the total count of vowels found in the string, including any trailing 'y'.\n\nThis approach ensures that all standard vowels are counted and handles the special case for 'y' at the end of the word correctly."}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine number of digits\n    int num_digits = num_str.length();\n    \n    // Handle case where shift is greater than or equal to the number of digits\n    if (shift >= num_digits) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Compute effective shift\n    shift %= num_digits;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_digits - shift) + num_str.substr(0, num_digits - shift);\n    \n    return shifted_str;\n}\n", "py_code": "def circular_shift(x: int, shift: int) -> str:\n    num_str = str(x)\n    num_digits = len(num_str)\n    \n    if shift >= num_digits:\n        return num_str[::-1]\n    \n    shift %= num_digits  # Handle cases where shift > number of digits\n    shifted_str = num_str[-shift:] + num_str[:-shift]\n    return shifted_str\n```\n\n", "py_summary": "The Python function `circular_shift` takes an integer `x` and an integer `shift` as input and returns a string representing the circular shift of the digits in `x`. Here's a detailed analysis:\n\n1. **Convert Integer to String**: The integer `x` is converted to its string representation `num_str`.\n2. **Determine Number of Digits**: The length of `num_str` (i.e., the number of digits) is stored in `num_digits`.\n3. **Handle Shift Greater Than Number of Digits**:\n   - If `shift >= num_digits`, it means that shifting by this amount would result in a full rotation or more, so the function returns the reversed string of `num_str`.\n4. **Compute Effective Shift**: The effective shift is computed using `shift %= num_digits`. This ensures that if `shift` is greater than the number of digits, it wraps around to an equivalent smaller shift.\n5. **Perform Circular Shift**:\n   - The last `shift` characters from `num_str` are taken and concatenated with the remaining part of `num_str`.\n6. **Return Result**: The resulting string after performing the circular shift is returned.\n\nThis approach ensures that the function handles both cases where the shift value is within the number of digits and when it exceeds the number of digits, returning the reversed string in such cases.\n\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int result = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            result += static_cast<int>(c);\n        }\n    }\n    return result;\n}\n", "py_code": "def digitSum(s):\n    result = 0\n    for char in s:\n        if char.isupper():\n            result += ord(char)\n    return result\n```\n\n", "py_summary": "The Python function `digitSum` calculates the sum of the ASCII values of all uppercase characters in a given string `s`. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `result` is initialized to 0. This will store the cumulative sum of the ASCII values of uppercase characters.\n\n2. **Iteration through Characters**: A for loop iterates over each character in the input string `s`.\n\n3. **Check Uppercase Character**: For each character, the function checks if it is an uppercase letter using the `isupper()` method.\n\n4. **Add ASCII Value**: If the character is uppercase, its ASCII value (obtained using the `ord()` function) is added to `result`.\n\n5. **Return Result**: After iterating through all characters in the string, the function returns the accumulated sum stored in `result`.\n\nThis approach ensures that only uppercase letters are considered and their corresponding ASCII values are summed up correctly.\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <regex>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract numbers from the string using regex\n    smatch matches;\n    regex apple_regex(\"(\\\\d+) apples\");\n    regex orange_regex(\"(\\\\d+) oranges\");\n\n    // Declare variables outside of if statements to keep them in scope\n    int apples = 0;\n    int oranges = 0;\n\n    // Find and extract the number of apples\n    if (regex_search(s, matches, apple_regex)) {\n        apples = stoi(matches[1].str());\n    } else {\n        throw runtime_error(\"Invalid input: no apples found.\");\n    }\n\n    // Find and extract the number of oranges\n    if (regex_search(s, matches, orange_regex)) {\n        oranges = stoi(matches[1].str());\n    } else {\n        throw runtime_error(\"Invalid input: no oranges found.\");\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n\n    return mangoes;\n}\n", "py_code": "def fruit_distribution(s: str, n: int) -> int:\n    # Extract numbers from the string using split and findall\n    import re\n    words = s.split()\n    apples = int(re.findall(r'\\d+', words[0])[0])\n    oranges = int(re.findall(r'\\d+', words[3])[0])\n\n    # Calculate the number of mangoes\n    mangoes = n - (apples + oranges)\n    \n    return mangoes\n```\n\n", "py_summary": "The Python code defines a function `fruit_distribution` that takes two parameters: a string `s` representing the number of apples and oranges in the basket, and an integer `n` representing the total number of fruits in the basket. The function returns the number of mangoes in the basket.\n\nHere's a step-by-step breakdown of how the code works:\n\n1. **Splitting the String**: \n   - The string `s` is split into individual words using `split()`. This results in a list where each element is a word from the input string.\n   \n2. **Extracting Numbers**:\n   - The function uses regular expressions (`re.findall(r'\\d+', ...)` to find all digit sequences in specific positions of the split string.\n   - It extracts the number of apples by taking the first integer found after splitting (which corresponds to `words[0]`).\n   - Similarly, it extracts the number of oranges by finding the integer at the fourth position (`words[3]`) in the list.\n\n3. **Calculating Mangoes**:\n   - The total number of mangoes is calculated by subtracting the sum of apples and oranges from the total number of fruits `n`.\n\n4. **Returning Result**:\n   - Finally, the function returns the calculated number of mangoes.\n\nThis approach ensures that the input string is correctly parsed to extract the necessary numerical values and then uses basic arithmetic to determine the remaining fruit count (mangoes).\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = INT_MAX;\n    int index_of_smallest_even_value = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value || (arr[i] == smallest_even_value && i < index_of_smallest_even_value)) {\n                smallest_even_value = arr[i];\n                index_of_smallest_even_value = i;\n            }\n        }\n    }\n    \n    if (smallest_even_value == INT_MAX) {\n        return {};\n    } else {\n        return {smallest_even_value, index_of_smallest_even_value};\n    }\n}\n", "py_code": "def pluck(arr):\n    smallest_even_value = float('inf')\n    index_of_smallest_even_value = -1\n    \n    for i, value in enumerate(arr):\n        if value % 2 == 0 and (smallest_even_value > value or (smallest_even_value == value and index_of_smallest_even_value > i)):\n            smallest_even_value = value\n            index_of_smallest_even_value = i\n            \n    if smallest_even_value == float('inf'):\n        return []\n    \n    return [smallest_even_value, index_of_smallest_even_value]\n```", "py_summary": "The Python function `pluck` is designed to find and return the node with the smallest even value from a given list of non-negative integers (representing nodes in a tree branch). If there are multiple nodes with the same smallest even value, it returns the one with the smallest index.\n\nHere's an analysis of how the code works:\n\n1. **Initialization**:\n   - `smallest_even_value` is initialized to infinity (`float('inf')`). This variable will store the smallest even value found in the list.\n   - `index_of_smallest_even_value` is initialized to `-1`. This variable will store the index of the node with the smallest even value.\n\n2. **Iteration**:\n   - The function iterates through each element and its index in the input list using `enumerate(arr)`.\n   - For each element, it checks if the element is an even number (`value % 2 == 0`).\n   - If the current element is even and either smaller than the current smallest even value or equal to the current smallest even value but with a smaller index, it updates `smallest_even_value` and `index_of_smallest_even_value`.\n\n3. **Result**:\n   - After iterating through all elements, if no even values were found (`smallest_even_value` remains infinity), the function returns an empty list `[]`.\n   - Otherwise, it returns a list containing the smallest even value and its index `[smallest_even_value, index_of_smallest_even_value]`.\n\nThis approach ensures that the function correctly identifies and returns the node with the smallest even value or the first occurrence of the smallest even value if there are multiple such nodes."}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n\nint search(std::vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer in the list\n    std::unordered_map<int, int> frequency_dict;\n    \n    // Count the frequency of each integer in the list\n    for (const auto& num : lst) {\n        frequency_dict[num]++;\n    }\n    \n    int result = -1;\n    \n    // Iterate through the frequency map to find the greatest valid integer\n    for (const auto& entry : frequency_dict) {\n        if (entry.second >= entry.first && entry.first > result) {\n            result = entry.first;\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef search(lst: List[int]) -> int:\n    frequency_dict = {}\n    \n    # Count the frequency of each integer in the list\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    \n    result = -1\n    for num, freq in frequency_dict.items():\n        if freq >= num and num > result:\n            result = num\n            \n    return result\n```\n\n", "py_summary": "The Python code defines a function `search` that takes a list of integers as input and returns the greatest integer with a frequency greater than or equal to its value. Here's a detailed breakdown:\n\n1. **Frequency Counting**:\n   - A dictionary `frequency_dict` is initialized to store the frequency of each integer in the list.\n   - The function iterates through the list, updating the count for each integer in the dictionary.\n\n2. **Finding the Result**:\n   - An initial result variable `result` is set to `-1`, which will be returned if no valid integer is found.\n   - The function then iterates through the items of the frequency dictionary. For each item `(num, freq)`, it checks if the frequency `freq` is greater than or equal to the integer value `num`.\n   - If this condition is met and the current integer `num` is greater than the current result, the result is updated to `num`.\n\n3. **Return**:\n   - The function returns the highest valid integer found during the iteration, or `-1` if no such integer exists.\n\nThis approach ensures that the solution efficiently finds the required integer by leveraging a dictionary for frequency counting and iterating through the dictionary items to determine the maximum valid integer based on the given criteria.\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    \n    while (!lst.empty()) {\n        // Add minimum value (first element)\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        \n        if (!lst.empty()) {\n            // Add maximum value (last element)\n            result.push_back(lst.back());\n            lst.erase(prev(lst.end()));\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    \n    while sorted_lst:\n        # Add minimum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(0))\n        \n        # Add maximum value\n        if sorted_lst:\n            result.append(sorted_lst.pop())\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `strange_sort_list` that takes a list of integers and returns a new list in \"strange order.\" Here's a detailed analysis:\n\n1. **Sorting the List**: The input list is first sorted using `sorted(lst)`. This ensures that all elements are arranged in ascending order.\n\n2. **Initializing Result List**: An empty list `result` is initialized to store the final output.\n\n3. **Processing Elements**:\n   - A while loop runs as long as there are elements left in `sorted_lst`.\n   - Inside the loop, the smallest remaining element (the first element of `sorted_lst`) is appended to `result`, and then removed from `sorted_lst` using `pop(0)`.\n   - If there are still elements left in `sorted_lst`, the largest remaining element (the last element of `sorted_lst`) is appended to `result`, and then removed from `sorted_lst` using `pop()`.\n\n4. **Returning Result**: Once all elements have been processed, the function returns the `result` list which contains the elements in the desired \"strange order.\"\n\nThis approach ensures that the output alternates between the minimum and maximum of the remaining elements until no more elements are left to process.\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b > c) && (b + c > a) && (c + a > b)) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to two decimal places\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n", "py_code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n```\n\n", "py_summary": "The Python function `triangle_area` calculates the area of a triangle given its three side lengths and returns the result rounded to two decimal places if the sides form a valid triangle. Here's an analysis of how it works:\n\n1. **Validation Check**: The function first checks whether the given side lengths can form a valid triangle using the triangle inequality theorem, which states that for any triangle with sides `a`, `b`, and `c`:\n   - `a + b > c`\n   - `b + c > a`\n   - `c + a > b`\n\n2. **Semi-perimeter Calculation**: If the sides form a valid triangle, the function calculates the semi-perimeter (`s`) of the triangle using the formula:\n   \\[\n   s = \\frac{a + b + c}{2}\n   \\]\n\n3. **Area Calculation**: The area of the triangle is then calculated using Heron's formula:\n   \\[\n   \\text{Area} = \\sqrt{s(s - a)(s - b)(s - c)}\n   \\]\n   \n4. **Return Value**: If the sides form a valid triangle, the function returns the computed area rounded to two decimal places. Otherwise, it returns `-1`.\n\nThis approach ensures that only valid triangles are processed and their areas calculated accurately.\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    bool balanced = std::equal(q.begin(), q.begin() + q.size()/2, q.rbegin());\n    \n    // Calculate the sum of elements in the vector\n    int total_weight = std::accumulate(q.begin(), q.end(), 0);\n    \n    // Determine if it can fly based on balance and weight constraints\n    return balanced && total_weight <= w;\n}\n", "py_code": "def will_it_fly(q, w):\n    # Check if the vector is palindromic (balanced)\n    balanced = q == q[::-1]\n    \n    # Calculate the sum of elements in the vector\n    total_weight = sum(q)\n    \n    # Determine if it can fly based on balance and weight constraints\n    return balanced and total_weight <= w\n```\n\n", "py_summary": "The Python function `will_it_fly` checks whether an object represented by a vector `q` will fly given a maximum possible weight `w`. Here's a detailed analysis of how it works:\n\n1. **Check if the Vector is Palindromic (Balanced)**:\n   - The code uses slicing to reverse the vector and then compares it with the original vector (`q == q[::-1]`). If both are equal, the vector is palindromic or balanced.\n\n2. **Calculate the Sum of Elements in the Vector**:\n   - The function calculates the total weight by summing up all elements in the vector `q` using `sum(q)`.\n\n3. **Determine if It Can Fly Based on Balance and Weight Constraints**:\n   - The function returns `True` if both conditions are met: \n     1. The vector is balanced (palindromic).\n     2. The total weight of the elements in the vector is less than or equal to the maximum possible weight `w`.\n\nThe logic ensures that an object will fly only if it meets both criteria, making sure the function accurately determines whether the given conditions are satisfied.\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n\nint smallest_change(std::vector<int>& arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n", "py_code": "def smallest_change(arr):\n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n```\n\n", "py_summary": "The Python function `smallest_change` calculates the minimum number of element changes required to make a given list (`arr`) palindromic. Here's an analysis of how it works:\n\n1. **Initialization**: \n   - `changes`: A counter initialized to 0, which will keep track of the number of changes needed.\n   - `left`: An index starting from the beginning of the array (index 0).\n   - `right`: An index starting from the end of the array (last index).\n\n2. **While Loop**:\n   - The loop continues as long as `left` is less than `right`, ensuring that we only compare elements symmetrically around the center.\n   - Inside the loop, if the element at `arr[left]` does not match the element at `arr[right]`, it increments the `changes` counter by 1. This indicates a necessary change to make these two elements equal (and thus contributing to making the array palindromic).\n   - After checking and potentially incrementing the changes, both indices are moved closer towards the center: `left` is incremented (`left += 1`) and `right` is decremented (`right -= 1`).\n\n3. **Return Statement**:\n   - The function returns the total number of changes needed to make the array palindromic.\n\nThis approach ensures that each pair of elements symmetrically placed around the center of the array is checked, and only necessary changes are counted. This method efficiently calculates the minimum number of changes required without needing to explicitly change any elements in the list itself.\n\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\n// Helper function to count the total number of characters in a vector of strings\nint count_chars(const std::vector<std::string>& lst) {\n    int char_count = 0;\n    for (const auto& str : lst) {\n        char_count += str.length();\n    }\n    return char_count;\n}\n\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    // Calculate the total number of characters in each list\n    int char_count_lst1 = count_chars(lst1);\n    int char_count_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector based on character counts\n    if (char_count_lst1 < char_count_lst2) {\n        return lst1;\n    } else if (char_count_lst2 < char_count_lst1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n", "py_code": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    char_count_lst1 = count_chars(lst1)\n    char_count_lst2 = count_chars(lst2)\n\n    if char_count_lst1 < char_count_lst2:\n        return lst1\n    elif char_count_lst2 < char_count_lst1:\n        return lst2\n    else:\n        return lst1\n```\n\n", "py_summary": "The Python code defines a function `total_match` that takes two lists of strings (`lst1` and `lst2`) as input and returns one of them based on the total number of characters in each list. The function works as follows:\n\n1. **Helper Function**: A helper function `count_chars` is defined to calculate the total number of characters in a given list of strings.\n   - It uses a generator expression inside the `sum` function to iterate over each string in the list and sum up their lengths.\n\n2. **Character Count Calculation**:\n   - The function calculates the total character count for both `lst1` and `lst2` using the helper function `count_chars`.\n\n3. **Comparison and Return**:\n   - If the total number of characters in `lst1` is less than that in `lst2`, it returns `lst1`.\n   - If the total number of characters in `lst2` is less than that in `lst1`, it returns `lst2`.\n   - If both lists have the same total number of characters, it returns `lst1`.\n\nThis approach ensures that the function correctly identifies and returns the list with fewer total characters or the first list if they are equal.\n\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Ensure the input number is within a reasonable range\n    if (a < 2 || a > 999) return false;\n\n    std::vector<int> prime_factors;\n    \n    for (int i = 2; i <= 99 && a >= 2; ++i) {\n        if (is_prime(i)) {\n            while (a % i == 0) {\n                prime_factors.push_back(i);\n                a /= i;\n            }\n        }\n    }\n\n    // Check if exactly three prime factors were found\n    return prime_factors.size() == 3 && a == 1;\n}\n", "py_code": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_of_three_primes(a):\n    if a < 2 or a > 999:  # Since the product of three primes less than 100 will be at most 9841 (71*73)\n        return False\n    \n    prime_factors = []\n    \n    for i in range(2, 100):\n        if is_prime(i) and a % i == 0:\n            prime_factors.append(i)\n            a //= i\n            if len(prime_factors) > 3:  # If more than three primes are found, it's not the product of exactly three primes.\n                return False\n    \n    return len(prime_factors) == 3 and is_prime(a // (prime_factors[0] * prime_factors[1])) and a == prime_factors[0] * prime_factors[1] * prime_factors[2]\n```\n\n", "py_summary": "The Python code defines a function `is_multiply_of_three_primes` that checks if a given number is the product of exactly three prime numbers, with each prime number being less than 100.\n\nHere's an analysis of how the function works:\n\n1. **Prime Check Function (`is_prime`)**:\n   - This helper function determines whether a given integer `n` is a prime number.\n   - It returns `False` if `n` is less than or equal to 1, as these are not prime numbers.\n   - For integers greater than 1, it checks divisibility from 2 up to the square root of `n`. If any divisor is found, it returns `False`.\n\n2. **Main Function (`is_multiply_of_three_primes`)**:\n   - The function first checks if the input number `a` is within a reasonable range (greater than or equal to 2 and less than or equal to 999). This ensures that the product of three primes less than 100 fits within this range.\n   - It initializes an empty list `prime_factors` to store prime factors found during iteration.\n   - The function iterates through all integers from 2 to 99 (since each prime factor must be less than 100).\n     - For each integer, it checks if the number is a prime using the `is_prime` helper function and whether it divides `a`.\n     - If both conditions are met, the integer is added to the list of prime factors.\n     - The input number `a` is divided by this prime factor.\n   - If more than three prime factors are found during iteration, the function returns `False`, as the number cannot be a product of exactly three primes.\n   - After iterating through possible prime factors, it checks if exactly three prime factors have been identified and that their product equals the original input number `a`.\n\nThis approach ensures that the given number is verified to be the product of exactly three prime numbers within the specified constraints.\n\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n\n    double log_value = log(x) / log(n);\n    return floor(log_value) == log_value;\n}\n\n", "py_code": "import math\n\ndef is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    \n    log_value = math.log(x, n)\n    return log_value.is_integer()\n```\n\n", "py_summary": "The Python function `is_simple_power` checks whether a given number \\( x \\) is a simple power of another number \\( n \\). Here's a detailed analysis:\n\n1. **Base Case Check**:\n   - If \\( n = 1 \\), the function returns true only if \\( x = 1 \\). This handles the special case where any other value of \\( x \\) would not be a simple power of 1.\n\n2. **Logarithmic Calculation**:\n   - The function calculates the logarithm of \\( x \\) to the base \\( n \\) using `math.log(x, n)`. This calculation determines the exponent required for \\( n \\) to equal \\( x \\).\n\n3. **Integer Check**:\n   - It checks if the result of the logarithmic calculation is an integer by calling `.is_integer()` on the log value.\n   - If the log value is an integer, it means that \\( x = n^k \\) for some integer \\( k \\), and thus \\( x \\) is a simple power of \\( n \\).\n\n4. **Return Value**:\n   - The function returns `True` if the logarithm result is an integer, indicating that \\( x \\) is indeed a simple power of \\( n \\). Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether \\( x \\) can be expressed as \\( n^k \\) for some integer \\( k \\), which aligns with the problem's requirements."}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of 'a'\n    double root = cbrt(a);\n    \n    // Round the cube root to the nearest integer\n    int rounded_root = round(root);\n\n    // Check if the cube of the rounded root equals the original number\n    return pow(rounded_root, 3) == a;\n}\n", "py_code": "import math\n\ndef iscube(a):\n    if a < 0:\n        root = -(-a) ** (1/3)\n    else:\n        root = a ** (1/3)\n    \n    # Check if the cube of the rounded root equals the original number\n    return round(root) ** 3 == a\n```\n\n", "py_summary": "The Python function `iscube(a)` checks whether an integer `a` is a perfect cube of some other integer. Here's a detailed analysis:\n\n1. **Input Handling**: The function takes a single integer `a` as input.\n2. **Root Calculation**:\n   - If `a` is negative, the function calculates the cube root of `-a` and then negates it to handle negative inputs correctly.\n   - For non-negative values of `a`, the function directly computes the cube root using `a ** (1/3)`.\n3. **Rounding**: The cube root value is rounded to the nearest integer using Python's built-in rounding behavior when converting a float to an int implicitly through exponentiation.\n4. **Verification**:\n   - The function then checks if raising this rounded integer to the power of 3 equals the original input `a`.\n5. **Return Value**: If the condition holds true, the function returns `True`, indicating that `a` is indeed a perfect cube; otherwise, it implicitly returns `False`.\n\nThis approach ensures that both positive and negative integers are correctly handled for determining if they are perfect cubes.\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char digit : num) {\n        // Check if the digit is a prime hexadecimal digit\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n", "py_code": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python function `hex_key` takes a hexadecimal number as a string and counts how many of its digits are prime hexadecimal digits. Here's an analysis of the code:\n\n1. **Initialization**:\n   - A set `prime_hex_digits` is defined to store the hexadecimal digits that are considered prime: '2', '3', '5', '7', 'B', and 'D'.\n   - An integer variable `count` is initialized to zero, which will be used to keep track of the number of prime hexadecimal digits found in the input string.\n\n2. **Iteration**:\n   - The function iterates through each character (digit) in the input string `num`.\n   \n3. **Counting Prime Digits**:\n   - For each digit, it checks if the digit is present in the set `prime_hex_digits`. If the digit is found in this set, it increments the count by 1.\n\n4. **Return Result**:\n   - After iterating through all digits of the input string, the function returns the value of `count`, which represents the number of prime hexadecimal digits in the input string.\n\nThis approach ensures that each character in the input string is checked only once and efficiently determines if it is a prime hexadecimal digit by leveraging set membership testing."}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for easy manipulation\n    string binary = \"\";\n    if (decimal == 0) {\n        binary = \"0\";\n    } else {\n        while (decimal > 0) {\n            binary = to_string(decimal % 2) + binary;\n            decimal /= 2;\n        }\n    }\n\n    // Add \"db\" at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n", "py_code": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # Convert decimal to binary and remove the '0b' prefix.\n    return f\"db{binary_str}db\"\n```\n\n", "py_summary": "The Python function `decimal_to_binary` converts a given decimal number to its binary representation and formats it according to the specified requirements:\n\n1. **Convert Decimal to Binary**: The function uses the built-in `bin()` function in Python, which converts an integer to its binary string representation prefixed with '0b'. For example, `bin(15)` returns `'0b1111'`.\n\n2. **Remove Prefix**: The `[2:]` slice operation removes the first two characters ('0b') from the binary string.\n\n3. **Add Extra Characters**: The function then formats the resulting binary string by adding 'db' at both the beginning and end of the binary string using an f-string.\n\nFor example:\n- `decimal_to_binary(15)` will return `\"db1111db\"`.\n- `decimal_to_binary(32)` will return `\"db100000db\"`.\n\nThis ensures that the output matches the required format with \"db\" at both ends of the binary string."}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_happy` checks if a given string is \"happy\" based on the criteria that its length must be at least 3 and every set of three consecutive letters must be distinct.\n\n1. **Initial Length Check**: The function first checks if the length of the string `s` is less than 3. If it is, the function immediately returns `False`, as a happy string must have at least 3 characters.\n   \n2. **Iterate Through String**: The function then iterates through each character in the string up to the third last character (i.e., from index 0 to len(s) - 3). For each position `i`:\n   - It checks if any of the three consecutive characters (`s[i]`, `s[i + 1]`, and `s[i + 2]`) are not distinct.\n   - If it finds that any two out of these three characters are the same, it returns `False`.\n\n3. **Return True**: If the loop completes without finding any set of three consecutive non-distinct characters, the function returns `True`.\n\nThis approach ensures that all conditions for a string to be considered \"happy\" are met.\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\"); // For GPA below 0, which should not normally occur but is handled for completeness.\n        }\n    }\n\n    return letter_grades;\n}\n", "py_code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grades.append(\"A\")\n        elif gpa > 3.3:\n            letter_grades.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grades.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grades.append(\"B\")\n        elif gpa > 2.3:\n            letter_grades.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grades.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grades.append(\"C\")\n        elif gpa > 1.3:\n            letter_grades.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grades.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grades.append(\"D\")\n        elif gpa >= 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")  # In case of a GPA below 0, which is not expected but handled for completeness\n    return letter_grades\n```\n\n", "py_summary": "The Python code defines a function `numerical_letter_grade` that takes a list of GPAs as input and returns a corresponding list of letter grades based on the provided grading scale. The function iterates through each GPA in the input list and assigns a letter grade according to the specified conditions:\n\n- If the GPA is exactly 4.0, it assigns \"A+\".\n- For other values, it uses a series of `elif` statements to check if the GPA falls within specific ranges:\n  - Greater than 3.7: Assigns \"A\".\n  - Greater than 3.3: Assignes \"A-\".\n  - Greater than 3.0: Assignes \"B+\".\n  - Greater than 2.7: Assignes \"B\".\n  - Greater than 2.3: Assignes \"B-\".\n  - Greater than 2.0: Assignes \"C+\".\n  - Greater than 1.7: Assignes \"C\".\n  - Greater than 1.3: Assignes \"C-\".\n  - Greater than 1.0: Assignes \"D+\".\n  - Greater than 0.7: Assignes \"D\".\n  - Greater than or equal to 0.0: Assignes \"D-\" (including exactly 0.0).\n  \nIf the GPA is below 0, which should not normally occur but is handled for completeness, it assigns \"E\".\n\nThe function appends each letter grade to a list and returns this list at the end.\n\nThis approach ensures that each GPA in the input list is correctly mapped to its corresponding letter grade based on the grading scale provided."}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n\n", "py_code": "def prime_length(s: str) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    length = len(s)\n    return is_prime(length)\n```\n\n", "py_summary": "The Python code defines a function `prime_length` that takes a string as input and returns `True` if the length of the string is a prime number, otherwise it returns `False`.\n\nHere's an analysis of how the function works:\n\n1. **Helper Function (`is_prime`)**:\n   - The helper function `is_prime(n)` checks whether a given integer `n` is a prime number.\n   - It first handles edge cases where `n <= 1`, returning `False` since neither 0 nor 1 are prime numbers.\n   - For integers greater than 1, the function iterates from 2 to the square root of `n`. If any divisor is found (i.e., if `n % i == 0`), it returns `False`.\n   - If no divisors are found during this iteration, the function returns `True`, indicating that `n` is a prime number.\n\n2. **Main Function (`prime_length`)**:\n   - The main function calculates the length of the input string `s` and stores it in the variable `length`.\n   - It then calls the helper function `is_prime(length)` to determine if this length is a prime number.\n   - Finally, it returns the result from the `is_prime` function.\n\nThis approach ensures that the main function leverages an efficient helper function for checking primality and correctly determines whether the string's length is a prime number."}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1)\n        return 1;\n\n    // For n-digit numbers starting with 1: There is exactly one such number for each length (i.e., 10^(n-1))\n    int start_with_1 = static_cast<int>(pow(10, n - 1));\n\n    // For n-digit numbers ending with 1: The first digit can be any of the digits from 1 to 9, and the rest can be anything.\n    int end_with_1 = 9 * static_cast<int>(pow(10, n - 1));\n\n    // Subtract the overlap where a number both starts and ends with 1\n    int overlap = static_cast<int>(pow(10, n - 2));\n\n    return start_with_1 + end_with_1 - overlap;\n}\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    \n    # For n-digit numbers starting with 1: There is exactly one such number for each length (i.e., 10^(n-1))\n    start_with_1 = 10 ** (n - 1)\n    \n    # For n-digit numbers ending with 1: The first digit can be any of the digits from 1 to 9, and the rest can be anything.\n    end_with_1 = 9 * (10 ** (n - 1))\n    \n    # Subtract the overlap where a number both starts and ends with 1\n    overlap = 10 ** (n - 2)\n    \n    return start_with_1 + end_with_1 - overlap\n```\n\n", "py_summary": "The Python function `starts_one_ends(n)` calculates the count of n-digit positive integers that either start or end with the digit 1. Here's a detailed breakdown:\n\n1. **Base Case**: If `n` is 1, there is only one such number (which is '1').\n2. **Numbers Starting with 1**:\n   - For an n-digit number starting with 1, there are exactly \\(10^{(n-1)}\\) such numbers.\n3. **Numbers Ending with 1**:\n   - For an n-digit number ending with 1, the first digit can be any of the digits from 1 to 9 (i.e., 9 choices), and each of the remaining \\((n-1)\\) positions can be filled by any digit from 0 to 9. Thus, there are \\(9 \\times 10^{(n-1)}\\) such numbers.\n4. **Overlap**:\n   - The overlap occurs when a number both starts and ends with 1. For an n-digit number starting and ending with 1, the middle part can be any combination of digits from 0 to 9 for \\((n-2)\\) positions. Thus, there are \\(10^{(n-2)}\\) such numbers.\n5. **Final Calculation**:\n   - The total count is the sum of numbers starting with 1 and ending with 1 minus the overlap.\n\nThe function returns this calculated value as the result.\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n\nstd::string solve(int N) {\n    // Convert integer to string to iterate over each digit\n    std::stringstream ss;\n    ss << N;\n    std::string str_n = ss.str();\n\n    // Initialize sum of digits\n    int digit_sum = 0;\n\n    // Iterate through each character in the string and convert it back to an integer to add to the sum\n    for (char c : str_n) {\n        digit_sum += c - '0';\n    }\n\n    // Convert the sum of digits to binary\n    std::string binary_sum;\n    if (digit_sum == 0) {\n        binary_sum = \"0\";\n    } else {\n        while (digit_sum > 0) {\n            binary_sum = std::to_string(digit_sum % 2) + binary_sum;\n            digit_sum /= 2;\n        }\n    }\n\n    return binary_sum;\n}\n", "py_code": "def solve(N):\n    # Convert the integer to a string to iterate over each digit\n    str_n = str(N)\n    \n    # Initialize sum of digits\n    digit_sum = 0\n    \n    # Iterate through each character in the string and convert it back to an integer to add to the sum\n    for char in str_n:\n        digit_sum += int(char)\n    \n    # Convert the sum of digits to binary\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n```\n\n", "py_summary": "The Python function `solve` takes an integer `N` as input and returns a string representing the binary form of the sum of its digits. Here's a detailed breakdown of how it works:\n\n1. **Convert Integer to String**: The integer `N` is first converted into a string (`str_n`). This allows us to iterate over each character in the number, which represents an individual digit.\n\n2. **Initialize Sum Variable**: A variable `digit_sum` is initialized to 0. This will be used to accumulate the sum of all digits in the number.\n\n3. **Sum Digits**: The function iterates through each character in `str_n`. For each character (which corresponds to a digit), it converts that character back into an integer and adds it to `digit_sum`.\n\n4. **Convert Sum to Binary**: After calculating the sum of the digits, the function uses Python's built-in `bin` function to convert this sum into its binary representation. The `[2:]` slice is used to remove the '0b' prefix that `bin` adds to indicate a binary number.\n\n5. **Return Result**: Finally, the function returns the binary string representing the digit sum.\n\nThis approach ensures that we correctly compute and return the desired output in the specified format (binary string)."}
{"task_id": "CPP/85", "generation": "#include <vector>\n#include <iostream>\n\nint add(const std::vector<int>& lst) {\n    int result = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {  \n        if (lst[i] % 2 == 0) {  \n            result += lst[i];\n        }\n    }\n    return result;\n}\n\n", "py_code": "def add(lst):\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current odd index is even\n            result += lst[i]\n    return result\n```\n\n", "py_summary": "The Python function `add` takes a list of integers as input and returns the sum of all even elements that are located at odd indices in the list.\n\n1. **Initialization**: The variable `result` is initialized to 0 to store the cumulative sum of the desired elements.\n2. **Iteration through Odd Indices**: A for loop iterates over the range starting from index 1 (the first odd index) and increments by 2, ensuring that only odd indices are processed.\n3. **Check Even Condition**: Inside the loop, it checks if the element at the current odd index is even using `lst[i] % 2 == 0`.\n4. **Accumulate Sum**: If the condition is true (i.e., the element is even), its value is added to `result`.\n5. **Return Result**: After iterating through all relevant indices, the function returns the accumulated sum stored in `result`.\n\nThis approach ensures that only elements at odd indices and which are even are considered for the final sum.\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n\nstd::string anti_shuffle(std::string s) {\n    std::istringstream iss(s);\n    std::ostringstream oss;\n    std::string word;\n\n    while (iss >> word) {\n        // Sort the characters in the current word\n        std::sort(word.begin(), word.end());\n        \n        // Append the sorted word to the output string stream\n        oss << word << \" \";\n    }\n\n    // Get the result by converting the stringstream back to a string and trimming trailing space\n    std::string result = oss.str();\n    if (!result.empty()) {\n        result.pop_back();  // Remove the last space character\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef anti_shuffle(s: str) -> str:\n    words = s.split()\n    result = []\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n        \n    return ' '.join(result)\n```\n\n", "py_summary": "The Python code defines a function `anti_shuffle` that takes a string `s` and returns an ordered version of it according to the specified rules:\n\n1. **Splitting the String**: The input string is split into individual words using the `split()` method, which separates the string at each space character.\n2. **Sorting Each Word**: For each word in the list of words, the characters are sorted in ascending order based on their ASCII values using the `sorted()` function and then joined back together with `''.join()`.\n3. **Reconstructing the String**: The sorted words are recombined into a single string, maintaining the original order of the words and spaces by joining them with `' '.join(result)`.\n\nHere is a step-by-step breakdown:\n\n1. **Splitting the Input String**:\n   ```python\n   words = s.split()\n   ```\n   This splits the input string `s` into a list of words based on whitespace characters.\n\n2. **Sorting Each Word**:\n   ```python\n   for word in words:\n       sorted_word = ''.join(sorted(word))\n       result.append(sorted_word)\n   ```\n   For each word, it sorts the characters and then joins them back together to form a new string with characters in ascending ASCII order.\n\n3. **Reconstructing the String**:\n   ```python\n   return ' '.join(result)\n   ```\n   The sorted words are joined back into a single string using spaces as separators.\n\nThis approach ensures that the original structure of the input string (including word order and spacing) is preserved while each individual word's characters are ordered alphabetically based on ASCII values."}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<std::vector<int>> result;\n\n    // Iterate through each row in the nested vector\n    for (size_t row_index = 0; row_index < lst.size(); ++row_index) {\n        const auto& row = lst[row_index];\n        \n        // Iterate through each element in the current row\n        for (size_t col_index = 0; col_index < row.size(); ++col_index) {\n            if (row[col_index] == x) {\n                // Add coordinate to result list, adjusting column index from end of row\n                result.push_back({static_cast<int>(row_index), static_cast<int>(row.size() - 1 - col_index)});\n            }\n        }\n    }\n\n    // Sort the result by rows in ascending order and then by columns in descending order\n    std::sort(result.begin(), result.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index in descending order\n        }\n        return a[0] < b[0]; // Sort by row index in ascending order\n    });\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append([row_index, len(row) - 1 - col_index])\n                \n    # Sort by rows in ascending order and then by columns in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `get_row` that takes a nested list `lst` and an integer `x`, and returns a list of coordinates where `x` is found in `lst`. The function works as follows:\n\n1. **Initialization**: An empty list `result` is initialized to store the coordinates of occurrences of `x`.\n\n2. **Iterate through rows and columns**: \n   - The function iterates over each row using its index (`row_index`) and the elements within that row.\n   - For each element in the row, if it matches the integer `x`, a coordinate `[row_index, col_index]` is added to the result list. Here, `col_index` is adjusted to be the column index from the end of the row by using `len(row) - 1 - col_index`.\n\n3. **Sorting**: \n   - The result list is sorted first by the row index in ascending order and then by the column index in descending order.\n\n4. **Return Result**:\n   - Finally, the function returns the sorted list of coordinates.\n\nThis approach ensures that all occurrences of `x` are found and returned with their correct positions, and the resulting list is properly sorted as required.\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function declaration\nstd::vector<int> sort_array(std::vector<int> array) {\n    if (array.empty()) {\n        return {};\n    }\n\n    int first_value = array.front();\n    int last_value = !array.empty() ? array.back() : first_value;\n\n    int sum_of_ends = first_value + last_value;\n    \n    std::vector<int> sorted_array(array);  // Make a copy of the input vector\n\n    if (sum_of_ends % 2 == 0) {  // Even\n        std::sort(sorted_array.rbegin(), sorted_array.rend());  // Sort in descending order\n    } else {  // Odd\n        std::sort(sorted_array.begin(), sorted_array.end());  // Sort in ascending order\n    }\n\n    return sorted_array;\n}\n", "py_code": "from typing import List\n\ndef sort_vector(array: List[int]) -> List[int]:\n    if not array:\n        return []\n    \n    first_value = array[0]\n    last_value = array[-1] if len(array) > 1 else first_value\n    \n    sum_of_ends = first_value + last_value\n    \n    if sum_of_ends % 2 == 0:  # Even\n        sorted_array = sorted(array, reverse=True)\n    else:  # Odd\n        sorted_array = sorted(array)\n    \n    return sorted_array\n```\n\n", "py_summary": "The Python code defines a function `sort_vector` that takes a list of integers as input and returns a new list based on specific sorting criteria. Here's an analysis of how the function works:\n\n1. **Check for Empty List**: The function first checks if the input list is empty. If it is, the function immediately returns an empty list.\n\n2. **Determine First and Last Values**:\n   - It retrieves the value at the first index (`first_value`).\n   - If the list has more than one element, it also retrieves the value at the last index (`last_value`). Otherwise, `last_value` is set to be equal to `first_value`.\n\n3. **Calculate Sum of First and Last Values**:\n   - The function calculates the sum of `first_value` and `last_value`. This sum determines whether the list should be sorted in ascending or descending order.\n\n4. **Sorting Logic**:\n   - If the sum is even, the function sorts the input list in descending order.\n   - If the sum is odd, the function sorts the input list in ascending order.\n\n5. **Return Sorted List**: Finally, the function returns the newly sorted list without modifying the original list.\n\nThis approach ensures that the sorting behavior is determined by the parity of the sum of the first and last elements of the list, adhering to the problem's requirements.\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted_string = \"\";\n    \n    for (char c : s) {\n        if ('a' <= c && c <= 'z') {\n            // Calculate new character position after rotation by 4 positions\n            int offset = (c - 'a' + 4) % 26;\n            encrypted_string += char('a' + offset);\n        } else {\n            // Non-alphabetic characters remain unchanged\n            encrypted_string += c;\n        }\n    }\n    \n    return encrypted_string;\n}\n\n", "py_code": "def encrypt(s):\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate new character position after rotation\n            offset = (ord(char) - ord('a') + 4) % 26\n            encrypted_string += chr(ord('a') + offset)\n        else:\n            encrypted_string += char\n    return encrypted_string\n```\n\n", "py_summary": "The Python function `encrypt` takes a string `s` as input and returns an encrypted version of this string by rotating each letter in the alphabet down by 4 positions (since two multiplied by two is four).\n\nHere's a breakdown of how the function works:\n\n1. **Initialization**: The variable `encrypted_string` is initialized to an empty string, which will store the final encrypted result.\n\n2. **Iteration through characters**: A loop iterates over each character in the input string `s`.\n\n3. **Character Check and Rotation**:\n   - For each character `char`, it checks if the character is a lowercase letter (`'a'` to `'z'`). This ensures that only alphabetic characters are encrypted.\n   - If the character is within the range of lowercase letters, it calculates its new position after rotating down by 4 positions. The formula used for this calculation is:\n     \\[\n     \\text{offset} = (\\text{ord(char)} - \\text{ord('a')} + 4) \\% 26\n     \\]\n   - This offset value represents the number of positions to shift the character in the alphabet.\n   - The new character is then computed using `chr(ord('a') + offset)` and appended to `encrypted_string`.\n\n4. **Non-alphabetic Characters**: If a character is not within the range `'a'` to `'z'`, it is directly added to `encrypted_string` without any modification.\n\n5. **Return Result**: After processing all characters, the function returns the final encrypted string stored in `encrypted_string`.\n\nThis approach ensures that only lowercase letters are rotated and non-alphabetic characters remain unchanged in the output string."}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return INT_MIN; // Use a sentinel value to indicate None\n    }\n    \n    set<int> unique_elements(lst.begin(), lst.end());\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    if (sorted_unique.size() < 2) {\n        return INT_MIN; // Use a sentinel value to indicate None\n    }\n\n    return sorted_unique[1];\n}\n\n// Helper function to handle the case where we need to return None\nint next_smallest_helper(vector<int> lst) {\n    int result = next_smallest(lst);\n    if (result == INT_MIN) {\n        return -1; // Use a different sentinel value for clarity in this context\n    }\n    return result;\n}\n\n", "py_code": "from typing import List, Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = sorted(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    return unique_elements[1]\n```\n\n", "py_summary": "The Python function `next_smallest` is designed to find and return the second smallest element in a given list of integers. Here's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if the length of the input list `lst` is less than 2. If so, there cannot be a second smallest element, and the function returns `None`.\n\n2. **Remove Duplicates**: To ensure that we are working with unique elements, the function converts the list to a set (which removes duplicates) and then back to a sorted list (`unique_elements`). This step is crucial because if there are duplicate minimum values, they should be treated as a single element.\n\n3. **Check for Second Smallest Element**: After sorting the unique elements, the function checks if the length of `unique_elements` is less than 2. If it is, then there is no second smallest element (since all remaining elements are duplicates of the minimum value), and the function returns `None`.\n\n4. **Return Second Smallest Element**: Finally, if the list has at least two unique elements, the function returns the second element in the sorted list (`unique_elements[1]`).\n\nThis approach ensures that the function correctly handles cases with duplicate values and empty lists.\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Split the string into sentences using '.', '?' or '!'\n    vector<string> sentences;\n    stringstream ss(S);\n    string token;\n    while (getline(ss, token, '.')) {\n        for (char c : {'?', '!'}) {\n            size_t pos = 0;\n            while ((pos = token.find(c)) != string::npos) {\n                sentences.push_back(token.substr(0, pos));\n                token = token.substr(pos + 1);\n            }\n        }\n        if (!token.empty()) {\n            sentences.push_back(token);\n        }\n    }\n\n    // Iterate through each sentence\n    for (const auto& sentence : sentences) {\n        string trimmed_sentence = sentence;\n        \n        // Trim leading and trailing whitespace\n        trimmed_sentence.erase(0, trimmed_sentence.find_first_not_of(\" \\t\"));\n        trimmed_sentence.erase(trimmed_sentence.find_last_not_of(\" \\t\") + 1);\n\n        if (!trimmed_sentence.empty() && trimmed_sentence.substr(0, 2) == \"I \") {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n", "py_code": "def is_bored(S):\n    boredom_count = 0\n    sentences = S.split('.')\n    for sentence in sentences:\n        if '?' in sentence or '!' in sentence:\n            # Split by these delimiters and check each part separately\n            parts = sentence.split('?')\n            for part in parts:\n                sub_parts = part.split('!')\n                for sub_part in sub_parts:\n                    if sub_part.strip().startswith(\"I \"):\n                        boredom_count += 1\n        else:\n            if sentence.strip().startswith(\"I \"):\n                boredom_count += 1\n    \n    return boredom_count\n```\n\n", "py_summary": "The Python function `is_bored` takes a string `S` as input and counts the number of sentences that start with the word \"I\". Sentences are delimited by '.', '?', or '!'. Here's a detailed breakdown of how the function works:\n\n1. **Initialization**: The variable `boredom_count` is initialized to 0 to keep track of the number of boredoms (sentences starting with \"I\").\n\n2. **Splitting into Sentences**: The string `S` is split into sentences using the delimiter '.'. This creates a list of potential sentences.\n\n3. **Iterating Through Sentences**:\n   - For each sentence in the list, it checks if the sentence contains '?' or '!'.\n   - If the sentence contains '?' or '!', it further splits the sentence by these delimiters to handle multiple sentences within one period-separated segment.\n     - It first splits by '?' and then iterates through each part.\n     - Each part is further split by '!' and iterates through sub-parts.\n   - For each sub-part, it checks if the stripped version of the sub-part starts with \"I \". If true, `boredom_count` is incremented.\n\n4. **Handling Sentences Without Delimiters**:\n   - If a sentence does not contain '?' or '!', it directly checks if the stripped version of the sentence starts with \"I \".\n   - If true, `boredom_count` is incremented.\n\n5. **Return Result**: The function returns the total count of boredoms found in the input string `S`.\n\nThis approach ensures that all possible sentences are checked for starting with \"I\", regardless of whether they are separated by '.', '?', or '!'."}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Check if one number is the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n    \n    return false;\n}\n", "py_code": "def any_int(a: float, b: float, c: float) -> bool:\n    # Check if all numbers are integers\n    if int(a) != a or int(b) != b or int(c) != c:\n        return False\n    \n    # Check if one number is the sum of the other two\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    \n    return False\n```\n\n", "py_summary": "The Python function `any_int` takes three floating-point numbers as input and returns a boolean value based on specific conditions:\n\n1. **Check if all numbers are integers**: The function first checks whether each of the provided numbers is an integer by comparing them to their integer counterparts (`int(a)`, `int(b)`, `int(c)`). If any number is not equal to its integer counterpart, it means that at least one of the numbers has a fractional part, and thus the function returns `False`.\n\n2. **Check if one number is the sum of the other two**: If all three numbers are integers (as determined in the first step), the function then checks whether any one of the numbers equals the sum of the other two:\n   - It verifies if `a == b + c`\n   - Or, if `b == a + c`\n   - Or, if `c == a + b`\n\nIf any of these conditions are met, the function returns `True`. If none of the conditions are satisfied, it returns `False`.\n\nThis ensures that the function only returns `True` when one number is exactly equal to the sum of the other two and all numbers are integers."}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha(), toupper(), tolower()\n\nusing namespace std;\n\n// Function to encode the message as per the given rules\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    char shifted_vowels[] = {'c', 'g', 'k', 'q', 'w', // lowercase\n                              'C', 'G', 'K', 'Q', 'W'}; // uppercase\n    \n    for (size_t i = 0; i < message.length(); ++i) {\n        char& ch = message[i];\n        \n        // Swap case of the character\n        if (islower(ch)) {\n            ch = toupper(ch);\n        } else {\n            ch = tolower(ch);\n        }\n        \n        // Shift vowels by 2 places ahead\n        size_t vowel_index = vowels.find(ch);\n        if (vowel_index != string::npos) {\n            ch = shifted_vowels[vowel_index];\n        }\n    }\n\n    return message;\n}\n\n", "py_code": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    shifted_vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n                       'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = ''\n    \n    for char in message:\n        if char.isalpha():\n            # Swap case\n            new_char = char.swapcase()\n            \n            # Shift vowels by 2 places ahead\n            if new_char in vowels:\n                new_char = shifted_vowels[new_char]\n                \n            encoded_message += new_char\n        else:\n            encoded_message += char\n    \n    return encoded_message\n```\n\n", "py_summary": "The Python code defines a function `encode` that takes a string message as input and encodes it according to specific rules: swapping the case of all letters and replacing vowels with the letter that appears two places ahead in the English alphabet.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - A dictionary `shifted_vowels` is defined, which maps each vowel (both lowercase and uppercase) to its corresponding shifted character.\n   \n2. **Iterating through the message**:\n   - The function iterates over each character in the input string `message`.\n   \n3. **Swapping case**:\n   - For each alphabetic character, it swaps the case using the `swapcase()` method.\n\n4. **Shifting vowels**:\n   - If the swapped character is a vowel (checked against the `vowels` set), it replaces the vowel with its corresponding shifted character from the `shifted_vowels` dictionary.\n   \n5. **Building the encoded message**:\n   - The transformed character is appended to the `encoded_message`.\n\n6. **Returning the result**:\n   - Finally, the function returns the constructed `encoded_message`.\n\nThis approach ensures that all alphabetic characters have their cases swapped and vowels are correctly shifted as per the problem requirements.\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n\n    if (max_prime == -1) return 0;\n\n    return sum_of_digits(max_prime);\n}\n\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = -1\n    for num in lst:\n        if is_prime(num):\n            if num > max_prime:\n                max_prime = num\n    \n    if max_prime == -1:\n        return 0\n    \n    return sum_of_digits(max_prime)\n```\n\n", "py_summary": "The Python code defines a function `skjkasdkd` that takes a list of integers and returns the sum of the digits of the largest prime number in the list. Here's a detailed breakdown:\n\n1. **Helper Function: `is_prime(n)`**\n   - This function checks if a given integer `n` is a prime number.\n   - It first handles edge cases where `n <= 1`, returning `False`.\n   - Then, it iterates from 2 to the square root of `n` (inclusive) to check for any divisors. If any divisor is found, it returns `False`. Otherwise, it returns `True`.\n\n2. **Helper Function: `sum_of_digits(n)`**\n   - This function calculates and returns the sum of the digits of an integer `n`.\n   - It converts the number to a string, iterates over each character (digit), converts them back to integers, and sums them up.\n\n3. **Main Function: `skjkasdkd(lst)`**\n   - The main function initializes `max_prime` to `-1`, which will store the largest prime number found in the list.\n   - It iterates through each element in the input list `lst`.\n     - For each element, it checks if the element is a prime number using the `is_prime` helper function.\n     - If the element is a prime and greater than the current value of `max_prime`, it updates `max_prime`.\n   - After iterating through all elements, if no prime numbers were found (`max_prime` remains `-1`), the function returns 0.\n   - Otherwise, it calculates the sum of digits of `max_prime` using the `sum_of_digits` helper function and returns this value.\n\nThis approach ensures that we correctly identify the largest prime number in the list and compute the desired digit sum efficiently."}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto &pair : dict) {\n        const std::string &key = pair.first;\n\n        // Check if the key is not in lowercase\n        if (!std::all_of(key.begin(), key.end(), ::islower)) {\n            all_lower = false;\n        }\n\n        // Check if the key is not in uppercase\n        if (!std::all_of(key.begin(), key.end(), ::isupper)) {\n            all_upper = false;\n        }\n\n        // If both flags are false, return false early\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    // Return true if either flag is still true\n    return all_lower || all_upper;\n}\n", "py_code": "from typing import Dict\n\ndef check_dict_case(dictionary: Dict[str, str]) -> bool:\n    if not dictionary:\n        return False\n    \n    all_lower = True\n    all_upper = True\n    \n    for key in dictionary.keys():\n        if not key.islower():\n            all_lower = False\n        if not key.isupper():\n            all_upper = False\n        \n        if not all_lower and not all_upper:\n            return False\n    \n    return all_lower or all_upper\n```\n\n", "py_summary": "The Python function `check_dict_case` checks whether a given dictionary has keys that are either all in lowercase or all in uppercase. Here's an analysis of how it works:\n\n1. **Check if Dictionary is Empty**: The function first checks if the input dictionary is empty. If it is, the function returns `False`.\n\n2. **Initialize Flags**: Two boolean flags, `all_lower` and `all_upper`, are initialized to `True`. These flags will be used to track whether all keys in the dictionary are lowercase or uppercase.\n\n3. **Iterate Through Keys**: The function iterates through each key in the dictionary:\n   - For each key, it checks if the key is not in lowercase using `not key.islower()`, and sets `all_lower` to `False` if this condition is true.\n   - Similarly, it checks if the key is not in uppercase using `not key.isupper()`, and sets `all_upper` to `False` if this condition is true.\n\n4. **Early Exit**: If both flags are set to `False` during iteration (indicating that keys are neither all lowercase nor all uppercase), the function returns `False`.\n\n5. **Return Result**: After iterating through all keys, the function checks whether either `all_lower` or `all_upper` is still `True`. If one of them is true, it means all keys in the dictionary are consistently in either lower case or upper case, and the function returns `True`.\n\nThis approach ensures that the function correctly identifies dictionaries with uniformly cased keys while returning `False` for mixed-case keys or empty dictionaries.\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count up to n and return prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n", "py_code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for number in range(2, n):\n        if is_prime(number):\n            primes.append(number)\n    return primes\n```\n\n", "py_summary": "The Python code defines a function `count_up_to` that takes an integer `n` and returns a list of prime numbers less than `n`. The solution involves two main parts:\n\n1. **Prime Checking Function (`is_prime`)**:\n   - This helper function checks if a given number is prime.\n   - It first handles the base case where numbers less than or equal to 1 are not considered prime.\n   - Then, it iterates from 2 up to the square root of the number (inclusive) to check for any divisors. If any divisor is found, the function returns `False`. Otherwise, it returns `True`.\n\n2. **Main Function (`count_up_to`)**:\n   - This function initializes an empty list called `primes`.\n   - It iterates through all integers from 2 up to (but not including) `n`.\n   - For each integer, it calls the `is_prime` function to check if the number is prime.\n   - If a number is determined to be prime, it appends that number to the `primes` list.\n   - Finally, the function returns the list of primes.\n\nThis approach ensures that all numbers less than `n` are checked for primality and only those that pass the check are included in the result."}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers using modulo operation\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Calculate and return the product of the unit digits\n    return unit_digit_a * unit_digit_b;\n}\n", "py_code": "def multiply(a: int, b: int) -> int:\n    # Extract the unit digit of both numbers\n    unit_digit_a = abs(a % 10)\n    unit_digit_b = abs(b % 10)\n    \n    # Calculate and return the product of the unit digits\n    return unit_digit_a * unit_digit_b\n```\n\n", "py_summary": "The Python function `multiply` takes two integers as input and returns the product of their unit digits. Here's a detailed analysis:\n\n1. **Extract Unit Digits**:\n   - The unit digit of an integer is obtained by taking the remainder when divided by 10 (`a % 10` for `a` and `b % 10` for `b`). \n   - To handle negative numbers correctly, we use the absolute value function `abs()` to ensure that the unit digits are always non-negative.\n\n2. **Calculate Product**:\n   - The product of the unit digits is computed by multiplying the two extracted unit digits (`unit_digit_a * unit_digit_b`).\n\n3. **Return Result**:\n   - The result of the multiplication is returned as an integer.\n\nThis approach ensures that the function works correctly for both positive and negative integers, as well as zero values, since `abs()` will handle all cases appropriately.\n\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n#include <algorithm>\n\nint count_upper(std::string s) {\n    // Define uppercase vowels\n    const std::string vowels = \"AEIOU\";\n    int count = 0;\n\n    // Iterate over even indices\n    for (size_t i = 0; i < s.length(); i += 2) {\n        // Check if the character at index i is an uppercase vowel\n        if (vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    count = 0\n    for i in range(0, len(s), 2):  # Iterate over even indices\n        if s[i] in vowels:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python function `count_upper` is designed to count the number of uppercase vowels at even indices in a given string `s`. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - The variable `vowels` is initialized with the string `\"AEIOU\"`, which contains all uppercase vowels.\n   - The variable `count` is initialized to 0, which will be used to keep track of the number of uppercase vowels found at even indices.\n\n2. **Iteration over Even Indices**:\n   - A for loop iterates over the indices of the string `s` starting from index 0 (the first character) and increments by 2 in each iteration. This ensures that only even indices are processed.\n   \n3. **Checking for Uppercase Vowels**:\n   - For each character at an even index, the function checks if it is one of the uppercase vowels by using the `in` operator to check membership in the string `vowels`.\n   - If the character is a vowel, the count variable is incremented.\n\n4. **Return Result**:\n   - After iterating through all even indices, the function returns the value of `count`, which represents the total number of uppercase vowels found at even indices.\n\nThis approach ensures that only characters at even positions are considered and efficiently counts how many of those characters are uppercase vowels.\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nint closest_integer(std::string value) {\n    // Convert string to float\n    double num = std::stod(value);\n    \n    // Determine floor and ceiling values\n    int floor_value = static_cast<int>(num);\n    int ceil_value;\n    if (num > 0) {\n        ceil_value = floor_value + 1;\n    } else {\n        ceil_value = floor_value - 1;\n    }\n\n    // Calculate differences to floor and ceiling values\n    double diff_floor = std::abs(num - floor_value);\n    double diff_ceil = std::abs(num - ceil_value);\n\n    // Determine the closest integer, rounding away from zero in case of a tie\n    if (diff_floor < diff_ceil) {\n        return floor_value;\n    } else if (diff_floor > diff_ceil) {\n        return ceil_value;\n    } else {\n        return num > 0 ? ceil_value : floor_value;\n    }\n}\n\n", "py_code": "def closest_integer(value):\n    num = float(value)\n    floor_value = int(num)\n    ceil_value = floor_value + 1 if num > 0 else floor_value - 1\n    \n    if abs(num - floor_value) < abs(num - ceil_value):\n        return floor_value\n    elif abs(num - floor_value) > abs(num - ceil_value):\n        return ceil_value\n    else:\n        return ceil_value if num > 0 else floor_value\n```\n\n", "py_summary": "The Python function `closest_integer` takes a string input representing a number and returns the closest integer to that number, rounding away from zero in case of a tie.\n\nHere's a detailed breakdown:\n\n1. **Convert Input String to Float**: The input string is converted to a floating-point number using `float(value)`.\n\n2. **Determine Floor and Ceiling Values**:\n   - `floor_value` is the integer part of the float, obtained by casting the float to an integer (`int(num)`).\n   - If the number is positive, `ceil_value` is set to `floor_value + 1`.\n   - If the number is negative, `ceil_value` is set to `floor_value - 1`.\n\n3. **Calculate Differences**:\n   - The function calculates the absolute differences between the float and both the floor value (`abs(num - floor_value)`) and the ceiling value (`abs(num - ceil_value)`).\n\n4. **Determine Closest Integer**:\n   - If the difference to `floor_value` is smaller, return `floor_value`.\n   - If the difference to `ceil_value` is smaller, return `ceil_value`.\n   - If both differences are equal (i.e., the number is equidistant from two integers), round away from zero by returning `ceil_value` for positive numbers and `floor_value` for negative numbers.\n\nThis ensures that the function correctly rounds the input value to the nearest integer, with ties broken by rounding away from zero."}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current_stones = n;\n\n    for (int level = 0; level < n; ++level) {\n        pile.push_back(current_stones);\n        if (n % 2 == 0) {\n            // If n is even, the next number should be the next even number\n            current_stones += 2;\n        } else {\n            // If n is odd, the next number should be the next odd number\n            current_stones += 2;  // Adding 2 to an odd number results in the next odd number\n        }\n    }\n\n    return pile;\n}\n", "py_code": "def make_a_pile(n):\n    pile = []\n    current_stones = n\n    for level in range(n):\n        pile.append(current_stones)\n        if n % 2 == 0:\n            current_stones += 2  # next even number\n        else:\n            current_stones += 2  # next odd number, since adding 2 to an odd number results in the next odd number\n    return pile\n```\n\n", "py_summary": "The Python function `make_a_pile` generates a vector representing the number of stones at each level for a given integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - An empty list `pile` is created to store the number of stones in each level.\n   - The variable `current_stones` is initialized with the value of `n`, representing the number of stones in the first level.\n\n2. **Loop through levels**:\n   - A loop runs from 0 to `n-1`, iterating over each level of the pile.\n   - For each iteration, the current number of stones (`current_stones`) is added to the `pile`.\n\n3. **Determine next stone count**:\n   - The function checks if `n` is even or odd using the condition `if n % 2 == 0`.\n     - If `n` is even, it adds 2 to `current_stones` to get the next even number.\n     - If `n` is odd, adding 2 to an odd number results in the next odd number.\n\n4. **Return result**:\n   - After iterating through all levels, the function returns the list `pile`, which contains the number of stones for each level.\n\nThis approach ensures that the pile starts with `n` stones and follows the rule of incrementing by 2 (either to the next even or odd number based on the initial parity) for subsequent levels."}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces for uniformity in splitting\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Split the string by spaces and store the result in a vector of strings\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n", "py_code": "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    # Replace commas with spaces for uniformity in splitting\n    s = s.replace(',', ' ')\n    # Split the string by spaces and return as a list of strings\n    words = s.split()\n    return words\n```\n\n", "py_summary": "The Python code defines a function `words_string` that takes a single string `s` as input and returns a vector (list in Python) of strings representing the individual words from the input string.\n\n1. **Replace Commas with Spaces**: The first line of the function replaces all commas in the input string with spaces to ensure uniformity when splitting the string into words.\n2. **Split the String**: The `split()` method is used to split the modified string by any whitespace (including spaces and tabs), which effectively splits the string into individual words based on spaces.\n3. **Return Result**: Finally, the function returns the list of words.\n\nThis approach ensures that both commas and spaces are treated as delimiters for splitting the input string into separate words.\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the larger number and work backwards\n    for (int num = y; num >= x; --num) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n\n    return -1;\n}\n", "py_code": "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    \n    # Start from the larger number and work backwards\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    return -1\n```\n\n", "py_summary": "The Python function `choose_num` takes two positive integers `x` and `y` as input and returns the largest even integer within the inclusive range `[x, y]`. If no such number exists in the given range, it returns `-1`.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initial Check**: The function first checks if `x` is greater than `y`. If this condition is true, it means there are no numbers in the range `[x, y]`, and thus it immediately returns `-1`.\n\n2. **Iterate Backwards from `y` to `x`**: \n   - The function starts iterating from `y` down to `x`.\n   - It checks each number to see if it is even (i.e., divisible by 2).\n   \n3. **Return the First Even Number Found**:\n   - As soon as an even number is found during iteration, the function returns that number.\n\n4. **Return `-1` if No Even Number is Found**:\n   - If no even numbers are found within the range `[x, y]`, the loop completes without returning any value, and the function then returns `-1`.\n\nThis approach ensures that the largest even number in the given range is efficiently identified by starting from the upper bound `y` and moving downwards."}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    double average = static_cast<double>(sum) / (m - n + 1);\n    int rounded_average = floor(average);\n\n    if (rounded_average == 0) return \"0\";\n\n    string binary_representation = \"\";\n    while (rounded_average > 0) {\n        binary_representation = to_string(rounded_average % 2) + binary_representation;\n        rounded_average /= 2;\n    }\n\n    return binary_representation;\n}\n\n", "py_code": "def rounded_avg(n, m):\n    if n > m:\n        return \"-1\"\n    \n    # Calculate the sum of integers from n to m using arithmetic series formula\n    total_sum = (m - n + 1) * (n + m) // 2\n    \n    # Calculate the average and round it down to the nearest integer\n    rounded_avg = total_sum // (m - n + 1)\n    \n    # Convert the rounded average to binary\n    return bin(rounded_avg)[2:]\n```\n\n", "py_summary": "The Python function `rounded_avg` calculates the average of integers from `n` to `m`, rounds it down to the nearest integer, and converts that integer to its binary representation. Here's a detailed breakdown:\n\n1. **Initial Check**: The function first checks if `n` is greater than `m`. If this condition is true, it returns `-1`.\n\n2. **Sum Calculation**: \n   - It calculates the sum of integers from `n` to `m` using the arithmetic series formula: \n     \\[\n     \\text{sum} = (m - n + 1) \\times \\frac{(n + m)}{2}\n     \\]\n   - This is implemented in Python as:\n     ```python\n     total_sum = (m - n + 1) * (n + m) // 2\n     ```\n\n3. **Average Calculation**:\n   - The average of the integers from `n` to `m` is calculated by dividing the sum by the number of integers in this range, which is `(m - n + 1)`:\n     ```python\n     rounded_avg = total_sum // (m - n + 1)\n     ```\n   - This division uses integer division (`//`) to round down to the nearest integer.\n\n4. **Binary Conversion**:\n   - The function converts the rounded average to its binary representation using Python's built-in `bin` function, which returns a string prefixed with '0b'. To remove this prefix and get only the binary digits, it slices the string starting from index 2:\n     ```python\n     return bin(rounded_avg)[2:]\n     ```\n\nThis approach ensures that the function correctly handles the constraints and requirements of the problem statement."}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number has any even digit\nbool has_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0)\n            return true;\n        n /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Iterate through each number in the input vector\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    def has_even_digit(n):\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n //= 10\n        return False\n    \n    result = []\n    for num in x:\n        if not has_even_digit(num):\n            result.append(num)\n    \n    result.sort()\n    return result\n```\n\n", "py_summary": "The Python code defines a function `unique_digits` that takes a list of positive integers and returns a sorted list of all elements that do not contain any even digits.\n\n1. **Helper Function**: The helper function `has_even_digit` checks if a given number contains any even digit.\n   - It iterates through each digit of the number by repeatedly dividing it by 10 and checking the remainder (last digit).\n   - If an even digit is found, it returns `True`.\n   - If no even digits are found after checking all digits, it returns `False`.\n\n2. **Main Function**:\n   - Initializes an empty list `result` to store numbers that do not contain any even digits.\n   - Iterates through each number in the input list `x`.\n   - For each number, calls the helper function `has_even_digit`. If the result is `False`, it means the number does not have any even digits and thus adds this number to the `result` list.\n   - After processing all numbers, sorts the `result` list in increasing order.\n   - Returns the sorted `result` list.\n\nThis approach ensures that only numbers without even digits are included in the final result, and those numbers are returned in a sorted manner."}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Define a map to store digit names\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the input array to include only numbers between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array in ascending order\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array to get descending order\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map each integer to its corresponding word using digit_names map\n    vector<string> result;\n    for (int num : filtered_arr) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def by_length(arr):\n    # Define a mapping from digits 1-9 to their corresponding names\n    digit_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter out numbers that are not between 1 and 9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Convert each number to its corresponding name using the mapping\n    result = [digit_names[num] for num in reversed_arr if num in digit_names]\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `by_length` that processes an input list of integers and returns a new list with specific transformations applied:\n\n1. **Filtering**: The function first filters out any numbers in the input list that are not between 1 and 9 inclusive.\n2. **Sorting**: It then sorts the filtered list in ascending order.\n3. **Reversing**: After sorting, it reverses the sorted list to get a descending order of the valid integers.\n4. **Mapping**: Finally, it maps each integer (from 1 to 9) to its corresponding word representation using a predefined dictionary `digit_names`.\n\nHere's a detailed breakdown:\n\n- **Filtering**:\n    ```python\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    ```\n    This line creates a new list containing only the integers from 1 to 9.\n\n- **Sorting**:\n    ```python\n    sorted_arr = sorted(filtered_arr)\n    ```\n    The `sorted` function sorts the filtered array in ascending order.\n\n- **Reversing**:\n    ```python\n    reversed_arr = list(reversed(sorted_arr))\n    ```\n    The `reversed` function reverses the sorted array, and converting it to a list ensures that we get a new list with elements in descending order.\n\n- **Mapping**:\n    ```python\n    result = [digit_names[num] for num in reversed_arr if num in digit_names]\n    ```\n    This line maps each integer from 1 to 9 in the reversed array to its corresponding word using the `digit_names` dictionary. The condition `if num in digit_names` ensures that only valid keys are mapped.\n\nThe function then returns the resulting list of strings representing the numbers as words in descending order.\n\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\n// Helper function to calculate factorial of i\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate the sum of numbers from 1 to i\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0)\n            result[i - 1] = factorial(i); // Even index, use factorial\n        else\n            result[i - 1] = sum_to_i(i); // Odd index, use sum\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef factorial(i: int) -> int:\n    if i == 0 or i == 1:\n        return 1\n    result = 1\n    for j in range(2, i + 1):\n        result *= j\n    return result\n\ndef sum_to_i(i: int) -> int:\n    return (i * (i + 1)) // 2\n\ndef f(n: int) -> List[int]:\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_to_i(i))\n    return result\n```\n\n", "py_summary": "The Python code defines a function `f` that takes an integer `n` as input and returns a vector (list) of size `n`. The value at each index `i` in this list is determined based on whether `i` is even or odd:\n\n1. **Factorial Calculation**:\n   - A helper function `factorial(i)` calculates the factorial of an integer `i`, which is the product of all positive integers up to `i`.\n   - The base case for the factorial function handles `0! = 1` and `1! = 1`.\n\n2. **Sum Calculation**:\n   - Another helper function `sum_to_i(i)` calculates the sum of numbers from `1` to `i`, which can be computed using the formula `(i * (i + 1)) // 2`.\n\n3. **Main Function**:\n   - The main function `f(n)` initializes an empty list `result`.\n   - It iterates over each index `i` from `1` to `n`. For each index, it checks if `i` is even or odd.\n     - If `i` is even, the factorial of `i` is appended to the result list using the `factorial(i)` function.\n     - If `i` is odd, the sum of numbers from `1` to `i` is appended to the result list using the `sum_to_i(i)` function.\n\nThe final list `result` contains the appropriate values for each index based on whether the index is even or odd and is returned by the function.\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str_num = std::to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n\n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return [even_count, odd_count]\n```\n\n", "py_summary": "The Python code defines a function `even_odd_palindrome` that takes an integer `n` and returns a list containing the counts of even and odd palindromic integers within the range from 1 to `n`, inclusive.\n\nHere's a breakdown of how the function works:\n\n1. **Helper Function**: The helper function `is_palindrome(num)` checks if a given number is a palindrome by converting it to a string, reversing the string, and comparing it with the original string representation.\n   \n2. **Initialization**: Two counters, `even_count` and `odd_count`, are initialized to zero. These will keep track of the number of even and odd palindromic integers found.\n\n3. **Iteration**: The function iterates through all numbers from 1 to `n`. For each number:\n   - It checks if the number is a palindrome using the `is_palindrome` helper function.\n   - If it is a palindrome, it increments either `even_count` or `odd_count` based on whether the number is even or odd.\n\n4. **Return Value**: Finally, the function returns a list containing the counts of even and odd palindromic integers in that order.\n\nThis approach ensures that all numbers within the specified range are checked for being palindromes and their parity (even/odd) is correctly counted."}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of signed digits for a given integer.\nint sum_of_digits(int num) {\n    if (num == 0)\n        return 0;\n\n    int digit_sum = 0;\n    bool is_negative = num < 0;\n\n    while (num != 0) {\n        int digit = abs(num % 10);\n        if (is_negative && digit > 0)\n            digit *= -1; // Adjust the first signed digit for negative numbers\n        digit_sum += digit;\n        num /= 10;\n    }\n\n    return digit_sum;\n}\n\n// Main function to count elements with a sum of digits greater than zero.\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (const auto& number : n) {\n        if (sum_of_digits(number) > 0)\n            count++;\n    }\n\n    return count;\n}\n", "py_code": "from typing import List\n\ndef count_nums(n: List[int]) -> int:\n    def sum_of_digits(num):\n        if num == 0:\n            return 0\n        is_negative = num < 0\n        digit_sum = 0\n        while num != 0:\n            digit = abs(num % 10)\n            if is_negative:\n                digit *= -1\n            digit_sum += digit\n            num //= 10\n        return digit_sum\n    \n    count = 0\n    for number in n:\n        if sum_of_digits(number) > 0:\n            count += 1\n            \n    return count\n```\n\n", "py_summary": "The Python code defines a function `count_nums` that takes a list of integers and returns the number of elements whose sum of digits is greater than zero. Here's a detailed analysis:\n\n1. **Helper Function (`sum_of_digits`)**:\n   - This helper function calculates the sum of signed digits for a given integer.\n   - It checks if the input number `num` is zero, in which case it returns 0 immediately since the sum of digits of zero is zero.\n   - The variable `is_negative` determines whether the number is negative or not.\n   - A loop runs while `num` is not zero. In each iteration:\n     - It calculates the absolute value of the last digit using `abs(num % 10)`.\n     - If the number is negative, it multiplies the digit by `-1` to account for the signed nature of digits in negative numbers.\n     - The digit is added to `digit_sum`, and `num` is updated by removing the last digit (`num //= 10`).\n\n2. **Main Function (`count_nums`)**:\n   - Initializes a counter variable `count` to zero.\n   - Iterates through each number in the input list `n`.\n   - For each number, it calls the helper function `sum_of_digits` and checks if the returned sum is greater than 0.\n   - If the condition is met, increments the `count`.\n\n3. **Return Statement**:\n   - Returns the final count of numbers whose sum of digits is greater than zero.\n\nThis approach ensures that each number in the list is processed correctly to determine whether its digit sum meets the specified criteria."}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {  // Check if the vector is empty\n        return true;\n    }\n    \n    int n = arr.size();\n    int break_point = -1;  // Initialize break point index\n    \n    // Find the index where the sequence breaks (i.e., arr[i] < arr[i-1])\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no break point is found, return true\n    if (break_point == -1) {\n        return true;\n    }\n\n    // Check if the vector can be considered a valid rotation of a sorted array\n    for (int j = break_point + 1; j < n; ++j) {\n        if (arr[j] < arr[(j - 1) % n]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "py_code": "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    \n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            break\n    \n    # Find the index where the array should start to be considered as a rotated sorted array\n    start_index = i % n\n\n    # Check if the array is indeed a rotated version of a sorted array\n    for j in range(1, n):\n        if arr[(start_index + j) % n] < arr[(start_index + j - 1) % n]:\n            return False\n    \n    return True\n```\n\n", "py_summary": "The Python function `move_one_ball` checks if a given vector can be sorted in non-decreasing order by performing right shift operations. Here's an analysis of how it works:\n\n1. **Initial Check for Empty Vector**:\n   - If the input vector is empty, the function immediately returns `True`.\n\n2. **Identify Break Point**:\n   - The function iterates through the array to find the first index where a number is smaller than its predecessor (i.e., `arr[i] < arr[i-1]`). This identifies the point where the sorted sequence would be broken if it were rotated.\n\n3. **Determine Start Index for Rotated Array**:\n   - The break point index (`i`) is used to determine the starting index of the array when considered as a rotated version of a sorted array. If `i` is 0, it means the array is already in non-decreasing order and no rotation is needed.\n\n4. **Validate Rotated Sorted Array**:\n   - The function then checks if the array can be considered a valid rotation of a sorted array by iterating through the elements starting from the identified start index.\n   - For each element, it verifies that the next element (considering circular indexing) is not smaller than the previous one. If any such pair violates this condition, the function returns `False`.\n\n5. **Return Result**:\n   - If no violations are found during the validation step, the function returns `True`, indicating that the array can be sorted by right shifts.\n\nThis approach ensures that the function correctly identifies whether a given vector can be transformed into a non-decreasing order through rotations and handles edge cases such as empty vectors."}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of odd elements in lst1\n    int odd_count_lst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++odd_count_lst1;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    int even_count_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    // Check if it's possible to exchange elements to make all elements in lst1 even\n    if (odd_count_lst1 > even_count_lst2) {\n        return \"NO\";\n    } else {\n        return \"YES\";\n    }\n}\n", "py_code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_in_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_count_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n\n    # If there are more odd numbers in lst1 than even numbers in lst2, it's impossible to exchange\n    if odd_count_in_lst1 > even_count_in_lst2:\n        return \"NO\"\n    \n    # If the number of odd elements in lst1 is less than or equal to the number of even elements in lst2,\n    # then it's possible to make all elements in lst1 even by exchanging.\n    return \"YES\"\n```\n", "py_summary": "The Python code defines a function `exchange` that takes two lists of integers (`lst1` and `lst2`) as input and returns a string indicating whether it is possible to exchange elements between them such that all elements in `lst1` become even.\n\nHere's the step-by-step analysis:\n\n1. **Count Odd Elements in lst1**: The function first counts the number of odd numbers in `lst1`. This is done using a generator expression inside the `sum` function, which iterates through each element in `lst1` and checks if it is odd (`num % 2 != 0`). If an element is odd, it contributes to the count.\n\n2. **Count Even Elements in lst2**: Similarly, the function counts the number of even numbers in `lst2`. This is done using another generator expression inside the `sum` function, which iterates through each element in `lst2` and checks if it is even (`num % 2 == 0`). If an element is even, it contributes to the count.\n\n3. **Check Feasibility of Exchange**: The function then compares the counts:\n   - If there are more odd numbers in `lst1` than even numbers in `lst2`, it returns `\"NO\"`. This means that there aren't enough even numbers in `lst2` to exchange with all the odd numbers in `lst1`.\n   - Otherwise, if the number of odd elements in `lst1` is less than or equal to the number of even elements in `lst2`, it returns `\"YES\"`. This indicates that it is possible to make all elements in `lst1` even by exchanging.\n\nThis approach ensures that we only need to count and compare the necessary elements, making the solution efficient."}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    if (test.empty()) {\n        return {};\n    }\n\n    map<char, int> char_count;\n    int max_count = 0;\n\n    // Split the string into individual characters\n    stringstream ss(test);\n    char current_char;\n    while (ss >> current_char) {\n        char_count[current_char]++;\n        max_count = max(max_count, char_count[current_char]);\n    }\n\n    map<char, int> result;\n    for (const auto& entry : char_count) {\n        if (entry.second == max_count) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n", "py_code": "from collections import defaultdict\n\ndef histogram(test):\n    if not test:\n        return {}\n    \n    char_count = defaultdict(int)\n    max_count = 0\n    \n    for char in test.split():\n        char_count[char] += 1\n        max_count = max(max_count, char_count[char])\n    \n    result = {char: count for char, count in char_count.items() if count == max_count}\n    return result\n```\n\n", "py_summary": "The Python code defines a function `histogram` that takes a string as input and returns a dictionary containing characters with their highest frequency of occurrence in the string. Here's a detailed breakdown:\n\n1. **Input Validation**: The function first checks if the input string is empty. If it is, an empty dictionary is returned.\n\n2. **Character Counting**:\n   - A `defaultdict` named `char_count` is initialized to keep track of the frequency of each character.\n   - `max_count` is initialized to 0 to keep track of the maximum count of any character encountered so far.\n   \n3. **Splitting and Counting**:\n   - The input string is split into individual characters using `.split()`.\n   - For each character in the split list, its frequency in `char_count` is incremented by 1.\n   - The `max_count` variable is updated to keep track of the highest frequency encountered.\n\n4. **Result Construction**:\n   - A dictionary comprehension is used to create a result dictionary containing only those characters whose count matches `max_count`.\n\n5. **Return Result**: Finally, the function returns this result dictionary.\n\nThis approach ensures that all characters with the maximum frequency are included in the output, and if multiple characters have the same highest frequency, they will all be returned.\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in `s` that are present in `c`\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome = true;\n    for (size_t i = 0; i < result.length() / 2; ++i) {\n        if (result[i] != result[result.length() - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    // Return the result string and whether it is a palindrome\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n", "py_code": "def reverse_delete(s: str, c: str) -> list:\n    # Remove all characters in `s` that are present in `c`\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return [result, \"True\" if is_palindrome else \"False\"]\n```\n\n", "py_summary": "The Python code defines a function `reverse_delete` that takes two strings, `s` and `c`, as input and returns a list containing the modified string and whether it is a palindrome.\n\n1. **Remove Characters**: The function first creates a new string by filtering out all characters in `s` that are present in `c`. This is done using a list comprehension:\n   ```python\n   result = ''.join([char for char in s if char not in c])\n   ```\n   Here, each character in `s` is checked to see if it is not in `c`, and only those characters are included in the resulting string.\n\n2. **Check Palindrome**: The function then checks whether the resulting string is a palindrome by comparing the string with its reverse:\n   ```python\n   is_palindrome = result == result[::-1]\n   ```\n   If the string reads the same backward as forward, `is_palindrome` will be `True`; otherwise, it will be `False`.\n\n3. **Return Result**: Finally, the function returns a list containing the modified string and a boolean value converted to a string (\"True\" or \"False\"):\n   ```python\n   return [result, \"True\" if is_palindrome else \"False\"]\n   ```\n\nThis approach ensures that all characters in `s` that are also present in `c` are removed, and then it checks whether the resulting string is a palindrome.\n\n"}
{"task_id": "CPP/113", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& s : lst) {\n        int count_odd = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count_odd++;\n            }\n        }\n\n        // Generate the formatted output string\n        std::string output_string = \"the number of odd elements \";\n        output_string += std::to_string(count_odd);\n        output_string += \"n the str\";\n        output_string += std::to_string(count_odd);\n        output_string += \"ng \";\n        output_string += std::to_string(count_odd);\n        output_string += \" of the \";\n        output_string += std::to_string(count_odd);\n        output_string += \"nput.\";\n\n        // Append the formatted string to the result vector\n        result.push_back(output_string);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count_odd = sum(1 for char in s if int(char) % 2 != 0)\n        output_string = f'the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.'\n        result.append(output_string)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `odd_count` that takes a list of strings as input and returns a list of formatted strings. Each string in the output indicates the number of odd digits in the corresponding input string.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Initialization**: An empty list `result` is initialized to store the final output strings.\n2. **Iterate through each string**: For each string `s` in the input list `lst`, the following steps are performed:\n   - **Count odd digits**: A generator expression inside the `sum` function counts the number of characters in `s` that represent odd digits (i.e., `int(char) % 2 != 0`). The result is stored in `count_odd`.\n   - **Generate output string**: An f-string is used to format a new string. This string includes placeholders for the count of odd digits (`{count_odd}`), which are inserted at appropriate positions within the template string.\n3. **Append formatted string**: Each generated string is appended to the `result` list.\n4. **Return result**: Finally, the function returns the `result` list containing all the formatted strings.\n\nThis approach ensures that each output string correctly reflects the number of odd digits in its corresponding input string and follows the specified format.\n\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For LLONG_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX;  // Initialize to the maximum possible value for a long long integer\n    long long current_sum = 0;      // Current sub-array sum\n    \n    for (auto num : nums) {\n        // Update current sum by adding the current number or starting fresh from the current number\n        current_sum += num;\n        if (current_sum > num) {\n            current_sum = num;\n        }\n        \n        // Update minimum sum found so far\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n    }\n    \n    return min_sum;\n}\n", "py_code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    min_sum = float('inf')\n    current_sum = 0\n    \n    for num in nums:\n        # Update current sum by adding the current number or starting fresh from the current number\n        current_sum += num\n        if current_sum > num:\n            current_sum = num\n        \n        # Update minimum sum found so far\n        if current_sum < min_sum:\n            min_sum = current_sum\n    \n    return min_sum\n```\n\n", "py_summary": "The Python code defines a function `minSubArraySum` that takes a list of integers as input and returns the minimum sum of any non-empty sub-vector (subarray) within the list.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**:\n   - `min_sum`: This variable is initialized to positive infinity (`float('inf')`). It will store the smallest sub-array sum found during the iteration.\n   - `current_sum`: This variable is used to keep track of the current sub-array sum being considered.\n\n2. **Iteration through the list**:\n   - The function iterates through each element in the input list `nums`.\n   - For each element, it updates `current_sum` by adding the current number or starting fresh from the current number if the current number is smaller than the previous cumulative sum (`current_sum > num`). This ensures that we are considering the smallest possible sub-array ending at the current position.\n\n3. **Updating minimum sum**:\n   - After updating `current_sum`, it checks whether `current_sum` is less than `min_sum`. If so, it updates `min_sum` to `current_sum`.\n\n4. **Return result**:\n   - Finally, after iterating through all elements in the list, the function returns the value of `min_sum`, which represents the minimum sum of any non-empty sub-vector found.\n\nThis approach is based on Kadane's algorithm for finding the maximum subarray sum but adapted to find the minimum subarray sum. The key idea is to maintain a running sum and reset it when necessary to ensure that we are always considering the smallest possible sub-array sums.\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    // Calculate total water units in the grid\n    int total_water_units = 0;\n    for (const auto& row : grid) {\n        total_water_units += std::accumulate(row.begin(), row.end(), 0);\n    }\n\n    // Calculate the number of times buckets need to be lowered\n    return (total_water_units + capacity - 1) / capacity;\n}\n", "py_code": "def max_fill(grid, capacity):\n    total_water_units = sum(sum(row) for row in grid)\n    return (total_water_units + capacity - 1) // capacity\n```\n\n", "py_summary": "The Python function `max_fill` calculates the number of times buckets need to be lowered to empty all the wells given a grid and bucket capacity. Here's an analysis of how it works:\n\n1. **Summing Water Units**: The function first computes the total amount of water in the grid by summing up all the 1s (representing units of water) across all rows.\n   ```python\n   total_water_units = sum(sum(row) for row in grid)\n   ```\n2. **Calculating Bucket Operations**: It then calculates how many times buckets need to be lowered based on the total amount of water and the bucket capacity using integer division:\n   ```python\n   return (total_water_units + capacity - 1) // capacity\n   ```\n   This formula ensures that even if there is a remainder after dividing `total_water_units` by `capacity`, it will still count as an additional operation. For example, if there are 5 units of water and the bucket can hold 2 units, you need to lower the bucket 3 times (2 + 1).\n\nIn summary, this function efficiently computes the total number of bucket operations needed to empty all wells by leveraging integer division and ensuring that any remainder is accounted for.\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n// Helper function to count the number of '1' bits in the binary representation of an integer.\nint count_ones(int n) {\n    return __builtin_popcount(n);  // Use GCC's built-in popcount function for efficiency\n}\n\n// Custom comparator for sorting based on the number of ones and absolute value.\nbool custom_compare(int a, int b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n\n    if (count_a == count_b) {\n        return abs(a) < abs(b);  // Sort by absolute value for equal counts\n    }\n    return count_a < count_b;  // Primary sort by number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Use the custom comparator to sort the array.\n    std::sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n", "py_code": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    def count_ones(n):\n        # Count the number of ones in the binary representation of n.\n        return bin(abs(n)).count('1')\n    \n    # Sort the array based on the number of ones and then by the value itself\n    arr.sort(key=lambda x: (count_ones(x), abs(x)))\n    return arr\n```\n\n", "py_summary": "The Python code defines a function `sort_array` that sorts an array of integers based on two criteria:\n1. The number of ones in their binary representation.\n2. Their decimal value for numbers with the same number of ones.\n\nHere's a detailed breakdown:\n\n1. **Counting Ones**: \n   - A helper function `count_ones(n)` is defined to count the number of '1' bits in the binary representation of an integer `n`. This is done using Python\u2019s built-in `bin` function, which converts an integer to its binary string representation. The `count('1')` method then counts the occurrences of '1' in this string.\n\n2. **Sorting**:\n   - The array `arr` is sorted using the `sort` method with a custom key.\n   - The key is a lambda function that returns a tuple `(count_ones(x), abs(x))`. This ensures that the primary sorting criterion is the number of ones (ascending order) and the secondary criterion is the absolute value of the integer (also in ascending order).\n\n3. **Return**:\n   - After sorting, the sorted array `arr` is returned.\n\nThis approach leverages Python's powerful sorting capabilities to efficiently sort the array based on multiple criteria.\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nstd::vector<std::string> select_words(std::string s, int n) {\n    // Define a set of vowels for easy checking\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Split the string into words and process each word\n    std::vector<std::string> result;\n    std::istringstream iss(s);\n    std::string word;\n\n    while (iss >> word) {\n        int consonants_count = 0;\n        \n        // Count the number of consonants in the current word\n        for (char c : word) {\n            if (isalpha(c) && vowels.find(c) == vowels.end()) {\n                ++consonants_count;\n            }\n        }\n\n        // Check if the count matches n and add to result if it does\n        if (consonants_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    vowels = set('aeiouAEIOU')\n    consonants_count = 0\n    \n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonants_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        \n        if consonants_count == n:\n            result.append(word)\n            \n    return result\n```\n\n", "py_summary": "The Python code defines a function `select_words` that takes a string `s` and an integer `n` as input and returns a list of words from the string that contain exactly `n` consonants. Here's a detailed breakdown of how it works:\n\n1. **Initialization**:\n   - A set of vowels is defined to easily check if a character is a vowel.\n   - The function splits the input string `s` into individual words using the `split()` method.\n\n2. **Processing Each Word**:\n   - For each word in the list of words, it calculates the number of consonants by iterating through each character in the word and checking if it is an alphabetic character that is not a vowel.\n   - The count of such characters (consonants) is stored in `consonants_count`.\n\n3. **Filtering Words**:\n   - If the count of consonants for a word matches the given integer `n`, the word is added to the result list.\n\n4. **Returning Result**:\n   - After processing all words, the function returns the list of words that meet the criteria.\n\nThis approach ensures that only words with exactly `n` consonants are included in the final output, maintaining the order they appear in the input string.\n\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int closest_vowel_index = -1;\n    \n    for (int i = word.length() - 2; i > 0; --i) {  // Start from second last character and move towards first character\n        if (vowels.find(word[i]) == string::npos) {  // Check if the current character is a consonant\n            char next_char = word[i + 1];\n            char prev_char = word[i - 1];\n            \n            if (vowels.find(next_char) != string::npos && vowels.find(prev_char) == string::npos) {\n                closest_vowel_index = i + 1;\n            }\n        }\n    }\n\n    return closest_vowel_index == -1 ? \"\" : string(1, word[closest_vowel_index]);\n}\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    closest_vowel_index = -1\n    \n    for i in range(len(word) - 2, 0, -1):  # Start from the second last character and go to the first character\n        if word[i] not in vowels and word[i + 1] in vowels:\n            if word[i - 1] not in vowels:  # Check if there's a consonant before the vowel\n                closest_vowel_index = i + 1\n                break\n    \n    return \"\" if closest_vowel_index == -1 else word[closest_vowel_index]\n```\n\n", "py_summary": "The Python code defines a function `get_closest_vowel` that takes a string `word` as input and returns the closest vowel standing between two consonants from the right side of the word. Here's an analysis of how the function works:\n\n1. **Initialization**:\n   - A string `vowels` containing all English vowels (both lowercase and uppercase) is defined.\n   - The variable `closest_vowel_index` is initialized to `-1`, which will be used to store the index of the closest vowel found.\n\n2. **Iterate from Right to Left**:\n   - The function iterates through the characters of the word starting from the second last character (index `len(word) - 2`) and moving towards the first character.\n   - For each character at position `i`, it checks if the character is a consonant (`word[i] not in vowels`).\n\n3. **Check for Vowel Between Consonants**:\n   - If the current character is a consonant, it then checks if the next character (at index `i + 1`) is a vowel.\n   - It further checks if the previous character (at index `i - 1`) is also a consonant (`word[i - 1] not in vowels`).\n\n4. **Update Closest Vowel Index**:\n   - If both conditions are met, it means there's a vowel between two consonants, and the function updates `closest_vowel_index` to `i + 1`.\n\n5. **Return Result**:\n   - After iterating through the word, if `closest_vowel_index` is still `-1`, it means no such vowel was found, so an empty string is returned.\n   - Otherwise, the function returns the character at `closest_vowel_index`.\n\nThis approach ensures that we find the closest vowel from the right side of the word that stands between two consonants."}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int open_count = 0;\n    int close_count = 0;\n\n    // Check concatenation in both possible orders\n    for (int order = 0; order < 2; ++order) {\n        bool is_balanced = true;\n        int temp_open = 0;\n        int temp_close = 0;\n\n        // Concatenate strings in the current order\n        string first_str = lst[order];\n        string second_str = lst[(order + 1) % 2];\n\n        for (char c : first_str) {\n            if (c == '(') {\n                ++temp_open;\n            } else {\n                ++temp_close;\n            }\n            if (temp_close > temp_open) {\n                is_balanced = false;\n                break;\n            }\n        }\n\n        // Continue checking the second string\n        for (char c : second_str) {\n            if (c == '(') {\n                ++open_count;\n            } else {\n                ++close_count;\n            }\n            if (temp_close > temp_open) {\n                is_balanced = false;\n                break;\n            }\n        }\n\n        // If the current order results in a balanced string, return \"Yes\"\n        if (is_balanced && open_count == close_count) {\n            return \"Yes\";\n        }\n\n        // Reset counters for the next iteration\n        temp_open = 0;\n        temp_close = 0;\n    }\n\n    // If neither order resulted in a balanced string, return \"No\"\n    return \"No\";\n}\n", "py_code": "def match_parens(lst):\n    # Counters for open and close parentheses in both strings\n    open_count = 0\n    close_count = 0\n    \n    # Iterate through each string in the list\n    for s in lst:\n        temp_open = 0\n        temp_close = 0\n        \n        # Check if concatenating this string first results in a balanced string\n        for char in s:\n            if char == '(':\n                temp_open += 1\n            elif char == ')':\n                temp_close += 1\n            \n            # If at any point the number of closing parentheses exceeds opening ones, it's unbalanced\n            if temp_close > temp_open:\n                break\n        \n        # Check if concatenating this string first results in a balanced string\n        for char in s:\n            if char == '(':\n                open_count += 1\n            elif char == ')':\n                close_count += 1\n            \n            # If at any point the number of closing parentheses exceeds opening ones, it's unbalanced\n            if close_count > open_count:\n                break\n        \n        # Reset counters for next iteration\n        temp_open = 0\n        temp_close = 0\n    \n    # Check if concatenating in reverse order results in a balanced string\n    lst.reverse()\n    for s in lst:\n        temp_open = 0\n        temp_close = 0\n        \n        # Check if concatenating this string first (now second due to reversal) results in a balanced string\n        for char in s:\n            if char == '(':\n                temp_open += 1\n            elif char == ')':\n                temp_close += 1\n            \n            # If at any point the number of closing parentheses exceeds opening ones, it's unbalanced\n            if temp_close > temp_open:\n                break\n        \n        # Check if concatenating this string first (now second due to reversal) results in a balanced string\n        for char in s:\n            if char == '(':\n                open_count += 1\n            elif char == ')':\n                close_count += 1\n            \n            # If at any point the number of closing parentheses exceeds opening ones, it's unbalanced\n            if close_count > open_count:\n                break\n        \n        # Reset counters for next iteration\n        temp_open = 0\n        temp_close = 0\n    \n    # Final check after concatenation in both orders\n    if open_count == close_count:\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "The Python function `match_parens` checks whether it is possible to concatenate two strings of parentheses in such a way that the resulting string is balanced (i.e., every opening parenthesis '(' has a corresponding closing parenthesis ')'). The function takes a list containing exactly two strings as input.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: Two counters, `open_count` and `close_count`, are initialized to zero. These will be used to keep track of the number of open and close parentheses encountered during concatenation checks.\n\n2. **First Order Check**:\n   - The function iterates through each string in the list.\n   - For each string, it performs two checks: one for checking if the string can start with itself (i.e., concatenated first) and another for checking if the entire sequence remains balanced when this string is considered as part of a larger sequence.\n\n3. **Inner Loop**:\n   - The function uses temporary counters `temp_open` and `temp_close` to check if concatenating the current string first results in an unbalanced state at any point.\n   - If during the iteration, the number of closing parentheses exceeds the number of opening ones (`temp_close > temp_open`), it breaks out of the loop as this indicates that the sequence is not balanced.\n\n4. **Second Order Check**:\n   - The list is reversed to check if concatenating in reverse order results in a balanced string.\n   - Similar checks are performed for each string after reversing the list, using the same logic and temporary counters.\n\n5. **Final Balance Check**:\n   - After iterating through both strings in both orders, the function checks whether `open_count` equals `close_count`.\n   - If they are equal, it means that there is a way to concatenate the two strings such that all parentheses are balanced, and the function returns \"Yes\".\n   - Otherwise, if any of the checks indicate an imbalance, or if the final counts do not match, the function returns \"No\".\n\nThis approach ensures that both possible concatenation orders (first string followed by second, and vice versa) are checked for balance."}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements from the sorted array\n    vector<int> top_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Sort these k elements in ascending order\n    sort(top_k_elements.begin(), top_k_elements.end());\n    \n    return top_k_elements;\n}\n", "py_code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    # Sort the array in descending order and take the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return these elements sorted in ascending order\n    return sorted(sorted_arr)\n```\n\n", "py_summary": "The Python code defines a function `maximum` that takes an array of integers and a positive integer `k`, and returns a vector containing the maximum `k` numbers from the input array in ascending order.\n\n1. **Sorting in Descending Order**: The first step is to sort the entire array in descending order using `sorted(arr, reverse=True)`. This ensures that the largest elements are at the beginning of the sorted list.\n2. **Selecting Top k Elements**: After sorting, we take the first `k` elements from this sorted list using slicing `[:k]`.\n3. **Sorting Selected Elements in Ascending Order**: Finally, these `k` selected elements are sorted again in ascending order to meet the requirement of returning a vector with elements in ascending order.\n\nThis approach ensures that the returned vector contains exactly the largest `k` numbers from the input array and is sorted in ascending order as required."}
{"task_id": "CPP/121", "generation": "#include <vector>\n\nint solution(std::vector<int>& lst) {\n    int total_sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {  // Iterate through even positions (0-based index)\n        if (lst[i] % 2 != 0) {  // Check if the element at the current position is odd\n            total_sum += lst[i];\n        }\n    }\n    return total_sum;\n}\n", "py_code": "def solution(lst):\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate through even positions (0-based index)\n        if lst[i] % 2 != 0:  # Check if the element at the current position is odd\n            total_sum += lst[i]\n    return total_sum\n```\n\n", "py_summary": "The Python function `solution` takes a list of integers as input and returns the sum of all odd elements that are in even positions (0-based index). Here's a detailed breakdown:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0, which will store the cumulative sum of the desired elements.\n\n2. **Iteration through Even Positions**:\n   - A for loop iterates over the indices of the list starting from index 0 and increments by 2 in each step (`range(0, len(lst), 2)`). This ensures that only even positions (like 0, 2, 4, etc.) are considered.\n   \n3. **Check if Element is Odd**:\n   - For each element at an even position, the function checks whether it is odd using `lst[i] % 2 != 0`.\n   - If the condition is true, the element is added to `total_sum`.\n\n4. **Return Result**: After iterating through all relevant positions and summing up the appropriate elements, the function returns the final value of `total_sum`.\n\nThis approach ensures that only odd numbers in even positions are considered for the sum calculation.\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <string>\n\nint add_elements(std::vector<int> arr, int k) {\n    int total_sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (std::to_string(arr[i]).length() <= 2) {\n            total_sum += arr[i];\n        }\n    }\n    return total_sum;\n}\n", "py_code": "def add_elements(arr, k):\n    total_sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            total_sum += arr[i]\n    return total_sum\n```\n\n", "py_summary": "The Python function `add_elements` takes a list of integers `arr` and an integer `k`, and returns the sum of elements with at most two digits from the first `k` elements of `arr`. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0, which will store the cumulative sum of valid elements.\n\n2. **Iteration**: A loop runs for each index `i` in the range `[0, k)`, iterating over the first `k` elements of the list `arr`.\n\n3. **Condition Check**: For each element at index `i`, it checks if the length of the string representation of the element is less than or equal to 2 (i.e., the number has at most two digits).\n\n4. **Sum Calculation**: If the condition is satisfied, the element is added to `total_sum`.\n\n5. **Return Result**: After iterating through the first `k` elements, the function returns the accumulated sum stored in `total_sum`.\n\nThis approach ensures that only numbers with at most two digits are included in the final sum.\n\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> sequence;\n    \n    while (n != 1) {\n        sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    sequence.push_back(1);  // Ensure the final number (1) is included\n\n    vector<int> odd_numbers;\n    for (int num : sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n", "py_code": "def get_odd_collatz(n):\n    sequence = []\n    while n != 1:\n        sequence.append(n)\n        if n % 2 == 0:  # If n is even\n            n //= 2\n        else:           # If n is odd\n            n = 3 * n + 1\n    \n    sequence.append(1)  # Add the final number in the Collatz sequence, which is always 1.\n    \n    odd_numbers = [num for num in sequence if num % 2 != 0]\n    return sorted(odd_numbers)\n```\n\n", "py_summary": "The Python function `get_odd_collatz(n)` generates and returns a sorted vector containing the odd numbers from the Collatz sequence starting with the integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**: The function initializes an empty list called `sequence` to store all numbers in the Collatz sequence.\n\n2. **Generating the Sequence**:\n    - A while loop runs until `n` becomes 1.\n    - Inside the loop, the current value of `n` is appended to the `sequence`.\n    - If `n` is even (`n % 2 == 0`), it updates `n` to be half of its previous value (`n //= 2`).\n    - If `n` is odd, it updates `n` to be three times its previous value plus one (`n = 3 * n + 1`).\n\n3. **Adding the Final Number**:\n    - After exiting the loop (when `n == 1`), the number 1 is explicitly added to the sequence since every Collatz sequence ends with 1.\n\n4. **Extracting Odd Numbers**:\n    - A list comprehension filters out only the odd numbers from the `sequence`.\n    - The filtered odd numbers are stored in a new list called `odd_numbers`.\n\n5. **Sorting and Returning**:\n    - Finally, the function returns the sorted list of odd numbers (`sorted(odd_numbers)`).\n\nThis approach ensures that all steps of generating the Collatz sequence and extracting the odd numbers are handled correctly and efficiently.\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nbool valid_date(std::string date) {\n    // Try parsing the date string using the format mm-dd-yyyy\n    std::istringstream ss(date);\n    int month, day, year;\n    \n    if (!(ss >> month >> day >> year)) return false;  // Check for invalid input format\n    \n    // Validate months and days based on the rules provided\n    if (month < 1 || month > 12) return false;\n    \n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n        return false;\n    }\n    else if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    }\n    else if (month == 2 && (day < 1 || day > 29)) {\n        return false;\n    }\n\n    // Check for the correct date format mm-dd-yyyy\n    std::string month_str = std::to_string(month);\n    std::string day_str = std::to_string(day);\n    \n    if (month_str.length() == 1) month_str = \"0\" + month_str;  // Ensure two digits for month\n    if (day_str.length() == 1) day_str = \"0\" + day_str;        // Ensure two digits for day\n    \n    std::string expected_format = month_str + \"-\" + day_str + \"-\" + std::to_string(year);\n    \n    return date == expected_format;\n}\n\n", "py_code": "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    # Define the format for the date string\n    date_format = \"%m-%d-%Y\"\n    \n    try:\n        # Try parsing the date using the specified format\n        parsed_date = datetime.strptime(date, date_format)\n        \n        # Extract month and day from the parsed date\n        month = parsed_date.month\n        day = parsed_date.day\n        \n        # Check if the day is valid for the given month\n        if (month in [1, 3, 5, 7, 8, 10, 12] and not 1 <= day <= 31) or \\\n           (month in [4, 6, 9, 11] and not 1 <= day <= 30) or \\\n           (month == 2 and not 1 <= day <= 29):\n            return False\n        \n        # If parsing is successful and all conditions are met, the date is valid\n        return True\n    \n    except ValueError:\n        # If parsing fails, the date string does not match the format or contains invalid values\n        return False\n```\n\n", "py_summary": "The Python code defines a function `valid_date` that takes a date string as input and returns `True` if the date is valid according to specified rules, otherwise it returns `False`. Here's an analysis of how the function works:\n\n1. **Date Format Validation**: The function uses the `datetime.strptime()` method from the `datetime` module to parse the input date string using the format `%m-%d-%Y`, which corresponds to \"mm-dd-yyyy\". If the date string does not match this format, a `ValueError` is raised.\n\n2. **Month and Day Validation**: After parsing the date successfully, the function extracts the month and day from the parsed date object. It then checks if the day value is within valid ranges for each month:\n   - For months 1 (January), 3 (March), 5 (May), 7 (July), 8 (August), 10 (October), and 12 (December) (months with 31 days), it ensures that `day` is between 1 and 31.\n   - For months 4 (April), 6 (June), 9 (September), and 11 (November) (months with 30 days), it ensures that `day` is between 1 and 30.\n   - For February (month 2), it ensures that `day` is between 1 and 29.\n\n3. **Exception Handling**: If the date string does not match the specified format or contains invalid values, a `ValueError` will be raised during parsing, and the function catches this exception to return `False`.\n\n4. **Return Value**: If all checks pass without raising an exception, the function returns `True`, indicating that the date is valid.\n\nThis approach ensures that the date string adheres to the required format and contains valid month and day values according to standard calendar rules."}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> words;\n    \n    // Split on whitespace first\n    size_t start = 0, end = txt.find(' ');\n    while (end != string::npos) {\n        if (start == end) {\n            start++;\n            end = txt.find(' ', start);\n            continue;\n        }\n        words.push_back(txt.substr(start, end - start));\n        start = end + 1;\n        end = txt.find(' ', start);\n    }\n    words.push_back(txt.substr(start));\n\n    // Check if there is more than one word\n    if (words.size() > 1) {\n        return words;\n    }\n\n    // If no whitespaces, try splitting on commas\n    string single_word = words[0];\n    size_t comma_pos = single_word.find(',');\n    while (comma_pos != string::npos) {\n        words.push_back(single_word.substr(0, comma_pos));\n        single_word = single_word.substr(comma_pos + 1);\n        comma_pos = single_word.find(',');\n    }\n    words.push_back(single_word);\n\n    // If no commas, count the number of lowercase letters with odd order in the alphabet\n    if (words.size() == 1) {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                count++;\n            }\n        }\n        words.clear();\n        words.push_back(to_string(count));\n    }\n\n    return words;\n}\n", "py_code": "def split_words(txt):\n    # Split on whitespace first\n    words = txt.split()\n    \n    if len(words) > 1:\n        return words\n    \n    # If no whitespaces, try splitting on commas\n    elif ',' in txt:\n        words = txt.split(',')\n        return words\n    \n    # If no commas, count the number of lowercase letters with odd order in the alphabet\n    else:\n        count = sum(1 for char in txt if 'a' <= char <= 'z' and (ord(char) - ord('a')) % 2 == 1)\n        return [str(count)]\n```\n\n", "py_summary": "The Python function `split_words` processes a given string `txt` according to specific rules:\n\n1. **Split on Whitespace**: The function first attempts to split the input string using whitespace as the delimiter. If this results in more than one word (i.e., the list of words has length greater than 1), it returns the resulting list.\n\n2. **Split on Commas**: If splitting on whitespace does not yield multiple words, the function checks if there are any commas in the input string. If commas exist, it splits the string using commas as delimiters and returns the resulting list of substrings.\n\n3. **Count Lowercase Letters with Odd Order**: If neither whitespaces nor commas are present in the input string, the function counts the number of lowercase letters whose positions in the alphabet (where 'a' is 0, 'b' is 1, etc.) have odd values. It then returns a list containing this count as a single-element string.\n\nThis approach ensures that the function handles different cases appropriately and provides the correct output based on the presence or absence of delimiters and specific character conditions in the input string.\n\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.empty()) return true;  // Check for empty list\n\n    unordered_map<int, int> frequency;  // Dictionary to keep track of frequencies\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;  // Check if the list is sorted in ascending order\n        }\n        \n        frequency[lst[i]]++;  // Update frequency of current element\n        \n        if (frequency[lst[i]] > 2) {\n            return false;  // If any number appears more than twice, return false\n        }\n    }\n\n    return true;  // Return true if no violations are found\n}\n", "py_code": "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    \n    frequency = {}\n    for i in range(len(lst)):\n        if i > 0 and lst[i] < lst[i - 1]:\n            return False\n        \n        if lst[i] in frequency:\n            frequency[lst[i]] += 1\n            if frequency[lst[i]] > 2:\n                return False\n        else:\n            frequency[lst[i]] = 1\n    \n    return True\n```\n\n", "py_summary": "The Python function `is_sorted` checks whether a given list of integers is sorted in ascending order and ensures that no integer appears more than twice. Here's an analysis of how it works:\n\n1. **Initial Check for Empty List**: The function first checks if the input list is empty. If it is, the function returns `True`, as an empty list can be considered to be trivially sorted.\n\n2. **Frequency Dictionary Initialization**: A dictionary named `frequency` is initialized to keep track of how many times each integer appears in the list.\n\n3. **Iterate Through List**:\n   - The function iterates through each element in the list.\n   - For each element, it checks if the current element is less than the previous element (i.e., `lst[i] < lst[i-1]`). If this condition is true, it means the list is not sorted in ascending order, and the function returns `False`.\n   \n4. **Update Frequency Dictionary**:\n   - For each integer encountered, the code checks if it already exists in the frequency dictionary.\n   - If the integer exists, its count is incremented by 1. Additionally, if this count exceeds 2, the function immediately returns `False` because an integer appearing more than twice violates the condition.\n   - If the integer does not exist in the dictionary, it is added with a count of 1.\n\n5. **Return True**: If the loop completes without finding any violations (i.e., no element less than its predecessor and no integer appears more than twice), the function returns `True`.\n\nThis approach ensures that both conditions are checked efficiently: whether the list is sorted in ascending order and whether any number appears more than twice.\n\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n    return is_prime(length_of_intersection) ? \"YES\" : \"NO\";\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    \n    if start_max > end_min:\n        return \"NO\"\n    \n    length_of_intersection = end_min - start_max + 1\n    \n    if is_prime(length_of_intersection):\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "The Python code defines a function `intersection` that takes two intervals as input and determines whether the length of their intersection is a prime number. Here's an analysis of how it works:\n\n1. **Prime Number Check Function (`is_prime`)**:\n   - This helper function checks if a given integer `n` is a prime number.\n   - It returns `False` for numbers less than or equal to 1, as they are not considered prime.\n   - For other values of `n`, it iterates from 2 up to the square root of `n`. If any divisor is found within this range, it returns `False`.\n   - Otherwise, if no divisors are found, it returns `True`.\n\n2. **Intersection Function (`intersection`)**:\n   - The function takes two intervals as input: `interval1 = (start1, end1)` and `interval2 = (start2, end2)`.\n   - It calculates the maximum of the start points (`start_max`) to determine the beginning of the intersection.\n   - It also calculates the minimum of the end points (`end_min`) to determine the end of the intersection.\n   - If `start_max` is greater than `end_min`, it means there is no overlap between the intervals, and the function returns `\"NO\"`.\n   - Otherwise, it computes the length of the intersection as `length_of_intersection = end_min - start_max + 1`.\n   - It then uses the `is_prime` helper function to check if this length is a prime number.\n   - If the length is prime, it returns `\"YES\"`, otherwise, it returns `\"NO\"`.\n\nThis approach ensures that the code correctly identifies whether the intersection of two intervals has a prime length or not."}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int magnitude_sum = 0;\n    int sign_product = 1;\n\n    for (const auto& num : arr) {\n        magnitude_sum += std::abs(num);\n        if (num == 0) {\n            sign_product = 0;\n            break; // No need to continue if there's a zero\n        } else if (num < 0) {\n            sign_product *= -1;\n        }\n    }\n\n    return magnitude_sum * sign_product;\n}\n", "py_code": "def prod_signs(arr):\n    if not arr:\n        return -32768\n    \n    magnitude_sum = 0\n    sign_product = 1\n    \n    for num in arr:\n        magnitude_sum += abs(num)\n        if num == 0:\n            sign_product = 0\n        elif num < 0:\n            sign_product *= -1\n    \n    return magnitude_sum * sign_product\n```\n\n", "py_summary": "The Python function `prod_signs` calculates the sum of magnitudes of integers in a given list and multiplies it by the product of all signs (represented as 1 for positive, -1 for negative, and 0 if any number is zero). Here's a detailed breakdown:\n\n1. **Check for Empty List**: The function first checks if the input list `arr` is empty. If it is, the function returns `-32768`.\n\n2. **Initialize Variables**:\n   - `magnitude_sum`: This variable will store the sum of the absolute values (magnitudes) of all integers in the list.\n   - `sign_product`: This variable will store the product of signs for each integer in the list, initialized to 1.\n\n3. **Iterate Through List**: The function iterates through each number in the list:\n   - It adds the absolute value of the current number to `magnitude_sum`.\n   - If the current number is zero, it sets `sign_product` to 0 and exits further sign product calculations.\n   - If the current number is negative, it multiplies `sign_product` by `-1`.\n\n4. **Return Result**: Finally, the function returns the result of multiplying `magnitude_sum` by `sign_product`.\n\nThis approach ensures that if there's any zero in the list, the final product will be zero regardless of other numbers' signs and magnitudes.\n\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Path {\n    vector<int> values;\n    int steps;\n    \n    // Constructor\n    Path(vector<int>& v, int s) : values(v), steps(s) {}\n    \n    // Comparison operator for priority queue\n    bool operator<(const Path& other) const {\n        if (steps == other.steps) {\n            return values > other.values;  // Lexicographical comparison\n        }\n        return steps < other.steps;\n    }\n};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Helper function to get neighbors of a cell (x, y)\n    vector<pair<int, int>> get_neighbors(int x, int y) {\n        vector<pair<int, int>> directions{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n        vector<pair<int, int>> neighbors;\n        \n        for (auto [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                neighbors.push_back({nx, ny});\n            }\n        }\n        return neighbors;\n    }\n\n    // Initialize the priority queue with all possible starting points\n    priority_queue<Path> pq;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> path{grid[i][j]};\n            pq.push(Path(path, 1));\n        }\n    }\n\n    while (k > 0) {\n        priority_queue<Path> new_pq;\n        \n        while (!pq.empty()) {\n            Path current = pq.top();\n            pq.pop();\n\n            if (current.steps == k) {\n                return current.values;\n            }\n            \n            for (auto [nx, ny] : get_neighbors(current.values.back() / N, current.values.back() % N)) {\n                vector<int> new_path = current.values;\n                new_path.push_back(grid[nx][ny]);\n                new_pq.push(Path(new_path, current.steps + 1));\n            }\n        }\n\n        pq = move(new_pq);\n    }\n    \n    return {};\n}\n", "py_code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    \n    # Initialize a list of lists to store paths of length 1 to k\n    dp = [[[] for _ in range(N)] for _ in range(N)]\n    \n    # Fill the base case (paths of length 1)\n    for i in range(N):\n        for j in range(N):\n            dp[i][j] = [grid[i][j]]\n            \n    # Fill paths of lengths from 2 to k\n    for path_length in range(2, k + 1):\n        for i in range(N):\n            for j in range(N):\n                min_path = None\n                # Check all possible moves (up, down, left, right)\n                if i > 0:\n                    up_path = dp[i - 1][j] + [grid[i][j]]\n                    if not min_path or up_path < min_path:\n                        min_path = up_path\n                if j > 0:\n                    left_path = dp[i][j - 1] + [grid[i][j]]\n                    if not min_path or left_path < min_path:\n                        min_path = left_path\n                if i < N - 1:\n                    down_path = dp[i + 1][j] + [grid[i][j]]\n                    if not min_path or down_path < min_path:\n                        min_path = down_path\n                if j < N - 1:\n                    right_path = dp[i][j + 1] + [grid[i][j]]\n                    if not min_path or right_path < min_path:\n                        min_path = down_path\n                \n                # Store the minimum path for this cell and length\n                dp[i][j] = min_path\n    \n    # Find the global minimum path of length k\n    final_min_path = None\n    for i in range(N):\n        for j in range(N):\n            if not final_min_path or dp[i][j] < final_min_path:\n                final_min_path = dp[i][j]\n    \n    return final_min_path\n\n", "py_summary": "The Python code defines a function `minPath` that calculates the minimum path sum of length `k` in a given grid. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - The function initializes a 3D list `dp` where `dp[i][j]` will store all possible paths starting from cell `(i, j)` with lengths ranging from 1 to `k`.\n   - It sets the base case for paths of length 1 by initializing each cell in `dp` with a path containing only its value.\n\n2. **Dynamic Programming Table Filling**:\n   - The function iterates over all possible path lengths from 2 to `k`.\n   - For each cell `(i, j)` and each path length, it considers the four possible moves (up, down, left, right) if they are within grid boundaries.\n   - It constructs new paths by appending the current cell's value to the end of the shortest valid path found from neighboring cells.\n\n3. **Finding Minimum Path**:\n   - After filling the `dp` table for all lengths up to `k`, it iterates over all cells in the grid to find the minimum path of length `k`.\n   - The final result is stored in `final_min_path`.\n\n### Detailed Steps:\n\n1. **Base Case Initialization**:\n   ```python\n   dp = [[[] for _ in range(N)] for _ in range(N)]\n   for i in range(N):\n       for j in range(N):\n           dp[i][j] = [grid[i][j]]\n   ```\n   - This initializes the `dp` table with paths of length 1 starting from each cell.\n\n2. **Filling DP Table**:\n   ```python\n   for path_length in range(2, k + 1):\n       for i in range(N):\n           for j in range(N):\n               min_path = None\n               if i > 0:\n                   up_path = dp[i - 1][j] + [grid[i][j]]\n                   if not min_path or up_path < min_path:\n                       min_path = up_path\n               if j > 0:\n                   left_path = dp[i][j - 1] + [grid[i][j]]\n                   if not min_path or left_path < min_path:\n                       min_path = left_path\n               if i < N - 1:\n                   down_path = dp[i + 1][j] + [grid[i][j]]\n                   if not min_path or down_path < min_path:\n                       min_path = down_path\n               if j < N - 1:\n                   right_path = dp[i][j + 1] + [grid[i][j]]\n                   if not min_path or right_path < min_path:\n                       min_path = down_path\n               \n               dp[i][j] = min_path\n   ```\n   - For each cell `(i, j)` and path length `path_length`, it checks all possible moves (up, left, down, right) to find the shortest valid path of that length.\n   - It updates `dp[i][j]` with the minimum path found.\n\n3. **Finding Global Minimum Path**:\n   ```python\n   final_min_path = None\n   for i in range(N):\n       for j in range(N):\n           if not final_min_path or dp[i][j] < final_min_path:\n               final_min_path = dp[i][j]\n   \n   return final_min_path\n   ```\n   - After filling the `dp` table, it iterates over all cells to find the minimum path of length `k`.\n   - The function returns this global minimum path.\n\nThis approach ensures that each cell's shortest path for a given length is computed based on the shortest paths from its neighbors in previous lengths. This dynamic programming method efficiently builds up solutions for longer paths by leveraging shorter ones, ensuring correctness and efficiency."}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) {\n        return {};\n    }\n    \n    vector<int> tribonacci = {1};  // Initialize with a placeholder value for indexing purposes\n    \n    auto calculate_tribonacci = [&](int value) -> int {\n        static vector<int> memo(n + 1, -1);  // Memoization array to store results of subproblems\n        \n        function<int(int)> helper = [&](int value) -> int {\n            if (value == 1) return 3;\n            else if (memo[value] != -1) return memo[value];\n            else if (value % 2 == 0) return memo[value] = 1 + (value / 2);\n            else return memo[value] = helper(value - 1) + helper(value - 2) + helper(value + 1);\n        };\n        \n        return helper(value);\n    };\n\n    for (int i = 1; i <= n; ++i) {\n        tribonacci.push_back(calculate_tribonacci(i));\n    }\n\n    // Adjust the first element to match tri(1) = 3\n    tribonacci[0] = 3;\n    \n    return tribonacci;\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return []\n    \n    tribonacci = [1]  # tri(1) is defined as 3 but we start with 1 for indexing purposes\n    \n    def calculate_tribonacci(value):\n        if value == 1:\n            return 3\n        elif value % 2 == 0:\n            return 1 + (value // 2)\n        else:\n            # Calculate tri(n-1), tri(n-2), and tri(n+1) recursively\n            return calculate_tribonacci(value - 1) + calculate_tribonacci(value - 2) + calculate_tribonacci(value + 1)\n    \n    for i in range(1, n + 1):\n        tribonacci.append(calculate_tribonacci(i))\n    \n    # Adjust the first element to match tri(1) = 3\n    tribonacci[0] = 3\n    \n    return tribonacci\n```\n\n", "py_summary": "The Python code defines a function `tri(n)` that calculates and returns the first `n + 1` numbers of the Tribonacci sequence as specified in the problem statement. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - The function starts by checking if `n` is zero, in which case it returns an empty list.\n   - It initializes a list `tribonacci` with the first element set to 1 (for indexing purposes).\n\n2. **Helper Function**:\n   - A helper function `calculate_tribonacci(value)` is defined to compute the value of `tri(value)` based on the given rules:\n     - If `value == 1`, it returns 3.\n     - If `value` is even, it calculates `1 + (value // 2)`.\n     - If `value` is odd, it recursively computes `tri(n-1) + tri(n-2) + tri(n+1)`.\n\n3. **Main Loop**:\n   - The main loop iterates from 1 to `n`, appending the result of `calculate_tribonacci(i)` to the `tribonacci` list for each value of `i`.\n\n4. **Adjustment**:\n   - After populating the list, it adjusts the first element to match the definition `tri(1) = 3`.\n   \n5. **Return Value**:\n   - Finally, the function returns the `tribonacci` list containing the sequence.\n\nThis approach ensures that each value in the Tribonacci sequence is computed correctly according to the given rules and stored in a list which is then returned as the result."}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10;\n    }\n\n    return has_odd_digit ? product : 0;\n}\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    \n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    \n    return product if has_odd_digit else 0\n```\n\n", "py_summary": "The Python function `digits` calculates the product of the odd digits in a given positive integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - `product`: This variable is initialized to 1 and will store the cumulative product of all odd digits found.\n   - `has_odd_digit`: A boolean flag that tracks whether at least one odd digit has been encountered.\n\n2. **Loop through each digit**:\n   - The function enters a loop that continues as long as `n` is greater than 0.\n   - In each iteration, the last digit of `n` (obtained using `digit = n % 10`) is extracted and checked to see if it is odd (`digit % 2 != 0`).\n   \n3. **Update product**:\n   - If the current digit is odd, its value is multiplied with `product`.\n   - The flag `has_odd_digit` is set to True.\n\n4. **Remove last digit**:\n   - After processing each digit, it is removed from `n` by performing integer division (`n //= 10`).\n\n5. **Return result**:\n   - If at least one odd digit was found (`has_odd_digit` is True), the function returns the product of all odd digits.\n   - Otherwise (if no odd digits were found), it returns 0.\n\nThis approach ensures that the function correctly handles cases where there are no odd digits and calculates the product only for odd digits."}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> bracketStack;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            bracketStack.push(c);\n        } else if (c == ']') {\n            if (!bracketStack.empty() && !hasNested && bracketStack.size() > 1) {\n                hasNested = true;\n            }\n            if (!bracketStack.empty()) {\n                bracketStack.pop();\n            } else {\n                // If the stack is empty but we encounter a closing bracket, it's invalid\n                return false;\n            }\n        }\n    }\n\n    // Ensure that all brackets are properly closed and there was at least one nested structure\n    return hasNested && bracketStack.empty();\n}\n", "py_code": "def is_nested(str):\n    stack = []\n    has_nested = False\n    \n    for char in str:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 1:\n                has_nested = True\n            stack.pop()\n    \n    return has_nested and not stack\n```\n\n", "py_summary": "The Python function `is_nested` checks whether a given string of square brackets contains at least one nested bracket sequence. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - A stack is initialized to keep track of open brackets.\n   - A boolean variable `has_nested` is set to `False` initially, which will be used to indicate whether there has been a nested structure.\n\n2. **Iterating through the string**:\n   - The function iterates over each character in the input string.\n   - If the character is an opening bracket `[`, it is pushed onto the stack.\n   \n3. **Processing closing brackets**:\n   - When a closing bracket `]` is encountered, the function checks if there are at least two open brackets on the stack (i.e., `len(stack) > 1`). This condition ensures that there is a nested structure because for a nested structure to exist, there must be an opening bracket before another opening bracket.\n   - If this condition is met, `has_nested` is set to `True`.\n   - The top element of the stack (the most recent open bracket) is popped off.\n\n4. **Final check**:\n   - After processing all characters in the string, the function returns `True` if there was at least one nested structure (`has_nested == True`) and the stack is empty (indicating that every opening bracket had a corresponding closing bracket).\n\nThis approach ensures that we correctly identify whether there is any valid subsequence of brackets where at least one bracket is nested.\n\n"}
{"task_id": "CPP/133", "generation": "#include <cmath>\n#include <vector>\n\nint sum_squares(std::vector<float> lst) {\n    int total_sum = 0;\n    for (float num : lst) {\n        float ceiling_num = std::ceil(num);\n        int squared_num = static_cast<int>(ceiling_num * ceiling_num);\n        total_sum += squared_num;\n    }\n    return total_sum;\n}\n", "py_code": "from math import ceil\n\ndef sum_squares(lst):\n    total_sum = 0\n    for num in lst:\n        squared_num = ceil(num) ** 2\n        total_sum += squared_num\n    return total_sum\n```\n\n", "py_summary": "The Python function `sum_squares` takes a list of floating-point numbers as input and returns the sum of their ceiling-rounded values squared. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0 to keep track of the cumulative sum.\n2. **Iteration through List**: A loop iterates over each element in the input list `lst`.\n3. **Ceiling and Squaring**:\n   - For each number, it uses the `ceil` function from the math module to round up to the nearest integer.\n   - It then squares this ceiling-rounded value.\n4. **Accumulation**: The squared value is added to `total_sum`.\n5. **Return Result**: After iterating through all elements in the list, the total sum of squared values is returned.\n\nThis approach ensures that each number in the input list is processed individually, rounded up to the nearest integer, squared, and then summed together to produce the final result.\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype>  // For isalpha() function\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n    \n    // Remove trailing spaces\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the last character is an alphabetical character and not part of a word\n    size_t len = txt.length();\n    char last_char = txt.back();\n    if (isalpha(last_char) && (len == 1 || !isalpha(txt[len - 2]))) {\n        return true;\n    }\n    \n    return false;\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    # Remove trailing spaces\n    while txt and txt[-1] == ' ':\n        txt = txt[:-1]\n    \n    # Check if last character is an alphabetical character\n    if len(txt) > 0 and txt[-1].isalpha() and (len(txt) == 1 or not txt[-2].isalpha()):\n        return True\n    \n    return False\n```\n\n", "py_summary": "The Python function `check_if_last_char_is_a_letter` checks if the last character of a given string is an alphabetical character and not part of a word. Here's a detailed analysis:\n\n1. **Initial Check for Empty String**:\n   - The function first checks if the input string `txt` is empty. If it is, the function returns `False`.\n\n2. **Remove Trailing Spaces**:\n   - A while loop removes any trailing spaces from the end of the string. This ensures that only the relevant part of the string is considered.\n\n3. **Check Last Character Conditions**:\n   - The function checks if the length of the modified string is greater than 0 and if the last character is an alphabetical character using `txt[-1].isalpha()`.\n   - Additionally, it checks whether this character is not part of a word by ensuring that either the entire string consists of only one character or the second-to-last character (if it exists) is not an alphabetical character. This ensures that the last character is not part of a word.\n\n4. **Return Result**:\n   - If all conditions are met, the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the last character in the string meets the specified criteria."}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n", "py_code": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1\n```\n\n", "py_summary": "The Python function `can_arrange` takes a list of integers as input and returns the largest index where an element is smaller than its preceding element. If no such element exists, it returns `-1`.\n\nHere's a breakdown of how the function works:\n\n1. **Initialization**: The function starts by iterating through the list starting from the second element (index 1) to the end.\n2. **Comparison**: For each element at index `i`, it checks if `arr[i]` is less than `arr[i-1]`.\n3. **Return Index**: If such an element is found, the function immediately returns the current index `i`.\n4. **No Such Element**: If no such element is found after iterating through the entire list, the function returns `-1`.\n\nThis approach ensures that the function efficiently finds and returns the largest index where a violation of the non-decreasing order occurs.\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(std::vector<int> lst) {\n    int max_negative = INT_MIN;  // Initialize to the smallest possible integer value\n    int min_positive = INT_MAX;  // Initialize to the largest possible integer value\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative or positive integers were found, set to 0\n    if (max_negative == INT_MIN) {\n        max_negative = 0;\n    }\n    if (min_positive == INT_MAX) {\n        min_positive = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n", "py_code": "from typing import List\n\ndef largest_smallest_integers(lst: List[int]) -> List[int]:\n    max_negative = float('-inf')\n    min_positive = float('inf')\n\n    for num in lst:\n        if num < 0 and num > max_negative:\n            max_negative = num\n        elif num > 0 and num < min_positive:\n            min_positive = num\n\n    return [max_negative, min_positive] if max_negative != float('-inf') or min_positive != float('inf') else [0, 0]\n```\n\n", "py_summary": "The Python code defines a function `largest_smallest_integers` that takes a list of integers as input and returns a vector containing two elements: the largest negative integer and the smallest positive integer in the list. If there are no negative or positive integers in the list, it returns 0 for both values.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The variables `max_negative` and `min_positive` are initialized to `-inf` (negative infinity) and `inf` (positive infinity), respectively. This ensures that any valid integer value in the list will be larger than `max_negative` or smaller than `min_positive`.\n\n2. **Iteration through the List**:\n   - For each number in the input list, the function checks if it is negative.\n   - If a number is negative and greater than the current `max_negative`, it updates `max_negative`.\n   - Similarly, for positive numbers, if a number is smaller than the current `min_positive`, it updates `min_positive`.\n\n3. **Final Check**:\n   - After iterating through all elements in the list, the function checks whether `max_negative` and `min_positive` have been updated from their initial values.\n   - If either of them remains `-inf` or `inf`, it means there were no negative or positive integers respectively, so both are set to 0.\n\n4. **Return Value**:\n   - The function returns a list containing the largest negative integer and the smallest positive integer found in the input list. If no valid values were found for either, it returns `[0, 0]`.\n\nThis approach ensures that the function correctly identifies the required integers or defaults to zero if none are present.\n\n"}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n\nfloat string_to_float(const std::string& str) {\n    // Implementation of string_to_float\n    return 0.0f; // Placeholder implementation\n}\n\nbool compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(std::string)) {\n        float val_a = string_to_float(boost::any_cast<std::string>(a));\n        float val_b = string_to_float(boost::any_cast<std::string>(b));\n        return val_a < val_b;\n    } else if (a.type() == typeid(int) && b.type() == typeid(int)) {\n        int val_a = boost::any_cast<int>(a);\n        int val_b = boost::any_cast<int>(b);\n        return val_a < val_b;\n    } else if (a.type() == typeid(int) && b.type() == typeid(std::string)) {\n        float val_a = boost::any_cast<int>(a);\n        float val_b = string_to_float(boost::any_cast<std::string>(b));\n        return val_a < val_b;\n    } else if (a.type() == typeid(std::string) && b.type() == typeid(int)) {\n        float val_a = string_to_float(boost::any_cast<std::string>(a));\n        int val_b = boost::any_cast<int>(b);\n        return val_a < val_b;\n    } else if (a.type() == typeid(float) && b.type() == typeid(float)) {\n        float val_a = boost::any_cast<float>(a);\n        float val_b = boost::any_cast<float>(b);\n        return val_a < val_b;\n    }\n    // Add more conditions as needed\n    return false; // Default case, should be handled appropriately\n}\n", "py_code": "from typing import Any\n\ndef compare_one(a: Any, b: Any) -> Any:\n    # Convert inputs to float if they are strings with decimal points\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n\n    # Compare the values and return the larger one or \"None\" if equal\n    if a == b:\n        return \"None\"\n    elif a > b:\n        return a\n    else:\n        return b\n```\n\n", "py_summary": "The Python function `compare_one` takes two inputs of any type and returns the larger value in its original type or \"None\" if they are equal. Here's a detailed analysis:\n\n1. **Type Conversion**:\n   - If either input is a string, it converts the string to a float by replacing commas with dots (to handle both '.' and ',' as decimal separators).\n   \n2. **Comparison**:\n   - The function compares the two values after ensuring they are in comparable types (both floats if one or both were strings).\n\n3. **Return Value**:\n   - If the values are equal, it returns \"None\".\n   - Otherwise, it returns the larger value in its original type:\n     - If both inputs were originally numbers (integers or floats), the function will return the larger number.\n     - If one of the inputs was a string and the other was an integer/float, the function converts the string to a float for comparison but returns the original input types.\n\nThis approach ensures that the function handles different data types correctly and provides the expected output as specified in the problem statement."}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Since we need exactly 4 positive even numbers, the smallest sum of such numbers is 2 + 2 + 2 + 2 = 8.\n    if (n < 8) {\n        return false;\n    }\n    \n    // Any number that can be expressed as a sum of four even numbers must itself be even.\n    if (n % 2 != 0) {\n        return false;\n    }\n    \n    // Since the smallest possible sum is 8, any even number greater than or equal to 8 can be written\n    // as a sum of exactly 4 positive even numbers. For example, for n = 10: 2 + 2 + 2 + 4.\n    if (n >= 8) {\n        return true;\n    }\n    \n    return false;\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    # Since we need exactly 4 positive even numbers, the smallest sum of such numbers is 2 + 2 + 2 + 2 = 8.\n    if n < 8:\n        return False\n    \n    # Any number that can be expressed as a sum of four even numbers must itself be even.\n    if n % 2 != 0:\n        return False\n    \n    # Since the smallest possible sum is 8, any even number greater than or equal to 8 can be written\n    # as a sum of exactly 4 positive even numbers. For example, for n = 10: 2 + 2 + 2 + 4.\n    if n >= 8:\n        return True\n    \n    return False\n```\n\n", "py_summary": "The Python function `is_equal_to_sum_even` evaluates whether a given integer \\( n \\) can be written as the sum of exactly four positive even numbers. Here's an analysis of how the function works:\n\n1. **Initial Check for Minimum Value**:\n   - The smallest possible sum of four positive even numbers is \\( 2 + 2 + 2 + 2 = 8 \\). Therefore, if \\( n < 8 \\), it is impossible to write \\( n \\) as a sum of exactly four positive even numbers. Hence, the function returns `False` for values less than 8.\n\n2. **Check for Evenness**:\n   - For \\( n \\) to be written as a sum of four even numbers, \\( n \\) itself must be an even number. If \\( n \\% 2 != 0 \\), then \\( n \\) is odd and cannot be expressed as the sum of four even numbers. Hence, the function returns `False` for odd values.\n\n3. **General Case**:\n   - For any even number \\( n \\geq 8 \\), it can always be written as a sum of exactly four positive even numbers. This is because we can use the smallest possible even numbers (2) and adjust one or more to meet the target value. For example, if \\( n = 10 \\), then \\( 2 + 2 + 2 + 4 = 10 \\).\n\nThe function returns `True` for any even number greater than or equal to 8.\n\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    if (n <= 0) {\n        return 1;\n    }\n    \n    long long result = 1;\n    \n    for (int i = 1; i <= n; ++i) {\n        long long factorial = 1;\n        \n        // Calculate the factorial of i\n        for (int j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        \n        // Multiply the computed factorial into result\n        result *= factorial;\n    }\n    \n    return result;\n}\n", "py_code": "def special_factorial(n):\n    if n <= 0:\n        return 1\n    \n    result = 1\n    for i in range(1, n + 1):\n        factorial = 1\n        for j in range(1, i + 1):\n            factorial *= j\n        result *= factorial\n    \n    return result\n```\n\n", "py_summary": "The Python function `special_factorial(n)` calculates the Brazilian factorial of a given integer \\( n \\). The Brazilian factorial is defined as the product of factorials from \\( n! \\) down to \\( 1! \\).\n\nHere's an analysis of the code:\n\n1. **Base Case**: If \\( n \\leq 0 \\), the function returns 1. This handles edge cases where the input is non-positive, and by definition, the Brazilian factorial for such values should be 1.\n\n2. **Initialization**: The variable `result` is initialized to 1. This will store the cumulative product of the factorials from \\( n! \\) down to \\( 1! \\).\n\n3. **Outer Loop**: An outer loop runs from 1 to \\( n \\). For each iteration, it calculates the factorial of the current number (i.e., \\( i! \\)) and multiplies this value into `result`.\n\n4. **Inner Loop**: Inside the outer loop, an inner loop calculates the factorial of the current number \\( i \\). The variable `factorial` is initialized to 1 for each iteration of the outer loop.\n\n5. **Factorial Calculation**: The inner loop runs from 1 to \\( i \\) and multiplies all integers in this range to compute \\( i! \\).\n\n6. **Product Accumulation**: After computing \\( i! \\), it is multiplied into `result`.\n\n7. **Return Result**: Finally, the function returns the value of `result`, which contains the Brazilian factorial for the input \\( n \\).\n\nThis approach ensures that each factorial from \\( 1! \\) to \\( n! \\) is computed and accumulated correctly in the final result.\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n    \n    return result;\n}\n\n", "py_code": "def fix_spaces(text):\n    result = \"\"\n    space_count = 0\n    \n    for char in text:\n        if char == \" \":\n            space_count += 1\n        else:\n            if space_count > 2:\n                result += \"-\"\n            elif space_count > 0:\n                result += \"_\" * space_count\n            space_count = 0\n            result += char\n    \n    # Handle trailing spaces\n    if space_count > 2:\n        result += \"-\"\n    elif space_count > 0:\n        result += \"_\" * space_count\n    \n    return result\n```\n\n", "py_summary": "The Python function `fix_spaces` takes a string `text` as input and returns a modified version of the string where spaces are replaced according to specific rules:\n\n1. **Initialization**: The function initializes an empty string `result` to store the transformed text and a counter `space_count` to keep track of consecutive spaces.\n\n2. **Iteration through characters**: It iterates through each character in the input string `text`.\n\n3. **Counting spaces**:\n   - If the current character is a space, it increments the `space_count`.\n   \n4. **Replacing spaces**:\n   - When encountering a non-space character (or reaching the end of the string), the function checks the value of `space_count`:\n     - If `space_count > 2`, it appends a single hyphen `-` to `result`.\n     - Otherwise, if `space_count > 0`, it appends `_` for each space counted.\n   - The counter `space_count` is reset to zero after processing the spaces.\n\n5. **Handling trailing spaces**: After exiting the loop, there might be remaining consecutive spaces at the end of the string that need to be processed similarly:\n   - If `space_count > 2`, it appends a hyphen `-`.\n   - Otherwise, if `space_count > 0`, it appends `_` for each space counted.\n\n6. **Return result**: Finally, the function returns the modified string stored in `result`.\n\nThis approach ensures that all spaces are replaced correctly according to the specified rules."}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <regex>\n#include <string>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^0-9]*[0-9]{0,3}\\.(txt|exe|dll)$)\");\n\n    if (std::regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n", "py_code": "import re\n\ndef file_name_check(file_name):\n    # Regular expression pattern for validating the file name\n    pattern = r'^[a-zA-Z][^0-9]*[0-9]{0,3}(\\.[txt|exe|dll])$'\n    \n    if re.match(pattern, file_name):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "The Python code defines a function `file_name_check` that takes a string representing a file's name and returns `\"Yes\"` if the file's name is valid according to specified conditions, otherwise it returns `\"No\"`. The validation is performed using a regular expression pattern.\n\nHere\u2019s an analysis of how the function works:\n\n1. **Regular Expression Pattern**:\n   - `^[a-zA-Z]`: Ensures that the file name starts with a letter from the Latin alphabet.\n   - `[^0-9]*[0-9]{0,3}`: Allows for zero or more non-digit characters followed by up to three digits.\n   - `\\.[txt|exe|dll]$: Ensures that there is exactly one dot (`.`) in the file name and that it is immediately followed by either `txt`, `exe`, or `dll`.\n\n2. **Validation**:\n   - The function uses `re.match` to check if the entire string matches the pattern.\n   - If a match is found, `\"Yes\"` is returned; otherwise, `\"No\"` is returned.\n\nThis approach ensures that all conditions are met in a concise and efficient manner using regular expressions.\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nint sum_squares(std::vector<int> lst) {\n    int result = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            result += lst[i] * lst[i] * lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def sum_squares(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            result += lst[i] ** 3\n    return result\n```\n\n", "py_summary": "The Python function `sum_squares` takes a list of integers as input and returns an integer representing the sum of squared or cubed values based on specific conditions related to their indices.\n\n1. **Initialization**: The variable `result` is initialized to 0, which will store the cumulative sum.\n2. **Iteration through List**: A loop iterates over each index `i` in the range of the length of the list.\n3. **Condition Checking**:\n   - If the index `i` is a multiple of 3 (`i % 3 == 0`), the value at that index is squared and added to `result`.\n   - If the index `i` is a multiple of 4 but not a multiple of 3 (`i % 4 == 0 and i % 3 != 0`), the value at that index is cubed and added to `result`.\n4. **Return Result**: After iterating through all indices, the function returns the cumulative sum stored in `result`.\n\nThis approach ensures that only specific entries (those with indices that are multiples of 3 or 4) have their values modified according to the given rules, while other entries remain unchanged.\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::vector<std::string> words;\n    std::string word;\n\n    // Split the sentence into individual words\n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            words.push_back(word);\n        }\n    }\n\n    // Join the filtered words back into a single string\n    std::ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << words[i];\n    }\n\n    return oss.str();\n}\n\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence: str) -> str:\n    words = sentence.split()\n    result = []\n    \n    for word in words:\n        if is_prime(len(word)):\n            result.append(word)\n    \n    return ' '.join(result)\n```\n", "py_summary": "The Python code defines a function `words_in_sentence` that takes a string `sentence` as input and returns a new string containing words whose lengths are prime numbers. The order of the words in the output is the same as their order in the original sentence.\n\nHere's a breakdown of how the code works:\n\n1. **Helper Function (`is_prime`)**:\n   - This function checks if a given integer `n` is a prime number.\n   - It returns `False` for numbers less than or equal to 1.\n   - For other integers, it iterates from 2 up to the square root of `n` and checks if any number divides `n` without leaving a remainder. If such a divisor exists, `is_prime` returns `False`. Otherwise, it returns `True`.\n\n2. **Main Function (`words_in_sentence`)**:\n   - The input sentence is split into individual words using the `split()` method.\n   - An empty list `result` is initialized to store words whose lengths are prime numbers.\n   - For each word in the list of words, the function checks if its length (using `len(word)`) is a prime number by calling the `is_prime` helper function.\n   - If the length is prime, the word is appended to the `result` list.\n   - Finally, the function joins the words in the `result` list into a single string separated by spaces and returns this new string.\n\nThis approach ensures that only words with prime number lengths are included in the output while maintaining their original order from the input sentence."}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a fraction from a string and return numerator and denominator as integers\npair<int, int> parse_fraction(const string& frac) {\n    size_t pos = frac.find('/');\n    int numerator = stoi(frac.substr(0, pos));\n    int denominator = stoi(frac.substr(pos + 1));\n    return {numerator, denominator};\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions x and n\n    auto [x_num, x_den] = parse_fraction(x);\n    auto [n_num, n_den] = parse_fraction(n);\n\n    // Calculate the product of the two fractions\n    int result_num = x_num * n_num;\n    int result_den = x_den * n_den;\n\n    // Check if the denominator is 1 (i.e., the result is a whole number)\n    return result_den == 1 || (result_num % result_den == 0);\n}\n", "py_code": "from fractions import Fraction\n\ndef simplify(x: str, n: str) -> bool:\n    # Convert strings to Fraction objects\n    fraction_x = Fraction(x)\n    fraction_n = Fraction(n)\n\n    # Calculate x * n\n    result_fraction = fraction_x * fraction_n\n    \n    # Check if the result is a whole number (i.e., denominator == 1)\n    return result_fraction.denominator == 1\n```\n\n", "py_summary": "The Python code defines a function `simplify` that takes two string arguments representing fractions and returns a boolean value indicating whether the product of these fractions is a whole number.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Convert Strings to Fractions**: The input strings `x` and `n` are converted into `Fraction` objects using Python\u2019s `fractions.Fraction` class, which allows for precise arithmetic operations on rational numbers.\n   \n2. **Calculate Product**: The product of the two fractions is computed by multiplying the `Fraction` objects.\n\n3. **Check Whole Number Condition**: To determine if the result is a whole number, the function checks whether the denominator of the resulting fraction is 1. If the denominator is 1, it means that the numerator alone represents an integer value (i.e., the product is a whole number).\n\n4. **Return Result**: The function returns `True` if the product is a whole number and `False` otherwise.\n\nThis approach ensures accurate handling of rational numbers and simplifies the problem by leveraging Python's built-in support for fraction arithmetic.\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint sum_of_digits(int num) {\n    int digit_sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        digit_sum += abs(num % 10);\n        num /= -10; // Handle negative numbers correctly\n    }\n    return digit_sum;\n}\n\n// Custom comparator for sorting based on sum of digits and original index\nbool custom_comparator(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (sum_of_digits(a.second) == sum_of_digits(b.second)) {\n        return a.first < b.first;\n    }\n    return sum_of_digits(a.second) < sum_of_digits(b.second);\n}\n\n// Function to sort the vector based on the sum of digits and original index\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> enumerated_nums;\n\n    // Enumerate the list with indices\n    for (int i = 0; i < nums.size(); ++i) {\n        enumerated_nums.push_back({i, nums[i]});\n    }\n\n    // Sort using custom comparator\n    std::sort(enumerated_nums.begin(), enumerated_nums.end(), custom_comparator);\n\n    // Extract sorted numbers from the enumerated list\n    std::vector<int> result;\n    for (const auto& pair : enumerated_nums) {\n        result.push_back(pair.second);\n    }\n    \n    return result;\n}\n\n", "py_code": "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def sum_of_digits(num):\n        if num == 0:\n            return 0\n        is_negative = num < 0\n        digit_sum = 0\n        while num != 0:\n            digit_sum += abs(num % 10)\n            num //= -10 if is_negative else 10\n        return digit_sum\n    \n    # Sort the list based on sum of digits and then by original index in case of a tie.\n    sorted_nums = sorted(enumerate(nums), key=lambda x: (sum_of_digits(x[1]), x[0]))\n    \n    # Extract the sorted numbers from the enumerated list.\n    result = [num for _, num in sorted_nums]\n    return result\n```\n\n", "py_summary": "The Python code defines a function `order_by_points` that sorts a given vector of integers based on the sum of their digits in ascending order. If multiple numbers have the same digit sum, they are ordered by their original index.\n\nHere's an analysis of the code:\n\n1. **Helper Function (`sum_of_digits`)**:\n   - This function calculates the sum of the digits of a given integer.\n   - It handles negative integers correctly by considering the first digit as negative and then processing subsequent digits normally.\n   - The function iterates through each digit of the number, adding its absolute value to `digit_sum`.\n\n2. **Sorting**:\n   - The list is sorted using Python's built-in `sorted` function with a custom key.\n   - The key is a lambda function that returns a tuple `(sum_of_digits(num), index)`.\n     - This ensures primary sorting by the sum of digits and secondary sorting by original index in case of ties.\n\n3. **Extracting Sorted Numbers**:\n   - After sorting, the enumerated list contains pairs of indices and numbers.\n   - The result is constructed by extracting just the numbers from these pairs to form the final sorted vector.\n\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>  // For abs() function\n\nusing namespace std;\n\n// Helper function to check if both first and last digits of a number are odd\nbool isFirstLastDigitOdd(int number) {\n    string str_num = to_string(abs(number));\n    int first_digit = str_num[0] - '0';\n    int last_digit = str_num[str_num.length() - 1] - '0';\n\n    return (first_digit % 2 != 0 && last_digit % 2 != 0);\n}\n\n// Main function that filters and counts numbers based on the criteria\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10 && isFirstLastDigitOdd(num)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def special_filter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and is_first_last_digit_odd(num):\n            count += 1\n    return count\n\ndef is_first_last_digit_odd(number):\n    str_num = str(abs(number))\n    first_digit = int(str_num[0])\n    last_digit = int(str_num[-1])\n    \n    return first_digit % 2 != 0 and last_digit % 2 != 0\n```\n\n", "py_summary": "The Python code defines a function `special_filter` that takes a list of integers as input and returns the count of elements in the list that are greater than 10 and have both their first and last digits odd.\n\nHere's an analysis of how it works:\n\n1. **Main Function (`special_filter`)**:\n   - The function initializes a counter `count` to zero.\n   - It iterates through each number in the input list `nums`.\n   - For each number, it checks if the number is greater than 10 and whether both its first and last digits are odd by calling the helper function `is_first_last_digit_odd`.\n   - If the conditions are met, it increments the counter.\n   - Finally, the function returns the count.\n\n2. **Helper Function (`is_first_last_digit_odd`)**:\n   - This function takes an integer `number`, converts its absolute value to a string, and extracts the first and last digits.\n   - It checks if both these digits are odd by verifying that their remainder when divided by 2 is not zero.\n   - The function returns `True` if both conditions are met; otherwise, it returns `False`.\n\nThis approach ensures that only numbers meeting all specified criteria (greater than 10 and having first and last digits as odd) are counted.\n\n"}
{"task_id": "CPP/147", "generation": "#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Generate sequence a\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Iterate over all possible triples (a[i], a[j], a[k])\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count += 1;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count\n```\n\n", "py_summary": "The Python code defines a function `get_max_triples` that takes an integer `n` as input and returns the number of valid triples `(a[i], a[j], a[k])` in the sequence `a`, where each element `a[i] = i * i - i + 1`.\n\nHere's a step-by-step breakdown:\n\n1. **Generate Sequence `a`:**\n   ```python\n   a = [i * i - i + 1 for i in range(1, n + 1)]\n   ```\n   This line creates the sequence `a` of length `n`, where each element at index `i` is calculated as `i * i - i + 1`.\n\n2. **Initialize Count:**\n   ```python\n   count = 0\n   ```\n   A variable `count` is initialized to zero, which will keep track of the number of valid triples.\n\n3. **Nested Loops for Triple Combinations:**\n   The function uses three nested loops to iterate over all possible combinations of indices `(i, j, k)` such that `1 \u2264 i < j < k \u2264 n`.\n   ```python\n   for i in range(n):\n       for j in range(i + 1, n):\n           for k in range(j + 1, n):\n               if (a[i] + a[j] + a[k]) % 3 == 0:\n                   count += 1\n   ```\n   - The outer loop iterates over `i` from `0` to `n-1`.\n   - The middle loop iterates over `j` from `i+1` to `n-1`.\n   - The innermost loop iterates over `k` from `j+1` to `n-1`.\n\n4. **Check Condition and Increment Count:**\n   For each combination of `(i, j, k)`, the code checks if the sum of `a[i] + a[j] + a[k]` is divisible by 3.\n   ```python\n   if (a[i] + a[j] + a[k]) % 3 == 0:\n       count += 1\n   ```\n   If the condition is met, it increments the `count`.\n\n5. **Return Result:**\n   Finally, the function returns the total count of valid triples.\n\nThis approach ensures that all possible combinations are checked and counted correctly according to the given conditions."}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> order = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    if (find(order.begin(), order.end(), planet1) == order.end() || find(order.begin(), order.end(), planet2) == order.end()) {\n        return {};\n    }\n    \n    size_t start_index = find(order.begin(), order.end(), planet1) - order.begin();\n    size_t end_index = find(order.begin(), order.end(), planet2) - order.begin();\n\n    if (start_index > end_index) {\n        swap(start_index, end_index);\n    }\n\n    return vector<string>(order.begin() + start_index + 1, order.begin() + end_index + 1);\n}\n", "py_code": "def bf(planet1: str, planet2: str) -> list:\n    order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in order or planet2 not in order:\n        return []\n    \n    start_index = order.index(planet1)\n    end_index = order.index(planet2)\n    \n    if start_index > end_index:\n        start_index, end_index = end_index, start_index\n    \n    return order[start_index + 1:end_index]\n```\n\n", "py_summary": "The Python code defines a function `bf` that takes two planet names as strings and returns a list of planets whose orbits are located between the given two planets, sorted by their proximity to the sun.\n\n1. **Initialization**: The function starts by defining a list `order` containing the names of the eight planets in order from closest to farthest from the Sun.\n2. **Validation**: It checks if both input planet names (`planet1` and `planet2`) are present in the `order` list. If either name is not found, it returns an empty list.\n3. **Index Calculation**: The function finds the indices of `planet1` and `planet2` within the `order` list using the `index()` method. It then ensures that `start_index` is less than or equal to `end_index`. If this condition is not met, it swaps the indices so that `start_index` is always less than or equal to `end_index`.\n4. **Result Construction**: The function returns a sublist of `order` containing planets between `planet1` and `planet2`, excluding `planet1` but including `planet2`. This sublist is constructed using list slicing.\n\nThis approach ensures that the returned list contains all planets in order from closest to farthest, as required by the problem statement."}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string>& lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n    \n    // Sort the list by length, and then alphabetically for equal lengths\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    \n    return lst;\n}\n", "py_code": "from typing import List\n\ndef vector_sort(lst: List[str]) -> List[str]:\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for equal lengths\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings\n```\n\n", "py_summary": "The Python code defines a function `vector_sort` that takes a list of strings as input and returns a sorted list according to specific criteria:\n\n1. **Remove Strings with Odd Lengths**: The first step is to filter out all strings from the input list that have odd lengths, keeping only those with even lengths.\n2. **Sort by Length and Alphabetically**: After filtering, the remaining strings are sorted based on their length in ascending order. If two strings have the same length, they are further sorted alphabetically.\n\nHere's a breakdown of how this is achieved:\n- A list comprehension `[s for s in lst if len(s) % 2 == 0]` filters out all strings with odd lengths.\n- The `sort()` method sorts the filtered list using a custom key. The key function `(lambda x: (len(x), x))` ensures that sorting is primarily by length and secondarily by alphabetical order.\n\nThis approach ensures that the returned list meets the requirements of having only even-length strings, sorted first by their lengths in ascending order and then alphabetically for equal lengths."}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath>  // For sqrt() function\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n", "py_code": "def x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "The Python code defines a function `x_or_y` that takes three integers as input: `n`, `x`, and `y`. The function checks whether `n` is a prime number using another helper function `is_prime`.\n\nHere's an analysis of each part:\n\n1. **Function Definition**:\n   - `def x_or_y(n, x, y):`\n     This defines the main function that will return either `x` or `y` based on whether `n` is a prime number.\n\n2. **Prime Check Function**:\n   - `def is_prime(num):`\n     This helper function determines if a given integer `num` is a prime number.\n   \n3. **Prime Checking Logic in `is_prime`**:\n   - The function first checks if the number is less than or equal to 1, returning `False` because neither 0 nor 1 are prime numbers.\n   - It then iterates from 2 up to the square root of `num`. If any integer divides `num` without a remainder, it returns `False`.\n   - If no divisors are found within this range, it returns `True`, indicating that `num` is a prime number.\n\n4. **Main Function Logic**:\n   - The main function calls `is_prime(n)` to check if `n` is a prime number.\n   - If `n` is prime (`is_prime(n) == True`), the function returns `x`.\n   - Otherwise, it returns `y`.\n\nThis approach ensures that the correct value is returned based on whether `n` is a prime number or not.\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long long>(std::pow(num, 2));\n        }\n    }\n\n    return sum_of_squares;\n}\n", "py_code": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    sum_of_squares = 0\n    for num in lst:\n        if num > 0 and num == int(num):  # Check if number is positive and an integer\n            if num % 2 != 0:  # Check if the number is odd\n                sum_of_squares += num ** 2\n    return sum_of_squares\n```\n\n", "py_summary": "The Python function `double_the_difference` takes a list of floating-point numbers as input and returns the sum of squares of the odd positive integers in the list. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `sum_of_squares` is initialized to 0, which will store the cumulative sum of squares of valid odd integers.\n\n2. **Iteration through the List**: A loop iterates over each element `num` in the input list `lst`.\n\n3. **Validation**:\n   - **Positive and Integer Check**: The condition `if num > 0 and num == int(num)` ensures that only positive numbers which are also integers (i.e., no fractional part) are considered.\n   - **Odd Number Check**: If the number passes the previous check, it is further checked to see if it is odd using `num % 2 != 0`.\n\n4. **Sum of Squares Calculation**:\n   - For each valid odd integer, its square (`num ** 2`) is computed and added to `sum_of_squares`.\n\n5. **Return Result**: After the loop completes, the function returns the value stored in `sum_of_squares`.\n\nThis approach ensures that only positive integers which are also odd contribute to the final sum of squares.\n\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    // Iterate through each index in the vectors\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    result = []\n    for i in range(len(game)):\n        diff = abs(game[i] - guess[i])\n        result.append(diff)\n    return result\n```\n\n", "py_summary": "The Python function `compare` takes two lists, `game` and `guess`, as input and returns a list of integers representing how far off each guess was from the actual score for each match.\n\n1. **Initialization**: An empty list `result` is initialized to store the differences.\n2. **Iteration**: A loop iterates through each index in the range of the length of the lists (assuming both lists are of equal length).\n3. **Difference Calculation**: For each index, it calculates the absolute difference between the corresponding elements in the `game` and `guess` lists using `abs(game[i] - guess[i])`.\n4. **Appending Results**: The calculated difference is appended to the `result` list.\n5. **Return Result**: After iterating through all indices, the function returns the `result` list containing the differences.\n\nThis approach ensures that each element in the result vector accurately reflects how close or far off each guess was from the actual score for each match.\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension = \"\";\n    \n    for (const auto& extension : extensions) {\n        int cap_count = 0;\n        int sm_count = 0;\n        \n        for (char c : extension) {\n            if (isupper(c)) {\n                cap_count++;\n            } else if (islower(c)) {\n                sm_count++;\n            }\n        }\n        \n        int strength = cap_count - sm_count;\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() > 0 ? extensions[extensions.size()-1] : \"\") != strongest_extension) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n", "py_code": "def strongest_extension(class_name, extensions):\n    max_strength = float('-inf')\n    strongest_extension = \"\"\n    \n    for extension in extensions:\n        cap_count = sum(1 for c in extension if c.isupper())\n        sm_count = sum(1 for c in extension if c.islower())\n        strength = cap_count - sm_count\n        \n        if strength > max_strength or (strength == max_strength and extensions.index(extension) < extensions.index(strongest_extension)):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\"\n```\n\n", "py_summary": "The Python function `strongest_extension` is designed to find and return the strongest extension for a given class name based on a vector of extensions. The strength of each extension is determined by the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in its name.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**:\n   - `max_strength` is initialized to negative infinity to ensure any calculated strength will be greater.\n   - `strongest_extension` is initialized as an empty string to store the strongest extension found.\n\n2. **Iterating through Extensions**:\n   - The function iterates over each extension in the provided list of extensions.\n   \n3. **Calculating Strength**:\n   - For each extension, it calculates the number of uppercase letters (`cap_count`) and lowercase letters (`sm_count`).\n   - The strength is calculated as `strength = cap_count - sm_count`.\n\n4. **Updating Strongest Extension**:\n   - If the current extension's strength is greater than `max_strength`, or if it has the same strength but comes earlier in the list, then update `max_strength` and set `strongest_extension` to the current extension.\n\n5. **Returning Result**:\n   - Finally, the function returns a string formatted as \"ClassName.StrongestExtensionName\".\n\nThis approach ensures that the strongest extension is found based on the defined strength criteria and returned in the specified format."}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated_a = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return concatenated_a.find(b) != string::npos;\n}\n", "py_code": "def cycpattern_check(a: str, b: str) -> bool:\n    # Concatenate the first word with itself\n    concatenated_a = a + a\n    \n    # Check if the second word is a substring of the concatenated string\n    return b in concatenated_a\n```\n\n", "py_summary": "The Python function `cycpattern_check` checks whether the second word or any of its rotations is a substring of the first word. Here's an analysis of how it works:\n\n1. **Concatenate the First Word with Itself**: The function concatenates the string `a` with itself to form `concatenated_a`. This step effectively creates a circular version of the string, making it possible to check for rotations as substrings within a linear search.\n\n2. **Check Substring Presence**: The function then checks if the string `b` is a substring of `concatenated_a`. If `b` appears in `concatenated_a`, it means that either `b` or one of its rotations is a substring of `a`.\n\nThis approach leverages the fact that any rotation of a word can be found as a substring within twice the length of the original word. For example, if we have the string \"abcd\" and want to check for rotations of \"bcda\", concatenating \"abcd\" with itself gives us \"abcdabcd\". Now, \"bcda\" is clearly a substring of this concatenated version.\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the integer to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each character in the string representation of the number\n    for (char c : str_num) {\n        int digit = c - '0';  // Convert char to integer\n        \n        // Check if the digit is even or odd and increment the respective counter\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n", "py_code": "def even_odd_count(num):\n    # Convert the integer to a string to easily iterate over each digit\n    str_num = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each character in the string representation of the number\n    for char in str_num:\n        digit = int(char)\n        \n        # Check if the digit is even or odd and increment the respective counter\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return [even_count, odd_count]\n```\n\n", "py_summary": "The Python function `even_odd_count` takes an integer `num` as input and returns a list containing the counts of even and odd digits in that number.\n\n1. **Convert to String**: The absolute value of the integer is converted to its string representation (`str(abs(num))`). This allows for easy iteration over each digit.\n2. **Initialize Counters**: Two counters, `even_count` and `odd_count`, are initialized to zero. These will keep track of how many even and odd digits are found in the number.\n3. **Iterate Over Digits**: The function iterates through each character in the string representation of the number. Each character is converted back to an integer (`int(char)`).\n4. **Check Even/Odd**: For each digit, it checks if the digit is even or odd by using the modulus operator (`digit % 2 == 0`). If the digit is even, `even_count` is incremented; otherwise, `odd_count` is incremented.\n5. **Return Result**: Finally, a list containing the counts of even and odd digits is returned.\n\nThis approach ensures that all digits are correctly classified as either even or odd and counted accordingly."}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define mappings for Roman numerals\n    struct RomanNumeral {\n        int value;\n        string roman;\n    };\n\n    vector<RomanNumeral> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"},  {90, \"xc\"},  {50, \"l\"},  {40, \"xl\"},\n        {10, \"x\"},   {9, \"ix\"},   {5, \"v\"},   {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman = \"\";\n\n    // Iterate through the mappings\n    for (const auto& rn : roman_numerals) {\n        while (number >= rn.value) {\n            roman += rn.roman;\n            number -= rn.value;\n        }\n    }\n\n    return roman;\n}\n", "py_code": "def int_to_mini_roman(number):\n    # Define mappings for Roman numerals\n    roman_numerals = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    \n    roman = ''\n    for value, numeral in roman_numerals:\n        while number >= value:\n            roman += numeral\n            number -= value\n    \n    return roman\n```\n\n", "py_summary": "The Python function `int_to_mini_roman` converts a given integer to its Roman numeral equivalent in lowercase. Here's an analysis of how it works:\n\n1. **Mapping Definition**: The function starts by defining a list of tuples called `roman_numerals`. Each tuple contains two elements: the integer value and its corresponding Roman numeral character or sequence (e.g., `(1000, 'm')`, `(900, 'cm')`).\n\n2. **Initialization**: An empty string variable `roman` is initialized to store the resulting Roman numeral.\n\n3. **Conversion Loop**: The function iterates over each tuple in `roman_numerals`. For each tuple:\n   - It checks if the current integer value (`value`) can be subtracted from the input number (`number`). If it can, it appends the corresponding Roman numeral character or sequence to `roman` and decreases `number` by `value`.\n   - This process continues until `number` is less than `value`.\n\n4. **Return Result**: After processing all possible values in `roman_numerals`, the function returns the constructed Roman numeral string stored in `roman`.\n\nThis approach ensures that the largest possible Roman numeral value is used first, which optimizes the conversion process and handles special cases like subtractive notation (e.g., 'iv' for 4).\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm>  // For std::sort\n#include <cmath>      // For std::pow and std::abs\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Store sides in an array to sort them\n    float sides[3] = {a, b, c};\n    \n    // Sort the sides to ensure the longest side is last (hypotenuse)\n    sort(sides, sides + 3);\n    \n    // Check if the square of the hypotenuse equals the sum of squares of other two sides\n    return abs(pow(sides[2], 2) - (pow(sides[0], 2) + pow(sides[1], 2))) < numeric_limits<float>::epsilon();\n}\n", "py_code": "import math\n\ndef right_angle_triangle(a, b, c):\n    # Sort the sides to ensure the longest side is last (hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check if the square of the hypotenuse equals the sum of squares of other two sides\n    return math.isclose(sides[2] ** 2, sides[0] ** 2 + sides[1] ** 2)\n```\n\n", "py_summary": "The Python function `right_angle_triangle` checks if three given side lengths form a right-angled triangle. Here's an analysis of how it works:\n\n1. **Sorting the Sides**: The sides are sorted in ascending order to ensure that the longest side (hypotenuse) is always the last element in the list. This step simplifies the subsequent calculation by making sure we correctly identify the hypotenuse.\n\n2. **Pythagorean Theorem Check**: After sorting, the function checks if the square of the longest side (`sides[2]`) is equal to the sum of the squares of the other two sides (`sides[0]` and `sides[1]`). This is based on the Pythagorean theorem, which states that in a right-angled triangle, \\(a^2 + b^2 = c^2\\), where \\(c\\) is the hypotenuse.\n\n3. **Using `math.isclose`**: The function uses `math.isclose` to handle floating-point precision issues. This ensures that small numerical differences due to floating-point arithmetic do not cause incorrect results.\n\nThe function returns `True` if the sides form a right-angled triangle and `False` otherwise.\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nstd::string find_max(std::vector<std::string>& words) {\n    std::string result_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int num_unique_chars = unique_chars.size();\n\n        if (num_unique_chars > max_unique_chars || \n            (num_unique_chars == max_unique_chars && word < result_word)) {\n            max_unique_chars = num_unique_chars;\n            result_word = word;\n        }\n    }\n\n    return result_word;\n}\n", "py_code": "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    max_unique_chars = 0\n    result_word = \"\"\n    \n    for word in words:\n        unique_chars = len(set(word))\n        \n        if unique_chars > max_unique_chars or (unique_chars == max_unique_chars and word < result_word):\n            max_unique_chars = unique_chars\n            result_word = word\n            \n    return result_word\n```\n\n", "py_summary": "The Python code defines a function `find_max` that takes a list of strings as input and returns the string with the maximum number of unique characters. If multiple strings have the same number of unique characters, it returns the one that comes first in lexicographical order.\n\nHere's a breakdown of how the function works:\n\n1. **Initialization**: \n   - `max_unique_chars` is initialized to 0 to keep track of the highest number of unique characters found so far.\n   - `result_word` is initialized as an empty string to store the current word with the maximum number of unique characters.\n\n2. **Iterate through each word**:\n   - For each word in the list, it calculates the number of unique characters using `len(set(word))`. The `set()` function removes duplicate characters and `len()` counts the remaining distinct characters.\n   \n3. **Update result if necessary**:\n   - If the current word has more unique characters than the previously recorded maximum (`unique_chars > max_unique_chars`), or if it has the same number of unique characters but comes before the current `result_word` in lexicographical order (`word < result_word`), then update `max_unique_chars` and set `result_word` to the current word.\n\n4. **Return the final result**:\n   - After iterating through all words, return the `result_word`.\n\nThis approach ensures that the function correctly identifies the string with the maximum number of unique characters while also handling ties by returning the lexicographically smallest string among those with the same number of unique characters."}
{"task_id": "CPP/159", "generation": "#include <vector>\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after meals\n    int total_eaten = number + std::min(need, remaining);\n    \n    // Calculate the number of carrots left after meals\n    int carrots_left = std::max(0, remaining - need);\n\n    return {total_eaten, carrots_left};\n}\n", "py_code": "def eat(number: int, need: int, remaining: int) -> list:\n    total_eaten = number + min(need, remaining)\n    carrots_left = max(0, remaining - need)\n    return [total_eaten, carrots_left]\n```\n\n", "py_summary": "The Python function `eat` takes three integer parameters: `number`, `need`, and `remaining`. It calculates and returns a list containing two elements:\n\n1. The total number of carrots eaten after the meals.\n2. The number of carrots left after the meals.\n\nHere's a detailed breakdown of how the function works:\n\n- **Total Number of Carrots Eaten**: This is calculated as the sum of the initial number of carrots already eaten (`number`) and the minimum value between the required additional carrots (`need`) and the remaining available carrots (`remaining`). The `min` function ensures that you do not eat more carrots than are available.\n\n- **Number of Carrots Left**: This is calculated by subtracting the actual number of carrots eaten from the initial remaining carrots. If there are no remaining carrots after eating, this value will be 0. To ensure non-negative values, the `max` function is used to clamp the result at zero (`max(0, ...)`).\n\nThe function then returns a list containing these two calculated values.\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nint do_algebra(std::vector<std::string>& operators, std::vector<int>& operands) {\n    // Initialize a stringstream to build the expression\n    std::stringstream expression;\n    \n    // Add the first operand to start the expression\n    expression << operands[0];\n    \n    // Iterate through each operator and append it along with the next operand to the expression\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression << \" \" << operators[i] << \" \" << operands[i + 1];\n    }\n    \n    // Convert the stringstream to a string and evaluate the expression using std::stringstream's capabilities\n    std::string expr_str = expression.str();\n    std::istringstream iss(expr_str);\n    int result;\n    iss >> std::boolalpha >> result; // This line is just for initialization, we will use getline instead\n    \n    // Evaluate the expression by parsing it again\n    std::istringstream iss_expr(expr_str);\n    iss_expr >> result;\n    \n    char op;\n    int next_operand;\n    while (iss_expr >> op >> next_operand) {\n        if (op == '+') {\n            result += next_operand;\n        } else if (op == '-') {\n            result -= next_operand;\n        } else if (op == '*') {\n            result *= next_operand;\n        } else if (op == '/') { // Note: The original problem specifies '//' but C++ uses '/' for integer division\n            result /= next_operand;\n        } else if (op == '^') { // Note: In C++, '**' is not a valid operator, use '^' as an alternative or handle it manually\n            int power = 1;\n            for (int i = 0; i < next_operand; ++i) {\n                power *= result;\n            }\n            result = power;\n        } else {\n            // Handle unrecognized operators if necessary\n            break;\n        }\n    }\n\n    return result;\n}\n", "py_code": "def do_algebra(operators: list[str], operands: list[int]) -> int:\n    expression = str(operands[0])\n    \n    for i in range(len(operators)):\n        operation = operators[i]\n        next_operand = operands[i + 1]\n        \n        if operation == \"+\":\n            expression += f\" + {next_operand}\"\n        elif operation == \"-\":\n            expression += f\" - {next_operand}\"\n        elif operation == \"*\":\n            expression += f\" * {next_operand}\"\n        elif operation == \"//\":\n            expression += f\" // {next_operand}\"\n        elif operation == \"**\":\n            expression += f\" ** {next_operand}\"\n    \n    return eval(expression)\n```\n\n", "py_summary": "The Python function `do_algebra` takes two parameters: a list of strings representing algebraic operations (`operators`) and a list of integers representing operands (`operands`). The goal is to construct an algebraic expression from these inputs and evaluate it.\n\n1. **Initialization**: Start by initializing the expression string with the first operand.\n2. **Loop Through Operators**: Iterate through each operator in the `operators` list:\n   - For each operator, append the corresponding operation (e.g., \"+\", \"-\", \"*\", \"//\", \"**\") followed by the next operand to the expression string.\n3. **Evaluation**: After constructing the complete algebraic expression as a string, use Python's built-in `eval()` function to evaluate and return the result of this expression.\n\nThis approach ensures that the algebraic expression is correctly formed according to the given operators and operands, and then evaluated to produce the final result.\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, islower, toupper, tolower\n\nusing namespace std;\n\nstring solve(string s) {\n    string result = \"\";\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            // Check if character is a letter and reverse its case\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            // Keep the character as it is if it's not a letter\n            result += c;\n        }\n    }\n\n    // Check if there are no letters in the string and reverse the entire string if true\n    bool containsLetter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            break;\n        }\n    }\n\n    if (!containsLetter) {\n        return string(result.rbegin(), result.rend());\n    } else {\n        return result;\n    }\n}\n", "py_code": "def solve(s):\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Check if character is a letter and reverse its case\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            # Keep the character as it is if it's not a letter\n            result.append(char)\n    if all(not c.isalpha() for c in s):\n        # If there are no letters, reverse the string\n        return ''.join(result)[::-1]\n    else:\n        return ''.join(result)\n```\n\n", "py_summary": "The Python function `solve` takes a string `s` as input and processes each character in the string according to specific rules:\n\n1. **Initialization**: An empty list `result` is initialized to store the transformed characters.\n2. **Character Processing**:\n   - For each character `char` in the string `s`, it checks if `char` is an alphabetic letter using `char.isalpha()`.\n   - If `char` is a letter, it further checks whether it is lowercase (`char.islower()`). \n     - If true, it converts the character to uppercase and appends it to `result`.\n     - Otherwise (if uppercase), it converts the character to lowercase and appends it to `result`.\n3. **Non-Letter Characters**: If `char` is not a letter, it simply appends `char` as-is to `result`.\n4. **Final String Construction**:\n   - After processing all characters, if no letters were found in the string (`all(not c.isalpha() for c in s)`), the function reverses the entire list of transformed characters before joining them into a final string.\n   - If there are any letters present, it directly joins the `result` list to form the output string.\n\nThe function returns the processed and possibly reversed string based on these rules."}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function to convert byte array to hexadecimal string\nstring bytes_to_hex(const unsigned char* digest, size_t len) {\n    static const char hex_digits[] = \"0123456789abcdef\";\n    string result;\n    for (size_t i = 0; i < len; ++i) {\n        result += hex_digits[(digest[i] >> 4) & 0x0F];\n        result += hex_digits[digest[i] & 0x0F];\n    }\n    return result;\n}\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode('utf-8'))\n    return md5_hash.hexdigest()\n```\n\n", "py_summary": "The Python code defines a function `string_to_md5` that takes a string `text` as input and returns its MD5 hash equivalent if the string is not empty. Here's an analysis of how this function works:\n\n1. **Check for Empty String**: The function first checks if the input string `text` is empty using the condition `if not text`. If it is empty, the function immediately returns `None`.\n\n2. **Initialize MD5 Hash Object**: If the string is not empty, an MD5 hash object is created using `hashlib.md5()`.\n\n3. **Update Hash with Input String**: The input string `text` is encoded to bytes using UTF-8 encoding and then passed to the update method of the MD5 hash object: `md5_hash.update(text.encode('utf-8'))`.\n\n4. **Generate Hex Digest**: Finally, the function returns the hexadecimal representation of the computed MD5 hash by calling `md5_hash.hexdigest()`.\n\nThis approach ensures that the input string is securely hashed using the MD5 algorithm and returned in a standard hexadecimal format. If the input string is empty, it avoids unnecessary computation and simply returns `None`.\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is less than or equal to 'b'\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    std::vector<int> even_digits;\n\n    for (int num = start; num <= end; ++num) {\n        if (num < 10 && num % 2 == 0) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n", "py_code": "def generate_integers(a: int, b: int) -> list:\n    # Ensure that `a` is less than or equal to `b`\n    start = min(a, b)\n    end = max(a, b)\n    \n    even_digits = []\n    for num in range(start, end + 1):\n        if num < 10 and num % 2 == 0:\n            even_digits.append(num)\n\n    return even_digits\n```\n\n", "py_summary": "The Python function `generate_integers` takes two positive integers `a` and `b` as input and returns a list of even digits between these two numbers in ascending order. Here's a detailed analysis:\n\n1. **Input Validation**: The function first ensures that `start` is the smaller number and `end` is the larger number by using `min(a, b)` for `start` and `max(a, b)` for `end`.\n\n2. **Initialization**: An empty list `even_digits` is initialized to store the even digits found between `a` and `b`.\n\n3. **Range Iteration**: The function iterates through all integers from `start` to `end + 1` (inclusive) using a `for` loop.\n\n4. **Even Digit Check**: For each integer in this range, it checks if the number is less than 10 and even (`num % 2 == 0`). If both conditions are met, the number is added to the list `even_digits`.\n\n5. **Return Result**: Finally, the function returns the list of even digits.\n\nThis approach ensures that all even numbers between `a` and `b` (inclusive) that are less than 10 are collected in ascending order.\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list and check adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n```\n\n", "py_summary": "The Python code defines a function `has_close_elements` that checks whether any two numbers in a given list are closer to each other than a specified threshold.\n\n1. **Sorting**: The input list `numbers` is first sorted in ascending order.\n2. **Iteration and Comparison**:\n   - A loop iterates through the sorted list from the start to the second-to-last element.\n   - For each pair of adjacent elements, it calculates their absolute difference using `abs(numbers[i] - numbers[i + 1])`.\n   - If this difference is less than the given threshold, the function immediately returns `True`, indicating that there are two elements closer than the threshold.\n3. **Return**:\n   - If no such pair of elements is found after iterating through the entire list, the function returns `False`.\n\nThis approach ensures that we only need to check adjacent pairs in the sorted list, making it efficient and straightforward.\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    stack<char> s;\n    string current_group = \"\";\n\n    // Remove spaces from the input string\n    for (char& c : paren_string) {\n        if (c == ' ') continue;  // Ignore spaces\n        if (c == '(' || c == ')') {\n            current_group += c;\n\n            if (c == '(') {\n                s.push(c);\n            } else if (!s.empty() && s.top() == '(') {\n                s.pop();\n                if (s.empty()) {  // Current group is complete\n                    result.push_back(current_group);\n                    current_group = \"\";  // Reset for the next group\n                }\n            }\n        }\n    }\n\n    return result;\n}\n", "py_code": "def separate_paren_groups(paren_string):\n    result = []\n    stack = []\n    current_group = \"\"\n    \n    for char in paren_string.replace(\" \", \"\"):\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        elif char == \")\":\n            stack.pop()\n            current_group += char\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"\n                \n    return result\n```\n\n", "py_summary": "The Python function `separate_paren_groups` takes a string containing multiple groups of nested parentheses and separates those groups into individual strings that are balanced (each open parenthesis is properly closed) and not nested within each other. Here's an analysis of how it works:\n\n1. **Input Processing**: The input string is first stripped of any spaces using `paren_string.replace(\" \", \"\")`.\n\n2. **Initialization**:\n   - `result` is a list that will store the separated groups.\n   - `stack` is used to keep track of open parentheses.\n   - `current_group` is a temporary variable to build each group as it is being processed.\n\n3. **Iterating Through Characters**: The function iterates through each character in the stripped input string:\n   - If the character is an opening parenthesis `(`, it is added to both the stack and `current_group`.\n   - If the character is a closing parenthesis `)`, it is also added to `current_group`. Additionally, the corresponding open parenthesis is popped from the stack.\n\n4. **Group Completion**: When the stack becomes empty (indicating that all open parentheses have been closed), the current group is complete and is appended to the result list. The `current_group` variable is then reset for the next group.\n\n5. **Return Result**: Finally, the function returns the list of separated groups.\n\nThis approach ensures that each group is balanced and not nested within another group by leveraging a stack to track open parentheses and ensuring that each group is only added to the result when its corresponding closing parentheses have been processed.\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n```\n\n", "py_summary": "The Python function `truncate_number` takes a floating-point number as input and returns its decimal part. Here's an analysis of how it works:\n\n1. **Extracting the Integer Part**: The integer part of the given number is obtained by converting the float to an integer using the `int()` function. This effectively truncates the decimal places, leaving only the whole number part.\n\n2. **Calculating the Decimal Part**: To find the decimal part, the function subtracts the integer part from the original number. The result is the fractional component of the number, which lies between 0 (inclusive) and 1 (exclusive).\n\n3. **Returning the Result**: Finally, the function returns this calculated decimal part.\n\nThis approach ensures that the returned value accurately represents the decimal portion of the input floating-point number."}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n```\n\n", "py_summary": "The Python function `below_zero` checks whether a bank account's balance falls below zero given a list of deposit and withdrawal operations. Here\u2019s an analysis of how it works:\n\n1. **Initialization**: The function starts by initializing the account balance to 0.\n2. **Iteration through Operations**: It iterates through each operation in the input list `operations`.\n3. **Update Balance**: For each operation, it updates the balance by adding the value of the current operation (deposit or withdrawal).\n4. **Check for Negative Balance**: After updating the balance, it checks if the balance is less than zero.\n5. **Return Result**: If at any point the balance falls below zero, the function immediately returns `True`. If no such point is found after iterating through all operations, the function returns `False`.\n\nThis approach ensures that the function efficiently detects whether the account balance goes negative during the sequence of transactions.\n\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f;\n    }\n    \n    // Calculate the mean value of the dataset\n    float sum = std::accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean_value = sum / numbers.size();\n    \n    // Calculate the absolute differences from the mean and then their average\n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean_value);\n    }\n    float mad = mad_sum / numbers.size();\n    \n    return mad;\n}\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean and then their average\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad\n```\n\n", "py_summary": "The Python code defines a function `mean_absolute_deviation` that calculates the Mean Absolute Deviation (MAD) of a given list of floating-point numbers. Here's a breakdown of how it works:\n\n1. **Input Validation**: The function first checks if the input list is empty. If it is, the function returns 0.0 to avoid division by zero.\n\n2. **Calculate the Mean**:\n   - It calculates the mean (average) value of the dataset using `sum(numbers) / len(numbers)`.\n\n3. **Calculate Absolute Differences and Their Average**:\n   - The function then computes the absolute differences between each element in the list and the calculated mean.\n   - These absolute differences are summed up, and their average is computed by dividing this sum by the number of elements in the dataset.\n\n4. **Return Result**: Finally, the function returns the calculated Mean Absolute Deviation (MAD).\n\nThis approach ensures that the MAD is accurately computed as the average of the absolute deviations from the mean for all elements in the input list."}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0) {\n            result.push_back(delimiter);\n        }\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i > 0:\n            result.append(delimiter)\n        result.append(numbers[i])\n    return result\n```\n\n", "py_summary": "The Python code defines a function `intersperse` that takes two arguments: a list of integers `numbers` and an integer `delimiter`. The function returns a new list where the delimiter is inserted between every pair of consecutive elements in the input list.\n\nHere's a breakdown of how the function works:\n1. **Initialization**: An empty list `result` is initialized to store the final interspersed sequence.\n2. **Iteration through the List**: A loop iterates over each element in the `numbers` list using its index `i`.\n3. **Inserting Delimiter**: For each element, if it's not the first element (i.e., `i > 0`), a delimiter is appended to the result list before adding the current number.\n4. **Appending Current Number**: The current number from the input list is added to the result list after optionally inserting the delimiter.\n\nThe function then returns the `result` list, which contains the original numbers interspersed with the specified delimiter.\n\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> results;\n    \n    // Split the input string into groups based on spaces\n    size_t start = 0, end = 0;\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        start = end + 1;\n        \n        // Process each group to find the maximum depth of nesting\n        int max_depth = 0;\n        int current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        // Append the maximum depth of nesting to results\n        results.push_back(max_depth);\n    }\n\n    // Process the last group in the string\n    string last_group = paren_string.substr(start);\n    int max_depth = 0;\n    int current_depth = 0;\n    for (char c : last_group) {\n        if (c == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') {\n            current_depth--;\n        }\n    }\n    \n    results.push_back(max_depth);\n\n    return results;\n}\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    results = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        results.append(max_depth)\n    \n    return results\n```\n\n", "py_summary": "The Python function `parse_nested_parens` takes a string of nested parentheses groups separated by spaces and returns a list containing the deepest level of nesting for each group.\n\n1. **Splitting the Input String**: The input string is split into individual groups based on spaces using `split()`. Each group represents a separate sequence of nested parentheses.\n2. **Initializing Variables**: For each group, two variables are initialized: `max_depth` to keep track of the deepest level of nesting encountered so far and `current_depth` to maintain the current depth as we iterate through the characters in the group.\n3. **Iterating Through Characters**: The function iterates through each character in the group:\n   - If the character is an opening parenthesis '(', the `current_depth` is incremented by 1, and `max_depth` is updated if the new `current_depth` exceeds the current value of `max_depth`.\n   - If the character is a closing parenthesis ')', the `current_depth` is decremented by 1.\n4. **Appending Results**: After processing each group, the deepest level of nesting (`max_depth`) for that group is appended to the results list.\n5. **Returning Results**: Finally, the function returns the list containing the maximum depth of nesting for each group.\n\nThis approach ensures that we correctly track and determine the maximum depth of nested parentheses in each group within the input string."}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    for (const auto& s : strings) {\n        if (s.find(substring) != string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n\n    return filtered_strings;\n}\n", "py_code": "def filter_by_substring(strings, substring):\n    filtered_strings = []\n    for s in strings:\n        if substring in s:\n            filtered_strings.append(s)\n    return filtered_strings\n```\n\n", "py_summary": "The Python function `filter_by_substring` takes two parameters: a list of strings (`strings`) and a substring (`substring`). The goal is to filter out only those strings from the input list that contain the given substring.\n\nHere's an analysis of how this function works:\n\n1. **Initialization**: An empty list called `filtered_strings` is initialized to store the filtered results.\n2. **Iteration**: A loop iterates through each string in the input list `strings`.\n3. **Condition Check**: For each string, it checks if the substring is present within that string using the `in` operator.\n4. **Appending Matches**: If the condition is true (i.e., the substring is found in the current string), the string is appended to the `filtered_strings` list.\n5. **Return Result**: After iterating through all strings, the function returns the `filtered_strings` list containing only those strings that include the given substring.\n\nThis approach ensures that only strings containing the specified substring are included in the final output list."}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    \n    int total_sum = 0;\n    int product = 1;\n\n    for (int number : numbers) {\n        total_sum += number;\n        product *= number;\n    }\n\n    return {total_sum, product};\n}\n", "py_code": "from typing import List\n\ndef sum_product(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return [0, 1]\n    \n    total_sum = 0\n    product = 1\n    \n    for number in numbers:\n        total_sum += number\n        product *= number\n    \n    return [total_sum, product]\n```\n\n", "py_summary": "The Python code defines a function `sum_product` that takes a list of integers as input and returns a list containing two elements: the sum and the product of all the integers in the input list.\n\n1. **Initial Check for Empty List**:\n   - If the input list is empty, the function immediately returns `[0, 1]`. This handles the special cases where the sum of an empty set is `0` and the product of an empty set is `1`.\n\n2. **Initialization**:\n   - Two variables are initialized: `total_sum` to store the cumulative sum of the integers in the list (initialized to `0`) and `product` to store the cumulative product of the integers in the list (initialized to `1`).\n\n3. **Iteration Through List**:\n   - The function iterates through each integer in the input list.\n   - For each integer, it adds the integer to `total_sum`.\n   - It also multiplies the integer with `product`.\n\n4. **Return Result**:\n   - After iterating through all integers, the function returns a list containing `total_sum` and `product`.\n\nThis approach ensures that both sum and product are correctly calculated for any given list of integers, including handling empty lists appropriately.\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    std::vector<int> result;\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n    \n    return result[1:]\n```\n\n", "py_summary": "The Python code defines a function `rolling_max` that takes a list of integers as input and returns a new list containing the rolling maximum values found up to each point in the sequence.\n\nHere's an analysis of how the function works:\n\n1. **Initial Check**: The function first checks if the input list `numbers` is empty. If it is, the function returns an empty list.\n2. **Initialization**: \n   - A result list `result` is initialized with the first element of the input list to start building the rolling maximum sequence.\n   - A variable `current_max` is set to this initial value to keep track of the current maximum value encountered so far.\n3. **Iterate Through Numbers**:\n   - The function iterates through each number in the input list starting from the second element (since the first element has already been added to `result`).\n4. **Update Current Maximum**:\n   - For each number, it checks if the current number is greater than `current_max`.\n   - If true, it updates `current_max` to this new value.\n5. **Append Rolling Maximum**:\n   - Regardless of whether `current_max` was updated or not, the function appends `current_max` to the result list at each step.\n6. **Return Result**:\n   - Finally, the function returns the result list starting from the second element (to exclude the initial value that was added before the loop).\n\nThis approach ensures that the returned list contains the rolling maximum values up to each point in the sequence.\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\"\n     */\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix_to_reverse = str.substr(0, i);\n            return str + string(prefix_to_reverse.rbegin(), prefix_to_reverse.rend());\n        }\n    }\n    // If the entire string is a palindrome\n    return str;\n}\n\n", "py_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef make_palindrome(str_input):\n    n = len(str_input)\n    for i in range(n):\n        if is_palindrome(str_input[i:]):\n            prefix_to_reverse = str_input[:i]\n            return str_input + prefix_to_reverse[::-1]\n```\n", "py_summary": "### Analysis of Python Code\n\nThe provided Python functions `is_palindrome` and `make_palindrome` work together to solve the problem of finding the shortest palindrome that begins with a given string.\n\n1. **Function: is_palindrome**\n   - This function checks if a given string `s` is a palindrome.\n   - It returns `True` if the string reads the same forwards and backwards, otherwise it returns `False`.\n   - The check is performed by comparing the string to its reverse (`s[::-1]`).\n\n2. **Function: make_palindrome**\n   - This function takes a string `str_input` and finds the shortest palindrome that begins with this string.\n   - It starts by determining the length of the input string, denoted as `n`.\n   - The function then iterates through each possible postfix of the string starting from the beginning to the end.\n   - For each postfix, it checks if the postfix is a palindrome using the `is_palindrome` function.\n   - Once a palindromic suffix is found, the prefix preceding this suffix (i.e., everything before the palindromic part) is identified and reversed.\n   - The reversed prefix is then appended to the original string to form the shortest possible palindrome.\n\n### Example Walkthrough\n- **Input**: `\"cat\"`\n  - Iterate through each postfix: \"cat\", \"at\", \"t\".\n  - Check if any of these are palindromes. None of them are.\n  - The function will append the reverse of the entire string to itself, resulting in `\"catac\"`.\n  \n- **Input**: `\"cata\"`\n  - Iterate through each postfix: \"cata\", \"ata\", \"ta\", \"a\".\n  - Check if any of these are palindromes. The last one, `\"a\"`, is a palindrome.\n  - Append the reverse of the prefix before `\"a\"` (i.e., `\"cat\"`) to form `\"catac\"`.\n\nThis approach ensures that the resulting string is the shortest possible palindrome starting with the given input string."}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n", "py_code": "def string_xor(a: str, b: str) -> str:\n    result = \"\"\n    for i in range(len(a)):\n        # XOR operation on each bit\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n```\n\n", "py_summary": "The Python function `string_xor` takes two string inputs `a` and `b`, both consisting of binary digits (1s and 0s). The function performs a bitwise XOR operation on these strings and returns the result as a new string.\n\nHere's a detailed breakdown:\n- **Initialization**: An empty string `result` is initialized to store the final output.\n- **Iteration**: A loop iterates through each character of the input strings. Since both strings are assumed to be of equal length, we can safely compare characters at the same index in both strings.\n- **XOR Operation**: For each pair of corresponding bits (characters) from `a` and `b`, the function checks if they are the same or different:\n  - If the bits are the same (`a[i] == b[i]`), the XOR result is `0`.\n  - If the bits are different, the XOR result is `1`.\n- **Appending Result**: The computed bit is appended to the `result` string.\n- **Return Value**: After iterating through all characters, the function returns the accumulated `result`.\n\nThis approach ensures that each corresponding pair of bits from the input strings undergoes a bitwise XOR operation, and the resulting binary string is returned.\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::string(); // Return an empty string to represent None in C++\n    }\n    \n    size_t max_length = 0;\n    std::string longest_string = \"\";\n    \n    for (const auto& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            longest_string = str;\n        }\n    }\n    \n    return longest_string;\n}\n", "py_code": "from typing import List\n\ndef longest(strings: List[str]) -> str:\n    if not strings:\n        return None\n    \n    max_length = 0\n    longest_string = \"\"\n    \n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_string = string\n            \n    return longest_string\n```\n\n", "py_summary": "The Python code defines a function `longest` that takes a list of strings as input and returns the longest string in the list. If there are multiple strings with the same maximum length, it returns the first one encountered. If the input list is empty, it returns `None`.\n\nHere's a breakdown of how the function works:\n\n1. **Check for Empty Input**: The function first checks if the input list `strings` is empty using `if not strings`. If it is empty, the function immediately returns `None`.\n2. **Initialize Variables**: It initializes two variables: `max_length` to store the length of the longest string found so far and `longest_string` to store the actual longest string.\n3. **Iterate Through Strings**: The function iterates through each string in the input list using a for loop.\n4. **Update Longest String**: For each string, it checks if its length is greater than the current `max_length`. If so, it updates `max_length` to the length of this string and sets `longest_string` to this string.\n5. **Return Result**: After iterating through all strings, the function returns `longest_string`.\n\nThis approach ensures that the first longest string encountered in case of ties is returned.\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "py_code": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n", "py_summary": "The Python code defines a function `greatest_common_divisor` that calculates the greatest common divisor (GCD) of two integers `a` and `b`. The function uses the Euclidean algorithm to find the GCD.\n\nHere's a breakdown of how it works:\n1. **Initialization**: Start with the given integers `a` and `b`.\n2. **Loop until b is 0**: Continue iterating as long as `b` is not zero.\n3. **Update values**: In each iteration, update `a` to be `b`, and `b` to be the remainder of `a` divided by `b` (i.e., `a % b`).\n4. **Return result**: Once `b` becomes 0, return `a`, which will be the GCD.\n\nThis approach leverages the property that the GCD of two numbers also divides their difference and remainder when one is divided by the other. The loop continues until `b` reaches zero, at which point `a` contains the GCD of the original values of `a` and `b`.\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n", "py_code": "def all_prefixes(s):\n    prefixes = []\n    for i in range(1, len(s) + 1):\n        prefixes.append(s[:i])\n    return prefixes\n```\n\n", "py_summary": "The Python function `all_prefixes` generates a list of all prefixes of the input string `s`, from the shortest to the longest prefix.\n\n1. **Initialization**: An empty list called `prefixes` is initialized to store the resulting prefixes.\n2. **Loop through lengths**: A loop runs from 1 to the length of the string (inclusive). This ensures that each possible substring length is considered, starting from a single character up to the full length of the string.\n3. **Generate prefix**: For each iteration `i`, the function generates a prefix by slicing the input string `s` from index 0 to `i`. The slice operation `s[:i]` creates a substring that starts at the beginning and ends just before index `i`.\n4. **Store prefix**: Each generated prefix is appended to the list `prefixes`.\n5. **Return result**: After completing the loop, the function returns the list of prefixes.\n\nThis approach ensures that all possible prefixes are captured in order from shortest to longest."}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n", "py_code": "def string_sequence(n):\n    return \" \".join(map(str, range(n + 1)))\n```\n", "py_summary": "The Python function `string_sequence` takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to `n` inclusive.\n\nHere's a breakdown of how it works:\n1. **Range Generation**: The expression `range(n + 1)` generates a sequence of integers from 0 to `n`.\n2. **Mapping to Strings**: The `map(str, range(n + 1))` part converts each integer in the generated sequence to its string representation.\n3. **Joining with Spaces**: The `\" \".join(...)` part joins these string representations together into a single string, separated by spaces.\n\nThus, the function effectively constructs and returns a string that contains all integers from 0 up to `n`, inclusive, separated by spaces."}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>  // Include the set header for using std::set\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert all characters to lowercase and store them in a set to remove duplicates\n    set<char> distinct_chars;\n    \n    for (char c : str) {\n        char lower_c = tolower(c);  // Convert character to lowercase\n        distinct_chars.insert(lower_c);  // Insert the lowercase character into the set\n    }\n    \n    return distinct_chars.size();  // Return the number of unique characters in the set\n}\n", "py_code": "def count_distinct_characters(s):\n    # Convert all characters in the string to lowercase and then to a set to remove duplicates\n    distinct_chars = set(char.lower() for char in s)\n    return len(distinct_chars)\n```\n\n", "py_summary": "The Python function `count_distinct_characters` takes a string `s` as input and returns the number of distinct characters in the string, ignoring case differences.\n\n1. **Convert to Lowercase**: The function first converts each character in the string to its lowercase equivalent using `char.lower()`. This ensures that uppercase and lowercase versions of the same letter are treated as identical.\n2. **Use a Set**: It then creates a set from these lowercase characters. A set automatically removes any duplicate entries, leaving only unique characters.\n3. **Count Distinct Characters**: Finally, it returns the length of this set, which represents the number of distinct characters in the original string.\n\nThis approach ensures that all character comparisons are case-insensitive and efficiently counts the distinct characters using Python's built-in data structures.\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int start = 0;\n    while (start < music_string.length()) {\n        if (music_string.substr(start, 1) == \"o\") {\n            beats.push_back(4);\n            start += 1; // Move to the next character\n        } else if (music_string.substr(start, 2) == \"o|\") {\n            beats.push_back(2);\n            start += 2; // Move to the next two characters\n        } else if (music_string.substr(start, 2) == \".|\") {\n            beats.push_back(1);\n            start += 2; // Move to the next two characters\n        }\n    }\n    return beats;\n}\n", "py_code": "def parse_music(music_string):\n    beats = []\n    notes = music_string.split()\n    \n    for note in notes:\n        if note == \"o\":\n            beats.append(4)\n        elif note == \"o|\":\n            beats.append(2)\n        elif note == \".|\":\n            beats.append(1)\n    \n    return beats\n```\n\n", "py_summary": "The Python function `parse_music` takes a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts.\n\nHere's an analysis of the code:\n\n1. **Input Parsing**: The input string is split into individual notes using the `split()` method, which splits the string at whitespace.\n2. **Loop Through Notes**: A loop iterates through each note in the resulting list of notes.\n3. **Determine Beats**:\n   - If the note is `\"o\"`, it represents a whole note and lasts four beats. The function appends `4` to the `beats` list.\n   - If the note is `\"o|\"` (half note), it lasts two beats, so the function appends `2` to the `beats` list.\n   - If the note is `\".|\"`, it represents a quarter note and lasts one beat. The function appends `1` to the `beats` list.\n4. **Return Result**: After processing all notes, the function returns the `beats` list containing the number of beats for each note.\n\nThis approach ensures that each note in the input string is correctly mapped to its corresponding number of beats based on the provided legend."}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t start = 0;\n\n    while (start <= str.length() - substring.length()) {\n        size_t pos = str.find(substring, start);\n        if (pos != string::npos) {\n            count++;\n            start = pos + 1;\n        } else {\n            break;\n        }\n    }\n\n    return count;\n}\n\n", "py_code": "def how_many_times(str, substring):\n    count = 0\n    start = 0\n    \n    while start <= len(str) - len(substring):\n        pos = str.find(substring, start)\n        if pos != -1:\n            count += 1\n            start = pos + 1\n        else:\n            break\n            \n    return count\n```\n\n", "py_summary": "The Python function `how_many_times` calculates how many times a given substring can be found within an original string, including overlapping cases. Here's a detailed analysis of the code:\n\n1. **Initialization**:\n   - `count`: A variable to keep track of the number of occurrences.\n   - `start`: An index used to start searching for the substring from different positions in the original string.\n\n2. **Loop through the string**:\n   - The loop runs as long as the starting position (`start`) is within the bounds where a complete substring can still fit in the original string (`len(str) - len(substring)`).\n   \n3. **Find the substring**:\n   - `pos = str.find(substring, start)`: This line searches for the first occurrence of the substring starting from the current position `start`. The `.find()` method returns the index of the first character of the found substring or `-1` if no such substring exists.\n   \n4. **Update count and move forward**:\n   - If a substring is found (`pos != -1`), increment the count by 1 and update `start` to be one position after the current match (`start = pos + 1`). This ensures that overlapping substrings are counted.\n   - If no more occurrences of the substring can be found, break out of the loop.\n\n5. **Return result**:\n   - The function returns the total count of how many times the substring was found in the original string, including overlaps.\n\nThis approach effectively counts all instances of the substring, even if they overlap with each other or themselves within the main string."}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n// Function to convert integer back to word representation\nstring int_to_word(int num) {\n    map<int, string> num_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n        {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"},\n        {8, \"eight\"}, {9, \"nine\"}\n    };\n    return num_map[num];\n}\n\nstring sort_numbers(string numbers) {\n    // Mapping from word representation to integer value\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into individual words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Convert each word to its corresponding integer value using the mapping\n    vector<int> num_values;\n    for (const auto& w : num_words) {\n        num_values.push_back(num_map[w]);\n    }\n\n    // Sort the list of integers\n    sort(num_values.begin(), num_values.end());\n\n    // Convert the sorted integers back to their word representations\n    stringstream result;\n    for (int num : num_values) {\n        if (&num != &num_values.front()) {\n            result << \" \";\n        }\n        result << int_to_word(num);\n    }\n\n    return result.str();\n}\n\n", "py_code": "def sort_numbers(numbers):\n    # Mapping from string representation of numbers to their integer values\n    num_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into individual number words\n    num_words = numbers.split()\n    \n    # Convert each word to its corresponding integer value using the mapping\n    num_values = [num_map[word] for word in num_words]\n    \n    # Sort the list of integers\n    sorted_num_values = sorted(num_values)\n    \n    # Convert the sorted integers back to their string representations\n    sorted_num_words = [str(num) for num in sorted_num_values]\n    \n    # Join the words back into a single space-delimited string\n    return ' '.join(sorted_num_words)\n```\n\n", "py_summary": "The Python code defines a function `sort_numbers` that takes a space-delimited string of number words (from \"zero\" to \"nine\") and returns the string with numbers sorted from smallest to largest. Here's a detailed breakdown of how the function works:\n\n1. **Mapping Number Words to Integers**: \n   - A dictionary `num_map` is created to map each word representation of a number (\"zero\", \"one\", ..., \"nine\") to its corresponding integer value (0, 1, ..., 9).\n\n2. **Splitting Input String**:\n   - The input string `numbers` is split into individual words using the `split()` method, which splits on whitespace by default.\n\n3. **Converting Words to Integers**:\n   - A list comprehension is used to convert each word in `num_words` to its corresponding integer value using the `num_map`.\n\n4. **Sorting Integer Values**:\n   - The list of integers (`num_values`) is sorted using Python's built-in `sorted()` function.\n\n5. **Converting Integers Back to Words**:\n   - Another list comprehension converts each integer in `sorted_num_values` back to its corresponding word representation.\n\n6. **Joining the Sorted Words**:\n   - The sorted words are joined into a single space-delimited string using `' '.join(sorted_num_words)` and returned as the result.\n\nThis approach ensures that the input string is correctly parsed, converted, sorted, and then reassembled in the desired order.\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector of numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result;\n    \n    // Iterate through the sorted list to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    // Return the closest pair in a vector\n    return std::vector<float>{result.first, result.second};\n}\n", "py_code": "from typing import List\n\ndef find_closest_elements(numbers: List[float]) -> List[float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n    \n    return [result[0], result[1]]\n```\n\n", "py_summary": "The Python code defines a function `find_closest_elements` that takes a list of floating-point numbers and returns two numbers from this list that are closest to each other in ascending order.\n\nHere's a detailed analysis:\n\n1. **Sorting the List**: The input list `numbers` is first sorted using `numbers.sort()`. Sorting ensures that adjacent elements will be the closest possible candidates for being the minimum distance pair.\n\n2. **Initialization**:\n   - `min_diff` is initialized to positive infinity (`float('inf')`) to keep track of the smallest difference found between any two consecutive numbers.\n   - `result` is initialized as a tuple `(0, 0)` which will store the indices of the closest elements.\n\n3. **Finding Closest Elements**:\n   - A loop iterates through each element in the sorted list except for the last one (`range(len(numbers) - 1)`).\n   - For each pair of consecutive numbers `numbers[i]` and `numbers[i + 1]`, their difference is calculated.\n   - If this difference is smaller than the current minimum difference, `min_diff` is updated to this new value, and `result` is updated to store these two numbers.\n\n4. **Returning Result**:\n   - The function returns a list containing the closest pair of elements in ascending order `[result[0], result[1]]`.\n\nThis approach ensures that we efficiently find the closest pair by leveraging sorting and iterating through adjacent pairs only once, making it an O(n log n) solution due to the sort operation.\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_num = *min_element(numbers.begin(), numbers.end());\n    float max_num = *max_element(numbers.begin(), numbers.end());\n\n    // Calculate the range of the numbers\n    float range_num = max_num - min_num;\n\n    // Apply linear transformation to scale the values\n    for (float& num : numbers) {\n        if (range_num != 0) { // Avoid division by zero\n            num = (num - min_num) / range_num;\n        } else {\n            num = 0.0; // If all elements are the same, set them to 0\n        }\n    }\n\n    return numbers;\n}\n\n", "py_code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_num = max_num - min_num\n    \n    scaled_numbers = [(num - min_num) / range_num for num in numbers]\n    \n    return scaled_numbers\n```\n\n", "py_summary": "The Python code defines a function `rescale_to_unit` that takes a list of floating-point numbers and applies a linear transformation to scale the values such that the smallest number becomes 0 and the largest number becomes 1.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Find Minimum and Maximum Values**: The function first determines the minimum (`min_num`) and maximum (`max_num`) values in the input list `numbers`.\n\n2. **Calculate Range**: It calculates the range of the numbers, which is the difference between the maximum and minimum values (`range_num`).\n\n3. **Apply Linear Transformation**: For each number in the list, it applies a linear transformation to scale the value:\n   \\[\n   \\text{scaled\\_value} = \\frac{\\text{num} - \\text{min\\_num}}{\\text{range\\_num}}\n   \\]\n   This formula ensures that the smallest number is transformed to 0 and the largest number is transformed to 1, with all other numbers scaled proportionally between these two values.\n\n4. **Return Scaled Numbers**: The function returns a new list containing the scaled values.\n\nThis approach ensures that the output list has the same length as the input list, with each element rescaled according to the specified criteria.\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <string>\n#include <boost/any.hpp>\n\n// Define the list_any type as std::list<boost::any>\nusing list_any = std::list<boost::any>;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> filtered_ints;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            filtered_ints.push_back(intValue);\n        }\n    }\n\n    return filtered_ints;\n}\n\n", "py_code": "from typing import List\nimport boost.python as bp\n\ndef filter_integers(values):\n    filtered_ints = []\n    for value in values:\n        if isinstance(value, int):\n            filtered_ints.append(value)\n    return filtered_ints\n```\n\n", "py_summary": "The Python code defines a function `filter_integers` that takes a list of `boost::any` values and filters out only the integers from this list. Here's an analysis of how it works:\n\n1. **Function Definition**: The function `filter_integers(values)` is defined to take one argument, `values`, which is expected to be a list containing elements of type `boost::any`.\n\n2. **Initialization**: An empty list `filtered_ints` is initialized to store the integers found in the input list.\n\n3. **Iteration and Filtering**:\n   - The function iterates over each element in the input list `values`.\n   - For each element, it checks if the type of the element is an integer using `isinstance(value, int)`.\n   - If the condition is true (i.e., the value is an integer), the value is appended to the `filtered_ints` list.\n\n4. **Return Statement**: After iterating through all elements in the input list and filtering out only integers, the function returns the `filtered_ints` list containing the filtered integers.\n\n"}
{"task_id": "CPP/23", "generation": "#include <string>\n\nint strlen(std::string str) {\n    return str.length();\n}\n", "py_code": "def strlen(str):\n    return len(str)\n```\n\n", "py_summary": "The Python function `strlen` takes a string as input and returns its length using the built-in `len()` function. The `len()` function calculates the number of characters in the given string and returns this value.\n\nHere's a breakdown of how it works:\n1. **Input**: A string is passed to the function.\n2. **Processing**: The `len()` function computes the length of the string.\n3. **Output**: The length of the string is returned as an integer.\n\nThis approach leverages Python\u2019s built-in capabilities to determine the length of a string efficiently and concisely.\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // This line is technically not necessary as the function will always find a divisor, but it's good practice to have a return statement.\n    return 1;\n}\n", "py_code": "def largest_divisor(n):\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n```\n", "py_summary": "The Python function `largest_divisor` is designed to find the largest divisor of a given number `n` that is smaller than `n`. Here's an analysis of how it works:\n\n1. **Function Definition**: The function takes one parameter `n`, which is the integer for which we want to find the largest divisor.\n2. **Loop Initialization**: A loop starts from `n - 1` and decrements by 1 until it reaches 1 (`range(n - 1, 0, -1)`). This ensures that every number smaller than `n` is checked in descending order.\n3. **Divisibility Check**: Inside the loop, the function checks if `n % i == 0`, which means checking whether `i` divides `n` evenly (i.e., with no remainder).\n4. **Return Statement**: As soon as a divisor is found, it is returned immediately by the function. Since the loop starts from the largest possible number (`n - 1`) and moves downwards, this ensures that the first divisor encountered will be the largest one.\n\nThis approach guarantees that the function returns the largest divisor of `n` smaller than `n`, as soon as it finds one, making it efficient in terms of both time complexity and simplicity."}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        // Check if the current divisor is a factor of n\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;  // Divide n by the divisor to reduce it\n        }\n        divisor += 1;\n    }\n\n    return factors;\n}\n", "py_code": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    \n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    return factors\n```\n\n", "py_summary": "The Python code defines a function `factorize` that takes an integer `n` and returns a list of its prime factors in ascending order. Here's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - `factors`: An empty list to store the prime factors.\n   - `divisor`: A variable initialized to 2, which is the smallest prime number.\n\n2. **Main Loop**:\n   - The outer `while` loop continues as long as `n > 1`, ensuring that all factors are found until `n` becomes 1.\n   \n3. **Inner Loop**:\n   - The inner `while` loop checks if the current value of `divisor` is a factor of `n`. If it is, the divisor is added to the list of factors and `n` is divided by this divisor (`n //= divisor`). This ensures that all occurrences of the divisor are factored out.\n   - The inner loop continues until `n % divisor != 0`, meaning the current divisor no longer divides `n`.\n\n4. **Incrementing Divisor**:\n   - After exiting the inner loop, the divisor is incremented by 1 to check for the next potential factor.\n\n5. **Return Value**:\n   - Once the outer loop condition (`n > 1`) fails, all prime factors have been found and are stored in `factors`. The function returns this list of prime factors.\n\nThis approach ensures that each prime factor is included in the result as many times as it appears in the factorization of `n`, and the factors are returned in ascending order."}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> count_map;\n    vector<int> result;\n\n    for (int num : numbers) {\n        if (count_map[num] == 1 && result.size() > 0) {\n            // Remove the element from the result list\n            auto it = find(result.begin(), result.end(), num);\n            if (it != result.end()) {\n                result.erase(it);\n            }\n        } else if (count_map[num] == 0) {\n            // Add the element to both count_map and result\n            count_map[num]++;\n            result.push_back(num);\n        }\n\n        // Increment the count of the current number in the map\n        count_map[num]++;\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_map = {}\n    result = []\n    \n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 1\n            result.append(num)\n        elif count_map[num] == 1:\n            result.remove(num)  # Remove the element from the result list\n    \n        count_map[num] += 1\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `remove_duplicates` that takes a list of integers and returns a new list with all elements that occur more than once removed, while preserving the order of the remaining elements.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - A dictionary `count_map` is used to keep track of the count of each element in the input list.\n   - An empty list `result` is initialized to store the final result with duplicates removed.\n\n2. **Iterating through the Input List**:\n   - For each element `num` in the input list `numbers`, the function checks if `num` is already present in `count_map`.\n   \n3. **Adding Elements to Result**:\n   - If `num` is not in `count_map`, it means this is the first occurrence of `num`. The function adds `num` to both `count_map` and `result`.\n\n4. **Removing Duplicates**:\n   - If `num` is already in `count_map` but its count is 1 (indicating that `num` has been seen exactly once so far), the function removes `num` from `result`. This ensures that only elements occurring more than once are removed.\n\n5. **Updating Count Map**:\n   - The count of `num` in `count_map` is incremented by 1 to reflect its occurrence.\n\n6. **Returning Result**:\n   - After iterating through all the elements, the function returns the `result` list which contains only those elements that occur exactly once and maintains their original order from the input list.\n\nThis approach ensures that duplicates are removed while preserving the order of the remaining elements in the list."}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for toupper and tolower functions\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    for (char c : str) {\n        if (islower(c)) {\n            result += toupper(c);\n        } else {\n            result += tolower(c);\n        }\n    }\n    return result;\n}\n", "py_code": "def flip_case(s):\n    result = \"\"\n    for char in s:\n        if char.islower():\n            result += char.upper()\n        else:\n            result += char.lower()\n    return result\n```\n", "py_summary": "The Python function `flip_case` takes a string `s` as input and returns a new string where all lowercase letters are converted to uppercase and all uppercase letters are converted to lowercase.\n\n1. **Initialization**: An empty string `result` is initialized to store the transformed characters.\n2. **Iteration through Characters**: The function iterates over each character in the input string `s`.\n3. **Case Conversion**:\n   - If a character is determined to be lowercase using `char.islower()`, it converts the character to uppercase using `char.upper()` and appends it to `result`.\n   - Otherwise, if the character is uppercase (or any other non-lowercase character), it converts the character to lowercase using `char.lower()` and appends it to `result`.\n4. **Return Result**: After iterating through all characters in the input string, the function returns the transformed string stored in `result`.\n\nThis approach ensures that each character in the input string is appropriately flipped between uppercase and lowercase as required.\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n```\n\n", "py_summary": "The Python code defines a function `concatenate` that takes a list of strings as input and returns a single string formed by concatenating all the strings in the list.\n\n- The function uses the `join()` method of the string class to concatenate all elements of the input list into one continuous string. \n- If the input list is empty, `''.join([])` will return an empty string.\n- This approach ensures that the resulting string contains all characters from the input strings in the order they appear.\n\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    filtered_strings = [s for s in strings if s.startswith(prefix)]\n    return filtered_strings\n```\n\n", "py_summary": "The Python code defines a function `filter_by_prefix` that takes two parameters: a list of strings (`strings`) and a prefix string (`prefix`). The function filters the input list to include only those strings that start with the given prefix.\n\nHere's an analysis of how it works:\n1. **List Comprehension**: A list comprehension is used to iterate over each string `s` in the input list `strings`.\n2. **startswith Method**: For each string, the method `s.startswith(prefix)` checks if the string starts with the specified prefix.\n3. **Filtered List**: Only strings that start with the given prefix are included in the resulting list `filtered_strings`.\n\nThe function then returns this filtered list of strings.\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers;\n    \n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    return positive_numbers;\n}\n", "py_code": "from typing import List\n\ndef get_positive(l: List[float]) -> List[float]:\n    return [num for num in l if num > 0]\n```\n\n", "py_summary": "The Python code defines a function `get_positive` that takes a list of floats as input and returns a new list containing only the positive numbers from the original list.\n\nHere's an analysis of how this code works:\n1. **List Comprehension**: The function uses a list comprehension to iterate over each element in the input list `l`.\n2. **Condition Check**: For each element, it checks if the number is greater than 0.\n3. **Filtering Positive Numbers**: If the condition is true (i.e., the number is positive), it includes that number in the new list.\n4. **Return Result**: The function returns the filtered list containing only positive numbers.\n\nThis approach ensures that all negative and zero values are excluded from the output, leaving only the positive numbers in the returned list."}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <cmath>  // For sqrt and ceil functions\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= static_cast<long long>(sqrt(n)); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_prime` checks whether a given integer `n` is a prime number and returns `True` if it is, otherwise it returns `False`. Here's an analysis of how the function works:\n\n1. **Initial Check**: The function first checks if `n` is less than or equal to 1. Since neither 0 nor 1 are considered prime numbers, the function immediately returns `False` for these values.\n\n2. **Loop Through Potential Divisors**: For integers greater than 1, the function uses a loop that iterates from 2 up to and including the square root of `n`. This is because if `n` has any factors other than 1 and itself, at least one of those factors must be less than or equal to the square root of `n`.\n\n3. **Check for Divisibility**: Within the loop, the function checks whether `n` is divisible by the current value of `i`. If it finds a divisor (i.e., if `n % i == 0`), then `n` is not prime and the function returns `False`.\n\n4. **Return True if No Divisors Found**: If the loop completes without finding any divisors, the function concludes that `n` is prime and returns `True`.\n\nThis approach ensures efficient checking of primality by reducing the number of necessary divisibility checks to a minimum, specifically up to the square root of `n`."}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and guarantees a solution.\n    */\n    \n    double epsilon = 1e-6; // Tolerance level\n    double x = 0.5; // Initial guess for the root\n    \n    while (true) {\n        double fx = poly(xs, x);\n        if (abs(fx) < epsilon) break;\n        \n        // Compute the derivative of the polynomial at x\n        double dfx = 0;\n        int n = xs.size();\n        for (int i = 1; i < n; ++i) {\n            dfx += static_cast<double>(i) * xs[i] * pow(x, static_cast<int>(i - 1));\n        }\n        \n        // Update the guess using Newton's method\n        x -= fx / dfx;\n    }\n    \n    return x;\n}\n", "py_code": "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    \"\"\"\n    sum = 0.0\n    for i in range(len(xs)):\n        sum += xs[i] * (x ** i)\n    return sum\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds the value of x such that poly(x) = 0.\n    Returns only one zero point, even if there are many.\n    Assumes xs has an even number of coefficients and the largest non-zero coefficient is provided.\n    \"\"\"\n    # Use a simple iterative method to find the root\n    epsilon = 1e-6  # Tolerance level for convergence\n    x = 0.0  # Initial guess\n    \n    while True:\n        value = poly(xs, x)\n        if abs(value) < epsilon:\n            break\n        derivative_value = sum(i * xs[i] * (x ** (i - 1)) for i in range(1, len(xs)))\n        x -= value / derivative_value\n        \n    return x\n```\n\n", "py_summary": "The Python code defines two functions: `poly` and `find_zero`.\n\n1. **Function `poly`:**\n   - This function evaluates a polynomial with given coefficients at a specific point `x`.\n   - It takes a list of coefficients `xs` and a value `x`, and returns the result of the polynomial evaluation.\n   - The function iterates through each coefficient in `xs`, raising `x` to the power corresponding to the index of the coefficient, and accumulates the sum.\n\n2. **Function `find_zero`:**\n   - This function finds a root (zero point) of the polynomial defined by coefficients `xs`.\n   - It uses an iterative method similar to Newton's method to approximate the root.\n   - The function initializes with an initial guess for `x` and iteratively refines this guess until the value of the polynomial at `x` is close enough to zero (within a specified tolerance level, `epsilon`).\n   - The derivative of the polynomial is computed using the coefficients and used in the iterative update step.\n   - Once the value of the polynomial at `x` is sufficiently small (less than `epsilon`), the function returns this approximate root.\n\n### Summary:\n- **poly(xs, x):** Evaluates a polynomial with given coefficients at point `x`.\n- **find_zero(xs):** Finds an approximate zero of the polynomial using an iterative method. It assumes that the list of coefficients has an even number of elements and guarantees a solution based on this assumption.\n\nThis approach ensures that the function can find a root efficiently, leveraging the properties of polynomials with specific coefficient structures."}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3 and store them in a separate vector.\n    vector<int> third_indices_elements;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices_elements.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements in ascending order.\n    sort(third_indices_elements.begin(), third_indices_elements.end());\n\n    // Construct the result vector l_prime.\n    vector<int> l_prime;\n    size_t sorted_index = 0;\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            // Append the next element from the sorted list at indices divisible by 3.\n            l_prime.push_back(third_indices_elements[sorted_index++]);\n        } else {\n            // Keep other elements unchanged.\n            l_prime.push_back(l[i]);\n        }\n    }\n\n    return l_prime;\n}\n", "py_code": "from typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    # Extract elements at indices divisible by 3\n    third_indices_elements = [l[i] for i in range(len(l)) if (i + 1) % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_third_indices_elements = sorted(third_indices_elements)\n    \n    # Create a new list to store the result\n    l_prime = []\n    \n    # Iterate through the original list and construct the result list\n    for i in range(len(l)):\n        if (i + 1) % 3 == 0:\n            l_prime.append(sorted_third_indices_elements.pop(0))\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime\n```\n\n", "py_summary": "The Python code defines a function `sort_third` that takes a list of integers and returns a new list where elements at indices divisible by 3 are sorted in ascending order, while all other elements remain unchanged.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Extract Elements at Indices Divisible by 3**:\n   - The code uses a list comprehension to extract elements from the input list `l` that are located at indices divisible by 3 (i.e., positions 2, 5, 8, etc.). This is done using the condition `(i + 1) % 3 == 0`, where `i` is the index of the element in the list.\n\n2. **Sort the Extracted Elements**:\n   - The extracted elements are sorted in ascending order and stored in a new list called `sorted_third_indices_elements`.\n\n3. **Construct the Result List**:\n   - A new list `l_prime` is initialized to store the final result.\n   - The function iterates through each index of the input list `l`. For indices divisible by 3, it appends the next element from the sorted list `sorted_third_indices_elements` to `l_prime`.\n   - For all other indices, it simply appends the corresponding element from the original list `l`.\n\n4. **Return the Result**:\n   - The function returns the constructed list `l_prime`, which contains the elements of the input list with only those at indices divisible by 3 sorted in ascending order.\n\nThis approach ensures that the overall structure and non-divisible-by-3 elements remain unchanged, while the specific subset of elements at indices divisible by 3 are sorted as required."}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Convert vector to set to remove duplicates\n    auto it = unique(l.begin(), l.end());\n    l.erase(it, l.end());\n\n    // Sort the resulting vector\n    sort(l.begin(), l.end());\n\n    return l;\n}\n", "py_code": "from typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    # Convert list to a set to remove duplicates and then convert back to a sorted list\n    return sorted(set(l))\n```\n\n", "py_summary": "The Python code defines a function `unique` that takes a list of integers as input and returns a new list containing only the unique elements from the original list, sorted in ascending order.\n\nHere's a breakdown of how the function works:\n1. **Convert to Set**: The function first converts the input list `l` into a set using `set(l)`. This removes any duplicate values since sets cannot contain duplicates.\n2. **Sort the Set**: Next, it converts the set back into a list and sorts this list in ascending order using `sorted(set(l))`.\n3. **Return Result**: Finally, the function returns the sorted list of unique elements.\n\nThis approach ensures that all duplicates are removed and the remaining elements are returned in a sorted manner."}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) return 0; // Handle empty vector case\n\n    float max_val = l[0]; // Initialize the maximum value with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n", "py_code": "def max_element(l):\n    return max(l)\n```\n\n", "py_summary": "The Python code defines a function `max_element` that takes a list `l` as input and returns the maximum element in the list using the built-in `max()` function.\n\nHere's an analysis of how this works:\n1. The function receives a list `l`.\n2. It uses the `max()` function, which is a built-in Python function designed to return the largest item from the provided iterable (in this case, the list).\n3. The result returned by `max(l)` is then directly returned as the output of the `max_element` function.\n\nThis approach leverages Python's powerful and efficient built-in functions to find the maximum element in a list with minimal code.\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string num_str = std::to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n```\n\n", "py_summary": "The Python function `fizz_buzz` calculates the number of times the digit '7' appears in integers less than `n` that are divisible by either 11 or 13. Here's a detailed breakdown:\n\n1. **Initialization**:\n   - The variable `count` is initialized to zero, which will keep track of the total count of digit '7'.\n\n2. **Loop through numbers**:\n   - A loop iterates from 1 up to (but not including) `n`. For each integer `i` in this range:\n     - It checks if `i` is divisible by either 11 or 13 using the condition `if i % 11 == 0 or i % 13 == 0`.\n\n3. **Count occurrences of '7'**:\n   - If the number `i` satisfies the divisibility condition, it converts `i` to a string and counts how many times the digit '7' appears in this string using `str(i).count('7')`.\n   - The count is then added to the cumulative total stored in `count`.\n\n4. **Return result**:\n   - After iterating through all numbers less than `n`, the function returns the final value of `count`.\n\nThis approach ensures that only numbers divisible by 11 or 13 are considered, and within those numbers, it counts how many times '7' appears.\n\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract values at even indices (1-based index)\n    vector<float> even_indices_values;\n    for (int i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to keep odd indices unchanged\n    vector<float> result = l;\n\n    // Replace even index values with sorted values\n    int sorted_index = 0;\n    for (int i = 1; i < result.size(); i += 2) {\n        if (sorted_index < even_indices_values.size()) {\n            result[i] = even_indices_values[sorted_index++];\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef sort_even(l: List[float]) -> List[float]:\n    even_indices_values = [l[i] for i in range(1, len(l), 2)]\n    sorted_even_indices_values = sorted(even_indices_values)\n    \n    result = l[:]\n    for i, value in zip(range(1, len(l), 2), sorted_even_indices_values):\n        result[i] = value\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `sort_even` that takes a list of floats as input and returns a new list where the values at even indices are sorted while the values at odd indices remain unchanged.\n\nHere's a breakdown of how the function works:\n\n1. **Extract Even Index Values**: The first step is to extract all the elements from the original list `l` that are located at even indices (i.e., indices 1, 3, 5, etc.). This is done using a list comprehension:\n   ```python\n   even_indices_values = [l[i] for i in range(1, len(l), 2)]\n   ```\n\n2. **Sort the Extracted Values**: The extracted values are then sorted:\n   ```python\n   sorted_even_indices_values = sorted(even_indices_values)\n   ```\n\n3. **Create Result List**: A copy of the original list `l` is created to ensure that the original list remains unchanged:\n   ```python\n   result = l[:]\n   ```\n\n4. **Replace Even Index Values with Sorted Values**: The function then iterates over the even indices and replaces the values in the result list with the sorted values from the previous step:\n   ```python\n   for i, value in zip(range(1, len(l), 2), sorted_even_indices_values):\n       result[i] = value\n   ```\n\n5. **Return Result**: Finally, the modified `result` list is returned.\n\nThis approach ensures that the original list's odd-indexed values remain unchanged while the even-indexed values are sorted and placed back in their respective positions.\n\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string decoded_string = \"\";\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract a group of three characters or fewer.\n        string group = s.substr(i * 3, 3);\n        \n        if (group.length() == 3) {\n            // Reverse the cyclic shift applied during encoding.\n            group = group[1] + group[0] + group[2];\n        }\n        \n        decoded_string += group;\n    }\n\n    return decoded_string;\n}\n", "py_code": "def decode_cyclic(s):\n    decoded_string = \"\"\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            # Decoding by reversing the cyclic shift applied during encoding.\n            group = group[1] + group[0:1] + group[2:]\n        decoded_string += group\n    return decoded_string\n```\n\n", "py_summary": "The Python function `decode_cyclic` takes a string `s` as input and returns the original string before it was encoded using the cyclic shift method described in the problem statement.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The variable `decoded_string` is initialized to an empty string, which will store the final decoded result.\n2. **Loop through groups of three characters**: A loop iterates over the input string `s`, processing it in chunks of 3 characters at a time (or fewer if there are less than 3 characters left).\n   - The variable `i` is used to index into the string, and for each iteration, a substring `group` of length 3 or less is extracted from `s`.\n3. **Decoding logic**: \n   - If the group has exactly three characters (length == 3), it was encoded by shifting the first character to the second position and moving the rest accordingly.\n     - To decode this, the function shifts back by placing the second character of the encoded group at the beginning, followed by the first character, and then the third character remains unchanged.\n4. **Appending decoded groups**: The decoded `group` is appended to `decoded_string`.\n5. **Return result**: After processing all parts of the input string, the function returns the fully decoded string stored in `decoded_string`.\n\nThis approach ensures that each group of three characters (or fewer) is correctly reversed from its encoded form back to its original form.\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int a = 0, b = 1;\n    int count = 0;\n\n    while (true) {\n        int fib_num = a + b;\n        if (is_prime(fib_num)) {\n            count++;\n            if (count == n) return fib_num;\n        }\n        a = b;\n        b = fib_num;\n    }\n\n    // The loop will always terminate with the correct result, so no need for an explicit return here\n}\n\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n):\n    a, b = 0, 1\n    count = 0\n    while True:\n        fib_num = a + b\n        a, b = b, fib_num\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n```\n", "py_summary": "The Python code defines a function `prime_fib` that returns the n-th Fibonacci number which is also prime. The solution involves two main components: a helper function `is_prime` to check if a given number is prime and the main function `prime_fib`.\n\n1. **Helper Function (`is_prime`)**:\n   - This function takes an integer `num` as input.\n   - It returns `False` if the number is less than or equal to 1, since these numbers are not considered prime.\n   - For all other integers, it checks divisibility from 2 up to the square root of the number. If any divisor is found, it returns `False`. Otherwise, it returns `True`.\n\n2. **Main Function (`prime_fib`)**:\n   - The function initializes two variables `a` and `b` with the first two Fibonacci numbers (0 and 1).\n   - It also initializes a counter `count` to keep track of how many prime Fibonacci numbers have been found.\n   - A while loop runs indefinitely until the n-th prime Fibonacci number is found:\n     - The next Fibonacci number (`fib_num`) is calculated as the sum of `a` and `b`.\n     - `a` and `b` are updated to continue generating the next Fibonacci numbers.\n     - If `fib_num` is a prime number (checked using `is_prime`), the counter `count` is incremented.\n     - When `count` equals `n`, the function returns `fib_num`.\n\nThis approach ensures that we generate Fibonacci numbers sequentially and check each one for primality until we find the n-th such number."}
{"task_id": "CPP/40", "generation": "#include <vector>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    n = len(l)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n```\n\n", "py_summary": "The Python code defines a function `triples_sum_to_zero` that takes a list of integers as input and returns `True` if there are three distinct elements in the list that sum to zero, and `False` otherwise.\n\nHere's an analysis of how the function works:\n\n1. **Initialization**: The function starts by determining the length of the input list `l`.\n\n2. **Nested Loops for Triple Selection**:\n   - The outermost loop iterates over each element in the list using index `i`.\n   - The middle loop iterates from `i+1` to the end of the list, using index `j`. This ensures that we are selecting two distinct elements.\n   - The innermost loop iterates from `j+1` to the end of the list, using index `k`, ensuring all three selected elements are distinct.\n\n3. **Sum Calculation and Check**:\n   - For each combination of indices `(i, j, k)`, the function calculates the sum of the corresponding elements `l[i] + l[j] + l[k]`.\n   - If this sum equals zero, the function immediately returns `True`.\n\n4. **Return False if No Triple Found**: \n   - If no such triple is found after checking all possible combinations, the function returns `False`.\n\nThis approach ensures that every combination of three distinct elements in the list is checked for a sum of zero.\n\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each left-to-right car will collide with one right-to-left car.\n    return n;\n}\n", "py_code": "def car_race_collision(n):\n    # Since all cars are moving towards each other at the same speed and there is an equal number of cars on both sides,\n    # every left-to-right car will eventually collide with a right-to-left car.\n    return n\n```\n\n", "py_summary": "### Analysis of Python Code\n\nThe function `car_race_collision` takes an integer `n` as input and returns the number of collisions that occur in the described scenario.\n\n1. **Scenario Understanding**:\n   - There are `n` cars moving from left to right.\n   - There are also `n` cars moving from right to left.\n   - All cars move at the same speed.\n   - Each car will eventually collide with a car coming from the opposite direction because they start far apart and continue moving towards each other.\n\n2. **Logic**:\n   - Since there is an equal number of cars on both sides (left-to-right and right-to-left) and all cars are moving at the same speed, every left-moving car will eventually collide with a right-moving car.\n   - Therefore, the total number of collisions will be exactly `n`.\n\n3. **Implementation**:\n   - The function simply returns `n` because each of the `n` left-moving cars will collide with one of the `n` right-moving cars.\n\nThis straightforward logic ensures that the function correctly calculates the number of collisions based on the given conditions.\n\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n", "py_code": "def incr_vector(l):\n    return [x + 1 for x in l]\n```\n\n", "py_summary": "The Python code defines a function `incr_vector` that takes a list of integers as input and returns a new list where each element is incremented by 1.\n\nHere's an analysis of how this function works:\n- The function uses a list comprehension to iterate over each element in the input list `l`.\n- For each element `x` in the list, it adds 1 to `x` and includes the result in the new list.\n- The resulting list is then returned.\n\nThis approach ensures that every element in the original list is incremented by 1, and a new list with these updated values is returned. This solution is concise and leverages Python's powerful list comprehension feature for efficient processing.\n\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen_numbers;\n    for (int number : l) {\n        if (seen_numbers.find(-number) != seen_numbers.end()) {\n            return true;\n        }\n        seen_numbers.insert(number);\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    seen_numbers = set()\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    return False\n```\n\n", "py_summary": "The Python function `pairs_sum_to_zero` checks whether there are two distinct elements in a given list that sum to zero. Here's an analysis of how it works:\n\n1. **Initialization**: A set called `seen_numbers` is initialized to keep track of numbers encountered so far.\n2. **Iteration through the List**: The function iterates over each number in the input list `l`.\n3. **Check for Complement**: For each number, it checks if its negation (`-number`) has already been seen (i.e., exists in the set `seen_numbers`).\n4. **Update Set and Return True**: If a complement is found, the function immediately returns `True`.\n5. **Add Number to Set**: If no complement is found for the current number, it adds the number to the set `seen_numbers`.\n6. **Return False if No Pairs Found**: After iterating through all numbers without finding any pair that sums to zero, the function returns `False`.\n\nThis approach ensures efficient checking by leveraging the properties of a set (average O(1) time complexity for lookups and insertions), making it suitable for large lists.\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n\n", "py_code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    \n    result = \"\"\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x //= base\n    \n    return result\n```\n\n", "py_summary": "The Python function `change_base` converts a given integer `x` to its string representation in a specified base (which is less than 10). Here's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if `x` is zero. If so, it returns the string `\"0\"` immediately because zero in any base is represented as \"0\".\n\n2. **Initialization**: A variable `result` is initialized to an empty string. This will store the final converted number as a string.\n\n3. **Conversion Loop**:\n   - The function enters a loop that continues until `x` becomes zero.\n   - In each iteration, it calculates the remainder of `x` when divided by `base`. This remainder represents the least significant digit in the new base representation.\n   - The remainder is converted to a string and prepended to `result`.\n   - `x` is then updated to be the quotient of `x` divided by `base`, effectively reducing it for the next iteration.\n\n4. **Return Result**: Once the loop exits (i.e., when `x` becomes zero), the function returns the accumulated result, which now contains the string representation of `x` in the specified base.\n\nThis approach ensures that the number is converted correctly and efficiently to any base less than 10."}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n", "py_code": "def triangle_area(a: float, h: float) -> float:\n    return 0.5 * a * h\n```\n\n", "py_summary": "The Python function `triangle_area` calculates the area of a triangle given its base length (`a`) and height (`h`). The formula for the area of a triangle is:\n\n\\[ \\text{Area} = 0.5 \\times \\text{base} \\times \\text{height} \\]\n\nIn this code, the function takes two parameters: `a` (the base) and `h` (the height). It then returns the computed area by multiplying the base length with the height and dividing the result by 2.\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    \n    int a = 0, b = 0, c = 2, d = 0; // Initial values for fib4(0), fib4(1), fib4(2), and fib4(3)\n    int temp_d;\n\n    while (n > 3) {\n        temp_d = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = temp_d;\n        n--;\n    }\n\n    return d; // Return the nth element of fib4 sequence\n}\n\n", "py_code": "def fib4(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(3, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d\n```\n\n", "py_summary": "The Python function `fib4(n)` computes the n-th element of the Fib4 sequence without using recursion. Here's an analysis of how it works:\n\n1. **Base Cases**: The function first handles the base cases:\n   - If `n` is 0 or 1, return 0.\n   - If `n` is 2, return 2.\n\n2. **Initialization**: For values of `n` greater than 2, initialize four variables `a`, `b`, `c`, and `d` to represent the first four elements of the sequence:\n   - `a = fib4(0) = 0`\n   - `b = fib4(1) = 0`\n   - `c = fib4(2) = 2`\n   - `d = fib4(3) = 0`\n\n3. **Iterative Calculation**: Use a loop to iteratively calculate the subsequent elements of the sequence up to `n`:\n   - For each iteration from 3 to `n`, update the variables as follows:\n     ```python\n     a, b, c, d = b, c, d, a + b + c + d\n     ```\n   This updates the values in such a way that at each step, `d` holds the value of `fib4(i)` for the current iteration.\n\n4. **Return Result**: After completing the loop, return the value of `d`, which now contains the n-th element of the Fib4 sequence.\n\nThis approach ensures that the function efficiently computes the desired value without the overhead and potential stack overflow risks associated with recursion."}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm>\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n", "py_code": "from typing import List\n\ndef median(l: List[float]) -> float:\n    n = len(l)\n    l.sort()\n    \n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]\n```\n\n", "py_summary": "The Python code defines a function `median` that calculates and returns the median of elements in a given list `l`. Here's a detailed analysis:\n\n1. **Sorting the List**: The first step is to sort the list `l` using `l.sort()`. Sorting ensures that the elements are arranged in ascending order, which is necessary for finding the median.\n\n2. **Determining the Length of the List**: The length of the list `n` is calculated using `len(l)`.\n\n3. **Checking if the Length is Even or Odd**:\n   - If the length `n` is even (i.e., `n % 2 == 0`), the median is the average of the two middle elements.\n     - The two middle elements are at indices `n // 2 - 1` and `n // 2`.\n     - The function returns the average of these two elements: `(l[n // 2 - 1] + l[n // 2]) / 2`.\n\n   - If the length `n` is odd, the median is simply the middle element.\n     - The middle element is at index `n // 2`.\n     - The function returns this single element directly.\n\nThis approach ensures that the median is calculated correctly for both even and odd lengths of the list. Sorting is a crucial step to ensure elements are in order before determining the median.\n\n"}
{"task_id": "CPP/48", "generation": "#include <string>\n#include <algorithm>\n\nbool is_palindrome(std::string text) {\n    // Create a copy of the original string and reverse it\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    \n    // Compare the original string with the reversed one\n    return text == reversed_text;\n}\n", "py_code": "def is_palindrome(text: str) -> bool:\n    return text == text[::-1]\n```\n", "py_summary": "The Python function `is_palindrome` checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequences of characters that reads the same backward as forward.\n\nHere's an analysis of how the function works:\n\n1. **Input**: The function takes a single parameter `text`, which is a string.\n2. **Reversal**: It uses slicing to reverse the input string (`text[::-1]`). This slice notation means \"take all elements from start to end, but step backwards by 1\".\n3. **Comparison**: The function then checks if the reversed string is equal to the original string using `==`.\n4. **Return Value**: If the reversed string matches the original string, it returns `True`, indicating that the input text is a palindrome. Otherwise, it returns `False`.\n\nThis approach leverages Python's slicing capabilities for an efficient and concise way to determine if a string is a palindrome.\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Calculate 2^n using pow function and then take modulo p\n    long long result = static_cast<long long>(pow(2, n)) % p;\n    return static_cast<int>(result);\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    cout << \"modp(3, 5) = \" << modp(3, 5) << endl; // Expected: 3\n    cout << \"modp(1101, 101) = \" << modp(1101, 101) << endl; // Expected: 2\n    cout << \"modp(0, 101) = \" << modp(0, 101) << endl; // Expected: 1\n    cout << \"modp(3, 11) = \" << modp(3, 11) << endl; // Expected: 8\n    cout << \"modp(100, 101) = \" << modp(100, 101) << endl; // Expected: 1\n}\n\n", "py_code": "def modp(n: int, p: int) -> int:\n    result = pow(2, n, p)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `modp` that calculates \\(2^n \\mod p\\). The function uses the built-in `pow` function with three arguments: `pow(base, exp, mod)`, which efficiently computes \\((base^{exp}) \\mod mod\\).\n\nHere's a breakdown of how it works:\n1. **Function Definition**: The function `modp(n, p)` takes two integer parameters, `n` and `p`.\n2. **Calculation**: It uses the `pow` function with arguments `(2, n, p)`, which computes \\(2^n \\mod p\\).\n3. **Return Value**: The result of this computation is returned directly.\n\nThe use of `pow` with three arguments ensures that the calculation is done efficiently and avoids potential overflow issues when dealing with large numbers.\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] - 'a' + 5) % 26) + 'a';\n        out += char(w);\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] - 'a' - 5 + 26) % 26) + 'a';\n        out += char(w);\n    }\n    return out;\n}\n\n", "py_code": "def encode_shift(s):\n    out = \"\"\n    for char in s:\n        w = (ord(char) + 5 - ord('a')) % 26 + ord('a')\n        out += chr(w)\n    return out\n\ndef decode_shift(s):\n    out = \"\"\n    for char in s:\n        w = (ord(char) - 5 - ord('a') + 26) % 26 + ord('a')\n        out += chr(w)\n    return out\n```\n\n", "py_summary": "### Analysis of Python Code\n\n#### `encode_shift` Function:\nThe `encode_shift` function takes a string `s` as input and returns an encoded version of that string by shifting each character 5 positions forward in the alphabet. Here's how it works:\n\n1. **Initialization**: An empty string `out` is initialized to store the encoded result.\n2. **Iteration**: The function iterates over each character `char` in the input string `s`.\n3. **Character Encoding**:\n   - Convert the character to its ASCII value using `ord(char)`.\n   - Shift the character by 5 positions: `(ord(char) + 5)`.\n   - Adjust for wrapping around the alphabet (assuming lowercase letters only): `((ord(char) + 5 - ord('a')) % 26)`.\n   - Convert back to an ASCII value within the range of 'a' to 'z': `((ord(char) + 5 - ord('a')) % 26 + ord('a'))`.\n4. **Appending Encoded Character**: The encoded character is appended to the output string `out`.\n\n#### `decode_shift` Function:\nThe `decode_shift` function takes a string `s` that has been encoded using the `encode_shift` function and returns the original decoded string by shifting each character 5 positions backward in the alphabet. Here's how it works:\n\n1. **Initialization**: An empty string `out` is initialized to store the decoded result.\n2. **Iteration**: The function iterates over each character `char` in the input string `s`.\n3. **Character Decoding**:\n   - Convert the character to its ASCII value using `ord(char)`.\n   - Shift the character by 5 positions backward: `(ord(char) - 5)`.\n   - Adjust for wrapping around the alphabet (assuming lowercase letters only): `((ord(char) - 5 - ord('a') + 26) % 26)`.\n   - Convert back to an ASCII value within the range of 'a' to 'z': `((ord(char) - 5 - ord('a') + 26) % 26 + ord('a'))`.\n4. **Appending Decoded Character**: The decoded character is appended to the output string `out`.\n\n### Summary\n- Both functions handle lowercase letters only and ensure that characters wrap around the alphabet correctly.\n- The encoding function shifts each character forward by 5 positions, while the decoding function shifts each character backward by 5 positions.\n\nThis approach ensures that the encoded string can be accurately decoded back to its original form."}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char ch) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(ch) != string::npos;\n}\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    for (char ch : text) {\n        if (!isVowel(ch)) {\n            result += ch;\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result\n```\n\n", "py_summary": "The Python function `remove_vowels` takes a string `text` as input and returns a new string with all vowels removed. Here's a detailed analysis of how it works:\n\n1. **Initialization**:\n   - The variable `vowels` is initialized to contain all the vowel characters in both lowercase and uppercase.\n   \n2. **Result Initialization**:\n   - An empty string `result` is created to store the final output without vowels.\n\n3. **Iteration through Characters**:\n   - A for loop iterates over each character in the input string `text`.\n   - For each character, it checks if the character is not present in the `vowels` string.\n   \n4. **Building the Result String**:\n   - If a character is not a vowel, it is appended to the `result` string.\n\n5. **Return Statement**:\n   - After iterating through all characters, the function returns the `result` string which contains only consonants and other non-vowel characters from the input text.\n\nThis approach ensures that all vowels are removed efficiently while preserving the order of the remaining characters in the original string.\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def below_threshold(l: list, t: int) -> bool:\n    for num in l:\n        if num >= t:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `below_threshold` checks whether all numbers in a given list are below a specified threshold. Here's an analysis of how it works:\n\n1. **Function Definition**: The function takes two parameters: a list `l` and an integer `t`.\n2. **Iteration through the List**: It iterates through each element `num` in the list `l`.\n3. **Threshold Check**: For each number, it checks if the number is greater than or equal to the threshold `t`. If any number meets this condition (i.e., `num >= t`), the function immediately returns `False`, indicating that not all numbers are below the threshold.\n4. **Return True**: If the loop completes without finding any number that is greater than or equal to the threshold, the function returns `True`, indicating that all numbers in the list are indeed below the threshold.\n\nThis approach ensures that the function efficiently determines whether all elements in the list meet the condition of being below the specified threshold."}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x: int, y: int) -> int:\n    return x + y\n```\n\n", "py_summary": "The Python code defines a function `add` that takes two integer parameters, `x` and `y`, and returns their sum. The function simply uses the addition operator (`+`) to add the two numbers together and then returns the result.\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Convert strings to sets of characters\n    set<char> set_s0(s0.begin(), s0.end());\n    set<char> set_s1(s1.begin(), s1.end());\n\n    // Check if both sets are equal\n    return set_s0 == set_s1;\n}\n\n", "py_code": "def same_chars(s0: str, s1: str) -> bool:\n    # Convert strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if both sets are equal\n    return set_s0 == set_s1\n```\n\n", "py_summary": "The Python function `same_chars` checks whether two strings have the same set of characters. Here's a detailed analysis:\n\n1. **Convert Strings to Sets**: \n   - The function converts each string (`s0` and `s1`) into sets (`set_s0` and `set_s1`). This conversion removes duplicate characters from each string, ensuring that only unique characters are considered.\n   \n2. **Check Equality**:\n   - The function then checks if the two sets of characters (`set_s0` and `set_s1`) are equal using the equality operator (`==`). If both sets contain exactly the same elements (regardless of their order or frequency), the condition evaluates to `True`.\n\n3. **Return Result**:\n   - Finally, the function returns a boolean value indicating whether the two strings have the same set of characters.\n\nThis approach ensures that the function correctly identifies if both strings contain the exact same unique characters, regardless of the number of occurrences or order within each string.\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = b;\n            b = a + b;\n            a = temp;\n        }\n        return b;\n    }\n}\n", "py_code": "def fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\n", "py_summary": "The Python function `fib(n)` calculates the nth Fibonacci number using an iterative approach. Here's a detailed breakdown of how it works:\n\n1. **Base Cases**:\n   - If `n` is less than or equal to 0, the function returns 0.\n   - If `n` is exactly 1, the function returns 1.\n\n2. **Iterative Calculation**:\n   - For values of `n` greater than 1, two variables `a` and `b` are initialized to represent the first two Fibonacci numbers (0 and 1).\n   - A loop runs from 2 to `n`, updating `a` and `b` in each iteration. The variable `a` holds the current Fibonacci number, while `b` holds the next one.\n   - In each iteration, `a` is updated to the value of `b`, and `b` is updated to the sum of the previous values of `a` and `b`.\n\n3. **Return Result**:\n   - After completing the loop, the function returns the value of `b`, which represents the nth Fibonacci number.\n\nThis approach ensures that the function efficiently calculates the nth Fibonacci number in O(n) time complexity with constant space usage (O(1)).\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            s.push(bracket);\n        } else if (bracket == '>') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append('<')\n        elif bracket == '>':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n```\n\n", "py_summary": "The Python function `correct_bracketing` checks whether a given string of brackets is correctly bracketed with every opening bracket having a corresponding closing bracket.\n\n1. **Initialization**: An empty stack is initialized to keep track of unmatched opening brackets.\n2. **Iteration through Brackets**: The function iterates over each character in the input string `brackets`.\n   - If an opening bracket `<` is encountered, it is pushed onto the stack.\n   - If a closing bracket `>` is encountered:\n     - The function checks if there are any unmatched opening brackets by verifying if the stack is empty. If the stack is empty, this means there's no corresponding opening bracket for the current closing bracket, and thus the string is not correctly bracketed; the function returns `False`.\n     - If the stack is not empty, the topmost element (an opening bracket) is popped from the stack.\n3. **Final Check**: After iterating through all characters in the input string, if there are any unmatched opening brackets left in the stack, it means the string is not correctly bracketed; hence, the function returns `False`. If the stack is empty, meaning every opening bracket has a corresponding closing bracket, the function returns `True`.\n\nThis approach ensures that each opening bracket `<` is matched with exactly one closing bracket `>` and vice versa."}
{"task_id": "CPP/57", "generation": "#include <vector>\n\nbool monotonic(std::vector<float> l) {\n    if (l.empty()) {\n        return true;\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n", "py_code": "from typing import List\n\ndef monotonic(l: List[float]) -> bool:\n    if not l:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(l)):\n        if l[i] > l[i - 1]:\n            decreasing = False\n        elif l[i] < l[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing\n```\n\n", "py_summary": "The Python function `monotonic` checks if a list of numbers is either monotonically increasing or decreasing. Here's an analysis of how it works:\n\n1. **Initial Check for Empty List**: The function first checks if the input list `l` is empty. If it is, the function returns `True`. An empty list trivially satisfies both monotonic conditions (increasing and decreasing).\n\n2. **Initialization of Flags**: Two boolean flags are initialized: `increasing` and `decreasing`, both set to `True`. These flags will be used to track whether the sequence is monotonically increasing or decreasing.\n\n3. **Iterate Through List**: The function iterates through the list starting from the second element (index 1) to the end of the list.\n   - For each pair of consecutive elements, it checks if the current element (`l[i]`) is greater than the previous element (`l[i-1]`). If this condition holds true, it sets `decreasing` to `False`, indicating that the sequence cannot be monotonically decreasing.\n   - Similarly, if the current element is less than the previous element, it sets `increasing` to `False`, indicating that the sequence cannot be monotonically increasing.\n\n4. **Return Result**: After iterating through all elements, the function returns `True` if either `increasing` or `decreasing` remains `True`. This means the list is either monotonically increasing or decreasing (or both).\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert vectors to sets to find unique elements\n    set<int> set_l1(l1.begin(), l1.end());\n    set<int> set_l2(l2.begin(), l2.end());\n\n    // Find the intersection of both sets\n    set<int> common_elements;\n    set_intersection(set_l1.begin(), set_l1.end(),\n                     set_l2.begin(), set_l2.end(),\n                     inserter(common_elements, common_elements.begin()));\n\n    // Convert the result back to a sorted vector\n    return vector<int>(common_elements.begin(), common_elements.end());\n}\n", "py_code": "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    # Convert lists to sets to find unique common elements\n    set_l1 = set(l1)\n    set_l2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set_l1.intersection(set_l2)\n    \n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))\n```\n\n", "py_summary": "The Python code defines a function `common` that takes two lists of integers as input and returns a sorted list of unique common elements between them. Here's a detailed breakdown of how it works:\n\n1. **Convert Lists to Sets**: \n   - The function first converts the input lists `l1` and `l2` into sets (`set_l1` and `set_l2`). This step ensures that all elements are unique within each set.\n\n2. **Find Intersection**:\n   - It then finds the intersection of these two sets using the `intersection` method, which returns a new set containing only the common elements between `set_l1` and `set_l2`.\n\n3. **Convert to Sorted List**:\n   - The resulting set of common elements is converted back into a list.\n   - This list is then sorted in ascending order.\n\n4. **Return Result**:\n   - Finally, the function returns this sorted list of unique common elements.\n\nThis approach ensures that the output contains only the distinct elements present in both input lists and that these elements are returned in a sorted manner.\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int factor = 2;  // Initialize the smallest prime factor\n    int last_factor = 1;  // Keep track of the last prime factor\n\n    // Divide n by its smallest prime factors until it becomes a prime number\n    while (n > 1) {\n        if (n % factor == 0) {\n            last_factor = factor;\n            n /= factor;  // Divide n by factor\n        } else {\n            factor += 1;  // Move to the next potential factor\n        }\n    }\n\n    return last_factor;  // Return the largest prime factor\n}\n\n", "py_code": "import math\n\ndef largest_prime_factor(n):\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    \n    # Divide n by its smallest prime factors until it becomes a prime number\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n            \n    return last_factor\n```\n\n", "py_summary": "The Python function `largest_prime_factor` calculates and returns the largest prime factor of a given integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**: The smallest possible prime factor is initialized to 2 (`factor = 2`). Additionally, `last_factor` is set to 1 to keep track of the last prime factor that divides `n`.\n\n2. **Loop Until n Becomes Prime**: A while loop runs as long as `n > 1`. Inside this loop:\n   - The function checks if `n` is divisible by `factor`.\n   - If it is, then `last_factor` is updated to the current value of `factor`, and `n` is divided by `factor` (`n //= factor`). This step ensures that all factors of `n` are considered.\n   - If `n` is not divisible by `factor`, `factor` is incremented by 1.\n\n3. **Return Result**: Once the loop exits (i.e., when `n` becomes a prime number greater than 1), the function returns `last_factor`, which holds the largest prime factor of the original value of `n`.\n\nThis approach ensures that all factors are considered in ascending order, and the last updated `factor` will be the largest prime factor once the loop terminates.\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n", "py_code": "def sum_to_n(n):\n    return (n * (n + 1)) // 2\n```\n\n", "py_summary": "The Python function `sum_to_n` calculates the sum of all integers from 1 to `n`. The formula used is `(n * (n + 1)) // 2`, which is a well-known mathematical formula for finding the sum of the first `n` natural numbers.\n\nHere's an analysis of how this works:\n- **Formula Explanation**: The formula `(n * (n + 1)) // 2` comes from the arithmetic series sum formula. For any integer `n`, the sum of integers from 1 to `n` is given by this expression.\n- **Implementation**:\n  - The function takes an integer `n` as input.\n  - It calculates the sum using the formula `(n * (n + 1)) // 2`.\n  - The result is returned directly.\n\nThis approach ensures that the function efficiently computes the desired sum without needing to iterate through all numbers from 1 to `n`, making it very fast and suitable for large values of `n`.\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance += 1;\n        } else if (c == ')') {\n            balance -= 1;\n        }\n        // If at any point the balance is negative, it means there are more closing brackets than opening ones.\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, if balance is zero, all opening brackets have corresponding closing brackets.\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        # If at any point the balance is negative, it means there are more closing brackets than opening ones.\n        if balance < 0:\n            return False\n    # At the end, if balance is zero, all opening brackets have corresponding closing brackets.\n    return balance == 0\n```\n\n", "py_summary": "The Python function `correct_bracketing` checks whether a given string of parentheses is correctly bracketed. Here's an analysis of how it works:\n\n1. **Initialization**: The variable `balance` is initialized to 0. This variable keeps track of the balance between opening and closing brackets.\n\n2. **Iteration through the String**:\n   - For each character in the input string `brackets`, if the character is '(', the balance is incremented by 1.\n   - If the character is ')', the balance is decremented by 1.\n   \n3. **Checking for Imbalance**:\n   - During iteration, if at any point the balance becomes negative (`balance < 0`), it means there are more closing brackets than opening ones before this point, and thus the string cannot be correctly bracketed. The function immediately returns `False`.\n\n4. **Final Check**:\n   - After iterating through all characters in the string, if the final value of `balance` is zero (`balance == 0`), it means every opening bracket has a corresponding closing bracket, so the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the string is correctly bracketed by maintaining a running count of unmatched brackets and checking for any premature imbalance."}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "def derivative(xs):\n    return [i * x for i, x in enumerate(xs) if i > 0]\n```\n\n", "py_summary": "The Python function `derivative` calculates the derivative of a polynomial represented by its coefficients. Here's an analysis of how it works:\n\n1. **Input**: The input is a list `xs`, where each element represents the coefficient of the corresponding power of \\( x \\) in the polynomial.\n2. **Output**: The output is a new list representing the coefficients of the derivative polynomial.\n\nThe function uses a list comprehension to generate the coefficients of the derivative:\n- It iterates over the indices and values of `xs` using `enumerate(xs)`.\n- For each coefficient, it multiplies the index (which corresponds to the power of \\( x \\)) by the value of the coefficient.\n- The condition `if i > 0` ensures that the constant term (index 0) is skipped since its derivative is zero.\n\nThus, the resulting list contains the coefficients of the derivative polynomial in the same form as the input polynomial. For example:\n- If `xs = [3, 1, 2, 4, 5]`, then the output will be `[1*1, 2*2, 3*4, 4*5]` which simplifies to `[1, 4, 12, 20]`.\n- If `xs = [1, 2, 3]`, then the output will be `[1*1, 2*2]` which simplifies to `[2, 6]`.\n\nThis approach ensures that the derivative is computed correctly and efficiently."}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    else if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initialize the first three values of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int temp = a + b + c;\n        a = b;\n        b = c;\n        c = temp;\n    }\n    return c;\n}\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for i in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c\n```\n\n", "py_summary": "The Python function `fibfib(n)` computes the n-th element of the FibFib number sequence efficiently using dynamic programming principles. Here's a detailed breakdown:\n\n1. **Base Cases**:\n   - If `n` is 0 or 1, the function returns 0.\n   - If `n` is 2, the function returns 1.\n\n2. **Initialization for Iterative Calculation**:\n   - For values of `n` greater than 2, the function initializes three variables: `a`, `b`, and `c`. These represent the FibFib numbers at positions `n-3`, `n-2`, and `n-1` respectively.\n     - `a = fibfib(n-3)`\n     - `b = fibfib(n-2)`\n     - `c = fibfib(n-1)`\n\n   Initially, these are set to the base cases:\n   - `a = 0`\n   - `b = 0`\n   - `c = 1`\n\n3. **Iterative Calculation**:\n   - The function then iterates from 3 up to `n` (inclusive).\n   - In each iteration, it updates the values of `a`, `b`, and `c` as follows:\n     - `a` takes the value of `b`.\n     - `b` takes the value of `c`.\n     - `c` is updated to be the sum of `a`, `b`, and `c`.\n\n4. **Return Result**:\n   - After completing the loop, the function returns the value of `c`, which holds the n-th FibFib number.\n\nThis approach ensures that each FibFib number is computed only once and stored in variables for reuse, making it efficient with a time complexity of O(n) and space complexity of O(1).\n\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    string vowels = \"aeiou\";\n    \n    // Convert input string to lowercase for case-insensitive comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Iterate through each character in the string\n    for (char c : s) {\n        if (vowels.find(c) != string::npos) {\n            count++;\n        }\n    }\n    \n    // Check if 'y' is at the end of the string and treat it as a vowel\n    if (!s.empty() && s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n", "py_code": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    \n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n            \n    # Check if 'y' is at the end of the string and treat it as a vowel\n    if s[-1].lower() == 'y':\n        count += 1\n        \n    return count\n```\n\n", "py_summary": "The Python function `vowels_count` takes a string `s` as input and returns the number of vowels in the string. The vowels considered are 'a', 'e', 'i', 'o', 'u'. Additionally, if the last character of the string is 'y' (case-insensitive), it is also counted as a vowel.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: \n   - `vowels` is initialized to a string containing all vowels.\n   - `count` is initialized to 0, which will keep track of the number of vowels found in the string.\n\n2. **Iterate through each character**:\n   - The function iterates over each character in the input string `s`.\n   - For each character, it checks if the lowercase version of the character (`char.lower()`) is present in the `vowels` string.\n   - If the character is a vowel, it increments the `count`.\n\n3. **Check for 'y' at the end**:\n   - After iterating through all characters, the function checks if the last character of the string (accessed using `s[-1]`) is 'y'.\n   - If the last character is 'y', it increments the `count` by 1.\n\n4. **Return the result**:\n   - Finally, the function returns the total count of vowels found in the string.\n\nThis approach ensures that all standard vowels are counted and also considers 'y' as a vowel if it appears at the end of the word.\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine length of number\n    int num_length = num_str.length();\n    \n    // Handle case where shift is greater than or equal to the number's length\n    if (shift >= num_length) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Compute effective shift value\n    shift %= num_length;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_length - shift) + num_str.substr(0, num_length - shift);\n    \n    return shifted_str;\n}\n", "py_code": "def circular_shift(x: int, shift: int) -> str:\n    num_str = str(x)\n    num_length = len(num_str)\n    \n    if shift >= num_length:\n        return num_str[::-1]\n    \n    shift %= num_length  # Handle cases where shift is greater than the number of digits\n    shifted_str = num_str[-shift:] + num_str[:-shift]\n    return shifted_str\n```\n\n", "py_summary": "The Python function `circular_shift` takes an integer `x` and an integer `shift` as input and returns a string representing the circular shift of the digits in `x`. Here's a detailed analysis:\n\n1. **Convert Integer to String**: The integer `x` is first converted to its string representation `num_str`.\n\n2. **Determine Length of Number**: The length of the number (i.e., the number of digits) is calculated and stored in `num_length`.\n\n3. **Handle Shift Greater Than Length**:\n   - If `shift` is greater than or equal to `num_length`, it means that a full rotation or more has occurred, so the function returns the reversed string of `num_str`.\n   \n4. **Compute Effective Shift**: To handle cases where `shift` is larger than necessary (e.g., shifting by 10 positions when there are only 5 digits), the effective shift value is computed using `shift %= num_length`. This ensures that the shift value is within the range of the number's length.\n\n5. **Perform Circular Shift**:\n   - The function constructs the shifted string by concatenating two parts: \n     - `num_str[-shift:]` which takes the last `shift` digits.\n     - `num_str[:-shift]` which takes all but the last `shift` digits from the start of the number.\n\n6. **Return Result**: Finally, the function returns the shifted string.\n\nThis approach ensures that the circular shift is correctly computed and handles edge cases where the shift value exceeds the length of the number by reversing it instead.\n\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int result = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            result += static_cast<int>(c);\n        }\n    }\n    return result;\n}\n", "py_code": "def digitSum(s):\n    result = 0\n    for char in s:\n        if char.isupper():\n            result += ord(char)\n    return result\n```\n\n", "py_summary": "The Python function `digitSum` calculates the sum of the ASCII values of all uppercase characters in a given string `s`. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `result` is initialized to 0. This will store the cumulative sum of the ASCII values of uppercase characters.\n\n2. **Iteration through Characters**: A for loop iterates over each character in the input string `s`.\n\n3. **Check Uppercase Character**: For each character, the function checks if it is an uppercase letter using the `isupper()` method.\n\n4. **Add ASCII Value to Result**: If the character is uppercase, its ASCII value (obtained using the `ord()` function) is added to `result`.\n\n5. **Return Result**: After iterating through all characters in the string, the function returns the final cumulative sum stored in `result`.\n\nThis approach ensures that only uppercase letters are considered and their corresponding ASCII values are summed up correctly.\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nint fruit_distribution(std::string s, int n) {\n    // Split the string into parts using spaces as delimiters.\n    std::istringstream iss(s);\n    std::vector<std::string> parts;\n    std::string part;\n\n    while (iss >> part) {\n        parts.push_back(part);\n    }\n\n    // Extract the number of apples and oranges from the split parts.\n    int num_apples = std::stoi(parts[0]);\n    \n    // Remove comma if present in the number of oranges\n    size_t pos = parts[3].find(',');\n    if (pos != std::string::npos) {\n        parts[3] = parts[3].substr(0, pos);\n    }\n    int num_oranges = std::stoi(parts[3]);\n\n    // Calculate the number of mangoes in the basket.\n    int num_mangoes = n - (num_apples + num_oranges);\n\n    return num_mangoes;\n}\n", "py_code": "def fruit_distribution(s: str, n: int) -> int:\n    # Split the string into parts based on spaces and commas\n    parts = s.split()\n    \n    # Extract the number of apples and oranges from the string\n    num_apples = int(parts[0])\n    num_oranges = int(parts[3].replace(',', ''))\n    \n    # Calculate the number of mangoes by subtracting the number of apples and oranges from the total fruits\n    num_mangoes = n - (num_apples + num_oranges)\n    \n    return num_mangoes\n```\n\n", "py_summary": "The Python function `fruit_distribution` takes a string `s` and an integer `n`, where `s` represents a sentence describing the number of apples and oranges in a basket, and `n` is the total number of fruits in the basket. The goal is to determine the number of mangoes in the basket.\n\nHere's a step-by-step analysis of how the function works:\n\n1. **Splitting the String**: \n   - The string `s` is split into parts based on spaces using `parts = s.split()`. This results in a list where each element corresponds to a word from the input sentence.\n   \n2. **Extracting Numbers**:\n   - The number of apples is extracted as an integer from the first part of the split string: `num_apples = int(parts[0])`.\n   - The number of oranges is extracted by taking the fourth part (index 3) and removing any commas, then converting it to an integer: `num_oranges = int(parts[3].replace(',', ''))`.\n\n3. **Calculating Mangoes**:\n   - The total number of mangoes in the basket is calculated by subtracting the sum of apples and oranges from the total number of fruits (`n`): \n     ```python\n     num_mangoes = n - (num_apples + num_oranges)\n     ```\n\n4. **Returning the Result**:\n   - The function returns the calculated number of mangoes.\n\nThis approach ensures that the input string is correctly parsed to extract the relevant numerical values and then uses these values to compute the desired result efficiently.\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = INT_MAX;\n    int index_of_smallest_even_value = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value || (arr[i] == smallest_even_value && i < index_of_smallest_even_value)) {\n                smallest_even_value = arr[i];\n                index_of_smallest_even_value = i;\n            }\n        }\n    }\n\n    if (smallest_even_value == INT_MAX) {\n        return {};\n    } else {\n        return {smallest_even_value, index_of_smallest_even_value};\n    }\n}\n", "py_code": "def pluck(arr):\n    smallest_even_value = float('inf')\n    index_of_smallest_even_value = -1\n    \n    for i, value in enumerate(arr):\n        if value % 2 == 0 and (smallest_even_value > value or (smallest_even_value == value and index_of_smallest_even_value > i)):\n            smallest_even_value = value\n            index_of_smallest_even_value = i\n            \n    if smallest_even_value == float('inf'):\n        return []\n    \n    return [smallest_even_value, index_of_smallest_even_value]\n```\n\n", "py_summary": "The Python function `pluck` is designed to find and return the node with the smallest even value from a given list of non-negative integers (representing nodes in a tree branch). If there are multiple nodes with the same smallest even value, it returns the one with the smallest index.\n\nHere's an analysis of how the code works:\n\n1. **Initialization**:\n   - `smallest_even_value` is initialized to infinity (`float('inf')`) to ensure any valid even number in the list will be smaller.\n   - `index_of_smallest_even_value` is initialized to `-1`, which acts as a placeholder since indices start from 0.\n\n2. **Iteration**:\n   - The function iterates through each element of the input list `arr` using `enumerate` to get both the index and value of each node.\n   \n3. **Condition Check**:\n   - For each node, it checks if the node's value is even (`value % 2 == 0`).\n   - If the current node\u2019s value is even and either smaller than the previously recorded smallest even value or equal to it but with a smaller index, then `smallest_even_value` and `index_of_smallest_even_value` are updated.\n\n4. **Result**:\n   - After iterating through all nodes, if no valid even number was found (`smallest_even_value` remains infinity), the function returns an empty list `[]`.\n   - Otherwise, it returns a list containing `[smallest_even_value, index_of_smallest_even_value]`.\n\nThis approach ensures that the smallest even value is identified and returned along with its correct index if there are multiple occurrences of this value."}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n\nint search(std::vector<int>& lst) {\n    // Create a frequency map to store the count of each integer in the list\n    std::unordered_map<int, int> frequency_dict;\n    \n    // Count the frequency of each integer in the list\n    for (const auto& num : lst) {\n        frequency_dict[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check each unique number to see if it meets the criteria\n    for (const auto& entry : frequency_dict) {\n        int num = entry.first;\n        int freq = entry.second;\n        \n        if (num <= freq && num > result) {\n            result = num;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef search(lst: List[int]) -> int:\n    frequency_dict = {}\n    \n    # Count the frequency of each integer in the list\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    \n    result = -1\n    # Check each unique number to see if it meets the criteria\n    for num, freq in frequency_dict.items():\n        if num <= freq and num > result:\n            result = num\n            \n    return result\n```\n\n", "py_summary": "The Python code defines a function `search` that takes a list of integers as input and returns the greatest integer that meets specific criteria: its frequency in the list is greater than or equal to the value of the integer itself.\n\n1. **Frequency Calculation**:\n   - A dictionary `frequency_dict` is used to store the frequency of each unique integer in the list.\n   - The function iterates through the input list and updates the count for each integer in the dictionary.\n\n2. **Finding the Result**:\n   - The variable `result` is initialized to `-1`, which will be returned if no integer meets the criteria.\n   - The function then iterates through the items of the frequency dictionary, checking each unique number to see if its frequency is greater than or equal to itself and if it is larger than the current value of `result`.\n   - If a number meets both conditions, `result` is updated with this number.\n\n3. **Return Statement**:\n   - After iterating through all numbers in the dictionary, the function returns the final value of `result`.\n\nThis approach ensures that we efficiently find and return the greatest integer meeting the specified criteria or `-1` if no such integer exists.\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    \n    while (!lst.empty()) {\n        // Append the minimum value from the remaining elements\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (lst.empty()) break;\n\n        // Append the maximum value from the remaining elements\n        result.push_back(lst.back());\n        lst.pop_back();\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    \n    while sorted_lst:\n        # Append the minimum value from the remaining elements\n        if sorted_lst:\n            result.append(sorted_lst.pop(0))\n        \n        # Append the maximum value from the remaining elements\n        if sorted_lst:\n            result.append(sorted_lst.pop())\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `strange_sort_list` that takes a list of integers and returns a new list in \"strange order.\" The strange sorting process involves repeatedly selecting the minimum value from the remaining elements, followed by the maximum value from the remaining elements until all elements are processed.\n\nHere's an analysis of how the Python code works:\n\n1. **Sorting the List**: \n   - The input list `lst` is first sorted in ascending order using `sorted(lst)`. This ensures that we can easily extract the minimum and maximum values sequentially.\n   \n2. **Initialization**:\n   - An empty result list `result` is initialized to store the final output.\n\n3. **Processing Elements**:\n   - The function enters a loop that continues until all elements from the sorted list are processed (`while sorted_lst:`).\n   - Inside the loop, it first appends the minimum value (the first element of the remaining sorted list) to `result` and removes it from `sorted_lst`.\n   - Then, if there are still elements left in `sorted_lst`, it appends the maximum value (the last element of the remaining sorted list) to `result` and removes it from `sorted_lst`.\n\n4. **Returning Result**:\n   - Once all elements have been processed, the function returns the `result` list which contains the elements in strange order.\n\nThis approach ensures that the output alternates between the minimum and maximum values of the remaining unprocessed elements until no more elements are left to process."}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle using the triangle inequality theorem\n    if ((a + b > c) && (b + c > a) && (c + a > b)) {\n        // Calculate the semi-perimeter of the triangle\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to two decimal places\n        return round(area * 100) / 100;\n    } else {\n        // If the sides do not form a valid triangle, return -1\n        return -1;\n    }\n}\n\n", "py_code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n```\n\n", "py_summary": "The Python function `triangle_area` calculates the area of a triangle given its three side lengths and returns it rounded to two decimal places if the sides form a valid triangle. Here's an analysis of how the function works:\n\n1. **Validation Check**: The function first checks whether the given side lengths can form a valid triangle using the triangle inequality theorem, which states that for any triangle with sides \\(a\\), \\(b\\), and \\(c\\):\n   - \\(a + b > c\\)\n   - \\(b + c > a\\)\n   - \\(c + a > b\\)\n\n2. **Semi-perimeter Calculation**: If the sides form a valid triangle, the function calculates the semi-perimeter (\\(s\\)) of the triangle:\n   \\[\n   s = \\frac{a + b + c}{2}\n   \\]\n\n3. **Area Calculation Using Heron's Formula**: The area of the triangle is then calculated using Heron's formula:\n   \\[\n   \\text{area} = \\sqrt{s(s - a)(s - b)(s - c)}\n   \\]\n   \n4. **Return Value**: If the sides form a valid triangle, the function returns the area rounded to two decimal places. Otherwise, it returns `-1`.\n\nThis approach ensures that only valid triangles are considered and their areas are calculated accurately.\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to the maximum possible weight\n    int sum = 0;\n    for (int i : q) {\n        sum += i;\n    }\n    if (sum > w) {\n        return false;\n    }\n\n    // Check if the vector is balanced (palindromic)\n    std::vector<int> reversed_q(q);\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    if (q != reversed_q) {\n        return false;\n    }\n    \n    return true;\n}\n", "py_code": "def will_it_fly(q, w):\n    # Check if the sum of elements is less than or equal to the maximum possible weight\n    if sum(q) > w:\n        return False\n    \n    # Check if the vector is balanced (palindromic)\n    if q != q[::-1]:\n        return False\n    \n    return True\n```\n\n", "py_summary": "The Python function `will_it_fly` checks whether an object represented by a list of integers `q` will fly based on two conditions: \n\n1. **Balanced Condition (Palindromic Vector):** The vector is considered balanced if it reads the same forwards and backwards, i.e., it is a palindrome.\n2. **Weight Condition:** The sum of all elements in the vector must be less than or equal to the maximum possible weight `w`.\n\nHere's a detailed breakdown:\n\n1. **Sum Check:**\n   - The function first calculates the sum of all elements in the list `q` using `sum(q)`.\n   - It then compares this sum with the given weight limit `w`. If the sum is greater than `w`, the object cannot fly, and the function returns `False`.\n\n2. **Balanced Condition Check:**\n   - The function checks if the vector `q` is a palindrome by comparing it to its reverse (`q[::-1]`). \n   - If `q` does not match `q[::-1]`, the vector is unbalanced, and the function returns `False`.\n   \n3. **Return True:**\n   - If both conditions are satisfied (the sum of elements is less than or equal to `w` and the vector is balanced), the function returns `True`.\n\nThis ensures that the object will fly only if it meets both criteria.\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n\nint smallest_change(std::vector<int>& arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n", "py_code": "def smallest_change(arr):\n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n```\n\n", "py_summary": "The Python function `smallest_change` calculates the minimum number of element changes required to make a given vector palindromic. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - `changes`: A counter initialized to 0, which will keep track of the number of changes needed.\n   - `left`: An index starting from the beginning of the array (index 0).\n   - `right`: An index starting from the end of the array (last index).\n\n2. **Loop**:\n   - The function uses a while loop that continues as long as `left` is less than `right`.\n   - Inside the loop, it checks if the elements at positions `left` and `right` are different (`arr[left] != arr[right]`). If they are different, it increments the `changes` counter by 1.\n   - After checking, it moves the `left` index one step to the right and the `right` index one step to the left.\n\n3. **Return**:\n   - The function returns the total number of changes needed (`changes`) once the loop completes.\n\nThis approach ensures that each pair of elements from opposite ends of the array is checked, and if they are not equal, a change is counted. By moving inward towards the center of the array, all necessary comparisons are made to determine the minimum number of changes required for the vector to become palindromic."}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint count_chars(const std::vector<std::string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 < count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    if count_chars(lst1) < count_chars(lst2):\n        return lst1\n    else:\n        return lst2\n```\n\n", "py_summary": "The Python code defines a function `total_match` that takes two lists of strings (`lst1` and `lst2`) as input and returns one of them based on the total number of characters in each list. Here's an analysis of how it works:\n\n1. **Helper Function**: The function includes a nested helper function `count_chars` which calculates the total number of characters in a given list of strings by summing up the lengths of all strings in the list.\n\n2. **Character Count Calculation**:\n   - `count_chars(lst1)` computes the total number of characters in `lst1`.\n   - `count_chars(lst2)` computes the total number of characters in `lst2`.\n\n3. **Comparison and Return**:\n   - The function compares the character counts of both lists.\n   - If the total number of characters in `lst1` is less than that in `lst2`, it returns `lst1`.\n   - Otherwise, it returns `lst2`.\n\n4. **Edge Case Handling**: \n   - If the two lists have an equal number of characters, the function will return the first list (`lst1`) as specified.\n\nThis approach ensures that the correct vector is returned based on the total character count criteria provided in the problem statement."}
{"task_id": "CPP/75", "generation": "#include <cmath>\n#include <vector>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if a number is the product of exactly three prime numbers\nbool is_multiply_of_three_primes(int a) {\n    std::vector<int> prime_factors;\n\n    // Check divisibility by 2\n    while (a % 2 == 0 && prime_factors.size() < 3) {\n        prime_factors.push_back(2);\n        a /= 2;\n    }\n\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(a); i += 2) {\n        while (a % i == 0 && prime_factors.size() < 3) {\n            if (is_prime(i)) {\n                prime_factors.push_back(i);\n            }\n            a /= i;\n        }\n    }\n\n    // Check the remaining number\n    if (a > 2 && is_prime(a)) {\n        prime_factors.push_back(a);\n    }\n\n    return prime_factors.size() == 3;\n}\n\n// Function declaration as per problem statement\nbool is_multiply_prime(int a) {\n    return is_multiply_of_three_primes(a);\n}\n", "py_code": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_of_three_primes(a):\n    prime_factors = []\n    \n    # Check divisibility by 2\n    while a % 2 == 0 and len(prime_factors) < 3:\n        prime_factors.append(2)\n        a //= 2\n    \n    # Check for odd factors\n    for i in range(3, int(sqrt(a)) + 1, 2):\n        while a % i == 0 and len(prime_factors) < 3:\n            if is_prime(i):\n                prime_factors.append(i)\n            a //= i\n            \n    # Check the remaining number\n    if a > 2 and is_prime(a):\n        prime_factors.append(a)\n\n    return len(prime_factors) == 3\n\n", "py_summary": "The Python code defines a function `is_multiply_of_three_primes` that checks whether a given number `a` is the product of exactly three prime numbers. Here's an analysis of how it works:\n\n1. **Prime Check Function (`is_prime`)**:\n   - This helper function determines if a number `n` is prime.\n   - It returns `False` for numbers less than or equal to 1.\n   - For other numbers, it checks divisibility from 2 up to the square root of `n`. If any divisor is found, it returns `False`; otherwise, it returns `True`.\n\n2. **Main Function (`is_multiply_of_three_primes`)**:\n   - The function initializes an empty list `prime_factors` to store prime factors.\n   - It first checks if `a` is divisible by 2 repeatedly and appends 2 to the `prime_factors` list until it is no longer divisible by 2. This ensures that all factors of 2 are accounted for.\n   - Next, it iterates through odd numbers starting from 3 up to the square root of `a`, checking divisibility similarly. If a factor is found and it is prime (checked using `is_prime`), it appends the factor to `prime_factors`.\n   - After handling all small factors, if there's any remaining number greater than 2 that is also prime, it gets appended to `prime_factors`.\n   - Finally, the function checks if exactly three prime factors have been found and returns `True` if so; otherwise, it returns `False`.\n\nThis approach ensures that only prime numbers are considered as factors and limits the search space efficiently by checking up to the square root of `a`."}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n\n    // Calculate the logarithm of x with base n\n    double log_result = log(x) / log(n);\n\n    // Check if the result is an integer\n    return floor(log_result + 0.5) == log_result;\n}\n", "py_code": "import math\n\ndef is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    \n    # Calculate the logarithm of x with base n\n    log_result = math.log(x) / math.log(n)\n    \n    # Check if the result is an integer\n    return log_result.is_integer()\n```\n\n", "py_summary": "The Python function `is_simple_power` checks whether a number \\( x \\) is a simple power of another number \\( n \\). The function works as follows:\n\n1. **Base Case Check**: If \\( n \\) is 1, then \\( x \\) must also be 1 for the condition to hold true.\n2. **Logarithm Calculation**: For other values of \\( n \\), the function calculates the logarithm of \\( x \\) with base \\( n \\). This is done using the change of base formula: \n   \\[\n   \\log_n(x) = \\frac{\\log(x)}{\\log(n)}\n   \\]\n3. **Integer Check**: The result of the logarithm calculation should be an integer if \\( x \\) is a simple power of \\( n \\). This is checked using the `is_integer()` method.\n4. **Return Result**: If the logarithm result is an integer, the function returns `True`; otherwise, it returns `False`.\n\nThis approach leverages the mathematical property that if \\( x = n^k \\) for some integer \\( k \\), then \\( \\log_n(x) = k \\) must be an integer."}
{"task_id": "CPP/77", "generation": "#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double root = cbrt(a);\n\n    // Round the cube root to the nearest integer\n    int rounded_root = round(root);\n\n    // Check if the cube of the rounded value equals the original number\n    return pow(rounded_root, 3) == a;\n}\n", "py_code": "import math\n\ndef iscube(a):\n    if a < 0:\n        root = -(-a) ** (1/3)\n    else:\n        root = a ** (1/3)\n    \n    # Check if the cube of the rounded value equals the original number\n    return round(root) ** 3 == a\n```\n\n", "py_summary": "The Python function `iscube(a)` checks whether an integer `a` is a perfect cube of some integer. Here's a detailed analysis:\n\n1. **Input Handling**: The function takes an integer `a` as input.\n2. **Root Calculation**:\n   - If `a` is negative, it calculates the cube root using `-(-a) ** (1/3)` to handle the sign correctly.\n   - For non-negative values of `a`, it directly computes the cube root using `a ** (1/3)`.\n3. **Rounding**: The cube root value is rounded to the nearest integer using `round(root)`. This step ensures that we are dealing with an integer when checking if it is a perfect cube.\n4. **Verification**:\n   - It checks whether the cube of the rounded value equals the original number `a`.\n5. **Return Value**: The function returns `True` if `a` is a perfect cube, otherwise it returns `False`.\n\nThis approach ensures that both positive and negative integers are correctly handled to determine if they are perfect cubes.\n\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <algorithm>\n\nint hex_key(std::string num) {\n    // Set of prime hexadecimal digits\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    \n    for (char digit : num) {\n        if (std::find(prime_hex_digits, prime_hex_digits + sizeof(prime_hex_digits)/sizeof(char), digit) != prime_hex_digits + sizeof(prime_hex_digits)/sizeof(char)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python function `hex_key` takes a hexadecimal number as a string and counts the number of hexadecimal digits that are prime numbers. Here's an analysis of how it works:\n\n1. **Initialization**: \n   - A set `prime_hex_digits` is defined containing the hexadecimal digits that represent prime numbers: '2', '3', '5', '7', 'B', and 'D'.\n   \n2. **Counting Prime Digits**:\n   - The function initializes a counter variable `count` to zero.\n   - It then iterates through each character in the input string `num`.\n   - For each digit, it checks if the digit is present in the set of prime hexadecimal digits using the membership test (`digit in prime_hex_digits`).\n   - If the digit is found in the set, the counter `count` is incremented by 1.\n\n3. **Return Result**:\n   - After iterating through all the characters in the string, the function returns the value of `count`, which represents the number of prime hexadecimal digits in the input string.\n\nThis approach ensures that only the specified prime hexadecimal digits are counted and provides an efficient way to solve the problem by leveraging set membership testing for quick lookups."}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <bitset>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the integer to a binary string using bitset\n    string binary_str = bitset<32>(decimal).to_string();\n    \n    // Remove leading zeros\n    size_t first_one = binary_str.find('1');\n    if (first_one != string::npos) {\n        binary_str = binary_str.substr(first_one);\n    } else {\n        binary_str = \"0\";  // Handle the case where decimal is 0\n    }\n    \n    // Add \"db\" at the beginning and end of the binary string\n    return \"db\" + binary_str + \"db\";\n}\n\n", "py_code": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # Convert decimal to binary and remove '0b' prefix\n    return f\"db{binary_str}db\"\n```\n\n", "py_summary": "The Python function `decimal_to_binary` converts a given decimal number to its binary representation and formats it according to the specified requirements. Here's an analysis of how the function works:\n\n1. **Convert Decimal to Binary**: The `bin()` function in Python is used to convert an integer (decimal) to its binary string representation, prefixed with '0b'. For example, `bin(15)` returns `'0b1111'`.\n\n2. **Remove Prefix**: To get the actual binary digits without the '0b' prefix, we slice the string starting from index 2 (`binary_str = bin(decimal)[2:]`).\n\n3. **Format Output**: The function then formats the binary string by adding \"db\" at both the beginning and end of the binary string to match the required format.\n\n4. **Return Result**: Finally, the formatted string is returned as `f\"db{binary_str}db\"`.\n\nThis ensures that the output matches the expected format with \"db\" at the start and end of the binary representation.\n\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3)\n        return false;\n    \n    // Iterate through each character up to the third-to-last character\n    for (int i = 0; i < s.length() - 2; ++i) {\n        // Check if any two out of three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2])\n            return false;\n    }\n    \n    // If no sets of three consecutive characters contain duplicates, return true\n    return true;\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n            return False\n    return True\n```\n\n", "py_summary": "The Python function `is_happy(s)` checks if a given string `s` is \"happy\" based on the specified conditions:\n\n1. **Initial Length Check**: The function first checks if the length of the string is less than 3. If it is, the function immediately returns `False`, as strings shorter than 3 characters cannot be happy by definition.\n\n2. **Iterate Through String**: For strings with a length of at least 3, the function iterates through each character in the string up to the third-to-last character (i.e., from index 0 to index `len(s) - 3`). This is because we need to check every set of three consecutive characters.\n\n3. **Check Consecutive Characters**: For each position `i`, the function checks if any two out of the three consecutive characters (`s[i]`, `s[i + 1]`, and `s[i + 2]`) are the same:\n   - If `s[i]` is equal to `s[i + 1]`\n   - Or, if `s[i + 1]` is equal to `s[i + 2]`\n   - Or, if `s[i]` is equal to `s[i + 2]`\n\n4. **Return Result**: If any set of three consecutive characters are not distinct (i.e., contain duplicates), the function returns `False`. If no such sets are found throughout the iteration, the function returns `True`.\n\nThis approach ensures that all conditions for a string being \"happy\" are thoroughly checked.\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f && gpa <= 4.0f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f && gpa <= 3.7f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f && gpa <= 3.3f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f && gpa <= 3.0f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f && gpa <= 2.7f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f && gpa <= 2.3f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f && gpa <= 2.0f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f && gpa <= 1.7f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f && gpa <= 1.3f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f && gpa <= 1.0f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f && gpa < 0.7f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n", "py_code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grades.append(\"A\")\n        elif gpa > 3.3:\n            letter_grades.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grades.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grades.append(\"B\")\n        elif gpa > 2.3:\n            letter_grades.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grades.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grades.append(\"C\")\n        elif gpa > 1.3:\n            letter_grades.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grades.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grades.append(\"D\")\n        elif gpa >= 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")  # In case of negative GPA or other edge cases\n    return letter_grades\n```\n\n", "py_summary": "The Python code defines a function `numerical_letter_grade` that takes a list of GPAs as input and returns a list of corresponding letter grades based on the provided grading scale. The function iterates through each GPA in the input list and uses a series of conditional statements to determine the appropriate letter grade for each GPA.\n\nHere's a detailed breakdown:\n1. **Initialization**: An empty list `letter_grades` is initialized to store the resulting letter grades.\n2. **Iteration**: For each GPA in the input list, the function checks its value against the grading criteria using a series of conditional (`if`, `elif`) statements.\n3. **Conditional Checks**:\n   - If the GPA is exactly 4.0, it assigns \"A+\".\n   - If the GPA is greater than 3.7 but less than or equal to 4.0, it assigns \"A\".\n   - Similar checks are made for other ranges (e.g., > 3.3 and <= 3.7 for \"A-\", etc.).\n4. **Edge Case Handling**: A default case (`else`) is included to handle any GPA that does not fall into the specified ranges or negative GPAs, assigning \"E\".\n5. **Appending Grades**: Each determined letter grade is appended to the `letter_grades` list.\n6. **Return Statement**: Finally, the function returns the list of letter grades.\n\nThis approach ensures that each GPA in the input list is accurately mapped to its corresponding letter grade based on the grading scale provided."}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n", "py_code": "def prime_length(s: str) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    length = len(s)\n    return is_prime(length)\n```\n\n", "py_summary": "The Python code defines a function `prime_length` that takes a string as input and returns `True` if the length of the string is a prime number, otherwise it returns `False`.\n\nHere's an analysis of how this works:\n\n1. **Helper Function (`is_prime`)**:\n   - The helper function `is_prime(n)` checks whether a given integer `n` is a prime number.\n   - It first handles edge cases where `n <= 1`, returning `False` because neither 0 nor 1 are prime numbers.\n   - Then, it iterates from 2 to the square root of `n`. If any number in this range divides `n` without leaving a remainder, `is_prime(n)` returns `False`.\n   - If no divisors are found within the range, `is_prime(n)` returns `True`.\n\n2. **Main Function (`prime_length`)**:\n   - The main function calculates the length of the input string `s`.\n   - It then calls the helper function `is_prime(length)` to determine if this length is a prime number.\n   - Finally, it returns the result from `is_prime(length)`.\n\nThis approach ensures that the function efficiently checks whether the length of the given string is a prime number by leveraging an optimized primality test in the helper function."}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    \n    long long start_with_1 = static_cast<long long>(pow(9, n - 1));\n    long long end_with_1_not_starting_with_1 = static_cast<long long>(8 * pow(9, n - 2));\n    long long overlap = static_cast<long long>(pow(9, n - 2));\n\n    return start_with_1 + end_with_1_not_starting_with_1 - overlap;\n}\n\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    \n    # For a number of length n, we can calculate how many numbers start or end with 1.\n    # Numbers starting with 1: There are 9^(n-1) such numbers (since the remaining n-1 digits can be anything from 0 to 9 except the first digit which is fixed as 1).\n    # Numbers ending with 1 but not starting with 1: For a number of length n, there are 8 * 9^(n-2) such numbers. The first digit cannot be 0 or 1 (hence 8 options), and each subsequent digit can be anything from 0 to 9 except the last one which is fixed as 1.\n    # However, we need to subtract the overlap where a number both starts and ends with 1, counted twice in the above calculations. There are 9^(n-2) such numbers (since the middle n-2 digits can be anything from 0 to 9).\n    \n    start_with_1 = 9 ** (n - 1)\n    end_with_1_not_starting_with_1 = 8 * 9 ** (n - 2)\n    both_start_and_end_with_1 = 9 ** (n - 2)\n\n    return start_with_1 + end_with_1_not_starting_with_1 - both_start_and_end_with_1\n```\n\n", "py_summary": "The Python function `starts_one_ends(n)` calculates the count of n-digit positive integers that start or end with 1. Here's a detailed breakdown of how it works:\n\n1. **Base Case**: If `n` is 1, then there is only one such number: \"1\". Hence, the function returns 1.\n\n2. **General Case**:\n   - **Numbers Starting with 1**: For an n-digit number starting with 1, the remaining (n-1) digits can be any digit from 0 to 9 except for the first digit which is fixed as 1. Therefore, there are \\(9^{(n-1)}\\) such numbers.\n   - **Numbers Ending with 1 but Not Starting with 1**: For an n-digit number ending with 1 and not starting with 1, the first digit can be any of {2, 3, ..., 9} (8 options), and each of the remaining (n-2) digits can be anything from 0 to 9. Therefore, there are \\(8 \\times 9^{(n-2)}\\) such numbers.\n   - **Overlap**: The overlap occurs when a number both starts and ends with 1. For an n-digit number starting and ending with 1, the middle (n-2) digits can be any digit from 0 to 9. Therefore, there are \\(9^{(n-2)}\\) such numbers.\n\n3. **Combining Results**: The total count is obtained by summing the counts of numbers that start with 1 and end with 1 but not starting with 1, then subtracting the overlap (numbers that both start and end with 1).\n\nThe formula used in the function:\n\\[ \\text{Total Count} = 9^{(n-1)} + 8 \\times 9^{(n-2)} - 9^{(n-2)} \\]\n\nThis ensures that we correctly account for all cases where an n-digit number starts or ends with 1 without double-counting the overlap.\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n\nstd::string solve(int N) {\n    // Convert integer to string to iterate over each digit\n    std::stringstream ss;\n    ss << N;\n    std::string str_N = ss.str();\n\n    // Initialize sum of digits\n    int digit_sum = 0;\n\n    // Iterate through each character in the string and add it to the digit sum\n    for (char c : str_N) {\n        digit_sum += c - '0';\n    }\n\n    // Convert the sum of digits to binary\n    std::string binary_sum;\n    if (digit_sum == 0) {\n        binary_sum = \"0\";\n    } else {\n        while (digit_sum > 0) {\n            binary_sum = std::to_string(digit_sum % 2) + binary_sum;\n            digit_sum /= 2;\n        }\n    }\n\n    return binary_sum;\n}\n", "py_code": "def solve(N):\n    # Convert the integer to a string to iterate over each digit\n    str_N = str(N)\n    \n    # Initialize sum of digits\n    digit_sum = 0\n    \n    # Iterate through each character in the string and add it to the digit sum\n    for char in str_N:\n        digit_sum += int(char)\n    \n    # Convert the sum of digits to binary\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n```\n\n", "py_summary": "The Python function `solve` takes an integer `N` as input and returns a string representing the binary form of the sum of its digits. Here's a detailed breakdown of how it works:\n\n1. **Convert to String**: The integer `N` is converted to a string (`str_N`). This allows us to iterate over each character in the number, treating each digit individually.\n\n2. **Initialize Sum**: A variable `digit_sum` is initialized to 0. This will store the cumulative sum of the digits as we process them.\n\n3. **Sum Digits**: The function iterates through each character in `str_N`. For each character (which represents a single digit), it converts that character back into an integer and adds it to `digit_sum`.\n\n4. **Convert Sum to Binary**: After calculating the sum of all digits, the function uses Python's built-in `bin` function to convert this sum into its binary representation. The `[2:]` slice is used to remove the '0b' prefix that `bin` adds to indicate a binary number.\n\n5. **Return Result**: Finally, the function returns the binary string representing the digit sum.\n\nThis approach ensures that we correctly compute and return the desired output for any given integer `N`."}
{"task_id": "CPP/85", "generation": "#include <vector>\n\nint add(std::vector<int>& lst) {\n    int result = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {  // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) {  // Check if the element at the odd index is even\n            result += lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def add(lst):\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2 (odd indices)\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            result += lst[i]\n    return result\n```\n\n", "py_summary": "The Python function `add` takes a list of integers as input and returns the sum of all even elements that are located at odd indices in the list.\n\nHere's an analysis of how the function works:\n1. **Initialization**: The variable `result` is initialized to 0, which will store the cumulative sum of the even elements found at odd indices.\n2. **Iteration through Odd Indices**: A for loop iterates over the range starting from index 1 (the first odd index) and increments by 2 in each step to ensure only odd indices are processed.\n3. **Check Even Condition**: Inside the loop, it checks if the element at the current odd index is even using the condition `lst[i] % 2 == 0`.\n4. **Summation**: If the element is even, its value is added to `result`.\n5. **Return Result**: After iterating through all elements, the function returns the cumulative sum stored in `result`.\n\nThis approach ensures that only even numbers at odd indices are considered and summed up correctly.\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    int word_start = 0;\n    \n    for (int i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] == ' ') {\n            // Extract the current word\n            string word = s.substr(word_start, i - word_start);\n            \n            // Sort the characters in the word\n            sort(word.begin(), word.end());\n            \n            // Append the sorted word to the result\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n            \n            // Move to the next word start position\n            word_start = i + 1;\n        }\n    }\n    \n    return result;\n}\n\n", "py_code": "from typing import List\n\ndef anti_shuffle(s: str) -> str:\n    words = s.split()\n    result = []\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n    \n    return ' '.join(result)\n```\n\n", "py_summary": "The Python code defines a function `anti_shuffle` that takes a string `s` and returns an ordered version of it according to the specified rules:\n\n1. **Splitting the String**: The input string is split into words based on spaces using `split()`. This creates a list of words.\n2. **Sorting Each Word**: For each word in the list, the characters are sorted in ascending order based on their ASCII values using `sorted(word)`.\n3. **Joining Sorted Characters**: The sorted characters for each word are joined back into a string using `''.join(sorted_word)`.\n4. **Reconstructing the Sentence**: The processed words (with sorted characters) are then joined back together with spaces in between to form the final ordered version of the sentence.\n\nThe function ensures that:\n- The order of words and blank spaces is preserved.\n- Each word's characters are arranged in ascending ASCII value order.\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<std::vector<int>> result;\n\n    // Iterate through each row in the nested vector\n    for (size_t row_index = 0; row_index < lst.size(); ++row_index) {\n        const auto& row = lst[row_index];\n        \n        // Iterate through each element in the current row\n        for (size_t col_index = 0; col_index < row.size(); ++col_index) {\n            if (row[col_index] == x) {\n                // Append coordinates to result, adjusting column index to be in descending order\n                result.push_back({static_cast<int>(row_index), static_cast<int>(row.size() - 1 - col_index)});\n            }\n        }\n    }\n\n    // Sort the result by row index in ascending order and then by column index in descending order\n    std::sort(result.begin(), result.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1];\n        }\n        return a[0] < b[0];\n    });\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append([row_index, len(row) - 1 - col_index])\n                \n    # Sort by row index in ascending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `get_row` that takes a nested list `lst` and an integer `x`, and returns a list of coordinates where `x` is found in `lst`. The function works as follows:\n\n1. **Initialization**: An empty list `result` is initialized to store the coordinates.\n2. **Iterate through rows and columns**: The function iterates over each row and column of the nested list using two nested loops:\n   - `row_index, row` iterates over the index and content of each row in `lst`.\n   - `col_index, value` iterates over the index and value of each element within a given row.\n3. **Check for target value**: If an element's value matches `x`, its coordinates `[row_index, col_index]` are appended to `result`. Note that `col_index` is adjusted to be in descending order by using `len(row) - 1 - col_index`.\n4. **Sort the result**: The list of coordinates is sorted first by row index in ascending order and then by column index in descending order.\n5. **Return the result**: Finally, the function returns the sorted list of coordinates.\n\nThis approach ensures that all occurrences of `x` are found and their coordinates are returned in the specified order.\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_vector(vector<int> array) {\n    if (array.empty()) {\n        return {};\n    }\n\n    int first_value = array[0];\n    int last_value = array.size() > 1 ? array.back() : first_value;\n    \n    int sum_of_edges = first_value + last_value;\n\n    vector<int> sorted_array(array); // Make a copy of the original array\n\n    if (sum_of_edges % 2 == 0) { // Even\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else { // Odd\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n", "py_code": "from typing import List\n\ndef sort_vector(array: List[int]) -> List[int]:\n    if not array:\n        return []\n    \n    first_value = array[0]\n    last_value = array[-1] if len(array) > 1 else first_value\n    \n    sum_of_edges = first_value + last_value\n    \n    if sum_of_edges % 2 == 0:  # Even\n        sorted_array = sorted(array, reverse=True)\n    else:  # Odd\n        sorted_array = sorted(array)\n    \n    return sorted_array\n```\n\n", "py_summary": "The Python code defines a function `sort_vector` that takes a list of integers as input and returns a new list based on specific sorting criteria:\n\n1. **Check for Empty List**: The function first checks if the input list is empty. If it is, an empty list is returned immediately.\n\n2. **Determine First and Last Values**:\n   - `first_value` is set to the value at index 0.\n   - `last_value` is set to the value at the last index of the list (`array[-1]`). If the list has only one element, `last_value` will be equal to `first_value`.\n\n3. **Calculate Sum and Determine Sorting Order**:\n   - The sum of `first_value` and `last_value` is calculated.\n   - If this sum is even, the function sorts the input list in descending order (`reverse=True`).\n   - If the sum is odd, the function sorts the input list in ascending order.\n\n4. **Return Sorted List**: Finally, the sorted list is returned.\n\nThis approach ensures that the original list remains unchanged and a new list with the desired sorting criteria is created and returned.\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted_string = \"\";\n    for (char c : s) {\n        if ('a' <= c && c <= 'z') {\n            // Calculate new character position after rotation by 4 positions\n            int new_char_pos = ((c - 'a' + 4) % 26) + 'a';\n            encrypted_string += static_cast<char>(new_char_pos);\n        } else {\n            encrypted_string += c;\n        }\n    }\n    return encrypted_string;\n}\n", "py_code": "def encrypt(s):\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate new character position after rotation\n            new_char_pos = (ord(char) - ord('a') + 4) % 26 + ord('a')\n            encrypted_string += chr(new_char_pos)\n        else:\n            encrypted_string += char\n    return encrypted_string\n```\n\n", "py_summary": "The Python function `encrypt` takes a string `s` as an argument and returns a new string where each lowercase letter in the input string is shifted down by 4 positions in the alphabet (since two multiplied by two equals four). Here's a detailed breakdown of how it works:\n\n1. **Initialization**: The variable `encrypted_string` is initialized to an empty string, which will store the result.\n\n2. **Iteration through characters**: A loop iterates over each character `char` in the input string `s`.\n\n3. **Character check and transformation**:\n   - If the character `char` is a lowercase letter (between 'a' and 'z'), it calculates its new position after rotating by 4 positions.\n     - The ASCII value of the character is converted to an index within the range [0, 25] using `(ord(char) - ord('a'))`.\n     - This index is then incremented by 4: `new_char_pos = (ord(char) - ord('a') + 4) % 26`.\n     - The modulo operation `% 26` ensures that the new position wraps around if it exceeds 'z'.\n     - The new character's ASCII value is calculated and added to `encrypted_string`: `chr(new_char_pos)`.\n\n   - If the character is not a lowercase letter, it remains unchanged in the output string: `encrypted_string += char`.\n\n4. **Return result**: After processing all characters, the function returns the resulting encrypted string `encrypted_string`.\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <set>\n#include <optional>\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    // Step 1: Check if there are fewer than 2 elements in the vector.\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Step 2: Remove duplicates and sort the elements.\n    std::set<int> unique_elements(lst.begin(), lst.end());\n\n    // Step 3: Check if there are at least two unique elements.\n    if (unique_elements.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Step 4: Return the second smallest element.\n    auto it = unique_elements.begin();\n    ++it; // Move to the second element\n    return *it;\n}\n", "py_code": "from typing import List, Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = sorted(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    return unique_elements[1]\n```\n\n", "py_summary": "The Python function `next_smallest` is designed to find and return the second smallest element in a given list of integers. Here's an analysis of how it works:\n\n1. **Initial Check**: The function first checks if the length of the input list `lst` is less than 2. If so, there cannot be a second smallest element, and the function returns `None`.\n\n2. **Remove Duplicates**: To ensure that we are working with unique elements, the function converts the list to a set (which removes duplicates) and then back to a sorted list (`unique_elements`). This step is crucial because if there are duplicate values in the input list, they should be treated as a single value for finding the second smallest element.\n\n3. **Check Unique Elements**: The function checks if the length of `unique_elements` is less than 2. If it is, then there is no second smallest unique element, and the function returns `None`.\n\n4. **Return Second Smallest Element**: Finally, the function returns the second element in the sorted list of unique elements (`unique_elements[1]`). This ensures that we are returning the correct second smallest value.\n\nThis approach guarantees that the function correctly handles cases with duplicates and empty lists while efficiently finding the second smallest distinct element if it exists."}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Split sentences by '.'\n    size_t start = 0, end = 0;\n    while ((end = S.find('.', start)) != string::npos) {\n        string sentence = S.substr(start, end - start);\n        \n        if (sentence.find('?') != string::npos || sentence.find('!') != string::npos) {\n            // Split by '?' and process each part\n            size_t question_mark_pos;\n            while ((question_mark_pos = sentence.find('?')) != string::npos) {\n                string part = sentence.substr(0, question_mark_pos);\n                if (part.size() > 1 && part.substr(0, 2) == \"I \") {\n                    boredom_count++;\n                }\n                sentence.erase(0, question_mark_pos + 1); // Remove processed part\n            }\n            \n            // Split by '!' and process each subpart\n            size_t exclamation_pos;\n            while ((exclamation_pos = sentence.find('!')) != string::npos) {\n                string subpart = sentence.substr(0, exclamation_pos);\n                if (subpart.size() > 1 && subpart.substr(0, 2) == \"I \") {\n                    boredom_count++;\n                }\n                sentence.erase(0, exclamation_pos + 1); // Remove processed part\n            }\n            \n            // Check remaining sentence after removing '?' and '!'\n            if (sentence.size() > 1 && sentence.substr(0, 2) == \"I \") {\n                boredom_count++;\n            }\n        } else {\n            // Check if the entire sentence starts with \"I \"\n            if (sentence.size() > 1 && sentence.substr(0, 2) == \"I \") {\n                boredom_count++;\n            }\n        }\n\n        start = end + 1;\n    }\n\n    // Process remaining part after last '.'\n    string final_sentence = S.substr(start);\n    \n    if (final_sentence.find('?') != string::npos || final_sentence.find('!') != string::npos) {\n        size_t question_mark_pos;\n        while ((question_mark_pos = final_sentence.find('?')) != string::npos) {\n            string part = final_sentence.substr(0, question_mark_pos);\n            if (part.size() > 1 && part.substr(0, 2) == \"I \") {\n                boredom_count++;\n            }\n            final_sentence.erase(0, question_mark_pos + 1); // Remove processed part\n        }\n\n        size_t exclamation_pos;\n        while ((exclamation_pos = final_sentence.find('!')) != string::npos) {\n            string subpart = final_sentence.substr(0, exclamation_pos);\n            if (subpart.size() > 1 && subpart.substr(0, 2) == \"I \") {\n                boredom_count++;\n            }\n            final_sentence.erase(0, exclamation_pos + 1); // Remove processed part\n        }\n\n        if (final_sentence.size() > 1 && final_sentence.substr(0, 2) == \"I \") {\n            boredom_count++;\n        }\n    } else {\n        if (final_sentence.size() > 1 && final_sentence.substr(0, 2) == \"I \") {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n", "py_code": "def is_bored(S):\n    boredom_count = 0\n    sentences = S.split('.')\n    for sentence in sentences:\n        if '?' in sentence or '!' in sentence:\n            # Split by these delimiters and process each part separately\n            parts = sentence.split('?')\n            for part in parts:\n                subparts = part.split('!')\n                for subpart in subparts:\n                    if subpart.strip().startswith(\"I \"):\n                        boredom_count += 1\n        else:\n            if sentence.strip().startswith(\"I \"):\n                boredom_count += 1\n    \n    return boredom_count\n```\n\n", "py_summary": "The Python function `is_bored` takes a string `S` as input and counts the number of sentences that start with the word \"I\". Sentences are delimited by '.', '?', or '!'. Here's a detailed analysis:\n\n1. **Initialization**: The variable `boredom_count` is initialized to 0 to keep track of the number of boredoms.\n\n2. **Splitting into Sentences**: The string `S` is split into sentences using the delimiter '.'. This creates a list of potential sentences, which may still contain internal punctuation like '?' and '!'.\n\n3. **Processing Each Sentence**:\n   - For each sentence in the list generated by splitting on '.', the function checks if the sentence contains '?' or '!'.\n   - If the sentence contains '?', it is further split into parts using '?' as a delimiter.\n   - Similarly, if the sentence contains '!', it is further split into subparts using '!' as a delimiter.\n\n4. **Checking for Boredoms**:\n   - For each part (or subpart) generated from splitting on '?' or '!', the function checks if the part starts with \"I \". If it does, `boredom_count` is incremented.\n   - If the sentence does not contain any internal punctuation ('?' or '!'), the entire sentence is checked to see if it starts with \"I \", and if so, `boredom_count` is incremented.\n\n5. **Return Result**: Finally, the function returns the total count of boredoms found in the string `S`.\n\nThis approach ensures that all possible sentences are correctly identified and counted based on their starting word being \"I\".\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their integer conversion\n    if (a != std::floor(a) || b != std::floor(b) || c != std::floor(c)) {\n        return false;\n    }\n\n    // Convert to integers for comparison\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n", "py_code": "def any_int(a: float, b: float, c: float) -> bool:\n    # Check if all numbers are integers\n    if not (a.is_integer() and b.is_integer() and c.is_integer()):\n        return False\n    \n    # Convert to integers for comparison\n    a, b, c = int(a), int(b), int(c)\n    \n    # Check if any number is the sum of the other two\n    return a == b + c or b == a + c or c == a + b\n```\n", "py_summary": "The Python function `any_int` checks whether one of the three given numbers is equal to the sum of the other two and ensures that all numbers are integers. Here's an analysis of how it works:\n\n1. **Check if All Numbers Are Integers**:\n   - The function first checks if each of the input numbers (`a`, `b`, and `c`) is an integer using the `.is_integer()` method.\n   - If any number is not an integer, the function immediately returns `False`.\n\n2. **Convert to Integers for Comparison**:\n   - If all numbers are integers, they are converted to Python's `int` type for further comparison.\n\n3. **Check if Any Number Is the Sum of the Other Two**:\n   - The function then checks three conditions:\n     1. Whether `a` is equal to the sum of `b` and `c`.\n     2. Whether `b` is equal to the sum of `a` and `c`.\n     3. Whether `c` is equal to the sum of `a` and `b`.\n   - If any of these conditions are true, the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies cases where one number is the sum of the other two only if all numbers are integers."}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    char shifted_vowels[] = {'c', 'g', 'k', 'q', 'w',  // Lowercase\n                              'C', 'G', 'K', 'Q', 'W'}; // Uppercase\n    \n    for (char &ch : message) {\n        if (isalpha(ch)) {\n            // Swap case\n            ch = islower(ch) ? toupper(ch) : tolower(ch);\n            \n            // Shift vowels by 2 places ahead\n            size_t vowel_index = vowels.find(ch);\n            if (vowel_index != string::npos) {\n                ch = shifted_vowels[vowel_index];\n            }\n        }\n    }\n    \n    return message;\n}\n", "py_code": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    shifted_vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n                       'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = ''\n    \n    for char in message:\n        if char.isalpha():\n            # Swap case\n            new_char = char.swapcase()\n            \n            # Shift vowels by 2 places ahead\n            if new_char in shifted_vowels:\n                new_char = shifted_vowels[new_char]\n                \n            encoded_message += new_char\n        else:\n            encoded_message += char\n    \n    return encoded_message\n```\n\n", "py_summary": "The Python function `encode` takes a string message as input and encodes it according to specific rules:\n\n1. **Swap Case**: For each character in the message, if it is an alphabetic letter, its case is swapped (lowercase becomes uppercase and vice versa).\n\n2. **Shift Vowels**: If the resulting character after swapping the case is a vowel ('a', 'e', 'i', 'o', 'u' or their respective uppercase equivalents), it is replaced with the letter that appears two places ahead in the English alphabet:\n   - 'a' -> 'c'\n   - 'e' -> 'g'\n   - 'i' -> 'k'\n   - 'o' -> 'q'\n   - 'u' -> 'w'\n   - Similarly for uppercase vowels.\n\n3. **Non-Alphabetic Characters**: Any non-alphabetic characters in the message are left unchanged and appended to the encoded message as is.\n\nThe function iterates through each character of the input string, applies these transformations, and constructs the encoded message which is then returned.\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            if (num > max_prime) {\n                max_prime = num;\n            }\n        }\n    }\n\n    if (max_prime == -1) return 0;\n\n    return sum_of_digits(max_prime);\n}\n\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = -1\n    for num in lst:\n        if is_prime(num):\n            if num > max_prime:\n                max_prime = num\n    \n    if max_prime == -1:\n        return 0\n    \n    return sum_of_digits(max_prime)\n```\n\n", "py_summary": "The Python code defines a function `skjkasdkd` that takes a list of integers as input and returns the sum of the digits of the largest prime number in the list. Here's a detailed breakdown:\n\n1. **is_prime Function**:\n   - This helper function checks if a given integer `n` is a prime number.\n   - It first handles edge cases where `n` is less than or equal to 1, returning `False`.\n   - Then it iterates from 2 up to the square root of `n`. If any divisor is found, it returns `False`.\n   - If no divisors are found, it returns `True`.\n\n2. **sum_of_digits Function**:\n   - This helper function calculates and returns the sum of the digits of an integer `n`.\n   - It converts the number to a string, iterates over each character (digit), converts each digit back to an integer, and sums them up.\n\n3. **skjkasdkd Function**:\n   - The main function initializes `max_prime` to `-1`, which will store the largest prime number found in the list.\n   - It iterates through each element of the input list `lst`.\n   - For each element, it checks if the element is a prime number using the `is_prime` function.\n   - If an element is prime and greater than the current value of `max_prime`, it updates `max_prime`.\n   - After iterating through all elements, if no prime numbers were found (`max_prime` remains `-1`), it returns 0.\n   - Otherwise, it calculates the sum of digits of `max_prime` using the `sum_of_digits` function and returns this value.\n\nThis approach ensures that we correctly identify the largest prime number in the list and compute the sum of its digits efficiently."}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto &pair : dict) {\n        const std::string &key = pair.first;\n        \n        // Check if the key is not in lowercase\n        if (!std::all_of(key.begin(), key.end(), ::islower)) {\n            all_lower = false;\n        }\n\n        // Check if the key is not in uppercase\n        if (!std::all_of(key.begin(), key.end(), ::isupper)) {\n            all_upper = false;\n        }\n        \n        // If both flags are false, return false early\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys are in lowercase or uppercase\n    return all_lower || all_upper;\n}\n", "py_code": "from typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    if not dict:\n        return False\n    \n    all_lower = True\n    all_upper = True\n    \n    for key in dict.keys():\n        if not key.islower():\n            all_lower = False\n        if not key.isupper():\n            all_upper = False\n        \n        if not all_lower and not all_upper:\n            return False\n    \n    return all_lower or all_upper\n```\n\n", "py_summary": "The Python function `check_dict_case` checks whether a given dictionary's keys are either all in lowercase or all in uppercase. Here is an analysis of how it works:\n\n1. **Check for Empty Dictionary**: The function first checks if the input dictionary is empty. If it is, the function returns `False`.\n\n2. **Initialize Flags**: Two boolean flags, `all_lower` and `all_upper`, are initialized to `True`. These flags will be used to track whether all keys in the dictionary are lowercase or uppercase.\n\n3. **Iterate Through Keys**: The function iterates through each key in the dictionary:\n   - For each key, it checks if the key is not in lowercase using `not key.islower()`, and sets `all_lower` to `False` if this condition is true.\n   - Similarly, it checks if the key is not in uppercase using `not key.isupper()`, and sets `all_upper` to `False` if this condition is true.\n\n4. **Early Exit**: If both flags are set to `False` during iteration (indicating that keys are neither all lowercase nor all uppercase), the function returns `False`.\n\n5. **Final Check**: After iterating through all keys, the function checks whether either `all_lower` or `all_upper` is still `True`. If one of them is true, it means all keys are in the same case (either all lowercase or all uppercase), and the function returns `True`.\n\nThis approach ensures that the dictionary's keys meet the specified criteria.\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n", "py_code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for number in range(2, n):\n        if is_prime(number):\n            primes.append(number)\n    return primes\n```\n\n", "py_summary": "The Python code defines a function `count_up_to` that takes an integer `n` and returns a list of prime numbers less than `n`. The solution involves two main components:\n\n1. **Prime Check Function (`is_prime`)**:\n   - This helper function checks if a given number is prime.\n   - It first handles the base case where any number less than or equal to 1 is not considered prime.\n   - Then, it iterates from 2 up to the square root of the number (inclusive) to check for factors. If any factor is found, the function returns `False`. Otherwise, it returns `True`.\n\n2. **Main Function (`count_up_to`)**:\n   - This function initializes an empty list called `primes`.\n   - It iterates through all integers from 2 up to (but not including) `n`.\n   - For each integer, it calls the `is_prime` function to check if the number is prime.\n   - If a number is determined to be prime, it appends that number to the `primes` list.\n   - Finally, the function returns the list of primes.\n\nThis approach ensures that all numbers less than `n` are checked for primality and only those that pass the check are included in the result."}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers using modulo operation\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Calculate and return the product of the unit digits\n    return unit_digit_a * unit_digit_b;\n}\n", "py_code": "def multiply(a: int, b: int) -> int:\n    # Extract the unit digit of both numbers\n    unit_digit_a = abs(a % 10)\n    unit_digit_b = abs(b % 10)\n    \n    # Calculate and return the product of the unit digits\n    return unit_digit_a * unit_digit_b\n```\n\n", "py_summary": "The Python function `multiply` takes two integers as input and returns the product of their unit digits. Here's a detailed breakdown of how it works:\n\n1. **Extract Unit Digits**: \n   - The unit digit of an integer is obtained by taking the remainder when divided by 10 (`a % 10` for `a` and `b % 10` for `b`). This operation gives the last digit of each number.\n   - To handle negative numbers correctly, we use the absolute value function `abs()` to ensure that the unit digits are always positive.\n\n2. **Calculate Product**:\n   - The product of the unit digits is computed by multiplying the two extracted unit digits (`unit_digit_a * unit_digit_b`).\n\n3. **Return Result**:\n   - The result of this multiplication is returned as the output of the function.\n\nThis approach ensures that the function works correctly for both positive and negative integers, as well as zero values, since the absolute value operation handles all cases uniformly.\n\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n#include <algorithm>\n\nint count_upper(std::string s) {\n    std::string vowels = \"AEIOU\";\n    int count = 0;\n\n    for (size_t i = 1; i < s.length(); i += 2) {  // Start from index 1 and increment by 2 to check even indices\n        if (vowels.find(s[i]) != std::string::npos && i % 2 == 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    count = 0\n    for i in range(1, len(s) + 1):  # Start from index 1 (second character)\n        if i % 2 == 0 and s[i-1] in vowels:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python function `count_upper` is designed to count the number of uppercase vowels at even indices in a given string `s`. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - The variable `vowels` contains all uppercase vowels: \"AEIOU\".\n   - The variable `count` is initialized to 0, which will be used to keep track of the number of uppercase vowels found at even indices.\n\n2. **Iteration through the string**:\n   - A for loop iterates over the range from 1 to the length of the string (inclusive). This ensures that we start checking from the second character (index 1), as Python uses zero-based indexing.\n   \n3. **Condition Check**:\n   - For each index `i`, it checks if `i` is even (`i % 2 == 0`). Since the loop starts at 1, this condition will be true for indices like 2, 4, 6, etc., which are considered \"even\" in terms of their position (second character, fourth character, etc.).\n   - If `i` is even, it checks if the corresponding character in the string (`s[i-1]`) is an uppercase vowel by using the `in` operator to check membership in the `vowels` string.\n\n4. **Increment Count**:\n   - If both conditions are met (even index and uppercase vowel), the count is incremented by 1.\n\n5. **Return Result**:\n   - After iterating through all characters, the function returns the final value of `count`.\n\nThis approach ensures that only uppercase vowels at even indices are counted, as required by the problem statement.\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine floor and ceiling values\n    int floor_value = static_cast<int>(floor(num));\n    int ceil_value;\n    if (num > 0) {\n        ceil_value = floor_value + 1;\n    } else {\n        ceil_value = floor_value - 1;\n    }\n\n    // Calculate differences to floor and ceiling values\n    double diff_floor = abs(num - floor_value);\n    double diff_ceil = abs(num - ceil_value);\n\n    // Determine the closest integer, rounding away from zero if equidistant\n    if (diff_floor < diff_ceil) {\n        return floor_value;\n    } else if (diff_ceil < diff_floor) {\n        return ceil_value;\n    } else {\n        return num > 0 ? ceil_value : floor_value;\n    }\n}\n\n", "py_code": "def closest_integer(value):\n    num = float(value)\n    floor_value = int(num)\n    ceil_value = floor_value + 1 if num > 0 else floor_value - 1\n    \n    if abs(num - floor_value) < abs(num - ceil_value):\n        return floor_value\n    elif abs(num - floor_value) > abs(num - ceil_value):\n        return ceil_value\n    else:\n        return ceil_value if num > 0 else floor_value\n```\n\n", "py_summary": "The Python function `closest_integer` takes a string input representing a number and returns the closest integer to that number, rounding away from zero if necessary. Here's a detailed breakdown of how it works:\n\n1. **Convert Input String to Float**: The input string is converted to a floating-point number using `float(value)`.\n\n2. **Determine Floor and Ceiling Values**:\n   - `floor_value` is the largest integer less than or equal to the float value.\n   - `ceil_value` is determined based on whether the number is positive or negative:\n     - For positive numbers, `ceil_value = floor_value + 1`.\n     - For negative numbers, `ceil_value = floor_value - 1`.\n\n3. **Calculate Differences**:\n   - The function calculates the absolute differences between the float value and both `floor_value` and `ceil_value`.\n\n4. **Determine Closest Integer**:\n   - If the difference to `floor_value` is smaller than the difference to `ceil_value`, return `floor_value`.\n   - If the difference to `ceil_value` is smaller, return `ceil_value`.\n   - If both differences are equal (i.e., the number is equidistant from two integers), round away from zero:\n     - For positive numbers, return `ceil_value`.\n     - For negative numbers, return `floor_value`.\n\nThis approach ensures that the function correctly rounds to the nearest integer and handles cases where rounding should be away from zero.\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current_stones = n;\n\n    for (int level = 0; level < n; ++level) {\n        pile.push_back(current_stones);\n        if (n % 2 == 0) {\n            // If n is even, the next number should be the next even number\n            current_stones += 2;\n        } else {\n            // If n is odd, adding  2 to an odd number results in the next odd number\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n", "py_code": "def make_a_pile(n):\n    pile = []\n    current_stones = n\n    for level in range(n):\n        pile.append(current_stones)\n        if n % 2 == 0:\n            current_stones += 2  # next even number\n        else:\n            current_stones += 2  # next odd number, since adding 2 to an odd number results in the next odd number\n    return pile\n```\n\n", "py_summary": "The Python function `make_a_pile` takes a positive integer `n` and returns a list representing the number of stones at each level of a pile with `n` levels.\n\n1. **Initialization**:\n   - An empty list `pile` is initialized to store the number of stones in each level.\n   - The variable `current_stones` is set to `n`, which represents the number of stones in the first level.\n\n2. **Loop through Levels**:\n   - A loop runs from 0 to `n-1`, representing each level of the pile.\n   - For each iteration, the current value of `current_stones` (which corresponds to the number of stones at the current level) is appended to the list `pile`.\n   \n3. **Determine Next Level Stones**:\n   - If `n` is even (`n % 2 == 0`), then `current_stones` is incremented by 2 to get the next even number.\n   - If `n` is odd, adding 2 to an odd number results in the next odd number, so no separate condition for odd numbers is needed.\n\n4. **Return Result**:\n   - After completing all iterations, the function returns the list `pile`, which contains the number of stones at each level.\n\nThis approach ensures that the pile construction follows the specified rules and correctly builds a vector representing the stone count per level."}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces for uniformity in splitting\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Split the string by spaces and store the result in a vector of strings\n    stringstream ss(s);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n", "py_code": "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    # Replace commas with spaces for uniformity in splitting\n    s = s.replace(',', ' ')\n    # Split the string by spaces and return as a list of strings\n    return s.split()\n```\n\n", "py_summary": "The Python code defines a function `words_string` that takes a single string `s` as input and returns a vector (list in Python) of words extracted from the string. The function performs the following steps:\n\n1. **Replace Commas with Spaces**: It first replaces all commas in the input string `s` with spaces to ensure uniformity when splitting the string into individual words.\n2. **Split the String**: It then uses the `split()` method, which splits the modified string by any whitespace (including multiple consecutive spaces) and returns a list of the resulting substrings.\n\nThis approach ensures that the function can handle both commas and spaces as separators between words in the input string, returning a clean vector of individual words."}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the larger number and go downwards\n    for (int num = y; num >= x; --num) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n\n    return -1;\n}\n", "py_code": "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    \n    # Start from the larger number and go downwards\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    return -1\n```\n\n", "py_summary": "The Python function `choose_num` takes two positive integers `x` and `y` as input and returns the largest even integer within the inclusive range `[x, y]`. If no such number exists in the given range, it returns `-1`.\n\nHere's a step-by-step analysis of how the code works:\n\n1. **Initial Check**: The function first checks if `x` is greater than `y`. If this condition is true, it means there are no numbers in the range `[x, y]`, and thus it immediately returns `-1`.\n\n2. **Iterate Backwards from `y` to `x`**:\n   - The function uses a for loop that starts at `y` and decrements by 1 until it reaches `x`.\n   - For each number in this range, the function checks if the number is even (i.e., `num % 2 == 0`).\n\n3. **Return the First Even Number Found**:\n   - As soon as an even number is found within the loop, the function returns that number immediately.\n\n4. **Return `-1` if No Even Number Is Found**:\n   - If no even number is found after iterating through the range `[y, x]`, the function returns `-1`.\n\nThis approach ensures that the function efficiently finds and returns the largest even integer in the given range or `-1` if there are none.\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for accumulate\n#include <cmath>   // for floor\n#include <bitset>  // for bitset\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long total_sum = accumulate(begin(vector<int>(n, 0)), end(vector<int>(m + 1, 0)), 0);\n\n    // Count the number of integers in the range [n, m]\n    int count = m - n + 1;\n\n    // Calculate the average and round down to the nearest integer\n    long avg = total_sum / count;\n\n    // Convert the rounded-down average to binary\n    bitset<32> result(avg); // Assuming a reasonable size for the bitset\n\n    // Extract the relevant part of the binary representation (excluding leading zeros)\n    string binary_str = result.to_string();\n    auto pos = binary_str.find_first_of('1');\n    if (pos != string::npos) {\n        return binary_str.substr(pos);\n    } else {\n        return \"0\"; // In case avg is 0\n    }\n}\n\n", "py_code": "def rounded_avg(n: int, m: int) -> str:\n    if n > m:\n        return \"-1\"\n    \n    # Calculate the average of integers from n through m (inclusive)\n    total_sum = sum(range(n, m + 1))\n    count = m - n + 1\n    avg = total_sum // count\n    \n    # Round down to the nearest integer and convert to binary\n    result = bin(avg)[2:]\n    \n    return result\n```\n\n", "py_summary": "The Python function `rounded_avg` calculates the average of integers from `n` through `m` (inclusive) and returns the rounded-down average in binary format. Here's a detailed breakdown:\n\n1. **Input Validation**:\n   - The function first checks if `n` is greater than `m`. If this condition is true, it immediately returns `-1`.\n\n2. **Sum Calculation**:\n   - It calculates the sum of all integers from `n` to `m` using Python's built-in `sum` function and a range object.\n\n3. **Count Calculation**:\n   - The count of numbers in the range from `n` to `m` is calculated as `(m - n + 1)`.\n\n4. **Average Calculation**:\n   - The average is computed by dividing the total sum by the count, using integer division (`//`) to ensure that the result is an integer and rounded down automatically.\n\n5. **Binary Conversion**:\n   - The function converts the calculated average to its binary representation using Python's `bin` function.\n   - The `bin` function returns a string prefixed with '0b', so `[2:]` is used to remove this prefix, leaving only the binary digits.\n\n6. **Return Result**:\n   - Finally, the function returns the binary string of the rounded-down average.\n\nThis approach ensures that the result is correctly computed and formatted as required by the problem statement."}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_no_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            return false;\n        }\n        n /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers that do not contain any even digits\n    for (int num : x) {\n        if (has_no_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered list in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    def has_no_even_digit(n):\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return False\n            n //= 10\n        return True\n    \n    result = [num for num in x if has_no_even_digit(num)]\n    result.sort()\n    return result\n```\n\n", "py_summary": "The Python code defines a function `unique_digits` that takes a list of positive integers and returns a sorted list of all elements that do not contain any even digits.\n\n1. **Helper Function**: The helper function `has_no_even_digit` checks if a given number does not have any even digits.\n   - It iterates through each digit of the number by repeatedly taking the last digit (`n % 10`) and checking if it is odd (i.e., `digit % 2 != 0`). If an even digit is found, the function returns `False`. Otherwise, it continues until all digits have been checked.\n   - The function returns `True` only if no even digits are present in the number.\n\n2. **Main Function**: The main function `unique_digits` uses a list comprehension to filter out numbers that do not contain any even digits using the helper function `has_no_even_digit`.\n   - It then sorts the filtered list of numbers and returns it.\n\nThis approach ensures that only numbers with odd digits are included in the result, and these numbers are returned in increasing order."}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Mapping digits to names\n    map<int, string> digit_names = {\n        {1, \"One\"},\n        {2, \"Two\"},\n        {3, \"Three\"},\n        {4, \"Four\"},\n        {5, \"Five\"},\n        {6, \"Six\"},\n        {7, \"Seven\"},\n        {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n\n    // Filter and sort the valid numbers between 1 and 9\n    vector<int> filtered_sorted_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted_arr.push_back(num);\n        }\n    }\n\n    sort(filtered_sorted_arr.begin(), filtered_sorted_arr.end());\n\n    // Reverse the sorted list\n    reverse(filtered_sorted_arr.begin(), filtered_sorted_arr.end());\n\n    // Map each digit to its corresponding name\n    vector<string> result;\n    for (int num : filtered_sorted_arr) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def by_length(arr):\n    # Define a mapping from digits 1-9 to their corresponding names\n    digit_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter out numbers that are not between 1 and 9\n    filtered_arr = [x for x in arr if 1 <= x <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Map each digit to its corresponding name\n    result = [digit_names[num] for num in reversed_arr if num in digit_names]\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `by_length` that processes an input list of integers according to the specified rules and returns a list of strings representing the names of digits between 1 and 9 in reverse sorted order.\n\nHere's a detailed breakdown:\n\n1. **Mapping Digits to Names**: A dictionary `digit_names` is created to map each digit from 1 to 9 to its corresponding name (e.g., \"One\", \"Two\", etc.).\n\n2. **Filtering Valid Numbers**: The input list `arr` is filtered to include only integers between 1 and 9 using a list comprehension.\n\n3. **Sorting the Filtered List**: The filtered list is sorted in ascending order using Python's built-in `sorted()` function.\n\n4. **Reversing the Sorted List**: The sorted list is reversed using the `reversed()` function, which returns an iterator that is then converted back to a list.\n\n5. **Mapping Digits to Names and Filtering Again**: A final list comprehension maps each digit in the reversed list to its corresponding name from the `digit_names` dictionary. This step ensures that only valid digits (between 1 and 9) are included in the result.\n\n6. **Returning the Result**: The resulting list of names is returned by the function.\n\nThis process effectively handles all edge cases, such as empty input lists or lists containing numbers outside the range [1, 9]."}
{"task_id": "CPP/106", "generation": "#include <vector>\n\n// Helper function to calculate factorial\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    \n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate sum of numbers from 1 to i\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if (index % 2 == 0) { // Even index\n            result[i] = factorial(index);\n        } else { // Odd index\n            result[i] = sum_to_i(index);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef factorial(i: int) -> int:\n    if i == 0 or i == 1:\n        return 1\n    result = 1\n    for j in range(2, i + 1):\n        result *= j\n    return result\n\ndef sum_to_i(i: int) -> int:\n    return (i * (i + 1)) // 2\n\ndef f(n: int) -> List[int]:\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_to_i(i))\n    return result\n```\n\n", "py_summary": "The Python code defines a function `f` that takes an integer `n` as input and returns a vector (list) of size `n`. The value at each index `i` in this list is determined based on whether `i` is even or odd:\n\n1. **Factorial Calculation**:\n   - A helper function `factorial(i)` calculates the factorial of an integer `i`, which is the product of all positive integers up to `i`.\n   - If `i` is 0 or 1, the factorial is defined as 1.\n   - For other values of `i`, a loop multiplies numbers from 2 to `i`.\n\n2. **Sum Calculation**:\n   - A helper function `sum_to_i(i)` calculates the sum of all integers from 1 to `i`.\n   - This can be computed using the formula for the sum of an arithmetic series: \\( \\text{sum} = \\frac{i \\times (i + 1)}{2} \\).\n\n3. **Main Function**:\n   - The main function `f(n)` initializes an empty list `result` to store the values.\n   - It iterates from 1 to `n`, and for each index `i`:\n     - If `i` is even, it appends the factorial of `i` to the result list.\n     - If `i` is odd, it appends the sum of numbers from 1 to `i` to the result list.\n\nThe function then returns the resulting list. For example, calling `f(5)` would return `[1, 2, 6, 24, 15]`, where:\n- Index 0 (even): factorial(2) = 2\n- Index 1 (odd): sum_to_i(1) = 1\n- Index 2 (even): factorial(3) = 6\n- Index 3 (odd): sum_to_i(3) = 6\n- Index 4 (even): factorial(4) = 24\n- Index 5 (odd): sum_to_i(5) = 15\n\nThus, the output is `[1, 2, 6, 24, 15]`."}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\n// Declare the helper function before using it in even_odd_palindrome.\nbool is_palindrome(int num);\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n// Define the helper function.\nbool is_palindrome(int num) {\n    std::string str_num = std::to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n\n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n\n    return true;\n}\n", "py_code": "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return [even_count, odd_count]\n```\n\n", "py_summary": "The Python code defines a function `even_odd_palindrome` that takes an integer `n` as input and returns a list containing two integers: the count of even palindromes and the count of odd palindromes within the range from 1 to `n`, inclusive.\n\nHere's a detailed breakdown of how the Python code works:\n\n1. **Helper Function**: The function `is_palindrome(num)` checks if a given number is a palindrome by converting it to a string, reversing the string, and comparing it with the original string.\n   \n2. **Initialization**: Two counters, `even_count` and `odd_count`, are initialized to zero. These will be used to keep track of the number of even and odd palindromes found.\n\n3. **Loop Through Range**: A loop iterates through all integers from 1 to `n`. For each integer:\n   - It checks if the integer is a palindrome using the `is_palindrome` function.\n   - If it is a palindrome, it increments either `even_count` or `odd_count` based on whether the number is even or odd.\n\n4. **Return Result**: Finally, the function returns a list containing the counts of even and odd palindromes in that order.\n\nThis approach ensures that all integers within the specified range are checked for being palindromic, and their parity (even/odd) is correctly counted."}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of signed digits for a given integer.\nint sum_of_digits(int num) {\n    if (num == 0)\n        return 0;\n\n    int digit_sum = 0;\n    bool is_negative = num < 0;\n\n    while (num != 0) {\n        int digit = abs(num % 10);\n        if (is_negative && digit > 0)\n            digit *= -1; // Adjust the first signed digit\n        digit_sum += digit;\n        num /= 10;\n    }\n\n    return digit_sum;\n}\n\n// Main function to count the number of elements with a sum of digits greater than zero.\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (const auto& number : n) {\n        if (sum_of_digits(number) > 0)\n            count++;\n    }\n\n    return count;\n}\n", "py_code": "from typing import List\n\ndef count_nums(n: List[int]) -> int:\n    def sum_of_digits(num):\n        if num == 0:\n            return 0\n        is_negative = num < 0\n        digit_sum = 0\n        while num != 0:\n            digit = abs(num % 10)\n            if is_negative:\n                digit *= -1\n            digit_sum += digit\n            num //= 10\n        return digit_sum\n\n    count = 0\n    for number in n:\n        if sum_of_digits(number) > 0:\n            count += 1\n    return count\n```\n\n", "py_summary": "The Python code defines a function `count_nums` that takes a list of integers and returns the number of elements whose sum of digits is greater than zero. The function works as follows:\n\n1. **Helper Function (`sum_of_digits`)**:\n   - This helper function calculates the sum of signed digits for a given integer.\n   - It first checks if the input number is zero, in which case it returns 0 since the sum of digits for zero is zero.\n   - If the number is negative, it sets `is_negative` to True. The function then iterates through each digit of the number:\n     - For each digit, it takes the absolute value and multiplies by -1 if the number is negative (to account for signed digits).\n     - It adds this processed digit to a running total (`digit_sum`).\n   - Finally, it returns the `digit_sum`.\n\n2. **Main Function (`count_nums`)**:\n   - The main function initializes a counter variable `count` to zero.\n   - It iterates through each number in the input list `n`.\n   - For each number, it calls the helper function `sum_of_digits` and checks if the returned sum is greater than 0.\n   - If the condition is met, it increments the count by one.\n\n3. **Return Statement**:\n   - After iterating through all numbers, the main function returns the total count of numbers whose sum of digits is greater than zero.\n\nThis approach ensures that negative numbers are handled correctly with their signed digits and that only those elements meeting the criteria contribute to the final count."}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {  // Check if the vector is empty\n        return true;\n    }\n    \n    int n = arr.size();\n    \n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        \n        for (int j = 1; j < n && is_sorted; ++j) {\n            if (arr[i] > arr[(i + j) % n]) {  // Check non-decreasing condition\n                is_sorted = false;\n            }\n        }\n        \n        if (is_sorted) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n", "py_code": "def move_one_ball(arr):\n    if not arr:\n        return True\n\n    n = len(arr)\n    for i in range(n):\n        # Check if the array is already sorted or can be made sorted by a right shift\n        if arr[i] <= arr[(i + 1) % n]:\n            continue\n        else:\n            break\n    \n    # If we have completed one full cycle without breaking, it means the array can be sorted by a right shift\n    return i == n - 1\n```\n\n", "py_summary": "The Python function `move_one_ball` checks if a given list of integers can be made to form a non-decreasing sequence through any number of right shift operations.\n\nHere's an analysis of how it works:\n\n1. **Check for Empty List**: The function first checks if the input list is empty. If it is, the function returns `True`, as an empty list is trivially sorted.\n   \n2. **Cycle Through Elements**: It then iterates through each element in the list using a loop. For each element at index `i`, it compares this element with the next element (considering circular indexing to handle right shifts).\n\n3. **Comparison Logic**:\n   - The comparison checks if `arr[i]` is less than or equal to `arr[(i + 1) % n]`. This ensures that the sequence can be made non-decreasing by a right shift.\n   - If at any point this condition fails, it means the list cannot be sorted with a single right shift and thus breaks out of the loop.\n\n4. **Completion Check**: After completing one full cycle through all elements without breaking (i.e., if `i` reaches `n-1`), it confirms that the array can indeed be made non-decreasing by some number of right shifts, so it returns `True`.\n\n5. **Return Result**: If the loop breaks at any point due to an invalid comparison, the function returns `False`, indicating that no amount of right shifts will sort the list.\n\nThis approach ensures that we efficiently determine if a given permutation can be sorted with circular shifts by leveraging the properties of cyclic permutations and non-decreasing sequences."}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odd_count = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    int even_count = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count++;\n        }\n    }\n\n    if (odd_count <= even_count) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n", "py_code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_in_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_count_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n\n    # If there are more odd numbers in lst1 than even numbers in lst2, it's impossible to exchange\n    if odd_count_in_lst1 > even_count_in_lst2:\n        return \"NO\"\n    \n    # Since we can exchange any number of elements between the two lists,\n    # having at least as many even numbers in lst2 as there are odd numbers in lst1 is sufficient.\n    return \"YES\"\n```\n\n", "py_summary": "The Python code defines a function `exchange` that takes two lists of integers (`lst1` and `lst2`) and determines whether it is possible to exchange elements between them so that all elements in `lst1` become even.\n\nHere's an analysis of how the function works:\n\n1. **Count Odd Numbers in lst1**: The code first counts the number of odd numbers in `lst1`. This is done using a generator expression inside the `sum` function, which iterates through each element in `lst1` and checks if it is odd (`num % 2 != 0`). If an element is odd, it contributes to the count.\n\n2. **Count Even Numbers in lst2**: Similarly, the code counts the number of even numbers in `lst2`. This is done using another generator expression inside the `sum` function, which iterates through each element in `lst2` and checks if it is even (`num % 2 == 0`). If an element is even, it contributes to the count.\n\n3. **Check Feasibility of Exchange**: The code then compares the number of odd numbers in `lst1` with the number of even numbers in `lst2`. If there are more odd numbers in `lst1` than there are even numbers in `lst2`, it is impossible to exchange elements such that all elements in `lst1` become even. In this case, the function returns `\"NO\"`.\n\n4. **Return \"YES\" if Possible**: If the number of odd numbers in `lst1` does not exceed the number of even numbers in `lst2`, then it is possible to perform exchanges to make all elements in `lst1` even. The function returns `\"YES\"`.\n\nThis approach ensures that we only need to count the necessary elements and compare their counts, making the solution efficient and straightforward."}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    if (test.empty()) {\n        return {};\n    }\n\n    map<char, int> letter_counts;\n    int max_count = 0;\n\n    // Split the string into individual characters\n    stringstream ss(test);\n    char current_char;\n    while (ss >> current_char) {\n        letter_counts[current_char]++;\n        max_count = max(max_count, letter_counts[current_char]);\n    }\n\n    map<char, int> result;\n    for (const auto& entry : letter_counts) {\n        if (entry.second == max_count) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n", "py_code": "from collections import defaultdict\n\ndef histogram(test: str) -> dict:\n    if not test:\n        return {}\n    \n    letter_counts = defaultdict(int)\n    max_count = 0\n    \n    for char in test.split():\n        letter_counts[char] += 1\n        max_count = max(max_count, letter_counts[char])\n    \n    result = {letter: count for letter, count in letter_counts.items() if count == max_count}\n    return result\n```\n\n", "py_summary": "The Python code defines a function `histogram` that takes a string as input and returns a dictionary containing the letters with the highest frequency along with their counts. Here's an analysis of how it works:\n\n1. **Input Check**: The function first checks if the input string is empty. If it is, it immediately returns an empty dictionary.\n\n2. **Initialize Data Structures**:\n   - `letter_counts`: A `defaultdict` initialized to store the count of each letter in the input string.\n   - `max_count`: An integer variable to keep track of the maximum frequency of any letter encountered so far.\n\n3. **Split and Count Letters**: The function splits the input string into individual letters (assuming space-separated letters) and iterates over them:\n   - For each letter, it increments its count in `letter_counts`.\n   - It updates `max_count` to be the highest value between the current maximum frequency and the new count of the letter.\n\n4. **Filter Letters with Maximum Count**: After counting all letters, the function creates a dictionary comprehension that filters out only those letters whose counts match `max_count`.\n\n5. **Return Result**: Finally, it returns this filtered dictionary containing the most frequent letters along with their counts.\n\nThis approach ensures that if multiple letters have the same highest frequency, they are all included in the result. If no letters are present (empty string), an empty dictionary is returned as specified."}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in `s` that are present in `c`\n    string result;\n    for (char ch : s) {\n        if (find(c.begin(), c.end(), ch) == c.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome = true;\n    int left = 0, right = result.size() - 1;\n    while (left < right) {\n        if (result[left] != result[right]) {\n            is_palindrome = false;\n            break;\n        }\n        left++;\n        right--;\n    }\n\n    // Return the result string and whether it's a palindrome\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n", "py_code": "def reverse_delete(s: str, c: str) -> list:\n    # Remove all characters in `s` that are present in `c`\n    result = ''.join(ch for ch in s if ch not in c)\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return [result, \"True\" if is_palindrome else \"False\"]\n```\n\n", "py_summary": "The Python function `reverse_delete` takes two string parameters: `s` and `c`. The goal of this function is to remove all characters from `s` that are present in `c`, and then check if the resulting string is a palindrome.\n\nHere's a step-by-step breakdown:\n\n1. **Remove Characters**: \n   - A generator expression `''.join(ch for ch in s if ch not in c)` iterates through each character `ch` in the string `s`.\n   - If the character `ch` is not present in `c`, it is included in the resulting string.\n   - The `join` method concatenates these characters to form a new string without any characters from `c`.\n\n2. **Check Palindrome**:\n   - The function checks if the resulting string is equal to its reverse (`result == result[::-1]`).\n   - If they are equal, it means the string is a palindrome.\n   \n3. **Return Result**:\n   - The function returns a list containing two elements: \n     1. The modified string after removing characters from `c`.\n     2. A boolean value converted to \"True\" or \"False\" indicating whether the resulting string is a palindrome.\n\nThis approach ensures that all specified characters are removed and the remaining string is checked for palindromic properties efficiently."}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& s : lst) {\n        int count_odd = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count_odd++;\n            }\n        }\n\n        // Construct the output string with the count of odd digits\n        std::string output_string = \"the number of odd elements \";\n        output_string += std::to_string(count_odd);\n        output_string += \"n the str\";\n        output_string += std::to_string(count_odd);\n        output_string += \"ng \";\n        output_string += std::to_string(count_odd);\n        output_string += \" of the \";\n        output_string += std::to_string(count_odd);\n        output_string += \"nput.\";\n        \n        // Append the constructed string to the result vector\n        result.push_back(output_string);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for i, s in enumerate(lst):\n        count_odd = sum(1 for digit in s if int(digit) % 2 != 0)\n        output_string = f'the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.'\n        result.append(output_string)\n    return result\n```\n\n", "py_summary": "The Python code defines a function `odd_count` that takes a list of strings as input and returns a list of strings. Each string in the output corresponds to an input string and describes how many odd digits are present in it.\n\nHere's a detailed breakdown:\n\n1. **Initialization**: The function initializes an empty list called `result`, which will store the final output strings.\n2. **Iteration over Input List**: For each string `s` in the input list `lst`, the function performs the following steps:\n   - **Count Odd Digits**: It counts the number of odd digits in the string `s`. This is done using a generator expression inside the `sum` function, which iterates through each character in `s`, converts it to an integer, and checks if it's odd.\n3. **Construct Output String**: For each input string, the function constructs an output string that describes how many odd digits are present. The format of the output string is:\n   ```\n   'the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.'\n   ```\n   Here, `{count_odd}` is replaced with the actual count of odd digits.\n4. **Append to Result**: The constructed output string is appended to the `result` list.\n5. **Return Result**: Finally, the function returns the `result` list containing all the formatted strings.\n\nThis approach ensures that each input string is processed and a corresponding descriptive string is generated based on the count of odd digits in it."}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <limits>\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    long long current_min = std::numeric_limits<long long>::max();\n    long long temp_sum = 0;\n\n    for (auto num : nums) {\n        temp_sum += num;\n        if (temp_sum < current_min) {\n            current_min = temp_sum;\n        }\n\n        // Reset the temporary sum to zero if it becomes positive\n        if (temp_sum > 0) {\n            temp_sum = 0;\n        }\n    }\n\n    return current_min;\n}\n", "py_code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    current_min = float('inf')\n    temp_sum = 0\n    \n    for num in nums:\n        temp_sum += num\n        if temp_sum < current_min:\n            current_min = temp_sum\n        \n        # Reset the temporary sum to zero if it becomes positive, as a negative subarray sum can always be found that is smaller.\n        if temp_sum > 0:\n            temp_sum = 0\n    \n    return current_min\n```\n\n", "py_summary": "The Python code defines a function `minSubArraySum` that calculates the minimum sum of any non-empty sub-vector from a given list of integers (`nums`). The function uses a dynamic programming approach to keep track of the current minimum sum and a temporary cumulative sum.\n\nHere's a detailed breakdown:\n1. **Initialization**:\n   - `current_min`: Initialized to positive infinity, representing the smallest sub-array sum found so far.\n   - `temp_sum`: Initialized to zero, used to accumulate the sums of elements in the current sub-vector being considered.\n\n2. **Iteration through the list**:\n   - For each element `num` in `nums`, add it to `temp_sum`.\n   - If `temp_sum` is less than `current_min`, update `current_min` with `temp_sum`.\n\n3. **Resetting temporary sum**:\n   - If `temp_sum` becomes positive, reset it to zero. This step ensures that the function continues searching for a smaller sub-array sum by starting fresh from the next element.\n\n4. **Return value**:\n   - The function returns `current_min`, which holds the minimum sum of any non-empty sub-vector found during the iteration.\n\nThis approach effectively finds the smallest possible sum of contiguous elements in the list, leveraging Kadane's algorithm for finding the maximum subarray sum but adapted to find the minimum subarray sum by considering negative values and resetting when a positive cumulative sum is encountered."}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nint max_fill(std::vector<std::vector<int>> grid, int bucket_capacity) {\n    // Calculate total water units in the grid\n    int total_water_units = 0;\n    for (const auto& row : grid) {\n        total_water_units += std::accumulate(row.begin(), row.end(), 0);\n    }\n\n    // Calculate the number of times buckets need to be lowered\n    return (total_water_units + bucket_capacity - 1) / bucket_capacity;\n}\n", "py_code": "def max_fill(grid, bucket_capacity):\n    total_water_units = sum(sum(row) for row in grid)\n    return (total_water_units + bucket_capacity - 1) // bucket_capacity\n\n", "py_summary": "The Python function `max_fill` calculates the number of times buckets need to be lowered to empty all the wells given a grid and a bucket capacity. Here's an analysis of how it works:\n\n1. **Summing Water Units**: The function first computes the total amount of water in all the wells combined by iterating through each row (well) and summing up the number of 1s (units of water). This is done using `sum(sum(row) for row in grid)`.\n\n2. **Calculating Bucket Operations**: Once the total units of water are known, the function calculates how many times buckets need to be lowered to remove all this water. The formula `(total_water_units + bucket_capacity - 1) // bucket_capacity` is used:\n   - `total_water_units`: Total number of water units in the grid.\n   - `bucket_capacity`: Capacity of each bucket.\n   \n   This formula effectively divides the total amount of water by the bucket capacity, rounding up to ensure that any remaining water (less than a full bucket) still counts as an additional operation.\n\n3. **Return Result**: The function returns the calculated number of times buckets need to be lowered.\n\nThis approach ensures that all units of water are accounted for and removed using the minimum number of bucket operations given the specified capacity."}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of ones in the binary representation of an integer.\nint count_ones(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\nvector<int> sort_array(vector<int>& arr) {\n    // Sort the array based on a custom comparator.\n    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        int ones_a = count_ones(a);\n        int ones_b = count_ones(b);\n\n        if (ones_a == ones_b) {\n            return abs(a) < abs(b); // Sort by absolute value if the number of ones is the same\n        }\n        return ones_a < ones_b; // Otherwise, sort by the number of ones\n    });\n\n    return arr;\n}\n", "py_code": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    def count_ones(n):\n        # Count the number of ones in the binary representation of n.\n        return bin(abs(n)).count('1')\n\n    arr.sort(key=lambda x: (count_ones(x), abs(x)))\n    \n    return arr\n```\n\n", "py_summary": "The Python code defines a function `sort_array` that sorts a list of integers based on the number of ones in their binary representation and their decimal value if the number of ones is the same.\n\n1. **Counting Ones**: The helper function `count_ones(n)` takes an integer `n`, converts it to its absolute value (to handle negative numbers correctly), and then counts the number of '1' bits in its binary representation using `bin(abs(n)).count('1')`.\n\n2. **Sorting Logic**:\n   - The list `arr` is sorted using Python's built-in `sort` method with a custom key.\n   - The key function `(lambda x: (count_ones(x), abs(x)))` ensures that the sorting criteria are applied in two steps:\n     1. First, by the number of ones in the binary representation (`count_ones(x)`).\n     2. Second, by the absolute value of each integer (`abs(x)`) if the number of ones is the same.\n\n3. **Return**: The sorted list `arr` is returned after applying the sorting logic.\n\nThis approach ensures that integers with fewer ones come first and among those with the same number of ones, smaller decimal values come before larger ones.\n\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> select_words(std::string s, int n) {\n    std::vector<std::string> words_with_n_consonants;\n    const std::string vowels = \"aeiouAEIOU\";\n    \n    // Split the string into words\n    std::istringstream iss(s);\n    std::string word;\n    while (iss >> word) {\n        int consonant_count = 0;\n        \n        // Count the number of consonants in each word\n        for (char ch : word) {\n            if (isalpha(ch) && vowels.find(ch) == std::string::npos) {\n                ++consonant_count;\n            }\n        }\n\n        // Check if the count matches n and add to result vector\n        if (consonant_count == n) {\n            words_with_n_consonants.push_back(word);\n        }\n    }\n    \n    return words_with_n_consonants;\n}\n", "py_code": "from typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    vowels = \"aeiouAEIOU\"\n    words_with_n_consonants = []\n    \n    for word in s.split():\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        \n        if consonant_count == n:\n            words_with_n_consonants.append(word)\n            \n    return words_with_n_consonants\n```\n\n", "py_summary": "The Python code defines a function `select_words` that takes a string `s` and an integer `n` as input and returns a list of words from the string `s` that contain exactly `n` consonants. Here's a detailed breakdown of how it works:\n\n1. **Initialization**:\n   - A set of vowels is defined to help identify consonants.\n   - An empty list, `words_with_n_consonants`, is initialized to store the words that meet the criteria.\n\n2. **Splitting the String**:\n   - The input string `s` is split into individual words using the `split()` method, which splits the string at each space and returns a list of words.\n\n3. **Counting Consonants**:\n   - For each word in the list, the function counts the number of consonants by iterating through each character in the word.\n   - The condition `char.isalpha() and char not in vowels` checks if the character is an alphabet letter and not a vowel, thus identifying it as a consonant.\n   - The count of such characters (consonants) for each word is stored.\n\n4. **Filtering Words**:\n   - If the count of consonants in a word matches `n`, that word is added to the list `words_with_n_consonants`.\n\n5. **Returning Result**:\n   - After iterating through all words, the function returns the list of words with exactly `n` consonants.\n\nThis approach ensures that only words meeting the specified criteria are included in the final result, and it handles cases where no such words exist by returning an empty list if no matches are found."}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ? !(strchr(\"aeiouAEIOU\", c)) : false;\n}\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int closest_vowel_index = -1;\n\n    for (int i = word.length() - 2; i > 0; --i) {  // Iterate from the second-to-last character to the first\n        if (vowels.find(word[i]) != string::npos) {\n            if (is_consonant(word[i-1]) && is_consonant(word[i+1])) {\n                closest_vowel_index = i;\n                break;\n            }\n        }\n    }\n\n    return closest_vowel_index == -1 ? \"\" : word.substr(closest_vowel_index, 1);\n}\n\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    closest_vowel_index = -1\n    \n    # Iterate from right to left excluding the last character\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and is_consonant(word[i-1]) and is_consonant(word[i+1]):\n            closest_vowel_index = i\n            break\n    \n    return word[closest_vowel_index] if closest_vowel_index != -1 else \"\"\n\ndef is_consonant(char):\n    return char.isalpha() and char not in \"aeiouAEIOU\"\n```\n\n", "py_summary": "The Python code defines a function `get_closest_vowel` that takes a word as input and returns the closest vowel standing between two consonants from the right side of the word. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - The variable `vowels` contains all English vowels in both lowercase and uppercase.\n   - `closest_vowel_index` is initialized to `-1`, which will be used to store the index of the closest vowel found.\n\n2. **Iterate from Right to Left**:\n   - A loop iterates over each character in the word starting from the second-to-last character (index `len(word) - 2`) and moving leftwards towards the beginning of the string.\n   - The loop skips the last two characters (`word[-1]` and `word[-2]`) because vowels at the end do not count.\n\n3. **Check Conditions**:\n   - For each character in the word, it checks if the current character is a vowel (using `if word[i] in vowels`).\n   - It also checks if the characters immediately before (`word[i-1]`) and after (`word[i+1]`) the current character are consonants using the helper function `is_consonant`.\n\n4. **Helper Function**:\n   - The helper function `is_consonant(char)` returns `True` if the given character is an alphabetic letter but not a vowel.\n\n5. **Update Closest Vowel Index**:\n   - If all conditions are met (current character is a vowel and both adjacent characters are consonants), it sets `closest_vowel_index` to the current index (`i`) and breaks out of the loop.\n\n6. **Return Result**:\n   - After the loop, if `closest_vowel_index` remains `-1`, it means no such vowel was found, so an empty string is returned.\n   - Otherwise, the function returns the character at `closest_vowel_index`.\n\nThis approach ensures that only vowels between two consonants from the right side of the word are considered and returned."}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else if (c == ')') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first_option = lst[0] + lst[1];\n    string second_option = lst[1] + lst[0];\n\n    if (is_balanced(first_option) || is_balanced(second_option)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "py_code": "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    def is_balanced(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    first_option = lst[0] + lst[1]\n    second_option = lst[1] + lst[0]\n\n    if is_balanced(first_option) or is_balanced(second_option):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "The Python code defines a function `match_parens` that takes a list of two strings as input and checks if it is possible to concatenate these strings in any order such that the resulting string has balanced parentheses.\n\n1. **Helper Function (`is_balanced`)**:\n   - This function checks whether a given string of parentheses is balanced.\n   - It initializes a balance counter to zero.\n   - For each character in the string, if it's an open parenthesis '(', the balance counter increments by 1.\n   - If it's a close parenthesis ')', the balance counter decrements by 1.\n   - If at any point the balance counter becomes negative (indicating there are more closing parentheses than opening ones), the function returns `False`.\n   - After processing all characters, if the balance counter is zero, the string is balanced and the function returns `True`.\n\n2. **Main Function (`match_parens`)**:\n   - The main function takes a list of two strings as input.\n   - It generates both possible concatenations: `lst[0] + lst[1]` and `lst[1] + lst[0]`.\n   - For each concatenation, it uses the helper function `is_balanced` to check if the resulting string is balanced.\n   - If either of the two concatenations results in a balanced string, the main function returns `\"Yes\"`.\n   - If neither concatenation results in a balanced string, the function returns `\"No\"`.\n\nThis approach ensures that all possible ways to concatenate the given strings are checked for balance, and it provides a clear and concise solution to the problem."}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> maximum(std::vector<int> arr, int k) {\n    // Sort the array in descending order\n    std::sort(arr.begin(), arr.end(), std::greater<int>());\n    \n    // Take the first k elements from the sorted array\n    std::vector<int> top_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Sort these k elements in ascending order\n    std::sort(top_k_elements.begin(), top_k_elements.end());\n    \n    return top_k_elements;\n}\n", "py_code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    # Sort the array in descending order and take the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    \n    # Return these elements in ascending order\n    return sorted(sorted_arr)\n```\n\n", "py_summary": "The Python code defines a function `maximum` that takes an array of integers and a positive integer `k`, and returns a vector containing the maximum `k` numbers from the input array in ascending order.\n\n1. **Sorting in Descending Order**: The first step is to sort the entire array in descending order using `sorted(arr, reverse=True)`. This ensures that the largest elements are at the beginning of the sorted list.\n2. **Selecting Top k Elements**: After sorting, we take the first `k` elements from this sorted list using slicing `[:k]`.\n3. **Sorting Again for Ascending Order**: Finally, these top `k` elements are sorted again in ascending order to meet the requirement that the output vector should be in ascending order.\n\nThis approach ensures that the function returns a vector of length `k` containing the largest `k` numbers from the input array, arranged in increasing order."}
{"task_id": "CPP/121", "generation": "#include <vector>\n\nint solution(std::vector<int> lst) {\n    int total_sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            total_sum += lst[i];\n        }\n    }\n    return total_sum;\n}\n", "py_code": "def solution(lst):\n    total_sum = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total_sum += lst[i]\n    return total_sum\n```\n\n", "py_summary": "The Python function `solution` calculates the sum of all odd elements that are in even positions within a given list of integers.\n\n1. **Initialization**: The variable `total_sum` is initialized to 0 to keep track of the cumulative sum.\n2. **Iteration and Condition Checking**:\n   - The function iterates through each element in the list using an index-based loop (`for i in range(len(lst))`).\n   - For each element, it checks if the current position `i` is even (i.e., `i % 2 == 0`) and if the element at that position is odd (i.e., `lst[i] % 2 != 0`).\n3. **Sum Calculation**:\n   - If both conditions are met, the value of the element at index `i` is added to `total_sum`.\n4. **Return Result**: After iterating through all elements, the function returns the total sum.\n\nThis approach ensures that only odd numbers in even positions (0-based indexing) contribute to the final sum.\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int total_sum = 0;\n    \n    for (int i = 0; i < k; ++i) {\n        if (1 <= arr[i] && arr[i] < 100) {  // Check if the number has at most two digits\n            total_sum += arr[i];\n        }\n    }\n\n    return total_sum;\n}\n", "py_code": "def add_elements(arr, k):\n    total_sum = 0\n    for num in arr[:k]:\n        if 1 <= num < 100:  # Check if the number has at most two digits\n            total_sum += num\n    return total_sum\n```\n\n", "py_summary": "The Python function `add_elements` takes a list of integers `arr` and an integer `k`, and returns the sum of elements with at most two digits from the first `k` elements of `arr`.\n\n1. **Initialization**: The variable `total_sum` is initialized to 0, which will store the cumulative sum of numbers that meet the criteria.\n2. **Iteration through the first k elements**: A loop iterates over the first `k` elements of the list `arr`.\n3. **Condition Check**: For each element in this range, it checks if the number has at most two digits (i.e., between 1 and 99 inclusive).\n4. **Sum Calculation**: If the condition is met, the number is added to `total_sum`.\n5. **Return Result**: After iterating through all elements up to index `k-1`, the function returns the total sum.\n\nThis approach ensures that only numbers with at most two digits are included in the final sum, adhering to the problem constraints.\n\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    \n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {  // If n is even\n            n = n / 2;\n        } else {           // If n is odd\n            n = 3 * n + 1;\n        }\n    }\n\n    collatz_sequence.push_back(1);  // Append the final term, which is always 1\n\n    // Filter out only the odd numbers from the sequence and sort them\n    vector<int> odd_numbers;\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n", "py_code": "def get_odd_collatz(n):\n    collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:  # If n is even\n            n = n // 2\n        else:           # If n is odd\n            n = 3 * n + 1\n    \n    collatz_sequence.append(1)  # Append the final term, which is always 1\n\n    # Filter out only the odd numbers from the sequence and sort them\n    odd_numbers = sorted([num for num in collatz_sequence if num % 2 != 0])\n    \n    return odd_numbers\n```\n\n", "py_summary": "The Python function `get_odd_collatz` generates and processes the Collatz sequence for a given positive integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**: The function initializes an empty list `collatz_sequence` to store the numbers in the Collatz sequence.\n\n2. **Generating the Sequence**:\n   - A while loop runs until `n` becomes 1.\n   - In each iteration, the current value of `n` is appended to `collatz_sequence`.\n   - If `n` is even, it updates `n` to `n // 2`.\n   - If `n` is odd, it updates `n` to `3 * n + 1`.\n\n3. **Final Term**: After the loop ends (when `n` becomes 1), the function appends 1 to `collatz_sequence`, as per the Collatz conjecture.\n\n4. **Filtering Odd Numbers**:\n   - A list comprehension filters out only the odd numbers from `collatz_sequence`.\n   - The filtered odd numbers are then sorted in increasing order using Python's built-in `sorted` function.\n\n5. **Return**: Finally, the function returns the sorted list of odd numbers.\n\nThis approach ensures that all steps of generating and processing the Collatz sequence are handled correctly, and only the odd numbers are returned in a sorted manner."}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Define the format for parsing the date string\n    const char* format = \"%m-%d-%Y\";\n    \n    // Try to parse the date using strptime\n    struct tm parsedDate;\n    if (strptime(date.c_str(), format, &parsedDate)) {\n        int month = parsedDate.tm_mon + 1; // tm_mon is zero-based\n        int day = parsedDate.tm_mday;\n\n        // Check for valid month and day ranges\n        if (month >= 1 && month <= 12) {\n            bool isValidDay = true;\n            \n            switch(month) {\n                case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n                    isValidDay = day >= 1 && day <= 31;\n                    break;\n                case 4: case 6: case 9: case 11:\n                    isValidDay = day >= 1 && day <= 30;\n                    break;\n                case 2:\n                    // February has a maximum of 29 days\n                    isValidDay = day >= 1 && day <= 29;\n                    break;\n            }\n\n            return isValidDay;\n        }\n    }\n\n    // If parsing fails or validation rules are not met, return false\n    return false;\n}\n\n", "py_code": "from datetime import datetime\n\ndef valid_date(date):\n    # Define the format for the date string\n    date_format = \"%m-%d-%Y\"\n    \n    try:\n        # Try parsing the date using the specified format\n        parsed_date = datetime.strptime(date, date_format)\n        \n        # Extract month and day from the parsed date\n        month = parsed_date.month\n        day = parsed_date.day\n        \n        # Check if the day is valid for the given month\n        if (month in [1, 3, 5, 7, 8, 10, 12] and not 1 <= day <= 31) or \\\n           (month in [4, 6, 9, 11] and not 1 <= day <= 30) or \\\n           (month == 2 and not 1 <= day <= 29):\n            return False\n        \n        # If parsing is successful and all conditions are met, the date is valid\n        return True\n    \n    except ValueError:\n        # If parsing fails due to incorrect format or invalid values, return false\n        return False\n```\n\n", "py_summary": "The Python code defines a function `valid_date` that takes a date string as input and returns `True` if the date is valid according to specified rules, otherwise it returns `False`. Here's an analysis of how the function works:\n\n1. **Date Format Validation**: The function uses the `datetime.strptime()` method from the `datetime` module to parse the date string based on a predefined format (`\"%m-%d-%Y\"`). This ensures that the input date is in the correct format (mm-dd-yyyy).\n\n2. **Exception Handling**: If parsing fails due to an incorrect format or invalid values, a `ValueError` exception is raised and caught by the function. In such cases, the function returns `False`.\n\n3. **Month and Day Validation**:\n   - The parsed date object (`parsed_date`) is used to extract the month and day.\n   - For months with 31 days (January, March, May, July, August, October, December), it checks if the day is between 1 and 31 inclusive.\n   - For months with 30 days (April, June, September, November), it checks if the day is between 1 and 30 inclusive.\n   - For February (month 2), it checks if the day is between 1 and 29 inclusive.\n\n4. **Return Value**: If all conditions are met, the function returns `True`, indicating that the date is valid. Otherwise, it returns `False`.\n\nThis approach ensures that the input date string adheres to the specified format and rules for a valid date.\n\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Step 1: Split on whitespace\n    size_t start = 0;\n    vector<string> words;\n    \n    while (start < txt.length()) {\n        size_t end = txt.find_first_of(\" ,\", start);\n        \n        if (end == string::npos) {\n            end = txt.length();\n        }\n        \n        if (start != end) {\n            words.push_back(txt.substr(start, end - start));\n        }\n        \n        // Move to the next character after the current delimiter\n        start = end + 1;\n    }\n\n    // Step 2: Check for multiple words and return if more than one word exists\n    if (words.size() > 1) {\n        return words;\n    }\n\n    // Step 3: Split on commas if no whitespaces exist\n    if (!txt.find(',')) {\n        size_t start = 0;\n        \n        while (start < txt.length()) {\n            size_t end = txt.find(',', start);\n            \n            if (end == string::npos) {\n                end = txt.length();\n            }\n            \n            words.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n\n        return words;\n    }\n\n    // Step 4: Count the number of lowercase letters with odd order in the alphabet\n    int count_odd_order_letters = 0;\n\n    for (char c : txt) {\n        if ('a' <= c && c <= 'z') {\n            if ((c - 'a') % 2 == 1) {\n                count_odd_order_letters++;\n            }\n        }\n    }\n\n    // Return the count as a single-element vector\n    return {to_string(count_odd_order_letters)};\n}\n", "py_code": "def split_words(txt):\n    # Split on whitespace first\n    words = txt.split()\n    \n    if len(words) > 1:\n        return words\n    \n    # If no whitespaces, split on commas\n    if ',' in txt:\n        words = txt.split(',')\n        return words\n    \n    # If no commas, count the number of lowercase letters with odd order in the alphabet\n    count_odd_order_letters = sum(1 for char in txt if 'a' <= char <= 'z' and ord(char) % 2 == 0)\n    \n    return [str(count_odd_order_letters)]\n```\n\n", "py_summary": "The Python function `split_words` processes a given string `txt` according to specific rules:\n\n1. **Split on Whitespace**: The function first attempts to split the input string `txt` into words using whitespace as the delimiter. If there are multiple words separated by spaces, it returns these words in a list.\n\n2. **Split on Commas**: If splitting on whitespace does not yield more than one word (i.e., no whitespaces exist), the function checks if commas are present in the string. If commas are found, it splits the string using commas as delimiters and returns the resulting substrings.\n\n3. **Count Odd-Order Letters**: If neither whitespaces nor commas are present in the input string, the function counts the number of lowercase letters that have an odd order in the alphabet (where 'a' is 0, 'b' is 1, ..., 'z' is 25). The count is then converted to a string and returned as a single-element list.\n\nHere's a breakdown of each step:\n\n- **Splitting on Whitespace**: `words = txt.split()` splits the input string into words based on whitespace.\n  \n- **Checking for Multiple Words**: If the length of the resulting list `words` is greater than 1, it means there were multiple words separated by spaces, and the function returns this list.\n\n- **Splitting on Commas**: If splitting on whitespace did not yield more than one word (i.e., `len(words) <= 1`), the function checks if commas are present in the string using `if ',' in txt`. If a comma is found, it splits the input string using commas as delimiters: `words = txt.split(',')`.\n\n- **Counting Odd-Order Letters**: If neither whitespaces nor commas exist in the input string, the function counts the number of lowercase letters with an odd order in the alphabet. This is done by iterating over each character in the string and checking if it is a lowercase letter (`'a' <= char <= 'z'`) and if its ASCII value modulo 2 equals 0 (indicating an even position in the alphabet). The count is then converted to a string and returned as a single-element list: `return [str(count_odd_order_letters)]`.\n\nThis function ensures that the input string is processed according to the specified rules, providing appropriate output based on the presence or absence of whitespaces and commas."}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int>& lst) {\n    // Check if the list is sorted in ascending order\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    // Count occurrences of each number and check if any number appears more than twice\n    std::unordered_map<int, int> counts;\n    for (int num : lst) {\n        counts[num]++;\n        if (counts[num] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n", "py_code": "def is_sorted(lst):\n    # Check if the list is sorted in ascending order\n    if not all(x <= y for x, y in zip(lst, lst[1:])):\n        return False\n    \n    # Count occurrences of each number and check if any number appears more than twice\n    from collections import Counter\n    counts = Counter(lst)\n    \n    for count in counts.values():\n        if count > 2:\n            return False\n            \n    return True\n```\n\n", "py_summary": "The Python function `is_sorted` checks whether a given list of integers is sorted in ascending order and ensures that no integer appears more than twice. Here's an analysis of how it works:\n\n1. **Check if List is Sorted**:\n   - The function uses a generator expression within the `all()` function to check if each element in the list is less than or equal to the next element.\n   - This is done using `zip(lst, lst[1:])`, which pairs each element with its successor and checks the condition for all such pairs.\n\n2. **Count Occurrences of Each Number**:\n   - The function uses the `Counter` class from the `collections` module to count how many times each number appears in the list.\n   \n3. **Check if Any Number Appears More Than Twice**:\n   - After obtaining the counts, the function iterates through these counts and checks if any value is greater than 2.\n   - If such a value exists, it returns `False`.\n\n4. **Return True if All Conditions Are Met**:\n   - If both conditions (the list being sorted in ascending order and no number appearing more than twice) are satisfied, the function returns `True`.\n\nThis approach ensures that the list is checked for both sorting and frequency constraints efficiently.\n\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min)\n        return \"NO\";\n\n    int length = end_min - start_max + 1;\n    return is_prime(length) ? \"YES\" : \"NO\";\n}\n", "py_code": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    \n    if start_max > end_min:\n        return \"NO\"\n    \n    length = end_min - start_max + 1\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "The Python code defines a function `intersection` that takes two intervals as input and determines whether the length of their intersection is a prime number. Here's an analysis of how it works:\n\n1. **Prime Number Check Function (`is_prime`)**:\n   - This helper function checks if a given integer \\( n \\) is a prime number.\n   - It returns `False` for numbers less than or equal to 1, as they are not considered prime.\n   - For other values of \\( n \\), it iterates from 2 up to the square root of \\( n \\). If any divisor is found during this iteration, it returns `False`.\n   - Otherwise, if no divisors are found, it returns `True`.\n\n2. **Intersection Calculation**:\n   - The function first calculates the maximum start point (`start_max`) and the minimum end point (`end_min`) of the two intervals.\n   - If `start_max` is greater than `end_min`, it means that the intervals do not intersect, so the function returns \"NO\".\n   \n3. **Length Calculation**:\n   - The length of the intersection is calculated as `length = end_min - start_max + 1`.\n   - This formula accounts for both endpoints being inclusive.\n\n4. **Prime Check and Return Result**:\n   - The function uses the `is_prime` helper function to check if the length of the intersection is a prime number.\n   - If it is, the function returns \"YES\".\n   - Otherwise, it returns \"NO\".\n\nThis approach ensures that the code correctly identifies whether the intersection length is prime and handles non-intersecting intervals appropriately."}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int magnitude_sum = 0;\n    int sign_product = 1;\n\n    for (const auto& num : arr) {\n        magnitude_sum += std::abs(num);\n        if (num == 0) {\n            sign_product = 0;\n            break; // No need to continue if there's a zero\n        } else if (num < 0) {\n            sign_product *= -1;\n        }\n    }\n\n    return magnitude_sum * sign_product;\n}\n", "py_code": "def prod_signs(arr):\n    if not arr:\n        return -32768\n    \n    magnitude_sum = 0\n    sign_product = 1\n    \n    for num in arr:\n        magnitude_sum += abs(num)\n        if num == 0:\n            sign_product = 0\n        elif num < 0:\n            sign_product *= -1\n    \n    return magnitude_sum * sign_product\n```\n\n", "py_summary": "The Python function `prod_signs` calculates the sum of magnitudes of integers in a given list and multiplies it by the product of all signs (represented as 1 for positive, -1 for negative, and 0 if any number is zero) of each integer in the list.\n\nHere's an analysis of how the code works:\n\n1. **Check for Empty List**: The function first checks if the input list `arr` is empty. If it is, the function returns `-32768`.\n\n2. **Initialize Variables**:\n   - `magnitude_sum`: This variable keeps track of the sum of the magnitudes (absolute values) of all integers in the list.\n   - `sign_product`: This variable calculates the product of signs for each integer in the list.\n\n3. **Iterate Through List**: The function iterates through each number in the list:\n   - It adds the absolute value of the current number to `magnitude_sum`.\n   - If the current number is zero, it sets `sign_product` to 0 and exits further sign product calculations.\n   - If the current number is negative, it multiplies `sign_product` by `-1`.\n\n4. **Return Result**: Finally, the function returns the result of multiplying `magnitude_sum` by `sign_product`.\n\nThis approach ensures that the sum of magnitudes and the product of signs are correctly calculated and combined to produce the final result.\n\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function for DFS with memoization\nvoid dfs(vector<vector<int>>& grid, vector<vector<vector<int>>>& dp, int x, int y, int steps, int N) {\n    if (steps == 0)\n        return;\n    \n    if (dp[x][y][steps] != vector<int>(N * N + 1, INT_MAX)) {\n        return;\n    }\n    \n    for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n            if ((abs(dx) == abs(dy))) continue; // Skip diagonal moves\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                dfs(grid, dp, nx, ny, steps - 1, N);\n                \n                for (int i = 0; i <= steps; ++i) {\n                    dp[x][y][steps] = min(dp[x][y][steps], dp[nx][ny][steps - 1]);\n                    if (dp[x][y][steps].size() > i)\n                        break;\n                }\n                \n                dp[x][y][steps].push_back(grid[x][y]);\n            }\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Initialize the DP table with a large value\n    vector<vector<vector<int>>> dp(N, vector<vector<int>>(N, vector<int>(k + 1, vector<int>(N * N + 1, INT_MAX))));\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dfs(grid, dp, i, j, k - 1, N);\n        }\n    }\n\n    vector<int> result(N * N + 1, INT_MAX);\n    \n    // Find the minimum path\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j][k - 1].size() > result.size()) continue;\n            \n            vector<int> tempPath(dp[i][j][k - 1]);\n            tempPath.push_back(grid[i][j]);\n            \n            result = min(result, tempPath);\n        }\n    }\n\n    return result;\n}\n\n", "py_code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    \n    # Initialize a priority queue with all possible starting points.\n    from heapq import heappush, heappop\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heappush(pq, (grid[i][j], [grid[i][j]], i, j))\n    \n    # Define the directions to move: up, down, left, right.\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    \n    while k > 0:\n        size = len(pq)\n        for _ in range(size):\n            val, path, x, y = heappop(pq)\n            \n            # Explore all possible moves from the current cell.\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                # Check if the new position is within bounds of the grid.\n                if 0 <= nx < N and 0 <= ny < N:\n                    heappush(pq, (grid[nx][ny], path + [grid[nx][ny]], nx, ny))\n        \n        k -= 1\n    \n    # The minimum path will be at the top of the priority queue.\n    return pq[0][1][:k]\n```\n\n", "py_summary": "The Python code defines a function `minPath` that takes a grid and an integer `k`, and returns the minimum path consisting of the first `k` elements from the starting points in the grid. The function uses a priority queue (implemented with a heap) to explore all possible paths from each cell in the grid.\n\nHere's a detailed breakdown:\n\n1. **Initialization**:\n   - The size of the grid is determined by `N`, which is the length of one side of the square grid.\n   - A priority queue (`pq`) is initialized, and for every starting point `(i, j)` in the grid, an entry is pushed into the heap with the value at that cell, a path containing only that value, and the coordinates `(i, j)`.\n\n2. **Direction Vectors**:\n   - The `directions` list contains tuples representing possible moves: right (0, 1), down (1, 0), up (-1, 0), and left (0, -1).\n\n3. **Main Loop**:\n   - A loop runs `k` times to explore the grid.\n   - For each iteration of the main loop, a sub-loop processes all entries currently in the priority queue (`pq`). Each entry contains the current value, path taken so far, and coordinates `(x, y)`.\n   - From each cell, the function explores its neighbors by moving in one of the four directions. If the new position is within bounds of the grid, a new entry with updated information (value at the new cell, extended path, and new coordinates) is pushed into the priority queue.\n\n4. **Result Extraction**:\n   - After `k` iterations, the top element of the priority queue contains the minimum path consisting of the first `k` elements.\n   - The function returns this path truncated to length `k`.\n\nThis approach ensures that the shortest paths are explored first due to the nature of the priority queue (min-heap), making it efficient for finding the minimal path in a grid.\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0)\n        return {};\n\n    vector<int> sequence = {1};  // Initial condition for tri(1) = 3\n    \n    for (int i = 2; i <= n + 1; ++i) {  // Generate up to tri(n+1)\n        int value;\n        if (i % 2 == 0) {  // If i is even\n            value = 1 + (i / 2);\n        } else {  // If i is odd\n            value = sequence[i-3] + sequence[i-4] + sequence.back();\n        }\n        \n        sequence.push_back(value);\n    }\n    \n    return vector<int>(sequence.begin() + 1, sequence.end());  // Return the sequence starting from index 1 to n+1\n}\n\n", "py_code": "def tri(n):\n    if n == 0:\n        return []\n    \n    sequence = [1]  # tri(1) = 3 but we start with 1 as per the initial condition\n    \n    for i in range(2, n + 2):  # We need to generate up to n+1 elements\n        if i % 2 == 0:\n            value = 1 + (i // 2)\n        else:\n            value = sequence[i - 2] + sequence[i - 3] + sequence[i]\n        sequence.append(value)\n    \n    return sequence[1:]  # Return the sequence starting from tri(1) to tri(n)\n\n", "py_summary": "The Python function `tri` calculates and returns the first `n + 1` numbers of the Tribonacci sequence as defined by the problem statement. Here's a detailed breakdown:\n\n1. **Initialization**:\n   - If `n == 0`, an empty list is returned because there are no elements to generate.\n   - The function initializes a list `sequence` with `[1]`. This represents the initial condition for the Tribonacci sequence, starting from `tri(1) = 3`.\n\n2. **Loop through numbers**:\n   - A loop runs from `i = 2` to `n + 1`, generating each element of the sequence up to `tri(n+1)`.\n\n3. **Calculate value based on conditions**:\n   - If `i` is even, the value for `tri(i)` is calculated as `1 + (i // 2)`.\n   - If `i` is odd, the value for `tri(i)` is calculated using the recurrence relation: `sequence[i-2] + sequence[i-3] + sequence[i]`.\n\n4. **Append to sequence**:\n   - The computed value is appended to the `sequence` list.\n\n5. **Return result**:\n   - Finally, the function returns a slice of the `sequence` starting from index 1 (to exclude the initial `[1]`) up to `n + 1`.\n\nThis approach ensures that each element in the sequence is calculated correctly based on whether its index is even or odd and adheres to the given recurrence relations.\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10;\n    }\n\n    return has_odd_digit ? product : 0;\n}\n\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    \n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    \n    return product if has_odd_digit else 0\n```\n\n", "py_summary": "The Python function `digits` calculates the product of the odd digits in a given positive integer `n`. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - `product`: This variable is initialized to 1 and will store the cumulative product of all odd digits found.\n   - `has_odd_digit`: A boolean flag that tracks whether at least one odd digit has been encountered.\n\n2. **Loop through each digit**:\n   - The function uses a while loop to process each digit of the integer `n` from right to left (least significant to most significant).\n   - Inside the loop, the last digit (`digit`) is extracted using `n % 10`.\n   \n3. **Check if the digit is odd**:\n   - If the digit is odd (i.e., `digit % 2 != 0`), it updates the product by multiplying the current value of `product` with this digit.\n   - The flag `has_odd_digit` is set to True.\n\n4. **Remove the last digit**:\n   - After processing a digit, the function removes that digit from `n` using integer division (`n //= 10`).\n\n5. **Return the result**:\n   - If at least one odd digit was found (`has_odd_digit` is True), the function returns the product of all odd digits.\n   - If no odd digits were found, it returns 0.\n\nThis approach ensures that the function correctly calculates and returns the product of odd digits or 0 if there are none."}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> bracket_stack;\n    bool has_nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            bracket_stack.push(c);\n        } else if (c == ']') {\n            if (!bracket_stack.empty() && !has_nested && bracket_stack.size() > 1) {\n                has_nested = true;\n            }\n            if (!bracket_stack.empty()) {\n                bracket_stack.pop();\n            } else {\n                // If the stack is empty and we encounter a closing bracket, it's invalid\n                return false;\n            }\n        }\n    }\n\n    // Check if there was at least one nested bracket sequence and all brackets are properly closed\n    return has_nested && bracket_stack.empty();\n}\n\n", "py_code": "def is_nested(str):\n    stack = []\n    has_nested = False\n\n    for char in str:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 1:\n                has_nested = True\n            stack.pop()\n    \n    return has_nested and not stack\n```\n\n", "py_summary": "The Python function `is_nested` checks whether a given string containing only square brackets has at least one nested bracket sequence. Here's an analysis of how it works:\n\n1. **Initialization**:\n   - A stack is initialized to keep track of open brackets.\n   - A boolean variable `has_nested` is initialized to `False` to indicate if there is any nesting.\n\n2. **Iterate through the string**:\n   - For each character in the input string, the function checks whether it is an opening bracket `[`.\n     - If it is an opening bracket, the character is pushed onto the stack.\n   - If the character is a closing bracket `]`:\n     - The function checks if there are at least two brackets on the stack (indicating that there is a nested structure).\n       - If so, `has_nested` is set to `True`.\n     - The top element of the stack is popped.\n\n3. **Final check**:\n   - After iterating through all characters in the string, the function checks if `has_nested` is `True` and the stack is empty (indicating that all brackets are properly closed).\n   - If both conditions are met, the function returns `True`, otherwise it returns `False`.\n\nThis approach ensures that the function correctly identifies whether there is at least one nested bracket sequence in the input string.\n\n"}
{"task_id": "CPP/133", "generation": "#include <cmath>\n#include <vector>\n\nint sum_squares(std::vector<float> lst) {\n    int total_sum = 0;\n    for (float num : lst) {\n        int rounded_num = std::ceil(num);\n        int squared_num = rounded_num * rounded_num;\n        total_sum += squared_num;\n    }\n    return total_sum;\n}\n", "py_code": "from math import ceil\n\ndef sum_squares(lst):\n    total_sum = 0\n    for num in lst:\n        squared_num = ceil(num) ** 2\n        total_sum += squared_num\n    return total_sum\n```\n\n", "py_summary": "The Python function `sum_squares` takes a list of floating-point numbers as input and returns the sum of their ceiling-rounded values squared. Here's a detailed breakdown:\n\n1. **Initialization**: The variable `total_sum` is initialized to 0 to keep track of the cumulative sum.\n2. **Iteration through List**: A loop iterates over each element in the input list `lst`.\n3. **Ceiling and Squaring**:\n   - For each number `num`, it uses the `ceil` function from the math module to round up to the nearest integer.\n   - The rounded value is then squared using the exponentiation operator (`** 2`).\n4. **Accumulation**: The squared value is added to `total_sum`.\n5. **Return Result**: After iterating through all elements, the total sum of squared values is returned.\n\nThis approach ensures that each number in the list is processed individually, rounded up to its ceiling value, squared, and then summed up to produce the final result.\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype> // For isspace() function\n\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Strip trailing spaces\n    size_t last_non_space_pos = txt.find_last_not_of(' ');\n    std::string stripped_txt = txt.substr(0, last_non_space_pos + 1);\n\n    char last_char = stripped_txt.back();\n\n    // Check if the last character is an alphabetical character and not part of a word\n    bool is_alpha = std::isalpha(last_char);\n    bool has_space_before_last_char = (last_non_space_pos > 0 && txt[last_non_space_pos - 1] == ' ');\n\n    return is_alpha && (!has_space_before_last_char || stripped_txt.length() == 1);\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    # Strip trailing spaces and get the last character\n    stripped_txt = txt.rstrip()\n    last_char = stripped_txt[-1]\n    \n    # Check if the last character is an alphabetical character\n    # and it's not part of a word (i.e., there should be a space before it)\n    return last_char.isalpha() and ' ' in stripped_txt[:-1] or len(stripped_txt) == 1\n```\n\n", "py_summary": "The Python function `check_if_last_char_is_a_letter` checks if the last character of a given string is an alphabetical character and is not part of a word. Here's a detailed analysis:\n\n1. **Check for Empty String**:\n   - The function first checks if the input string `txt` is empty. If it is, the function returns `False`.\n\n2. **Strip Trailing Spaces**:\n   - The function uses `rstrip()` to remove any trailing spaces from the end of the string. This ensures that only significant characters are considered.\n\n3. **Get Last Character**:\n   - After stripping the trailing spaces, the last character of the modified string is obtained using `stripped_txt[-1]`.\n\n4. **Check if Last Character is Alphabetical**:\n   - The function checks if the last character is an alphabetical character using the `isalpha()` method.\n\n5. **Check if Last Character is Not Part of a Word**:\n   - To determine if the last character is not part of a word, the function checks if there is at least one space in the string before the last character (`' ' in stripped_txt[:-1]`).\n   - Additionally, it handles the case where the entire string consists of only one character by checking `len(stripped_txt) == 1`.\n\n6. **Return Result**:\n   - The function returns `True` if both conditions are met (last character is alphabetical and not part of a word), otherwise it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the last character in the string meets the specified criteria."}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n", "py_code": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1\n```\n\n", "py_summary": "The Python function `can_arrange` takes a list of integers as input and returns the largest index where an element is smaller than its preceding element. If no such element exists, it returns `-1`.\n\nHere's a detailed breakdown:\n- The function iterates through the list starting from the second element (index 1).\n- For each element at index `i`, it checks if `arr[i]` is less than `arr[i - 1]`.\n- If this condition is true, it means that the current element is smaller than its preceding element, and thus, the function returns the current index `i`.\n- If no such element is found after iterating through the list, the function returns `-1`.\n\nThis approach ensures that we find the largest possible index where an element violates the non-decreasing order condition."}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(std::vector<int> lst) {\n    int max_negative = INT_MIN;\n    int min_positive = INT_MAX;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative or positive integers were found, return [0, 0]\n    if (max_negative == INT_MIN) {\n        max_negative = 0;\n    }\n    if (min_positive == INT_MAX) {\n        min_positive = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n", "py_code": "from typing import List\n\ndef largest_smallest_integers(lst: List[int]) -> List[int]:\n    max_negative = float('-inf')\n    min_positive = float('inf')\n\n    for num in lst:\n        if num < 0 and num > max_negative:\n            max_negative = num\n        elif num > 0 and num < min_positive:\n            min_positive = num\n\n    return [max_negative, min_positive] if max_negative != float('-inf') or min_positive != float('inf') else [0, 0]\n```\n\n", "py_summary": "The Python function `largest_smallest_integers` takes a list of integers as input and returns a vector containing two elements: the largest negative integer and the smallest positive integer in the list. If there are no negative or positive integers in the list, it returns 0 for both values.\n\nHere's an analysis of how the code works:\n\n1. **Initialization**:\n   - `max_negative` is initialized to `-inf`, which ensures that any negative number encountered will be larger.\n   - `min_positive` is initialized to `+inf`, ensuring that any positive number encountered will be smaller.\n\n2. **Iteration through the list**:\n   - The function iterates over each element in the input list `lst`.\n   - For each element, it checks if the number is negative and greater than the current value of `max_negative`. If true, it updates `max_negative` to this new value.\n   - Similarly, for positive numbers, it checks if the number is smaller than the current value of `min_positive`. If true, it updates `min_positive` to this new value.\n\n3. **Return statement**:\n   - After iterating through all elements in the list, the function returns a vector containing `[max_negative, min_positive]`.\n   - However, if no negative or positive integers were found (i.e., `max_negative` remains `-inf` and `min_positive` remains `+inf`), it returns `[0, 0]`.\n\nThis approach ensures that the function correctly identifies the largest negative integer and the smallest positive integer in the list, handling edge cases where there are no such elements appropriately."}
{"task_id": "CPP/137", "generation": "#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nnamespace boost {\n    template <>\n    std::string any_cast<std::string>(const boost::any& operand) {\n        return operand.type() == typeid(std::string) ? *boost::any_cast<std::string>(&operand) : \"\";\n    }\n\n    template <>\n    double any_cast<double>(const boost::any& operand) {\n        if (operand.type() == typeid(double)) {\n            return *boost::any_cast<double>(&operand);\n        } else if (operand.type() == typeid(std::string)) {\n            std::string str = *boost::any_cast<std::string>(&operand);\n            size_t pos;\n            double value = std::stod(str, &pos); // Convert string to double\n            return value;\n        }\n        return 0.0; // Default case\n    }\n}\n\nstd::string convert_to_string(boost::any a) {\n    if (a.type() == typeid(int)) {\n        int val = boost::any_cast<int>(a);\n        return std::to_string(val);\n    } else if (a.type() == typeid(double)) {\n        double val = boost::any_cast<double>(a);\n        return std::to_string(val).replace(std::string::npos - 1, 2, \",\"); // Replace . with ,\n    } else if (a.type() == typeid(std::string)) {\n        return boost::any_cast<std::string>(a);\n    }\n    return \"\";\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double val_a = boost::any_cast<double>(a);\n    double val_b = boost::any_cast<double>(b);\n\n    if (val_a > val_b) {\n        return convert_to_string(a);\n    } else if (val_b > val_a) {\n        return convert_to_string(b);\n    } else {\n        return \"None\";\n    }\n}\n", "py_code": "from typing import Any\n\ndef compare_one(a: Any, b: Any) -> Any:\n    # Convert inputs to floats if they are strings with decimal points or commas\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n\n    # Compare the values and return the larger one in its original type\n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return \"None\"\n```\n\n", "py_summary": "The Python function `compare_one` takes two inputs of any type (integers, floats, or strings) and returns the larger value in its original type if they are not equal. If the values are equal, it returns \"None\". Here's a detailed breakdown:\n\n1. **Type Conversion**:\n   - The function first checks if `a` is a string. If so, it converts the string to a float by replacing any commas with periods (to handle different decimal separators).\n   - Similarly, it does the same for `b`.\n\n2. **Comparison and Return**:\n   - After converting strings to floats (if necessary), the function compares the values of `a` and `b`.\n   - If `a` is greater than `b`, it returns `a` in its original type.\n   - If `b` is greater than `a`, it returns `b` in its original type.\n   - If `a` and `b` are equal, the function returns \"None\".\n\nThis ensures that the function handles different types of inputs correctly and provides the expected output based on the comparison.\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Since we need exactly 4 positive even numbers, the smallest sum of such numbers is 2 + 2 + 2 + 2 = 8.\n    if (n < 8) {\n        return false;\n    }\n    \n    // Any number that can be written as a sum of four even numbers must itself be even and at least 8.\n    if (n % 2 == 0 && n >= 8) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    # Since we need exactly 4 positive even numbers, the smallest sum of such numbers is 2 + 2 + 2 + 2 = 8.\n    if n < 8:\n        return False\n    \n    # Any number that can be written as a sum of four even numbers must itself be even and at least 8.\n    if n % 2 == 0 and n >= 8:\n        return True\n    else:\n        return False\n```\n\n", "py_summary": "The Python function `is_equal_to_sum_even(n)` evaluates whether a given integer `n` can be expressed as the sum of exactly four positive even numbers.\n\n1. **Initial Check**: The smallest possible sum of four positive even numbers is \\(2 + 2 + 2 + 2 = 8\\). Therefore, if `n` is less than 8, it cannot be written as such a sum, and the function returns `False`.\n\n2. **Even Number Check**: If `n` is at least 8 and also an even number (i.e., `n % 2 == 0`), then it can indeed be expressed as the sum of four positive even numbers. This is because any even number greater than or equal to 8 can be decomposed into a combination of four even numbers.\n\n3. **Return Value**: If both conditions are satisfied, the function returns `True`. Otherwise, it returns `False`.\n\nThis approach leverages the properties of even numbers and ensures that the given integer meets the necessary criteria to be expressed as the sum of exactly four positive even numbers."}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    if (n <= 0) {\n        return 1;\n    }\n    \n    long long result = 1;\n    \n    for (int i = 1; i <= n; ++i) {\n        long long factorial = 1;\n        \n        // Calculate the factorial of i\n        for (int j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        \n        // Multiply the result by the current factorial\n        result *= factorial;\n    }\n    \n    return result;\n}\n\n// Function to test the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << endl;  // Expected output: 288\n    cout << \"special_factorial(3): \" << special_factorial(3) << endl;  // Expected output: 12\n}\n\n", "py_code": "def special_factorial(n):\n    if n <= 0:\n        return 1\n    \n    result = 1\n    for i in range(1, n + 1):\n        factorial = 1\n        for j in range(1, i + 1):\n            factorial *= j\n        result *= factorial\n    \n    return result\n```\n\n", "py_summary": "The Python function `special_factorial(n)` calculates the Brazilian factorial of a given integer `n`. The Brazilian factorial is defined as the product of factorials from `1!` to `n!`.\n\nHere's an analysis of how the function works:\n\n1. **Base Case**: If `n` is less than or equal to 0, the function returns 1. This handles edge cases where no calculation is needed.\n\n2. **Initialization**: The variable `result` is initialized to 1. This will store the cumulative product of factorials from `1!` to `n!`.\n\n3. **Outer Loop**: An outer loop runs from `i = 1` to `n`. For each value of `i`, it calculates the factorial of `i` and multiplies it with the current value of `result`.\n\n4. **Inner Loop (Factorial Calculation)**: Inside the outer loop, an inner loop calculates the factorial of the current value of `i`. The variable `factorial` is initialized to 1 and then multiplied by each integer from 1 to `i`.\n\n5. **Update Result**: After calculating the factorial for a given `i`, it multiplies this factorial with the cumulative product stored in `result`.\n\n6. **Return Result**: Finally, after all iterations are complete, the function returns the value of `result` which contains the Brazilian factorial.\n\nThis approach ensures that each factorial is computed and multiplied into the result correctly to produce the desired output for the Brazilian factorial.\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n    \n    return result;\n}\n\n", "py_code": "def fix_spaces(text):\n    result = \"\"\n    space_count = 0\n    \n    for char in text:\n        if char == \" \":\n            space_count += 1\n        else:\n            if space_count > 2:\n                result += \"-\"\n            elif space_count > 0:\n                result += \"_\" * space_count\n            space_count = 0\n            result += char\n    \n    # Handle trailing spaces\n    if space_count > 2:\n        result += \"-\"\n    elif space_count > 0:\n        result += \"_\" * space_count\n    \n    return result\n```\n\n", "py_summary": "The Python function `fix_spaces(text)` processes a given string to replace spaces according to specific rules:\n\n1. **Initialization**: The function initializes an empty string `result` to store the modified text and a counter `space_count` to keep track of consecutive spaces.\n\n2. **Iteration through characters**:\n   - For each character in the input string, if it is a space (`\" \"`), increment the `space_count`.\n   - If the character is not a space, check the value of `space_count`:\n     - If `space_count > 2`, append `\"-\"` to `result`.\n     - Otherwise, if `space_count > 0`, append `_` repeated by the number of spaces counted.\n     - Reset `space_count` to 0 and add the current character to `result`.\n\n3. **Handling trailing spaces**: After iterating through all characters, check the value of `space_count` one last time:\n   - If `space_count > 2`, append `\"-\"`.\n   - Otherwise, if `space_count > 0`, append `_` repeated by the number of spaces counted.\n\n4. **Return the result**: Finally, return the modified string stored in `result`.\n\nThis approach ensures that all single and double spaces are replaced with underscores (`_`) and more than two consecutive spaces are replaced with a hyphen (`-`)."}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*\\.(txt|exe|dll)$)\");\n\n    if (std::regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n", "py_code": "import re\n\ndef file_name_check(file_name):\n    # Regular expression pattern for validating the file name\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*\\.[txt|exe|dll]$'\n    \n    if re.match(pattern, file_name):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "The Python code defines a function `file_name_check` that takes a string representing a file's name and returns `\"Yes\"` if the file's name is valid according to specified conditions, otherwise it returns `\"No\"`. The validation logic uses a regular expression pattern to match the file name against the following criteria:\n\n1. **Starts with a letter**: The file name must start with an alphabetic character (`[a-zA-Z]`).\n2. **At most three digits**: There should not be more than three digits in the entire file name.\n3. **Exactly one dot**: The file name must contain exactly one dot (`.`, which separates the base name from the extension).\n4. **Valid extensions**: The substring after the dot should be one of `txt`, `exe`, or `dll`.\n\nThe regular expression pattern used is:\n- `^[a-zA-Z]`: Ensures that the file name starts with a letter.\n- `[^\\d]*\\d{0,3}[^\\d]*`: Allows for any number of non-digit characters followed by up to three digits and then more non-digit characters. This ensures there are at most three digits in total.\n- `\\.[txt|exe|dll]$: Ensures that the file name ends with exactly one dot followed by `txt`, `exe`, or `dll`.\n\nThe function uses `re.match` to check if the entire string matches this pattern and returns `\"Yes\"` if it does, otherwise it returns `\"No\"`."}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int result = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            result += lst[i] * lst[i] * lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def sum_squares(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            result += lst[i] ** 3\n    return result\n```\n\n", "py_summary": "The Python function `sum_squares` takes a list of integers as input and returns the sum of modified entries based on specific conditions related to their indices:\n\n1. **Initialization**: The variable `result` is initialized to 0 to store the cumulative sum.\n2. **Iteration through the List**: A loop iterates over each index `i` in the range of the length of the list.\n3. **Condition Checking**:\n   - If the index `i` is a multiple of 3 (`i % 3 == 0`), the function squares the value at that index and adds it to `result`.\n   - If the index `i` is a multiple of 4 but not a multiple of 3 (`i % 4 == 0 and i % 3 != 0`), the function cubes the value at that index and adds it to `result`.\n4. **Return Result**: After iterating through all indices, the function returns the cumulative sum stored in `result`.\n\nThis approach ensures that only specific entries are modified based on their indices, while others remain unchanged.\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::string word, result = \"\";\n    \n    // Iterate through each word in the sentence\n    while (iss >> word) {\n        int length = word.length();\n        \n        // Check if the length of the current word is a prime number\n        if (is_prime(length)) {\n            // Append the word to the result string followed by a space\n            result += word + \" \";\n        }\n    }\n    \n    // Remove the trailing space and return the final result\n    if (!result.empty()) {\n        result.pop_back();  // Remove the last space character\n    }\n    \n    return result;\n}\n\n", "py_code": "from sympy import isprime\n\ndef words_in_sentence(sentence):\n    # Split the sentence into individual words\n    words = sentence.split()\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through each word in the list of words\n    for word in words:\n        # Check if the length of the current word is a prime number\n        if isprime(len(word)):\n            # Append the word to the result string, followed by a space\n            result += word + \" \"\n    \n    # Remove the trailing space and return the final result\n    return result.strip()\n```\n", "py_summary": "The Python code defines a function `words_in_sentence` that takes a string `sentence` as input and returns a new string containing only those words from the original sentence whose lengths are prime numbers. The order of the words in the output is the same as their order in the input sentence.\n\nHere's a step-by-step breakdown of how the code works:\n\n1. **Splitting the Sentence**: \n   - The `sentence` is split into individual words using the `split()` method, which splits the string at each space and returns a list of words.\n   \n2. **Initializing Result String**:\n   - An empty string `result` is initialized to store the final output.\n\n3. **Iterating Through Words**:\n   - The code iterates through each word in the list of words using a for loop.\n   \n4. **Checking Prime Length**:\n   - For each word, the length of the word (`len(word)`) is checked to see if it is a prime number using the `isprime` function from the `sympy` library.\n\n5. **Appending Words with Prime Lengths**:\n   - If the length of the current word is a prime number, the word is appended to the `result` string followed by a space.\n   \n6. **Returning Final Result**:\n   - After iterating through all words, any trailing space in the result string is removed using the `strip()` method and the final result is returned.\n\nThis approach ensures that only words with prime lengths are included in the output while maintaining their original order from the input sentence."}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    long long num1, den1, num2, den2;\n    \n    stringstream ss1(x);\n    char slash1;\n    ss1 >> num1 >> slash1 >> den1;\n    \n    stringstream ss2(n);\n    char slash2;\n    ss2 >> num2 >> slash2 >> den2;\n\n    // Compute the product of the two fractions\n    long long numerator = num1 * num2;\n    long long denominator = den1 * den2;\n\n    // Check if the resulting fraction is a whole number\n    return (numerator % denominator == 0);\n}\n\n", "py_code": "from fractions import Fraction\n\ndef simplify(x: str, n: str) -> bool:\n    # Convert string representations of fractions to Fraction objects\n    fraction_x = Fraction(x)\n    fraction_n = Fraction(n)\n\n    # Calculate the product of the two fractions\n    result_fraction = fraction_x * fraction_n\n    \n    # Check if the resulting fraction is a whole number (i.e., its denominator is 1)\n    return result_fraction.denominator == 1\n```\n\n", "py_summary": "The Python code defines a function `simplify` that takes two string arguments representing fractions and returns a boolean value indicating whether their product evaluates to a whole number.\n\nHere's an analysis of how the function works:\n\n1. **Convert String Representations to Fractions**: The function uses the `Fraction` class from the `fractions` module to convert the input strings `x` and `n` into Fraction objects. This allows for precise arithmetic operations on fractions.\n   \n2. **Calculate Product of Fractions**: The product of the two Fraction objects is computed using the multiplication operator.\n\n3. **Check if Result is a Whole Number**: To determine if the resulting fraction is a whole number, the function checks whether its denominator is 1. If the denominator is 1, it means that the result is an integer (whole number).\n\n4. **Return Boolean Value**: The function returns `True` if the product evaluates to a whole number and `False` otherwise.\n\nThis approach ensures accurate handling of fractions and provides a straightforward way to determine whether their product results in a whole number."}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    while (n != 0) {\n        sum += abs(n % 10);\n        n /= -10; // Adjust division for negative numbers\n    }\n    return sum;\n}\n\n// Custom comparator function to sort based on digit sum and original index\nbool custom_compare(const std::tuple<int, int, int>& a, const std::tuple<int, int, int>& b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n        return std::get<1>(a) < std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of tuples (sum_of_digits, original_index, number)\n    std::vector<std::tuple<int, int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back(std::make_tuple(sum_of_digits(nums[i]), i, nums[i]));\n    }\n    \n    // Sort the vector of tuples using custom comparator\n    std::sort(indexed_nums.begin(), indexed_nums.end(), custom_compare);\n    \n    // Extract the sorted numbers from the tuples\n    std::vector<int> result;\n    for (const auto& t : indexed_nums) {\n        result.push_back(std::get<2>(t));\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def sum_of_digits(n):\n        if n == 0:\n            return 0\n        is_negative = n < 0\n        digit_sum = 0\n        while n != 0:\n            digit_sum += abs(n % 10)\n            n //= -10 if is_negative else 10\n        return digit_sum\n\n    # Create a list of tuples (sum_of_digits, original_index, number)\n    indexed_nums = [(sum_of_digits(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort the list based on sum_of_digits and then by index\n    indexed_nums.sort(key=lambda x: (x[0], x[1]))\n    \n    # Extract the sorted numbers from the tuples\n    result = [num for _, _, num in indexed_nums]\n    \n    return result\n```\n\n", "py_summary": "The Python code defines a function `order_by_points` that sorts a list of integers based on the sum of their digits and their original index if sums are equal. Here's an analysis of how it works:\n\n1. **Helper Function (`sum_of_digits`)**:\n   - This function calculates the sum of the digits of an integer, taking into account whether the number is negative.\n   - It handles both positive and negative numbers by using `abs(n % 10)` to get the absolute value of each digit and adjusting the division operation accordingly.\n\n2. **Indexed List Creation**:\n   - The function creates a list of tuples where each tuple contains three elements: \n     - The sum of digits of the number.\n     - The original index of the number in the input list.\n     - The number itself.\n   - This indexed list helps to preserve the original order when sums are equal.\n\n3. **Sorting**:\n   - The list is sorted based on two criteria:\n     1. The sum of digits (primary key).\n     2. The original index (secondary key) if multiple numbers have the same digit sum.\n   \n4. **Result Extraction**:\n   - After sorting, the function extracts just the numbers from the tuples and returns them as a list.\n\nThis approach ensures that the integers are sorted correctly according to the problem requirements.\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n\nbool is_first_last_digit_odd(int number) {\n    std::string str_num = std::to_string(std::abs(number));\n    int first_digit = str_num[0] - '0';\n    int last_digit = str_num.back() - '0';\n    return (first_digit % 2 != 0 && last_digit % 2 != 0);\n}\n\nint specialFilter(std::vector<int> nums) {\n    int count = 0;\n    for (const auto& num : nums) {\n        if (num > 10 && is_first_last_digit_odd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def special_filter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and is_first_last_digit_odd(num):\n            count += 1\n    return count\n\ndef is_first_last_digit_odd(number):\n    str_num = str(abs(number))\n    first_digit = int(str_num[0])\n    last_digit = int(str_num[-1])\n    return first_digit % 2 != 0 and last_digit % 2 != 0\n```\n\n", "py_summary": "The Python code defines a function `special_filter` that takes a list of integers as input and returns the count of elements in the list that are greater than 10 and have both their first and last digits odd.\n\nHere's an analysis of the code:\n\n1. **Function Definition**:\n   - The function `special_filter(nums)` iterates through each number in the given list `nums`.\n   \n2. **Condition Check**:\n   - For each number, it checks if the number is greater than 10.\n   - If the condition is met, it calls another helper function `is_first_last_digit_odd(number)` to check if both the first and last digits of the number are odd.\n\n3. **Helper Function**:\n   - The helper function `is_first_last_digit_odd(number)` converts the absolute value of the number to a string.\n   - It then extracts the first and last characters (digits) from this string, converts them back to integers, and checks if both digits are odd by verifying that they are not divisible by 2.\n\n4. **Counting**:\n   - If both conditions (`num > 10` and `is_first_last_digit_odd(number)` return True), the count is incremented.\n   \n5. **Return Statement**:\n   - Finally, the function returns the total count of numbers that meet the criteria.\n\nThis approach ensures that only numbers greater than 10 with odd first and last digits are counted."}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Create the vector a based on the given formula\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n    \n    // Iterate over all possible triples (a[i], a[j], a[k]) where i < j < k\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    count = 0\n    for i in range(len(a) - 2):\n        for j in range(i + 1, len(a) - 1):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n```\n\n", "py_summary": "The Python function `get_max_triples(n)` calculates the number of valid triples `(a[i], a[j], a[k])` in an integer vector `a`, where each element `a[i] = i * i - i + 1` for `i` ranging from 1 to `n`. The goal is to find all such triples that satisfy the condition `i < j < k` and `(a[i] + a[j] + a[k]) % 3 == 0`.\n\nHere's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - A list comprehension is used to generate the vector `a`, where each element at index `i` (starting from 0) corresponds to the formula `a[i+1] = (i + 1) * (i + 1) - (i + 1) + 1`. This ensures that the first element of `a` is computed for `i=1`, and so on up to `n`.\n\n2. **Triple Calculation**:\n   - The function uses three nested loops to iterate over all possible triples `(a[i], a[j], a[k])` where `0 <= i < j < k < n`.\n     - The outer loop iterates from the start of the list to the third-to-last element.\n     - The middle loop starts from the next index after `i` and goes up to the second-to-last element.\n     - The innermost loop starts from the next index after `j` and goes up to the last element.\n\n3. **Condition Check**:\n   - For each triple `(a[i], a[j], a[k])`, it checks if the sum of these three elements is divisible by 3 using the condition `(a[i] + a[j] + a[k]) % 3 == 0`.\n   - If the condition is met, the count variable `count` is incremented.\n\n4. **Return Result**:\n   - Finally, the function returns the total count of valid triples found.\n\nThis approach ensures that all possible combinations are checked and only those meeting the specified criteria are counted. The time complexity of this solution is \\(O(n^3)\\), which can be computationally expensive for large values of `n`. However, it guarantees correctness by exhaustively checking every triple combination."}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> order = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\n    // Check if both planets are valid\n    if (find(order.begin(), order.end(), planet1) == order.end() || find(order.begin(), order.end(), planet2) == order.end()) {\n        return {};\n    }\n\n    size_t start_index = find(order.begin(), order.end(), planet1) - order.begin();\n    size_t end_index = find(order.begin(), order.end(), planet2) - order.begin();\n\n    // Ensure start_index is less than end_index\n    if (start_index > end_index) {\n        swap(start_index, end_index);\n    }\n\n    vector<string> result;\n    for (size_t i = start_index + 1; i < end_index; ++i) {\n        result.push_back(order[i]);\n    }\n    return result;\n}\n", "py_code": "def bf(planet1: str, planet2: str) -> list:\n    order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in order or planet2 not in order:\n        return []\n    \n    start_index = order.index(planet1)\n    end_index = order.index(planet2)\n    \n    if start_index > end_index:\n        start_index, end_index = end_index, start_index\n    \n    return order[start_index + 1:end_index]\n```\n\n", "py_summary": "The Python code defines a function `bf` that takes two planet names as strings and returns a list of planets whose orbits are located between the given two planets, sorted by their proximity to the Sun.\n\n1. **Initialization**: The function starts by defining a list called `order`, which contains the names of the eight planets in order from closest to farthest from the Sun.\n2. **Validation**: It checks if both planet names (`planet1` and `planet2`) are present in the `order` list. If either name is not found, it returns an empty list immediately.\n3. **Index Calculation**: The function finds the indices of `planet1` and `planet2` within the `order` list using the `index()` method. It stores these indices in `start_index` and `end_index`.\n4. **Order Adjustment**: If `start_index` is greater than `end_index`, it swaps them to ensure that `start_index` always comes before `end_index`. This ensures the correct order of planets between the two given planets.\n5. **Result Construction**: Finally, the function returns a sublist from `order[start_index + 1:end_index]`, which contains all the planets located strictly between the orbits of `planet1` and `planet2`.\n\nThis approach ensures that the returned list is always in the correct order based on proximity to the Sun and handles invalid planet names gracefully by returning an empty list."}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string>& lst) {\n    // Filter out strings with odd lengths\n    vector<string> even_length_strings;\n    for (const auto& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    // Sort the filtered list by length, and then alphabetically for strings of the same length\n    sort(even_length_strings.begin(), even_length_strings.end(),\n         [](const string& a, const string& b) {\n             if (a.length() == b.length()) {\n                 return a < b;\n             }\n             return a.length() < b.length();\n         });\n\n    return even_length_strings;\n}\n", "py_code": "from typing import List\n\ndef vector_sort(lst: List[str]) -> List[str]:\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for strings of the same length\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings\n```\n\n", "py_summary": "The Python code defines a function `vector_sort` that takes a list of strings as input and returns a sorted list according to specific criteria:\n\n1. **Filtering Strings with Even Lengths**: The function first filters out all strings from the input list that have odd lengths, keeping only those with even lengths.\n2. **Sorting by Length and Alphabetically**: It then sorts the remaining strings based on their length in ascending order. If two strings have the same length, it further sorts them alphabetically.\n\nHere's a breakdown of how this is achieved:\n- The list comprehension `[s for s in lst if len(s) % 2 == 0]` filters out all strings with odd lengths.\n- The `sort` method is used on the filtered list. The key function `lambda x: (len(x), x)` ensures that sorting happens first by length and then alphabetically when lengths are equal.\n\nThis approach ensures that the returned list meets the requirements of having only even-length strings, sorted primarily by their length and secondarily by alphabetical order if lengths are identical."}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function that returns x if n is prime, otherwise y\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n", "py_code": "def x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "The Python code defines a function `x_or_y` that takes three integers as input: `n`, `x`, and `y`. The function checks whether `n` is a prime number using the helper function `is_prime`.\n\nHere's an analysis of each part:\n\n1. **Function Definition**:\n   - `def x_or_y(n, x, y)`: This defines the main function that takes three integer arguments: `n`, `x`, and `y`.\n   \n2. **Prime Check**:\n   - The function calls `is_prime(n)` to determine if `n` is a prime number.\n   \n3. **Return Value Based on Prime Check**:\n   - If `n` is a prime number, the function returns `x`.\n   - Otherwise, it returns `y`.\n\n4. **Helper Function for Prime Check (`is_prime`)**:\n   - The helper function `def is_prime(num)` checks if a given integer `num` is a prime number.\n   - It first handles edge cases where numbers less than or equal to 1 are not considered prime.\n   - Then, it iterates from 2 up to the square root of `num` (inclusive) and checks for divisibility. If any divisor is found, the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n### Summary:\n- The main function `x_or_y` uses a helper function `is_prime` to determine if `n` is prime.\n- Based on whether `n` is prime or not, it returns either `x` or `y`.\n- The `is_prime` function efficiently checks for primality by iterating up to the square root of the number and checking divisibility."}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum_of_squares += std::pow(static_cast<int>(num), 2);\n        }\n    }\n\n    return sum_of_squares;\n}\n", "py_code": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    sum_of_squares = 0\n    for num in lst:\n        if num > 0 and num == int(num):  # Check if number is positive and an integer\n            if num % 2 != 0:  # Check if the number is odd\n                sum_of_squares += num ** 2\n    return sum_of_squares\n```\n\n", "py_summary": "The Python function `double_the_difference` takes a list of floating-point numbers as input and returns the sum of squares of the odd positive integers in the list.\n\n1. **Initialization**: The variable `sum_of_squares` is initialized to 0 to keep track of the cumulative sum of squares.\n2. **Iteration through List**: A loop iterates over each element in the input list `lst`.\n3. **Condition Checks**:\n   - **Positive and Integer Check**: For each number, it checks if the number is positive (`num > 0`) and an integer (`num == int(num)`). This ensures that only non-negative integers are considered.\n   - **Odd Number Check**: It then checks if the number is odd (`num % 2 != 0`).\n4. **Sum of Squares Calculation**: If all conditions are met, it adds the square of the number to `sum_of_squares`.\n5. **Return Result**: After iterating through the list, the function returns the value stored in `sum_of_squares`.\n\nThis approach ensures that only positive odd integers from the input list contribute to the final sum of squares.\n\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int difference = std::abs(game[i] - guess[i]);\n        result.push_back(difference);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    result = []\n    for i in range(len(game)):\n        difference = abs(game[i] - guess[i])\n        result.append(difference)\n    return result\n```\n\n", "py_summary": "The Python function `compare` takes two lists of integers (`game` and `guess`) as input and returns a new list where each element represents how far off each guess was from the corresponding score in the game.\n\nHere's an analysis of the code:\n\n1. **Initialization**: An empty list named `result` is initialized to store the differences between the scores and guesses.\n2. **Iteration**: A for loop iterates through the indices of the input lists (`game` and `guess`). The length of both lists is assumed to be equal, so iterating over one will cover all elements in both.\n3. **Difference Calculation**: For each index `i`, the absolute difference between `game[i]` and `guess[i]` is calculated using the `abs()` function.\n4. **Appending Results**: The calculated difference is appended to the `result` list.\n5. **Return Result**: After iterating through all elements, the `result` list containing the differences is returned.\n\nThis approach ensures that each element in the output list corresponds correctly to how far off each guess was from the actual score for each match.\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_ext = \"\";\n    \n    for (const auto& ext : extensions) {\n        int cap_count = 0;\n        int sm_count = 0;\n        \n        for (char c : ext) {\n            if (isupper(c)) cap_count++;\n            else if (islower(c)) sm_count++;\n        }\n        \n        int strength = cap_count - sm_count;\n        \n        // Check if the current extension is stronger or comes first in case of a tie\n        if (strength > max_strength || (strength == max_strength && extensions.size() > 0 && extensions[extensions.size()-1] != strongest_ext)) {\n            max_strength = strength;\n            strongest_ext = ext;\n        }\n    }\n    \n    return class_name + \".\" + strongest_ext;\n}\n\n", "py_code": "def strongest_extension(class_name: str, extensions: list) -> str:\n    max_strength = float('-inf')\n    strongest_ext = \"\"\n    \n    for ext in extensions:\n        cap_count = sum(1 for c in ext if c.isupper())\n        sm_count = sum(1 for c in ext if c.islower())\n        strength = cap_count - sm_count\n        \n        if strength > max_strength or (strength == max_strength and extensions.index(ext) < extensions.index(strongest_ext)):\n            max_strength = strength\n            strongest_ext = ext\n    \n    return f\"{class_name}.{strongest_ext}\"\n```\n\n", "py_summary": "The Python function `strongest_extension` takes a class name and a list of extensions as input and returns the class name concatenated with its strongest extension in the format \"ClassName.StrongestExtensionName\". Here's a detailed breakdown of how it works:\n\n1. **Initialization**: \n   - `max_strength` is initialized to negative infinity (`float('-inf')`) to ensure any calculated strength will be greater.\n   - `strongest_ext` is initialized as an empty string to store the strongest extension found.\n\n2. **Iterate through extensions**:\n   - For each extension in the list, it calculates its strength based on the number of uppercase and lowercase letters.\n   - `cap_count` counts the number of uppercase letters (`c.isupper()`).\n   - `sm_count` counts the number of lowercase letters (`c.islower()`).\n   - The strength is calculated as `strength = cap_count - sm_count`.\n\n3. **Determine strongest extension**:\n   - If the current extension's strength is greater than `max_strength`, or if it has the same strength but comes earlier in the list, update `max_strength` and set `strongest_ext` to the current extension.\n\n4. **Return result**:\n   - After iterating through all extensions, return the class name concatenated with the strongest extension using string formatting `\"ClassName.StrongestExtensionName\"`.\n\nThis approach ensures that the function correctly identifies the strongest extension based on the given criteria and handles ties by choosing the first occurrence in the list."}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string doubled_a = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n", "py_code": "def cycpattern_check(a: str, b: str) -> bool:\n    # Concatenate the string 'a' with itself\n    doubled_a = a + a\n    \n    # Check if 'b' is a substring of the concatenated string\n    return b in doubled_a\n```\n\n", "py_summary": "The Python function `cycpattern_check` checks whether the second word or any of its rotations is a substring of the first word. Here's an analysis of how it works:\n\n1. **Concatenate the First Word with Itself**: The function concatenates the string `a` with itself to form `doubled_a`. This step effectively creates all possible rotations of `b` as substrings within `doubled_a`.\n\n2. **Check for Substring Presence**: The function then checks if `b` is a substring of `doubled_a`. If `b` or any rotation of `b` exists in `doubled_a`, the function returns `True`; otherwise, it returns `False`.\n\nBy concatenating `a` with itself, we ensure that all possible rotations of `b` are covered within this new string. For example:\n- If `a = \"abcd\"` and `b = \"abd\"`, then `doubled_a = \"abcdaabcd\"`. Clearly, `\"abd\"` is not a substring.\n- If `a = \"hello\"` and `b = \"ell\"`, then `doubled_a = \"hellohello\"`. Here, `\"ell\"` is a substring.\n\nThis approach simplifies the problem by leveraging string concatenation to handle rotations implicitly."}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n", "py_code": "def even_odd_count(num):\n    # Convert the number to a string to easily iterate over each digit\n    str_num = str(abs(num))\n    even_count = 0\n    odd_count = 0\n    \n    for digit in str_num:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    return [even_count, odd_count]\n```\n\n", "py_summary": "The Python function `even_odd_count` takes an integer `num` as input and returns a list containing two integers: the count of even digits and the count of odd digits in the given number.\n\n1. **Convert to String**: The absolute value of the input number is converted to a string (`str(abs(num))`) so that each digit can be easily iterated over.\n2. **Initialize Counts**: Two variables, `even_count` and `odd_count`, are initialized to zero to keep track of the counts of even and odd digits, respectively.\n3. **Iterate Over Digits**: A loop iterates through each character in the string representation of the number. Each character is converted back to an integer (`int(digit)`) and checked for parity:\n   - If the digit is even (i.e., `digit % 2 == 0`), increment `even_count`.\n   - Otherwise, increment `odd_count`.\n4. **Return Result**: The function returns a list containing the counts of even and odd digits.\n\nThis approach ensures that all digits are correctly classified as either even or odd and counted accordingly."}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\n\nstd::string int_to_mini_roman(int number) {\n    // Dictionary to store Roman numeral mappings\n    std::pair<int, char> roman_numerals[] = {\n        {1000, 'm'}, {900, 'cm'}, {500, 'd'}, {400, 'cd'},\n        {100, 'c'},  {90, 'xc'},  {50, 'l'},  {40, 'xl'},\n        {10, 'x'},   {9, 'ix'},   {5, 'v'},   {4, 'iv'},\n        {1, 'i'}\n    };\n\n    std::string roman = \"\";\n\n    // Iterate over the Roman numeral mappings\n    for (const auto& [value, numeral] : roman_numerals) {\n        while (number >= value) {\n            roman += numeral;\n            number -= value;\n        }\n    }\n\n    return roman;\n}\n", "py_code": "def int_to_mini_roman(number):\n    roman_numerals = {\n        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n        100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n        10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'\n    }\n    \n    roman = \"\"\n    for value, numeral in sorted(roman_numerals.items(), reverse=True):\n        while number >= value:\n            roman += numeral\n            number -= value\n            \n    return roman\n```\n\n", "py_summary": "The Python function `int_to_mini_roman` converts a given integer to its Roman numeral equivalent in lowercase. Here's an analysis of how it works:\n\n1. **Dictionary Initialization**: A dictionary named `roman_numerals` is defined with keys as integers and values as their corresponding Roman numerals in lowercase. The keys are sorted in descending order to facilitate the conversion process.\n\n2. **Initialization**: An empty string variable `roman` is initialized to store the resulting Roman numeral.\n\n3. **Iterate Over Numerals**: A loop iterates over each key-value pair in the dictionary, starting from the highest value (1000) and moving downwards.\n\n4. **Conversion Process**:\n   - For each key-value pair `(value, numeral)` in `roman_numerals`, a nested while loop runs as long as the input number is greater than or equal to the current Roman numeral's integer value.\n   - Inside this loop, the corresponding Roman numeral character(s) are appended to the `roman` string and the input number is reduced by the value of the current key.\n\n5. **Return Result**: Once all possible values have been processed, the function returns the constructed Roman numeral string stored in `roman`.\n\nThis approach ensures that the largest possible Roman numerals are used first, leading to an efficient conversion process for any integer within the specified range (1 to 1000)."}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::pow and std::abs\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure 'c' is the longest side\n    vector<float> sides = {a, b, c};\n    sort(sides.begin(), sides.end());\n    \n    // Check if the square of the longest side equals the sum of squares of the other two sides\n    return abs(pow(sides[2], 2) - (pow(sides[0], 2) + pow(sides[1], 2))) < numeric_limits<float>::epsilon();\n}\n", "py_code": "import math\n\ndef right_angle_triangle(a, b, c):\n    # Sort the sides so that 'c' is always the longest side\n    sides = sorted([a, b, c])\n    \n    # Check if the square of the longest side equals the sum of squares of the other two sides\n    return math.isclose(sides[2] ** 2, sides[0] ** 2 + sides[1] ** 2)\n```\n\n", "py_summary": "The Python function `right_angle_triangle` checks if a triangle with given side lengths is a right-angled triangle. Here's an analysis of how it works:\n\n1. **Sorting the Sides**: The sides are sorted to ensure that the longest side (hypotenuse) is always in the last position (`sides[2]`). This simplifies the comparison needed for the Pythagorean theorem.\n\n2. **Pythagorean Theorem Check**: According to the Pythagorean theorem, a triangle is right-angled if and only if the square of the longest side (hypotenuse) equals the sum of the squares of the other two sides. Mathematically, this can be expressed as:\n   \\[\n   c^2 = a^2 + b^2\n   \\]\n   where \\(c\\) is the hypotenuse and \\(a\\) and \\(b\\) are the other two sides.\n\n3. **Using `math.isclose`**: The function uses `math.isclose` to compare floating-point numbers, which helps in dealing with potential precision issues that can arise from floating-point arithmetic.\n\n4. **Return Value**: If the condition is satisfied, the function returns `True`, indicating that the triangle is a right-angled triangle; otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the given sides form a right-angled triangle by leveraging the Pythagorean theorem and handling floating-point precision issues."}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string result_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int num_unique_chars = unique_chars.size();\n\n        if (num_unique_chars > max_unique_chars || \n            (num_unique_chars == max_unique_chars && word < result_word)) {\n            max_unique_chars = num_unique_chars;\n            result_word = word;\n        }\n    }\n\n    return result_word;\n}\n\n", "py_code": "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    max_unique_chars = 0\n    result_word = \"\"\n    \n    for word in words:\n        unique_chars = len(set(word))\n        \n        if unique_chars > max_unique_chars or (unique_chars == max_unique_chars and word < result_word):\n            max_unique_chars = unique_chars\n            result_word = word\n            \n    return result_word\n```\n\n", "py_summary": "The Python code defines a function `find_max` that takes a list of strings as input and returns the string with the maximum number of unique characters. If multiple strings have the same number of unique characters, it returns the one that comes first in lexicographical order.\n\nHere's a breakdown of how the code works:\n\n1. **Initialization**: \n   - `max_unique_chars` is initialized to 0 to keep track of the highest number of unique characters found so far.\n   - `result_word` is initialized to an empty string to store the current word with the maximum number of unique characters.\n\n2. **Iteration through words**:\n   - The function iterates over each word in the input list `words`.\n   \n3. **Counting Unique Characters**:\n   - For each word, it calculates the number of unique characters using `len(set(word))`. This converts the word to a set (which removes duplicates) and then counts the length of this set.\n\n4. **Updating Result**:\n   - If the current word has more unique characters than any previously seen word (`unique_chars > max_unique_chars`), or if it has the same number of unique characters but comes before the current `result_word` in lexicographical order (`word < result_word`), then the function updates `max_unique_chars` and sets `result_word` to the current word.\n\n5. **Return Result**:\n   - After iterating through all words, the function returns `result_word`, which holds the string with the maximum number of unique characters or the lexicographically smallest one in case of a tie.\n\nThis approach ensures that the function efficiently finds and returns the desired word based on the criteria provided."}
{"task_id": "CPP/159", "generation": "#include <vector>\n\nstd::vector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after meals\n    int total_eaten = number + std::min(need, remaining);\n    \n    // Calculate the number of remaining carrots after eating\n    int carrots_left = std::max(0, remaining - need);\n\n    return {total_eaten, carrots_left};\n}\n", "py_code": "def eat(number: int, need: int, remaining: int) -> list:\n    total_eaten = number + min(need, remaining)\n    carrots_left = max(0, remaining - need)\n    return [total_eaten, carrots_left]\n```\n\n", "py_summary": "The Python function `eat` takes three integer parameters: `number`, `need`, and `remaining`. Here's a detailed analysis of how it works:\n\n1. **Calculate Total Eaten Carrots**:\n   - The total number of carrots eaten after your meals is calculated as the sum of the carrots already eaten (`number`) and the minimum of the required additional carrots (`need`) and the remaining carrots in stock (`remaining`). This ensures that you do not eat more than what is available.\n   \n2. **Calculate Remaining Carrots**:\n   - The number of remaining carrots after your meals is calculated as the maximum of 0 and the difference between `remaining` and `need`. If there are enough remaining carrots to meet the requirement, it calculates how many are left after eating the required amount. Otherwise, no additional carrots are left (hence, the use of `max(0, ...)`).\n\n3. **Return Result**:\n   - The function returns a list containing two elements: \n     1. The total number of carrots eaten.\n     2. The number of remaining carrots after eating.\n\nThis approach ensures that you eat as many carrots as needed or available and correctly calculates the remaining stock based on your consumption needs.\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n\nint do_algebra(std::vector<std::string>& operators, std::vector<int>& operands) {\n    int result = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // C++ integer division\n        } else if (operators[i] == \"**\") {\n            result = std::pow(result, operands[i + 1]);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "def do_algebra(operators, operands):\n    expression = str(operands[0])\n    \n    for i in range(len(operators)):\n        operation = operators[i]\n        next_operand = operands[i + 1]\n        \n        if operation == \"+\":\n            expression += f\" + {next_operand}\"\n        elif operation == \"-\":\n            expression += f\" - {next_operand}\"\n        elif operation == \"*\":\n            expression += f\" * {next_operand}\"\n        elif operation == \"//\":\n            expression += f\" // {next_operand}\"\n        elif operation == \"**\":\n            expression += f\" ** {next_operand}\"\n    \n    return eval(expression)\n```\n\n", "py_summary": "The Python function `do_algebra` takes two parameters: a list of strings representing algebraic operations (`operators`) and a list of integers representing operands (`operands`). The goal is to construct an algebraic expression from these inputs and evaluate it.\n\n1. **Initialization**: Start by initializing the expression string with the first operand.\n2. **Loop through operators**: Iterate over each operation in the `operators` list:\n   - For each operator, append the corresponding operation symbol followed by the next operand (from the `operands` list) to the expression string.\n3. **Evaluation**: After constructing the full algebraic expression as a string, use Python's built-in `eval()` function to evaluate and return the result of this expression.\n\nThis approach ensures that the algebraic operations are correctly applied in sequence according to the provided operators and operands, resulting in the correct evaluation of the constructed expression.\n\n"}
{"task_id": "CPP/161", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha, toupper, tolower\n\nusing namespace std;\n\nstring solve(string s) {\n    string result = \"\";\n    bool containsLetter = false;\n\n    // Process each character in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            // Reverse case of alphabetic characters\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            // Keep non-alphabetic characters as they are\n            result += c;\n        }\n    }\n\n    // If the string contains no letters, reverse the entire string\n    if (!containsLetter) {\n        return string(result.rbegin(), result.rend());\n    }\n\n    return result;\n}\n", "py_code": "def solve(s):\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Reverse case of alphabetic characters\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            # Keep non-alphabetic characters as they are\n            result.append(char)\n    \n    # If the string contains no letters, reverse the entire string\n    if all(not char.isalpha() for char in s):\n        return ''.join(result)[::-1]\n    \n    return ''.join(result)\n```\n", "py_summary": "The Python function `solve` takes a string `s` as input and processes it according to the specified rules:\n\n1. **Initialization**: An empty list `result` is initialized to store the transformed characters of the string.\n\n2. **Character Processing**:\n   - The function iterates through each character in the string.\n   - If the character is an alphabetic letter (`char.isalpha()` returns True), it checks whether the character is lowercase or uppercase and reverses its case accordingly:\n     - `char.upper()` converts a lowercase letter to uppercase.\n     - `char.lower()` converts an uppercase letter to lowercase.\n   - If the character is not an alphabetic letter, it is appended to the result list as-is.\n\n3. **String Reversal Check**:\n   - After processing all characters, the function checks if there were any alphabetic letters in the string using a generator expression (`all(not char.isalpha() for char in s)`).\n   - If no alphabetic letters are found (i.e., `s` contains only non-alphabetic characters), the result list is reversed before being joined into a final string.\n\n4. **Return Result**:\n   - The function returns the processed and possibly reversed string by joining the elements of the `result` list into a single string.\n\nThis approach ensures that all alphabetic letters have their cases reversed, while non-alphabetic characters remain unchanged. If no alphabetic letters are present in the input string, the entire string is reversed before being returned.\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function to convert a byte array to a hexadecimal string\nstring bytes_to_hex_string(const unsigned char* bytes, size_t length) {\n    static const char hex_chars[] = \"0123456789abcdef\";\n    string hex_str;\n    for (size_t i = 0; i < length; ++i) {\n        hex_str += hex_chars[bytes[i] >> 4];\n        hex_str += hex_chars[bytes[i] & 0x0F];\n    }\n    return hex_str;\n}\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), hash);\n\n    return bytes_to_hex_string(hash, MD5_DIGEST_LENGTH);\n}\n\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode('utf-8'))\n    return md5_hash.hexdigest()\n```\n\n", "py_summary": "The Python code defines a function `string_to_md5` that takes a string as input and returns its MD5 hash equivalent. Here's an analysis of how it works:\n\n1. **Check for Empty String**: The function first checks if the input string is empty (`if not text:`). If it is, the function returns `None`.\n\n2. **Initialize MD5 Hash Object**: An instance of the `hashlib.md5` class is created to generate an MD5 hash.\n\n3. **Update Hash with Input Text**: The `update` method of the MD5 hash object is called with the input string encoded in UTF-8 format (`text.encode('utf-8')`). This updates the hash object with the byte representation of the text.\n\n4. **Generate and Return Hex Digest**: Finally, the function returns the hexadecimal representation of the computed MD5 hash using `md5_hash.hexdigest()`.\n\nThis approach ensures that the input string is properly hashed and returned in a consistent format (hexadecimal). If the input string is empty, it gracefully handles this case by returning `None`.\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure a is less than or equal to b for simplicity in generating even digits\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    // Generate even numbers between start and end (inclusive)\n    std::vector<int> even_digits;\n    for (int i = start; i <= end; ++i) {\n        if (i % 2 == 0 && i < 10) {\n            even_digits.push_back(i);\n        }\n    }\n\n    // Remove duplicates and sort the result\n    auto last = std::unique(even_digits.begin(), even_digits.end());\n    even_digits.erase(last, even_digits.end());\n\n    return even_digits;\n}\n", "py_code": "def generate_integers(a: int, b: int) -> list:\n    # Ensure a is less than or equal to b for simplicity in generating even digits\n    start = min(a, b)\n    end = max(a, b)\n\n    # Generate even numbers between start and end (inclusive)\n    even_digits = [i for i in range(start, end + 1) if i % 2 == 0 and i < 10]\n\n    return sorted(set(even_digits))\n```\n\n", "py_summary": "The Python function `generate_integers` takes two positive integers `a` and `b` as input and returns a list of even digits between these two numbers in ascending order. Here's a detailed analysis:\n\n1. **Ensure Order**: The function first ensures that `start` is the smaller value and `end` is the larger value by using `min(a, b)` for `start` and `max(a, b)` for `end`. This allows the function to handle cases where `a > b`.\n\n2. **Range Generation**: It generates a range of numbers from `start` to `end`, inclusive.\n\n3. **Filter Even Digits**: The list comprehension filters out only even digits (numbers less than 10 and divisible by 2). Specifically, it checks if each number in the range is an even digit using the condition `i % 2 == 0 and i < 10`.\n\n4. **Remove Duplicates and Sort**: Since the input might result in duplicate values being generated within the range (e.g., both `a` and `b` could be even digits), converting to a set removes duplicates, and then sorting ensures that the output is in ascending order.\n\n5. **Return Result**: Finally, it returns the sorted list of unique even digits found between `start` and `end`.\n\nThis approach ensures that all conditions are met: the function handles cases where `a > b`, filters out only valid even digits (less than 10), removes duplicates, and sorts the result in ascending order.\n\n"}
