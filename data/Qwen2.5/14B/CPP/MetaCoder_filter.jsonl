{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list and check if any two consecutive elements\n    // are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::stack<char> stack;\n    std::string current_group = \"\";\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n            current_group += ch;\n        } else if (ch == ')') {\n            stack.pop();\n            current_group += ch;\n\n            // If the stack is empty, it means we have a complete group\n            if (stack.empty()) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);  // Get the integer part\n    float decimal_part = number - integer_part;  // Subtract to get the decimal part\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) {\n            return true; // If balance falls below zero, return true\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size.\n    vector<int> result(result_size);\n\n    if (!numbers.empty()) {\n        int pos = 0;\n        \n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result[pos++] = numbers[i];\n            \n            if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n                result[pos++] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes.\nvoid printVector(const vector<int>& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    \n    // Function to calculate depth for a single group of parentheses\n    auto calculate_depth = [](const string& group) -> int {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (max_depth < current_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                --current_depth;\n            }\n        }\n        return max_depth;\n    };\n\n    // Split the input string into groups and calculate depth for each group\n    size_t start = 0, end = paren_string.find(' ');\n    while (end != string::npos) {\n        depths.push_back(calculate_depth(paren_string.substr(start, end - start)));\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Add the last group\n    if (start < paren_string.length()) {\n        depths.push_back(calculate_depth(paren_string.substr(start)));\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    auto result1 = filter_by_substring({}, \"a\");\n    assert(result1.empty());\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    vector<string> expected_result2{\"abc\", \"bacd\", \"vector\"};\n    for (const auto& str : expected_result2) {\n        assert(find(result2.begin(), result2.end(), str) != result2.end());\n    }\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int total_sum = 0;\n    int product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int number : numbers) {\n        total_sum += number;\n        product *= number;\n    }\n\n    return {total_sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n\n    Examples:\n    >>> make_palindrome(\"\")\n    \"\"\n    \n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    \n    >>> make_palindrome(\"cata\")\n    \"catac\"\n    */\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix_to_reverse = str.substr(0, i);\n            return str + string(prefix_to_reverse.rbegin(), prefix_to_reverse.rend());\n        }\n    }\n    // If the entire string is a palindrome\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result.\n\n    // Iterate through each character in the strings and perform XOR operation.\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both characters are the same, append '0' to the result string.\n        } else {\n            result += '1';  // If characters are different, append '1'.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // If current string is longer than the longest found so far\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) {\n        return -1; // or throw an exception/error for invalid input\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\\n\";\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase\n    for (char &ch : str) {\n        ch = std::tolower(ch);\n    }\n\n    // Use a set to store unique characters\n    std::unordered_set<char> unique_chars;\n    \n    // Insert each character into the set\n    for (char ch : str) {\n        unique_chars.insert(ch);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n\nstd::vector<int> parse_music(std::string music_string) {\n    std::vector<int> beats;\n    size_t i = 0;\n\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2);\n                i += 2;\n            } else {\n                beats.push_back(4);\n                i += 1;\n            }\n        } else if (music_string.substr(i, 2) == \".|\") {\n            beats.push_back(1);\n            i += 2;\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move past the last found position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <map>\n\nstd::string sort_numbers(std::string numbers) {\n    // Mapping from string representation of numbers to their integer values\n    std::map<std::string, int> number_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into individual words\n    std::istringstream iss(numbers);\n    std::vector<std::string> number_words;\n    std::string word;\n\n    while (iss >> word) {\n        number_words.push_back(word);\n    }\n\n    // Convert the list of words to integers using the mapping\n    std::vector<int> int_numbers;\n    for (const auto& num_word : number_words) {\n        if (number_map.find(num_word) != number_map.end()) {\n            int_numbers.push_back(number_map[num_word]);\n        }\n    }\n\n    // Sort the vector of integer values\n    std::sort(int_numbers.begin(), int_numbers.end());\n\n    // Convert the sorted integers back to their corresponding string representations\n    std::vector<std::string> sorted_str_numbers;\n    for (int num : int_numbers) {\n        for (const auto& entry : number_map) {\n            if (entry.second == num) {\n                sorted_str_numbers.push_back(entry.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted strings into a single space-delimited string and return it\n    std::ostringstream oss;\n    for (size_t i = 0; i < sorted_str_numbers.size(); ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << sorted_str_numbers[i];\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result;\n    \n    // Iterate through pairs of adjacent elements to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    // Return the closest pair in ascending order\n    return {result.first, result.second};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation: (num - min_val) / (max_val - min_val)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check_function() {\n    list_any test1 = {std::string(\"a\"), 3.14, 5};\n    auto filtered_test1 = filter_integers(test1);\n    for (int num : filtered_test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    list_any test2 = {1, 2, 3, std::string(\"abc\"), {}, {}};\n    auto filtered_test2 = filter_integers(test2);\n    for (int num : filtered_test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint strlen(const std::string& str) {\n    return str.length(); // or str.size()\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle even numbers first.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print the vector of factors for testing purposes.\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << factors[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \" \", \"world\"}) == \"hello world\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and display results\nvoid check(vector<string> input, string prefix) {\n    vector<string> filtered = filter_by_prefix(input, prefix);\n    \n    cout << \"{\";\n    for (size_t i = 0; i < filtered.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << filtered[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to return only positive numbers from the input vector.\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the vector and check if it is positive.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is greater than zero.\n            result.push_back(num);  // Add positive numbers to the result vector.\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of get_positive function.\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    for (float num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 2 5 6\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    for (float num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 5 3 2 3 9 123 1\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by 2 and 3 first, as they are the smallest primes.\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // If divisible by 2 or 3, it's not prime\n    \n    // Check for divisibility from 5 onwards, skipping even numbers.\n    long long i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false; // If divisible by any number in this range, it's not prime\n        i += 6; // Skip even numbers and multiples of 3\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble poly_derivative(const std::vector<double>& xs, double x) {\n    /*\n    Computes the derivative of a polynomial with coefficients xs.\n    */\n    std::vector<double> deriv(xs.size() - 1);\n    for (size_t i = 1; i < xs.size(); ++i) {\n        deriv[i-1] = static_cast<int>(i) * xs[i];\n    }\n    return poly(deriv, x);\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    Finds the root of a polynomial with coefficients xs such that poly(x) = 0.\n    Assumes xs has an even number of coefficients and guarantees a solution.\n    */\n    double tol = 1e-6;\n    double initial_guess = 0.5; // Initial guess for Newton's method\n    double x = initial_guess;\n\n    while (true) {\n        double fx = poly(xs, x);\n        if (std::abs(fx) < tol) {\n            return x;\n        }\n        \n        double dfdx = poly_derivative(xs, x);  // Pass 'x' to the derivative function\n        if (dfdx == 0) {\n            break;\n        }\n\n        x -= fx / dfdx;\n    }\n\n    return x;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices_elements.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(third_indices_elements.begin(), third_indices_elements.end());\n\n    // Create a new list to store the result\n    vector<int> l_prime;\n    \n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l_prime.push_back(third_indices_elements[sorted_index]);\n            sorted_index++;\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n\n    return l_prime;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit 7\n                    count++;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract values at even indices (0-based indexing)\n    vector<float> even_indices_values;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to keep odd indices unchanged\n    vector<float> result = l;\n\n    // Update even indices with sorted values\n    size_t j = 0;\n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_indices_values[j++];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached as we always find a result.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <iostream>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Since all cars are moving towards each other and there is no avoidance,\n    // every left-to-right car will eventually collide with a right-to-left car.\n    return n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &i : l) {  // Iterate through each element and increment it by 1.\n        i += 1;\n    }\n    return l;  // Return the modified vector.\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    for (const int& elem : vec) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        \n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    return false;  // No pairs sum up to zero.\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1 || base >= 10) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    std::string result = \"\";\n    while (x > 0) {\n        // Prepend the remainder to the result string\n        result = std::to_string(x % base) + result;\n        x /= base; // Divide x by base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is (1/2) * base * height\n    return 0.5f * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    \n    int a = 0, b = 0, c = 2, d = 0; // Initial values for the first four terms\n    int next_value;\n\n    for (int i = 4; i <= n; ++i) {\n        next_value = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_value;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    size_t n = l.size();\n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Special case for 2^0 = 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the current result by the base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        int w = ((s[i] + 5 - 'a') % 26) + 'a';\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        int w = ((s[i] - 5 - 'a') % 26 + 26) % 26 + 'a'; // Ensure positive result\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Check if the character is not a vowel, considering both lowercase and uppercase.\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n            && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with provided data points.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::sort and std::unique\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from both sorted strings\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters in the string\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // First Fibonacci number\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid check_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will count the number of unmatched '<' characters.\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++; // Increment balance when an opening bracket is found.\n        } else if (c == '>') {\n            balance--; // Decrement balance when a closing bracket is found.\n            \n            // If at any point the balance goes negative, it means there's a closing\n            // bracket without a matching opening one before it.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // At the end of the string, the balance should be zero for all brackets to match correctly.\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() <= 1) return true; // A single element or empty list is trivially monotonic\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are met, the sequence is neither strictly increasing nor decreasing\n        if (increasing && decreasing) return false;\n\n    }\n    \n    return true; // The sequence is either monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    auto last_unique_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_unique_l1, l1.end());\n\n    auto last_unique_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_unique_l2, l2.end());\n\n    // Vector to store common elements\n    vector<int> result;\n\n    // Find and add common elements to the result vector\n    for (int num : l1) {\n        if (find(l2.begin(), l2.end(), num) != l2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << std::endl; // Should print 29\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << std::endl;   // Should print 2\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all opening brackets have been matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first coefficient and goes up to the last but one.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    std::string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert the string to lowercase\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (char ch : lower_s) {\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Special case: treat 'y' as a vowel only if it is at the end of the word\n    if (!lower_s.empty() && lower_s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine length of number\n    size_t num_length = num_str.length();\n    \n    // Handle case where shift is greater than or equal to the number of digits\n    if (shift >= num_length) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Compute effective shift within the range [0, num_length)\n    shift %= num_length;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_length - shift) + num_str.substr(0, num_length - shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Split the string into parts using stringstream\n    istringstream iss(s);\n    int num_apples, num_oranges;\n    \n    // Extract the number of apples and oranges from the string\n    string part;\n    if (iss >> num_apples >> part >> part >> num_oranges) {\n        // Calculate the number of mangoes by subtracting the total number of apples and oranges from the total number of fruits\n        int num_mangoes = n - (num_apples + num_oranges);\n        \n        return num_mangoes;\n    }\n    \n    // If parsing fails, return an error or handle appropriately\n    return -1;  // Indicate an error in case of invalid input format\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum integer value\n    int minIndex = -1;          // No even number found yet\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is an even number and less than or equal to the current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If it's smaller, or same but with a smaller index\n                minEvenValue = arr[i];                    // Update the smallest even value\n                minIndex = i;                             // Update the index of this value\n            }\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};  // Return an empty vector if no even number was found\n    } else {\n        return {minEvenValue, minIndex}; // Return the smallest even value and its index\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (auto num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that satisfies the condition\n    int max_val = -1; // Initialize with -1 to handle case where no such value exists\n    for (const auto& entry : freq) {\n        if (entry.first <= entry.second && entry.first > max_val) {\n            max_val = entry.first;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return lst; // Return empty vector if input is empty\n    \n    std::sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0, right = lst.size() - 1;\n    while (left <= right) {\n        if (left == right) { // If only one element is remaining\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        result.push_back(lst[left++]); // Add the minimum value and move left pointer to the right\n        result.push_back(lst[right--]); // Add the maximum value and move right pointer to the left\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet in the middle\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return total number of required changes\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    std::vector<int> prime_factors;\n\n    // Check divisibility by 2\n    while (a % 2 == 0 && prime_factors.size() < 3) {\n        if (is_prime(2)) {\n            prime_factors.push_back(2);\n        }\n        a /= 2;\n    }\n\n    // Check divisibility for odd numbers up to sqrt(a)\n    for (int i = 3; i <= std::sqrt(a); i += 2) {\n        while (a % i == 0 && prime_factors.size() < 3) {\n            if (is_prime(i)) {\n                prime_factors.push_back(i);\n            }\n            a /= i;\n        }\n    }\n\n    // Check the remaining number\n    if (a > 2 && is_prime(a)) {\n        prime_factors.push_back(a);\n    }\n\n    return prime_factors.size() == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can be any number to the power of 0.\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is 1, then only x = 1 is a valid simple power\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    // Calculate the logarithm of x to base n.\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value.\n    int exponent = static_cast<int>(log_result);\n    return fabs(log_result - exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double cbrt_a = std::cbrt(a);\n    \n    // Round to the nearest integer\n    int rounded_cbrt_a = static_cast<int>(std::round(cbrt_a));\n    \n    // Check if cubing this rounded value gives back 'a'\n    return (rounded_cbrt_a * rounded_cbrt_a * rounded_cbrt_a == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    // Define which hexadecimal characters are prime numbers.\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit.\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n// Function to test and verify the correctness of the hex_key function.\nvoid check(const std::string& num, int expected) {\n    int result = hex_key(num);\n    if (result == expected)\n        std::cout << \"PASS: For \\\"\" << num << \"\\\", got \" << result << \"\\n\";\n    else\n        std::cout << \"FAIL: For \\\"\" << num << \"\\\", expected \" << expected << \", but got \" << result << \"\\n\";\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal number to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for simplicity\n    string binary = \"\";\n    \n    if (decimal == 0) { // Special case for zero\n        return \"db0db\";\n    }\n    \n    while(decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder to form the binary string\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nbool is_happy(std::string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // If any two out of three consecutive characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");  // Invalid GPA\n        }\n    }\n\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n\n    // Count of numbers starting with 1\n    int count_starting_with_1 = static_cast<int>(pow(10, n - 1));\n\n    // Count of numbers ending with 1 but not starting with 1\n    int count_ending_with_1_not_starting_with_1 = 9 * static_cast<int>(pow(10, n - 2));\n\n    return count_starting_with_1 + count_ending_with_1_not_starting_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Sum all the digits of N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort()\nusing namespace std;\n\n// Function to anti-shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string after sorting each word\n    int n = s.length();\n    \n    for (int i = 0; i < n;) {\n        if (s[i] == ' ') {  // If current character is a space, add it to the result and move to next position\n            result += \" \";\n            ++i;\n        } else {\n            int j = i + 1;\n            \n            // Find the end of the word\n            while (j < n && s[j] != ' ') {\n                ++j;\n            }\n            \n            // Sort characters in this word\n            string temp = s.substr(i, j - i);\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n            \n            // Move to the next word\n            i = j;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing 'Hi': \" << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'hello': \" << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'Hello World!!!': \" << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for coordinate initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Comparator function to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col;  // Descending order for columns\n        else\n            return row < other.row;  // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through the list to find all occurrences of x and record their positions.\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x)\n                coordinates.push_back(Coordinate(row, col));\n        }\n    }\n\n    // Sort the coordinates as per the given criteria.\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> and return\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty or has only one element, return it as is.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n    \n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = tolower(c); // Convert to lowercase for simplicity\n            \n            size_t pos = ALPHABET.find(lower_c); // Find position of the letter in the alphabet\n            if (pos != std::string::npos) {\n                size_t new_pos = (pos + shift) % 26; // Calculate new position with wrapping around\n                char encrypted_char = ALPHABET[new_pos]; // Get the corresponding character\n                \n                // Preserve original case\n                c = isupper(c) ? toupper(encrypted_char) : encrypted_char;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <set>\n#include <iostream>\n\n// Function declaration\nint* next_smallest(std::vector<int> lst);\n\nint* next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) {\n        return nullptr;\n    }\n\n    // Use a set to remove duplicates and sort the elements\n    std::set<int> unique_elements(lst.begin(), lst.end());\n\n    // Check if there are at least two unique elements\n    if (unique_elements.size() < 2) {\n        return nullptr;\n    }\n\n    // Return the second smallest element\n    auto it = unique_elements.begin();\n    ++it; // Move to the second element in the set\n    int* result = new int(*it);\n    return result;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to trim whitespace from both ends of the string\nstring trim(const string& str) {\n    size_t first = str.find_first_not_of(' ');\n    if (first == string::npos)\n        return \"\";\n    \n    size_t last = str.find_last_not_of(' ');\n    return str.substr(first, (last - first + 1));\n}\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Split the string into sentences using '.', '?' or '!'\n    vector<string> sentences;\n    stringstream ss(S);\n    string token;\n    while (getline(ss, token, '.')) {\n        for (char c : { '?', '!' }) {\n            size_t start_pos = 0;\n            while ((start_pos = token.find(c, start_pos)) != string::npos) {\n                sentences.push_back(token.substr(start_pos + 1));\n                start_pos += 1; // Move past the delimiter\n            }\n        }\n        if (!token.empty()) {\n            sentences.push_back(token);\n        }\n    }\n\n    for (auto& sentence : sentences) {\n        size_t pos = sentence.find_first_of(\"?.!\");\n        string trimmed_sentence;\n        if (pos != string::npos) {\n            trimmed_sentence = trim(sentence.substr(0, pos));\n        } else {\n            trimmed_sentence = trim(sentence);\n        }\n        \n        // Check if the sentence starts with \"I \"\n        if (!trimmed_sentence.empty() && trimmed_sentence[0] == 'I' && \n            (trimmed_sentence.size() > 1 && trimmed_sentence[1] == ' ') || \n            trimmed_sentence.size() == 1) {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them to their integer conversion\n    if (std::floor(a) != a || std::floor(b) != b || std::floor(c) != c) {\n        return false;\n    }\n\n    // Check if one number is the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to swap case of a character\nchar swapCase(char ch) {\n    if (islower(ch)) return toupper(ch);\n    else return tolower(ch);\n}\n\n// Function to shift vowels by 2 places ahead in the alphabet\nchar shiftVowel(char vowel) {\n    string lower_vowels = \"aeiou\";\n    string upper_vowels = \"AEIOU\";\n    \n    if (islower(vowel)) {\n        size_t pos = lower_vowels.find(vowel);\n        return pos != string::npos ? lower_vowels[(pos + 2) % 5] : vowel;\n    } else {\n        size_t pos = upper_vowels.find(vowel);\n        return pos != string::npos ? upper_vowels[(pos + 2) % 5] : vowel;\n    }\n}\n\nstring encode(string message) {\n    for (char &ch : message) {\n        // Swap case\n        ch = swapCase(ch);\n\n        // Shift vowels by 2 places ahead\n        if (isalpha(ch)) {\n            ch = shiftVowel(ch);\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds and returns the sum of digits of the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime number\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    return digitSum(maxPrime); // Return the sum of digits of the largest prime\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Determine case consistency\n        if (!isLowercase(key)) allLowercase = false;\n        if (!isUppercase(key)) allUppercase = false;\n\n        // If both flags are already false, no need to continue checking\n        if (!allLowercase && !allUppercase) break;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count up to n and return a vector of prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the last digit of both numbers by taking modulo 10\n    int last_digit_a = abs(a % 10);\n    int last_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return last_digit_a * last_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5)\n        return static_cast<int>(ceil(num));\n    else if (num < 0 && ceil(num) - num == 0.5)\n        return static_cast<int>(floor(num));\n\n    return static_cast<int>(round(num)); // Standard rounding\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;  // Start with 'n' stones for the first level.\n    \n    // Add the number of stones for each level to the vector.\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine if we need an odd or even next number based on whether 'n' is odd/even.\n        int increment = (n % 2 == 1) ? 2 : 2;\n        current_stones += increment;  // Increment by 2 to get the next odd/even number.\n    }\n    \n    return pile;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i = 0; i < result.size(); ++i) {\n        printf(\"%d \", result[i]);\n    }\n    // Expected output: 3 5 7\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result and reset it\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop (in case there's no trailing comma or space)\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for (const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) return -1;\n    \n    // Adjust y to be the largest even number in the range [x, y]\n    if (y % 2 != 0) { \n        y--; // If y is odd, decrement it by 1 to make it even.\n    }\n    \n    // Check if the adjusted y is still within or equal to x\n    if (y >= x) {\n        return y;\n    } else {\n        return -1; // No even number in range [x, y]\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Main function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round it down\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number has any even digit\nbool has_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false\n        n /= 10; // Move to the next digit\n    }\n    return true; // All digits are odd\n}\n\n// Function to filter and sort numbers with only odd digits\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test and print results\nvoid test() {\n    std::vector<int> example1 = {15, 33, 1422, 1};\n    std::vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(example1) == expected1);\n\n    std::vector<int> example2 = {152, 323, 1422, 10};\n    std::vector<int> expected2;\n    assert(unique_digits(example2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Map to store digit names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Filter and sort the array\n    std::vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n\n    std::sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted vector\n    std::reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert digits to their corresponding names\n    std::vector<std::string> result;\n    for (int num : filtered_sorted) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n\n// Helper function to calculate factorial\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate the sum of numbers from 1 to i\nint sum_of_numbers(int i) {\n    return (i * (i + 1)) / 2;\n}\n\n// Main function that returns a vector based on the given rules\nstd::vector<int> f(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sum_of_numbers(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a given integer is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function to verify correctness.\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <string>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    if (num == 0) return 0;\n    int sum = 0;\n    bool is_negative = num < 0;\n\n    // Convert number to string for easy digit extraction\n    std::string str_num = std::to_string(num);\n\n    // Handle the first signed digit separately\n    if (is_negative) {\n        sum -= abs(str_num[1] - '0');  // Subtract the absolute value of the first digit\n    }\n\n    // Sum up remaining digits\n    for (size_t i = is_negative ? 1 : 0; i < str_num.size(); ++i) {\n        if (!is_negative || i > 0) {\n            sum += str_num[i] - '0';\n        }\n    }\n\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (const auto& number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\n\nbool move_one_ball(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    \n    // Check each possible starting point for a right shift operation\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n\n        // Check if the array is sorted after performing a right shift starting from index i\n        for (int j = 1; j < n; ++j) {\n            int prev_index = (i + j - 1) % n;\n            int current_index = (i + j) % n;\n            \n            // If any element violates the non-decreasing order, set is_sorted to false\n            if (arr[prev_index] > arr[current_index]) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        // If the array is sorted after a right shift starting from index i, return true\n        if (is_sorted) {\n            return true;\n        }\n    }\n\n    // If no such starting point exists that results in a sorted array, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in the vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (const auto& num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check if there are enough even numbers in the second list\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (const auto& num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n        if (evens >= requiredCount) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = countOdd(lst1);\n    \n    // If there are no odd numbers in lst1, it's already possible\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n    \n    // Check if lst2 has enough even numbers to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to find the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n\n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output string based on the count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For std::ceil\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    // Iterate through each well (row)\n    for(const auto& row : grid) {\n        int water_units = 0; // Total units of water in the current well\n        \n        // Sum up all 1s in the current well\n        for(int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times a bucket needs to be lowered for this well\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of ones in the binary representation of an integer.\nint count_ones(int n) {\n    if (n >= 0) {\n        return __builtin_popcount(n);\n    } else {\n        // For negative numbers, use two's complement and count the ones\n        unsigned int positive_n = -(n + 1);\n        return __builtin_popcount(positive_n);\n    }\n}\n\n// Main function to sort the array based on the number of ones in their binary representation.\nstd::vector<int> sort_array(std::vector<int> arr) {\n    // Sort using a custom comparator\n    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n\n        if (count_a == count_b) {\n            return a < b;\n        }\n        return count_a < count_b;\n    });\n\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from second last character to first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the current character is a vowel and both surrounding characters are consonants\n        if (is_vowel(middle_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, middle_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first = lst[0];\n    string second = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(first + second)) {\n        return \"Yes\";\n    } else if (is_balanced(second + first)) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements from the sorted vector\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the extracted elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if index is even and value at that index is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n\n    // Add the last number, which is always 1 and odd\n    odds.push_back(1);\n\n    // Sort the vector of odd numbers in increasing order\n    sort(odds.begin(), odds.end());\n\n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Find positions of '-' characters to split the date into components\n    size_t pos1 = date.find('-');\n    size_t pos2 = date.find('-', pos1 + 1);\n    \n    // Ensure there are exactly two '-' in the correct format\n    if (pos1 == string::npos || pos2 == string::npos) return false;\n    \n    // Extract month, day, and year from the string\n    int month = stoi(date.substr(0, pos1));\n    int day = stoi(date.substr(pos1 + 1, pos2 - pos1 - 1));\n    int year = stoi(date.substr(pos2 + 1));\n\n    // Validate month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate day range based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 2 && (day < 1 || day > 29))) {\n        return false;\n    } else if ((day < 1 || day > 31)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character has an odd order in the alphabet\nbool is_odd_order(char c) {\n    // Convert lowercase letter to its position in the alphabet (0 for 'a', 1 for 'b', etc.)\n    int pos = c - 'a';\n    return pos % 2 == 1;\n}\n\n// Function to count the number of characters with odd order\nint count_odd_order(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c) && is_odd_order(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on whitespace\n        size_t start = 0, end;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } else {\n        // Check for commas if no whitespace was found\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            size_t start = 0, end;\n            while ((end = txt.find(',', start)) != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n            }\n            result.push_back(txt.substr(start)); // Add the last part\n        } else {\n            // No whitespace or commas found, count odd order letters\n            int count = count_odd_order(txt);\n            result.push_back(to_string(count));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of the frequency of each number\n\n    for(int i = 0; i < lst.size(); ++i){\n        // Check ascending order\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n\n        // Count occurrences of each element\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if(countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;    \n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <cmath>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string intersection(std::vector<int> interval1, std::vector<int> interval2) {\n    int start1 = interval1[0];\n    int end1 = interval1[1];\n    int start2 = interval2[0];\n    int end2 = interval2[1];\n\n    int max_start = std::max(start1, start2);\n    int min_end = std::min(end1, end2);\n\n    if (max_start > min_end) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = min_end - max_start + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitude = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Calculate the magnitude\n        sum_magnitude += std::abs(num);\n\n        // Determine the sign and update the product of signs\n        if (num == 0) return 0; // Any number multiplied by zero is zero\n        else if (num > 0) continue; // Positive numbers don't change the product_of_signs\n        else product_of_signs *= -1; // Negative numbers flip the sign\n\n    }\n\n    // Return the final result: sum of magnitudes * product of signs\n    return sum_magnitude * product_of_signs;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Path {\n    vector<int> values;\n    int x, y;\n    \n    // Constructor to accept an rvalue or initializer list\n    Path(vector<int> v, int _x, int _y) : values(std::move(v)), x(_x), y(_y) {}\n    \n    // Comparison operator for priority queue\n    bool operator>(const Path& other) const {\n        return values.back() > other.values.back();\n    }\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    vector<int> result;\n    if (grid.empty() || grid[0].empty()) return result;\n\n    priority_queue<Path, vector<Path>, greater<Path>> pq;\n    \n    // Initialize the priority queue with starting positions\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            pq.push(Path({grid[i][j]}, i, j));\n        }\n    }\n\n    while (!pq.empty() && result.size() < k) {\n        Path currentPath = pq.top();\n        pq.pop();\n\n        if (result.size() == 0 || result.back() != currentPath.values.back()) {\n            result.push_back(currentPath.values.back());\n        }\n\n        // Add next elements to the priority queue\n        int x = currentPath.x, y = currentPath.y;\n        if (x + 1 < grid.size()) pq.push(Path(std::move(currentPath.values), x + 1, y));\n        if (y + 1 < grid[x].size()) pq.push(Path(std::move(currentPath.values), x, y + 1));\n\n        // Remove duplicates\n        while (!pq.empty() && result.back() == pq.top().values.back()) {\n            pq.pop();\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\n\nstd::vector<int> tri(int n) {\n    if (n == 0) {\n        return {1};\n    }\n\n    std::vector<int> sequence = {1, 3};  // Initial values for tribonacci sequence\n\n    for (int i = 2; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {  // If i is even\n            next_value = 1 + (i / 2);\n        } else {  // If i is odd\n            next_value = sequence[i - 1] + sequence[i - 2];\n            // The value at index i+1 will be computed in the subsequent iteration.\n            if (i < n) {\n                sequence.push_back(next_value);  // Store the current value for future use\n            }\n        }\n\n        if (i <= n) {\n            sequence.push_back(next_value);\n        }\n    }\n\n    return sequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets;\n    bool has_nested = false;\n\n    for (char bracket : str) {\n        if (bracket == '[') {\n            brackets.push(bracket);\n        } else if (bracket == ']') {\n            if (!brackets.empty() && !has_nested && brackets.size() > 1) {\n                has_nested = true;\n            }\n            if (!brackets.empty()) {\n                brackets.pop();\n            } else {\n                // If there's a closing bracket without an opening one, return false\n                return false;\n            }\n        }\n    }\n\n    // Check if there is at least one nested bracket and all brackets are matched\n    return has_nested && brackets.empty();\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number to the nearest upper integer\n        float ceiling_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += pow(ceiling_num, 2);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the input string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    char last_char = txt.back();\n    \n    // Check if the last character is an alphabetical letter and not part of a word\n    bool is_alpha = isalpha(last_char);\n    bool is_not_part_of_word = (txt.size() == 1 || !isalpha(txt[txt.size()-2]) && txt[txt.size()-2] == ' ');\n    \n    return is_alpha && is_not_part_of_word;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\nusing namespace boost;\n\n// Function to convert a string with decimal separator '.' or ',' to float\nfloat string_to_float(const string& str) {\n    size_t pos = str.find(',');\n    if (pos != string::npos) {\n        return stof(str.substr(0, pos) + \".\" + str.substr(pos + 1));\n    }\n    return stof(str);\n}\n\n// Function to compare two values of any type and return the larger one or \"None\" if equal\nany compare_one(any a, any b) {\n    // Convert strings to floats if necessary\n    float fa = 0.0f;\n    float fb = 0.0f;\n\n    if (a.type() == typeid(string)) {\n        fa = string_to_float(any_cast<string>(a));\n    } else if (a.type() == typeid(int)) {\n        fa = any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        fa = any_cast<float>(a);\n    }\n\n    if (b.type() == typeid(string)) {\n        fb = string_to_float(any_cast<string>(b));\n    } else if (b.type() == typeid(int)) {\n        fb = any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        fb = any_cast<float>(b);\n    }\n\n    // Compare the values\n    if (fa > fb) {\n        return a;\n    } else if (fb > fa) {\n        return b;\n    } else {\n        return \"None\";\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute the Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply the current factorial value with the result\n    }\n    return result;\n}\n\n// Function to test the correctness of the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << endl; // Output should be 288\n    cout << \"special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << endl; // Output should be 34560\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <regex>\n#include <string>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*\\.(txt|exe|dll)$)\");\n\n    if (std::regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n#include <iostream>\n\nint sum_squares(const std::vector<int>& lst) {\n    int total_sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i]; // Square the value\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total_sum += lst[i] * lst[i] * lst[i]; // Cube the value\n        }\n    }\n    \n    return total_sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) {\n        // Check if the length of the current word is a prime number\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a string fraction into numerator and denominator integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    int numX, denX;\n    parseFraction(x, numX, denX);\n\n    int numN, denN;\n    parseFraction(n, numN, denN);\n\n    // Compute the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the result\n    int prodDen = denX * denN;  // Denominator of the result\n\n    // Simplify the fraction by dividing numerator and denominator with their GCD\n    int commonDivisor = gcd(prodNum, prodDen);\n    prodNum /= commonDivisor;\n    prodDen /= commonDivisor;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1)\n    return prodDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint sum_of_digits(int num) {\n    int digit_sum = 0;\n    bool is_negative = (num < 0);\n    \n    while (num != 0) {\n        digit_sum += abs(num % 10);\n        num /= -10; // Adjust for negative numbers\n    }\n    \n    return digit_sum;\n}\n\n// Custom comparator function to sort based on sum of digits and original index.\nbool custom_compare(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (a.first == b.first) {\n        return a.second < b.second; // Sort by original index\n    }\n    return a.first < b.first; // Sort by sum of digits\n}\n\n// Main function to sort the vector based on the criteria.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    int n = nums.size();\n    \n    // Pair each number with its sum of digits and original index.\n    std::vector<std::pair<int, int>> paired_nums;\n    for (int i = 0; i < n; ++i) {\n        paired_nums.push_back({sum_of_digits(nums[i]), i});\n    }\n    \n    // Sort the pairs based on custom comparator.\n    std::sort(paired_nums.begin(), paired_nums.end(), custom_compare);\n    \n    // Extract and return only the numbers from the sorted pairs.\n    std::vector<int> result;\n    for (const auto& p : paired_nums) {\n        result.push_back(nums[p.second]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || \n                       firstDigit == '5' || firstDigit == '7' ||\n                       firstDigit == '9');\n    \n    bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || \n                      lastDigit == '5' || lastDigit == '7' ||\n                      lastDigit == '9');\n    \n    return isFirstOdd && isLastOdd;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula i * i - i + 1\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    bool valid_planet1 = false, valid_planet2 = false;\n\n    // Find the indices of planet1 and planet2 in the planets vector.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            valid_planet1 = true;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n            valid_planet2 = true;\n        }\n\n        // If both planets are found, break the loop.\n        if (valid_planet1 && valid_planet2)\n            break;\n    }\n\n    // Return an empty vector if either planet is not a valid name.\n    if (!valid_planet1 || !valid_planet2) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order of planets between them.\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    \n    // Collect all planets that are located between planet1 and planet2.\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test_bf() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort strings first by length and then lexicographically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;  // Alphabetical order for same lengths\n    }\n    return a.length() < b.length();  // Length-based sorting\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {  // Check even length\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    // Check if n is a prime number using the helper function\n    if (is_prime(n)) {\n        return x;  // Return x if n is prime\n    } else {\n        return y;  // Return y otherwise\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is positive and an integer\n        if (num > 0 && std::floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = compare({1,2,3,4,5,1}, {1,2,3,4,2,-2});\n    for (int i : res1) printf(\"%d \", i); // Expected: 0 0 0 0 3 3\n    \n    std::cout << \"\\n\";\n    \n    auto res2 = compare({0,5,0,0,0,4}, {4,1,1,0,0,-2});\n    for (int i : res2) printf(\"%d \", i); // Expected: 4 4 1 0 0 6\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on its name.\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) {\n            uppercase++;\n        } else if (islower(c)) {\n            lowercase++;\n        }\n    }\n    \n    return uppercase - lowercase;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() == 1)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the string 'a' with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    std::string str_num = std::to_string(std::abs(num));\n    \n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each character in the string representation of the number\n    for (char c : str_num) {\n        int digit = c - '0';  // Convert char to integer\n        \n        // Check if the digit is even or odd and update the respective counter\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},  {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},    {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with given examples\nvoid check() {\n    cout << \"19 -> \" << int_to_mini_roman(19) << endl;  // Expected: xix\n    cout << \"152 -> \" << int_to_mini_roman(152) << endl; // Expected: clii\n    cout << \"426 -> \" << int_to_mini_roman(426) << endl; // Expected: cdxxvi\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    float hypotenuse = sides[2]; // The largest value will be at index 2\n\n    // Check if it's a right-angled triangle using Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1]) == (hypotenuse * hypotenuse);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // for std::sort and std::unique\n#include <set>       // to count unique characters\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) return \"\";  // Handle empty vector case\n    \n    auto max_unique_chars = 0;\n    std::string result;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        \n        int current_unique_count = unique_chars.size();\n        \n        if (current_unique_count > max_unique_chars || \n            (current_unique_count == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_count;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total number of carrots to eat after meals\n    int totalToEat = number + need;\n    \n    // If there are enough remaining carrots, calculate the new counts\n    if (remaining >= need) {\n        return {totalToEat, remaining - need};\n    }\n    // Otherwise, eat all remaining carrots and be still hungry\n    else {\n        return {number + remaining, 0};\n    }\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stack>\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    // Initialize a stack to handle the evaluation of the algebraic expression\n    std::stack<long long> eval_stack;\n\n    // Push the first operand onto the stack\n    eval_stack.push(operands[0]);\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        const std::string& operator_str = operators[i];\n        int next_operand = operands[i + 1];\n\n        if (!eval_stack.empty()) {\n            long long prev_operand = eval_stack.top();\n            eval_stack.pop();\n\n            // Perform the operation and push the result back onto the stack\n            if (operator_str == \"+\") {\n                eval_stack.push(prev_operand + next_operand);\n            } else if (operator_str == \"-\") {\n                eval_stack.push(prev_operand - next_operand);\n            } else if (operator_str == \"*\") {\n                eval_stack.push(prev_operand * next_operand);\n            } else if (operator_str == \"//\") {\n                eval_stack.push(prev_operand / next_operand); // Note: This is integer division\n            } else if (operator_str == \"**\") {\n                long long result = 1;\n                for (int j = 0; j < next_operand; ++j) {\n                    result *= prev_operand;\n                }\n                eval_stack.push(result);\n            }\n        }\n    }\n\n    // The final result is the top of the stack\n    return static_cast<int>(eval_stack.top());\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed\n        for (char &c : s) {\n            if (isLetter(c)) c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&hash);\n\n    // Convert the computed hash to a hexadecimal string\n    stringstream hex_stream;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        hex_stream << uppercase << hex << static_cast<int>(hash[i]);\n    }\n\n    return hex_stream.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is less than or equal to 'b'\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    std::vector<int> even_digits;\n    \n    for (int num = start; num <= end; ++num) {\n        if (num < 10 && num % 2 == 0) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list and check if any two consecutive elements\n    // are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::stack<char> stack;\n    std::string current_group = \"\";\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            stack.pop();\n            current_group += c;\n\n            // When the stack is empty, it means a group is complete\n            if (stack.empty()) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);  // Get the integer part\n    float decimal_part = number - integer_part;  // Subtract to get the decimal part\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) {\n            return true; // If balance falls below zero, return true\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size.\n    vector<int> result(result_size);\n\n    if (!numbers.empty()) {\n        int pos = 0;\n        \n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result[pos++] = numbers[i];\n            \n            if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n                result[pos++] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes.\nvoid printVector(const vector<int>& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    \n    // Function to calculate depth for a single group of parentheses\n    auto calculate_depth = [](const string& group) -> int {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (max_depth < current_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                --current_depth;\n            }\n        }\n        return max_depth;\n    };\n\n    // Split the input string into groups and calculate depth for each group\n    size_t start = 0, end = paren_string.find(' ');\n    while (end != string::npos) {\n        depths.push_back(calculate_depth(paren_string.substr(start, end - start)));\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Add the last group\n    if (start < paren_string.length()) {\n        depths.push_back(calculate_depth(paren_string.substr(start)));\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    auto result1 = filter_by_substring({}, \"a\");\n    assert(result1.empty());\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    vector<string> expected_result2{\"abc\", \"bacd\", \"vector\"};\n    for (const auto& str : expected_result2) {\n        assert(find(result2.begin(), result2.end(), str) != result2.end());\n    }\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int total_sum = 0;\n    int total_product = 1;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Iterate through each number in the vector and update sum and product\n    for (int number : numbers) {\n        total_sum += number;\n        total_product *= number;\n    }\n\n    // Return a vector containing the sum and product\n    return {total_sum, total_product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str_input) {\n    int n = str_input.length();\n    for (int i = 0; i < n; ++i) {\n        string postfix = str_input.substr(i);\n        if (is_palindrome(postfix)) {\n            string prefix_to_reverse = str_input.substr(0, i);\n            return str_input + string(prefix_to_reverse.rbegin(), prefix_to_reverse.rend());\n        }\n    }\n    // If the entire input is a palindrome, just return it\n    return str_input;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result.\n\n    // Iterate through each character in the strings and perform XOR operation.\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both characters are the same, append '0' to the result string.\n        } else {\n            result += '1';  // If characters are different, append '1'.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // If current string is longer than the longest found so far\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) {\n        return -1; // or throw an exception/error for invalid input\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\\n\";\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase\n    for (char &ch : str) {\n        ch = std::tolower(ch);\n    }\n\n    // Use a set to store unique characters\n    std::unordered_set<char> unique_chars;\n    \n    // Insert each character into the set\n    for (char ch : str) {\n        unique_chars.insert(ch);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n\nstd::vector<int> parse_music(std::string music_string) {\n    std::vector<int> beats;\n    size_t i = 0;\n\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2);\n                i += 2;\n            } else {\n                beats.push_back(4);\n                i += 1;\n            }\n        } else if (music_string.substr(i, 3) == \".|\") {\n            beats.push_back(1);\n            i += 2;\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move past the last found position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n// Function to convert number words to integers\nint word_to_int(const string& word) {\n    static const map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n    \n    return num_map.at(word);\n}\n\n// Function to convert integers back to number words\nstring int_to_word(int num) {\n    static const map<int, string> rev_num_map = {\n        {0, \"zero\"},\n        {1, \"one\"},\n        {2, \"two\"},\n        {3, \"three\"},\n        {4, \"four\"},\n        {5, \"five\"},\n        {6, \"six\"},\n        {7, \"seven\"},\n        {8, \"eight\"},\n        {9, \"nine\"}\n    };\n    \n    return rev_num_map.at(num);\n}\n\n// Main function to sort number words\nstring sort_numbers(string numbers) {\n    // Split the input string into individual words\n    stringstream ss(numbers);\n    string word;\n    vector<int> int_numbers;\n\n    while (ss >> word) {\n        int_numbers.push_back(word_to_int(word));\n    }\n\n    // Sort the list of integers\n    sort(int_numbers.begin(), int_numbers.end());\n\n    // Convert the sorted integer list back to their corresponding string representations\n    stringstream result;\n    for (int num : int_numbers) {\n        result << int_to_word(num) << \" \";\n    }\n    \n    // Remove trailing space and return the final string\n    string sorted_str = result.str();\n    if (!sorted_str.empty()) {\n        sorted_str.pop_back();  // Remove the last space character\n    }\n\n    return sorted_str;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        // Calculate the difference between consecutive elements\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        \n        // Update the minimum difference and closest pair if a smaller difference is found\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    // Return the closest pair as a vector\n    return std::vector<float>{closest_pair.first, closest_pair.second};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation: (num - min_val) / (max_val - min_val)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check_function() {\n    list_any test1 = {std::string(\"a\"), 3.14, 5};\n    auto filtered_test1 = filter_integers(test1);\n    for (int num : filtered_test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    list_any test2 = {1, 2, 3, std::string(\"abc\"), {}, {}};\n    auto filtered_test2 = filter_integers(test2);\n    for (int num : filtered_test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint strlen(const std::string& str) {\n    return str.length(); // or str.size()\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle even numbers first.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print the vector of factors for testing purposes.\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << factors[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \" \", \"world\"}) == \"hello world\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and display results\nvoid check(vector<string> input, string prefix) {\n    vector<string> filtered = filter_by_prefix(input, prefix);\n    \n    cout << \"{\";\n    for (size_t i = 0; i < filtered.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << filtered[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to return only positive numbers from the input vector.\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the vector and check if it is positive.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is greater than zero.\n            result.push_back(num);  // Add positive numbers to the result vector.\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of get_positive function.\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    for (float num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 2 5 6\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    for (float num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 5 3 2 3 9 123 1\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by 2 and 3 first, as they are the smallest primes.\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // If divisible by 2 or 3, it's not prime\n    \n    // Check for divisibility from 5 onwards, skipping even numbers.\n    long long i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false; // If divisible by any number in this range, it's not prime\n        i += 6; // Skip even numbers and multiples of 3\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x. \n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble poly_derivative(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates the derivative of polynomial with coefficients xs at point x.\n    */\n    double deriv = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        deriv += static_cast<int>(i) * xs[i] * std::pow(x, static_cast<int>(i - 1));\n    }\n    return deriv;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    Finds the root of a polynomial with coefficients xs such that poly(x) = 0.\n    Returns only one zero point even if there are many.\n    Assumes xs has an even number of coefficients and the largest non-zero coefficient guarantees a solution.\n    */\n    double x0 = xs[1] / (-xs[0]); // Initial guess\n    const double tol = 1e-6;\n    const int max_iter = 100;\n\n    for (int iter = 0; iter < max_iter; ++iter) {\n        double fx = poly(xs, x0);\n        if (std::abs(fx) < tol) {\n            return x0;\n        }\n        double dfdx = poly_derivative(xs, x0);\n        if (dfdx == 0) {\n            break;\n        }\n        x0 -= fx / dfdx;\n    }\n\n    return x0;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    // Extract elements at indices divisible by 3 (0-based index)\n    std::vector<int> divisible_by_three;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Create a new vector to store the result\n    std::vector<int> result = l;\n\n    // Populate the result vector with sorted elements at indices divisible by 3\n    size_t j = 0;  // Index for the sorted elements\n    for (size_t i = 2; i < l.size(); i += 3) {\n        result[i] = divisible_by_three[j];\n        j++;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit 7\n                    count++;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract values at even indices (0-based indexing)\n    vector<float> even_indices_values;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted even index values\n    sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to store the result\n    vector<float> result = l;\n\n    // Update the even indices in the result with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 1; i < result.size() && sorted_index < even_indices_values.size(); i += 2) {\n        result[i] = even_indices_values[sorted_index++];\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached as we always find a result.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <iostream>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Since all cars are moving towards each other at the same speed,\n    // and there is an equal number of cars on both sides of the road,\n    // every left-to-right car will eventually collide with a right-to-left car.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &i : l) {  // Iterate through each element and increment it by 1.\n        i += 1;\n    }\n    return l;  // Return the modified vector.\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    for (const int& elem : vec) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        \n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    return false;  // No pairs sum up to zero.\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1 || base >= 10) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    std::string result = \"\";\n    while (x > 0) {\n        // Prepend the remainder to the result string\n        result = std::to_string(x % base) + result;\n        x /= base; // Divide x by base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is (1/2) * base * height\n    return 0.5f * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n    \n    // Initialize base cases\n    int a = 0, b = 0, c = 2, d = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        int next_value = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_value;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    size_t n = l.size();\n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Special case for 2^0 = 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the current result by the base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] + 5 - 'a') % 26) + 'a';\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] - 5 - 'a') % 26 + 26) % 26 + 'a'; // Ensure positive result\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Check if the character is not a vowel, considering both lowercase and uppercase.\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n            && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with provided data points.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::sort and std::unique\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from both sorted strings\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters in the string\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // First Fibonacci number\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid check_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will count the number of unmatched '<' characters.\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++; // Increment balance when an opening bracket is found.\n        } else if (c == '>') {\n            balance--; // Decrement balance when a closing bracket is found.\n            \n            // If at any point the balance goes negative, it means there's a closing\n            // bracket without a matching opening one before it.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // At the end of the string, the balance should be zero for all brackets to match correctly.\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() <= 1) return true; // A single element or empty list is trivially monotonic\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are met, the sequence is neither strictly increasing nor decreasing\n        if (increasing && decreasing) return false;\n\n    }\n    \n    return true; // The sequence is either monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    auto last_unique_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_unique_l1, l1.end());\n\n    auto last_unique_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_unique_l2, l2.end());\n\n    // Vector to store common elements\n    vector<int> result;\n\n    // Find and add common elements to the result vector\n    for (int num : l1) {\n        if (find(l2.begin(), l2.end(), num) != l2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << std::endl; // Should print 29\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << std::endl;   // Should print 2\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all opening brackets have been matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first coefficient and goes up to the last but one.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    std::string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert the string to lowercase\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (char ch : lower_s) {\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Special case: treat 'y' as a vowel only if it is at the end of the word\n    if (!lower_s.empty() && lower_s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Get length of the number as a string\n    int num_length = num_str.length();\n    \n    // If shift is greater than or equal to the number's length, reverse the digits\n    if (shift >= num_length) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Reduce shift to an equivalent value within the range of the number's length\n    shift %= num_length;\n    \n    // Perform circular shift using substrings\n    std::string shifted_str = num_str.substr(num_length - shift) + num_str.substr(0, num_length - shift);\n    \n    return shifted_str;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find positions of \"apples\" and \"oranges\"\n    size_t pos_apples = s.find(\" apples\");\n    size_t pos_oranges = s.find(\" oranges\");\n\n    // Extract the number of apples\n    string num_apples_str = s.substr(0, pos_apples);\n    int num_apples = stoi(num_apples_str);\n\n    // Extract the number of oranges\n    string num_oranges_str = s.substr(pos_apples + 8, pos_oranges - (pos_apples + 8));\n    int num_oranges = stoi(num_oranges_str);\n\n    // Calculate the number of mangoes\n    int num_mangoes = n - (num_apples + num_oranges);\n\n    return num_mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum integer value\n    int minIndex = -1;          // No even number found yet\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is an even number and less than or equal to the current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If it's smaller, or same but with a smaller index\n                minEvenValue = arr[i];                    // Update the smallest even value\n                minIndex = i;                             // Update the index of this value\n            }\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};  // Return an empty vector if no even number was found\n    } else {\n        return {minEvenValue, minIndex}; // Return the smallest even value and its index\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (auto num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that satisfies the condition\n    int max_val = -1; // Initialize with -1 to handle case where no such value exists\n    for (const auto& entry : freq) {\n        if (entry.first <= entry.second && entry.first > max_val) {\n            max_val = entry.first;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return lst; // Return empty vector if input is empty\n    \n    std::sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0, right = lst.size() - 1;\n    while (left <= right) {\n        if (left == right) { // If only one element is remaining\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        result.push_back(lst[left++]); // Add the minimum value and move left pointer to the right\n        result.push_back(lst[right--]); // Add the maximum value and move right pointer to the left\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet in the middle\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return total number of required changes\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    std::vector<int> prime_factors;\n\n    // Check divisibility by 2\n    while (a % 2 == 0) {\n        prime_factors.push_back(2);\n        a /= 2;\n    }\n\n    // Check for odd factors starting from 3 to sqrt(a)\n    for (int i = 3; i <= std::sqrt(a); i += 2) {\n        while (a % i == 0 && is_prime(i)) {\n            prime_factors.push_back(i);\n            a /= i;\n        }\n    }\n\n    // Check if the remaining number greater than 2 is also a prime\n    if (a > 2 && is_prime(a)) {\n        prime_factors.push_back(a);\n    }\n\n    // Return true if there are exactly three prime factors\n    return prime_factors.size() == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can be any number to the power of 0.\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is 1, then only x = 1 is a valid simple power\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    // Calculate the logarithm of x to base n.\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value.\n    int exponent = static_cast<int>(log_result);\n    return fabs(log_result - exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double cbrt_a = std::cbrt(a);\n    \n    // Round to the nearest integer\n    int rounded_cbrt_a = static_cast<int>(std::round(cbrt_a));\n    \n    // Check if cubing this rounded value gives back 'a'\n    return (rounded_cbrt_a * rounded_cbrt_a * rounded_cbrt_a == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    // Define which hexadecimal characters are prime numbers.\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit.\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n// Function to test and verify the correctness of the hex_key function.\nvoid check(const std::string& num, int expected) {\n    int result = hex_key(num);\n    if (result == expected)\n        std::cout << \"PASS: For \\\"\" << num << \"\\\", got \" << result << \"\\n\";\n    else\n        std::cout << \"FAIL: For \\\"\" << num << \"\\\", expected \" << expected << \", but got \" << result << \"\\n\";\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal number to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for simplicity\n    string binary = \"\";\n    \n    if (decimal == 0) { // Special case for zero\n        return \"db0db\";\n    }\n    \n    while(decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder to form the binary string\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nbool is_happy(std::string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // If any two out of three consecutive characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f && gpa < 0.7f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\"); // For invalid GPA values less than 0.0\n        }\n    }\n\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\n// Function to calculate the count of n-digit positive integers that start or end with 1.\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    \n    // Count numbers starting with 1: 10^(n-1)\n    long long count_start_with_1 = static_cast<long long>(pow(10, n - 1));\n    \n    // Count numbers ending with 1 but not starting with 1: 9 * 10^(n-2)\n    long long count_end_with_1_not_starting_with_1 = 9LL * pow(10, n - 2);\n    \n    // Overlap (numbers that both start and end with 1): 10^(n-2)\n    long long overlap = static_cast<long long>(pow(10, n - 2));\n    \n    // Total count\n    int total_count = count_start_with_1 + count_end_with_1_not_starting_with_1 - overlap;\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Sum all the digits of N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort()\nusing namespace std;\n\n// Function to anti-shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string after sorting each word\n    int n = s.length();\n    \n    for (int i = 0; i < n;) {\n        if (s[i] == ' ') {  // If current character is a space, add it to the result and move to next position\n            result += \" \";\n            ++i;\n        } else {\n            int j = i + 1;\n            \n            // Find the end of the word\n            while (j < n && s[j] != ' ') {\n                ++j;\n            }\n            \n            // Sort characters in this word\n            string temp = s.substr(i, j - i);\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n            \n            // Move to the next word\n            i = j;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing 'Hi': \" << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'hello': \" << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'Hello World!!!': \" << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for coordinate initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Comparator function to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col;  // Descending order for columns\n        else\n            return row < other.row;  // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through the list to find all occurrences of x and record their positions.\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x)\n                coordinates.push_back(Coordinate(row, col));\n        }\n    }\n\n    // Sort the coordinates as per the given criteria.\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> and return\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty or has only one element, return it as is.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n    \n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = tolower(c); // Convert to lowercase for simplicity\n            \n            size_t pos = ALPHABET.find(lower_c); // Find position of the letter in the alphabet\n            if (pos != std::string::npos) {\n                size_t new_pos = (pos + shift) % 26; // Calculate new position with wrapping around\n                char encrypted_char = ALPHABET[new_pos]; // Get the corresponding character\n                \n                // Preserve original case\n                c = isupper(c) ? toupper(encrypted_char) : encrypted_char;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <set>\n#include <optional>\n\nusing namespace std;\n\noptional<int> next_smallest(vector<int> lst) {\n    // Step 1: Check if the vector has at least two elements.\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Step 2: Remove duplicates and sort the elements.\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // Step 3: Check for second smallest element.\n    if (unique_elements.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Step 4: Return the second smallest element.\n    auto it = unique_elements.begin();\n    ++it; // Move to the second element\n    return *it;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Replace '!' and '?' with '.' to standardize sentence delimiters.\n    for (char& c : S) {\n        if (c == '!' || c == '?') {\n            c = '.';\n        }\n    }\n\n    // Split the string into sentences based on '.'\n    stringstream ss(S);\n    string sentence;\n    while (getline(ss, sentence, '.')) {\n        // Strip leading and trailing whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start == string::npos) continue;  // Skip empty or whitespace-only sentences\n\n        size_t end = sentence.find_last_not_of(\" \\t\");\n        sentence = sentence.substr(start, end - start + 1);\n\n        // Check if the sentence starts with \"I \"\n        if (sentence.size() >= 2 && sentence[0] == 'I' && sentence[1] == ' ') {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath> // For floor and ceil functions\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them to their integer conversions\n    bool is_a_integer = std::floor(a) == a;\n    bool is_b_integer = std::floor(b) == b;\n    bool is_c_integer = std::floor(c) == c;\n\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number is the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else return tolower(c);\n}\n\n// Function to encode the message according to specified rules\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::map<char, char> shifted_vowels = {\n        {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n        {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}\n    };\n\n    for (char &ch : message) {\n        if (isalpha(ch)) {\n            ch = swapCase(ch);\n            // Check if the character is a vowel and replace it\n            if (vowels.find(ch) != std::string::npos) {\n                ch = shifted_vowels[ch];\n            }\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds and returns the sum of digits of the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime number\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    return digitSum(maxPrime); // Return the sum of digits of the largest prime\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Determine case consistency\n        if (!isLowercase(key)) allLowercase = false;\n        if (!isUppercase(key)) allUppercase = false;\n\n        // If both flags are already false, no need to continue checking\n        if (!allLowercase && !allUppercase) break;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count up to n and return a vector of prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the last digit of both numbers by taking modulo 10\n    int last_digit_a = abs(a % 10);\n    int last_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return last_digit_a * last_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5)\n        return static_cast<int>(ceil(num));\n    else if (num < 0 && ceil(num) - num == 0.5)\n        return static_cast<int>(floor(num));\n\n    return static_cast<int>(round(num)); // Standard rounding\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;  // Start with 'n' stones for the first level.\n    \n    // Add the number of stones for each level to the vector.\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine if we need an odd or even next number based on whether 'n' is odd/even.\n        int increment = (n % 2 == 1) ? 2 : 2;\n        current_stones += increment;  // Increment by 2 to get the next odd/even number.\n    }\n    \n    return pile;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i = 0; i < result.size(); ++i) {\n        printf(\"%d \", result[i]);\n    }\n    // Expected output: 3 5 7\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result and reset it\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop (in case there's no trailing comma or space)\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for (const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) return -1;\n    \n    // Adjust y to be the largest even number in the range [x, y]\n    if (y % 2 != 0) { \n        y--; // If y is odd, decrement it by 1 to make it even.\n    }\n    \n    // Check if the adjusted y is still within or equal to x\n    if (y >= x) {\n        return y;\n    } else {\n        return -1; // No even number in range [x, y]\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Main function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round it down\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number has any even digit\nbool has_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false\n        n /= 10; // Move to the next digit\n    }\n    return true; // All digits are odd\n}\n\n// Function to filter and sort numbers with only odd digits\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test and print results\nvoid test() {\n    std::vector<int> example1 = {15, 33, 1422, 1};\n    std::vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(example1) == expected1);\n\n    std::vector<int> example2 = {152, 323, 1422, 10};\n    std::vector<int> expected2;\n    assert(unique_digits(example2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Map to store digit names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Filter and sort the array\n    std::vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n\n    std::sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted vector\n    std::reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert digits to their corresponding names\n    std::vector<std::string> result;\n    for (int num : filtered_sorted) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\n// Helper function to calculate the factorial of a number\nint factorial(int i) {\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate the sum from 1 to i\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if (index % 2 == 0) { // Even index\n            result[i] = factorial(index);\n        } else { // Odd index\n            result[i] = sum_to_i(index);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a given integer is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function to verify correctness.\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of signed digits for a given integer.\nint sum_of_digits(int num) {\n    if (num == 0) return 0;\n\n    bool is_negative = num < 0;\n    int digit_sum = 0;\n\n    while (num != 0) {\n        int digit = abs(num % 10);\n        if (is_negative && (num / 10) != 0) {\n            digit *= -1;\n        }\n        digit_sum += digit;\n        num /= 10;\n    }\n\n    return digit_sum;\n}\n\n// Main function to count the number of elements with a sum of digits > 0.\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (auto number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int break_point = -1;\n\n    // Find the first index where the array breaks from being non-decreasing\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no break point is found, the array is already sorted\n    if (break_point == -1) {\n        return true;\n    }\n\n    int start_index = (break_point + 1) % n;\n\n    // Verify if rotating from this index results in a non-decreasing order\n    for (int i = start_index; i < start_index + n - 1; ++i) {\n        int j = i % n;\n        if (arr[j] > arr[(j + 1) % n]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in the vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (const auto& num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check if there are enough even numbers in the second list\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (const auto& num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n        if (evens >= requiredCount) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = countOdd(lst1);\n    \n    // If there are no odd numbers in lst1, it's already possible\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n    \n    // Check if lst2 has enough even numbers to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to find the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n\n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output string based on the count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For std::ceil\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    // Iterate through each well (row)\n    for(const auto& row : grid) {\n        int water_units = 0; // Total units of water in the current well\n        \n        // Sum up all 1s in the current well\n        for(int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times a bucket needs to be lowered for this well\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of 1s in the binary representation of a number.\nint count_ones(int n) {\n    if (n >= 0) {\n        int count = 0;\n        for (int i = 31; i >= 0; --i) {\n            count += ((n >> i) & 1);\n        }\n        return count;\n    } else {\n        // For negative numbers, convert to positive and count\n        unsigned int pos_n = -static_cast<unsigned int>(n + 1);\n        int count = 0;\n        for (int i = 31; i >= 0; --i) {\n            count += ((pos_n >> i) & 1);\n        }\n        return count;\n    }\n}\n\n// Custom comparator function\nbool custom_compare(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return abs(a) < abs(b);\n    }\n\n    return ones_a < ones_b;\n}\n\n// Main sorting function\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from second last character to first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the current character is a vowel and both surrounding characters are consonants\n        if (is_vowel(middle_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, middle_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first = lst[0];\n    string second = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(first + second)) {\n        return \"Yes\";\n    } else if (is_balanced(second + first)) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements from the sorted vector\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the extracted elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if index is even and value at that index is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n\n    // Add the last number, which is always 1 and odd\n    odds.push_back(1);\n\n    // Sort the vector of odd numbers in increasing order\n    sort(odds.begin(), odds.end());\n\n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Find positions of '-' characters to split the date into components\n    size_t pos1 = date.find('-');\n    size_t pos2 = date.find('-', pos1 + 1);\n    \n    // Ensure there are exactly two '-' in the correct format\n    if (pos1 == string::npos || pos2 == string::npos) return false;\n    \n    // Extract month, day, and year from the string\n    int month = stoi(date.substr(0, pos1));\n    int day = stoi(date.substr(pos1 + 1, pos2 - pos1 - 1));\n    int year = stoi(date.substr(pos2 + 1));\n\n    // Validate month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate day range based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 2 && (day < 1 || day > 29))) {\n        return false;\n    } else if ((day < 1 || day > 31)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character has an odd order in the alphabet\nbool is_odd_order(char c) {\n    // Convert lowercase letter to its position in the alphabet (0 for 'a', 1 for 'b', etc.)\n    int pos = c - 'a';\n    return pos % 2 == 1;\n}\n\n// Function to count the number of characters with odd order\nint count_odd_order(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c) && is_odd_order(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on whitespace\n        size_t start = 0, end;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } else {\n        // Check for commas if no whitespace was found\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            size_t start = 0, end;\n            while ((end = txt.find(',', start)) != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n            }\n            result.push_back(txt.substr(start)); // Add the last part\n        } else {\n            // No whitespace or commas found, count odd order letters\n            int count = count_odd_order(txt);\n            result.push_back(to_string(count));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of the frequency of each number\n\n    for(int i = 0; i < lst.size(); ++i){\n        // Check ascending order\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n\n        // Count occurrences of each element\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if(countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;    \n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n    return is_prime(length_of_intersection) ? \"YES\" : \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitude = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Calculate the magnitude\n        sum_magnitude += std::abs(num);\n\n        // Determine the sign and update the product of signs\n        if (num == 0) return 0; // Any number multiplied by zero is zero\n        else if (num > 0) continue; // Positive numbers don't change the product_of_signs\n        else product_of_signs *= -1; // Negative numbers flip the sign\n\n    }\n\n    // Return the final result: sum of magnitudes * product of signs\n    return sum_magnitude * product_of_signs;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <set>\n\nbool is_valid(int x, int y, int N) {\n    return 0 <= x && x < N && 0 <= y && y < N;\n}\n\nvoid dfs(const std::vector<std::vector<int>>& grid, \n         std::vector<std::vector<bool>>& visited, \n         int x, int y, \n         int path_length, \n         std::vector<int>& current_path, \n         std::vector<std::vector<int>>& paths,\n         int k) {\n    if (path_length == k) {\n        paths.push_back(current_path);\n        return;\n    }\n    \n    for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n            if ((abs(dx) + abs(dy)) != 1) continue; // Only consider direct neighbors\n            int nx = x + dx, ny = y + dy;\n            if (is_valid(nx, ny, grid.size()) && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                current_path.push_back(grid[nx][ny]);\n                dfs(grid, visited, nx, ny, path_length + 1, current_path, paths, k);\n                current_path.pop_back();\n                visited[nx][ny] = false;\n            }\n        }\n    }\n}\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n    std::vector<std::vector<int>> paths;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> current_path;\n            current_path.push_back(grid[i][j]);\n            visited[i][j] = true;\n            dfs(grid, visited, i, j, 1, current_path, paths, k);\n            visited[i][j] = false;\n        }\n    }\n    \n    // Find the lexicographically smallest path\n    std::vector<int> min_path(paths[0]); // Initialize with first path\n    for (const auto& path : paths) {\n        if (path < min_path) {\n            min_path = path;\n        }\n    }\n    return min_path;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) {\n        return {};\n    }\n    \n    vector<int> sequence(n + 1, 1);\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            sequence[i] = 1 + (i / 2);\n        } else {\n            // The value of tri(i+1) will be computed later\n            sequence[i] = sequence[i - 1] + sequence[i - 2];\n        }\n    }\n    \n    // Adjust the first element to match the definition tri(1) = 3\n    if (n >= 1) {\n        sequence[0] = 3;\n    }\n    \n    return sequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets;\n    bool has_nested_bracket = false;\n\n    for (char bracket : str) {\n        if (bracket == '[') {\n            brackets.push(bracket);\n        } else if (bracket == ']') {\n            if (!brackets.empty() && !has_nested_bracket && brackets.size() > 1) {\n                has_nested_bracket = true;\n            }\n            if (!brackets.empty()) {\n                brackets.pop();\n            } else {\n                // If the stack is empty but we encounter a closing bracket, it means there's an imbalance\n                return false;\n            }\n        }\n    }\n\n    // Ensure all opening brackets have corresponding closing brackets and at least one nested sequence exists\n    return has_nested_bracket && brackets.empty();\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number to the nearest upper integer\n        float ceiling_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += pow(ceiling_num, 2);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isalpha()\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    // Remove trailing spaces\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the last character is an alphabetical character and not part of a word\n    if (!txt.empty() && isalpha(txt.back()) && (txt.length() == 1 || !isalpha(txt[txt.length()-2]))) {\n        return true;\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n\n// Function to convert a string with comma as decimal separator to float\nfloat string_to_float(const std::string& str) {\n    size_t pos = str.find(',');\n    if (pos != std::string::npos) {\n        return std::stof(str.substr(0, pos) + \".\" + str.substr(pos + 1));\n    }\n    return std::stof(str);\n}\n\n// Function to compare two values of any type and return the larger one\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(int)) {\n        int ia = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (ia == ib) ? std::string(\"None\") : (ia > ib ? std::to_string(ia) : std::to_string(ib));\n        } else if (b.type() == typeid(float)) {\n            float fb = boost::any_cast<float>(b);\n            return (static_cast<float>(ia) == fb) ? std::string(\"None\") : (static_cast<float>(ia) > fb ? std::to_string(ia) : std::to_string(fb));\n        } else if (b.type() == typeid(std::string)) {\n            float fb = string_to_float(boost::any_cast<std::string>(b));\n            return (static_cast<float>(ia) == fb) ? std::string(\"None\") : (static_cast<float>(ia) > fb ? std::to_string(ia) : boost::any_cast<std::string>(b));\n        }\n    } else if (a.type() == typeid(float)) {\n        float fa = boost::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (fa == static_cast<float>(ib)) ? std::string(\"None\") : (fa > static_cast<float>(ib) ? std::to_string(fa) : std::to_string(ib));\n        } else if (b.type() == typeid(float)) {\n            float fb = boost::any_cast<float>(b);\n            return (fa == fb) ? std::string(\"None\") : (fa > fb ? std::to_string(fa) : std::to_string(fb));\n        } else if (b.type() == typeid(std::string)) {\n            float fb = string_to_float(boost::any_cast<std::string>(b));\n            return (fa == fb) ? std::string(\"None\") : (fa > fb ? std::to_string(fa) : boost::any_cast<std::string>(b));\n        }\n    } else if (a.type() == typeid(std::string)) {\n        float fa = string_to_float(boost::any_cast<std::string>(a));\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (fa == static_cast<float>(ib)) ? std::string(\"None\") : (fa > static_cast<float>(ib) ? boost::any_cast<std::string>(a) : std::to_string(ib));\n        } else if (b.type() == typeid(float)) {\n            float fb = boost::any_cast<float>(b);\n            return (fa == fb) ? std::string(\"None\") : (fa > fb ? boost::any_cast<std::string>(a) : std::to_string(fb));\n        } else if (b.type() == typeid(std::string)) {\n            float fb = string_to_float(boost::any_cast<std::string>(b));\n            return (fa == fb) ? std::string(\"None\") : (fa > fb ? boost::any_cast<std::string>(a) : boost::any_cast<std::string>(b));\n        }\n    }\n\n    // If types are not handled above, return \"None\"\n    return std::string(\"None\");\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute the Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply the current factorial value with the result\n    }\n    return result;\n}\n\n// Function to test the correctness of the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << endl; // Output should be 288\n    cout << \"special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << endl; // Output should be 34560\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result += string(space_count, '_');\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result += string(space_count, '_');\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <regex>\n#include <string>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*\\.(txt|exe|dll)$)\");\n\n    if (std::regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n#include <iostream>\n\nint sum_squares(const std::vector<int>& lst) {\n    int total_sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i]; // Square the value\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total_sum += lst[i] * lst[i] * lst[i]; // Cube the value\n        }\n    }\n    return total_sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) {\n        // Check if the length of the current word is a prime number\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a string fraction into numerator and denominator integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    int numX, denX;\n    parseFraction(x, numX, denX);\n\n    int numN, denN;\n    parseFraction(n, numN, denN);\n\n    // Compute the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the result\n    int prodDen = denX * denN;  // Denominator of the result\n\n    // Simplify the fraction by dividing numerator and denominator with their GCD\n    int commonDivisor = gcd(prodNum, prodDen);\n    prodNum /= commonDivisor;\n    prodDen /= commonDivisor;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1)\n    return prodDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> order_by_points(std::vector<int> points) {\n    std::vector<std::pair<int, int>> pairs;\n\n    // Create pairs (value, index)\n    for (size_t i = 0; i < points.size(); ++i) {\n        pairs.push_back({points[i], static_cast<int>(i)});\n    }\n\n    // Sort using a lambda function\n    std::sort(pairs.begin(), pairs.end(),\n              [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                  if (a.first == b.first)\n                      return a.second < b.second;\n                  else\n                      return a.first < b.first;\n              });\n\n    // Extract the sorted indices back into a vector of integers\n    std::vector<int> result(points.size());\n    for (size_t i = 0; i < points.size(); ++i) {\n        result[i] = pairs[i].second;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || \n                       firstDigit == '5' || firstDigit == '7' ||\n                       firstDigit == '9');\n    \n    bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || \n                      lastDigit == '5' || lastDigit == '7' ||\n                      lastDigit == '9');\n    \n    return isFirstOdd && isLastOdd;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula i * i - i + 1\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    bool valid_planet1 = false, valid_planet2 = false;\n\n    // Find the indices of planet1 and planet2 in the planets vector.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            valid_planet1 = true;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n            valid_planet2 = true;\n        }\n\n        // If both planets are found, break the loop.\n        if (valid_planet1 && valid_planet2)\n            break;\n    }\n\n    // Return an empty vector if either planet is not a valid name.\n    if (!valid_planet1 || !valid_planet2) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order of planets between them.\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    \n    // Collect all planets that are located between planet1 and planet2.\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test_bf() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort strings first by length and then lexicographically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;  // Alphabetical order for same lengths\n    }\n    return a.length() < b.length();  // Length-based sorting\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {  // Check even length\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    // Check if n is a prime number using the helper function\n    if (is_prime(n)) {\n        return x;  // Return x if n is prime\n    } else {\n        return y;  // Return y otherwise\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<int> lst) {\n    long long sum = 0;\n    for (int num : lst) {\n        if (num > 0 && floor(num) == num && num % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = compare({1,2,3,4,5,1}, {1,2,3,4,2,-2});\n    for (int i : res1) printf(\"%d \", i); // Expected: 0 0 0 0 3 3\n    \n    std::cout << \"\\n\";\n    \n    auto res2 = compare({0,5,0,0,0,4}, {4,1,1,0,0,-2});\n    for (int i : res2) printf(\"%d \", i); // Expected: 4 4 1 0 0 6\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on its name.\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) {\n            uppercase++;\n        } else if (islower(c)) {\n            lowercase++;\n        }\n    }\n    \n    return uppercase - lowercase;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() == 1)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated_a = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return concatenated_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nstd::vector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    std::string str_num = std::to_string(std::abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},  {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},    {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with given examples\nvoid check() {\n    cout << \"19 -> \" << int_to_mini_roman(19) << endl;  // Expected: xix\n    cout << \"152 -> \" << int_to_mini_roman(152) << endl; // Expected: clii\n    cout << \"426 -> \" << int_to_mini_roman(426) << endl; // Expected: cdxxvi\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    float hypotenuse = sides[2]; // The largest value will be at index 2\n\n    // Check if it's a right-angled triangle using Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1]) == (hypotenuse * hypotenuse);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // for std::sort and std::unique\n#include <set>       // to count unique characters\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) return \"\";  // Handle empty vector case\n    \n    auto max_unique_chars = 0;\n    std::string result;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        \n        int current_unique_count = unique_chars.size();\n        \n        if (current_unique_count > max_unique_chars || \n            (current_unique_count == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_count;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total number of carrots to eat after meals\n    int totalToEat = number + need;\n    \n    // If there are enough remaining carrots, calculate the new counts\n    if (remaining >= need) {\n        return {totalToEat, remaining - need};\n    }\n    // Otherwise, eat all remaining carrots and be still hungry\n    else {\n        return {number + remaining, 0};\n    }\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nint do_algebra(const std::vector<std::string>& operators, const std::vector<int>& operands) {\n    // Initialize the expression string with the first operand\n    std::string expression = std::to_string(operands[0]);\n    \n    // Iterate over each operator and append it along with the next operand to the expression\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += \" \" + operators[i] + \" \" + std::to_string(operands[i + 1]);\n    }\n    \n    // Evaluate the constructed algebraic expression using C++'s stringstream and expressions\n    int result;\n    std::istringstream iss(expression);\n    iss >> result;  // Read the first operand\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        char op = operators[i][0];\n        int next_operand;\n        iss >> next_operand;  // Read the next operand\n        \n        switch (op) {\n            case '+':\n                result += next_operand;\n                break;\n            case '-':\n                result -= next_operand;\n                break;\n            case '*':\n                result *= next_operand;\n                break;\n            case '/':  // Note: C++ uses '/' for integer division, not '//'\n                if (next_operand != 0) {\n                    result /= next_operand;\n                } else {\n                    throw std::invalid_argument(\"Division by zero\");\n                }\n                break;\n            case '^':\n                result = static_cast<int>(std::pow(result, next_operand));\n                break;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed\n        for (char &c : s) {\n            if (isLetter(c)) c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function declaration\nchar hex_char(unsigned char c);\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    string md5_string;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        md5_string += hex_char(digest[i] >> 4);\n        md5_string += hex_char(digest[i] & 0x0F);\n    }\n\n    return md5_string;\n}\n\nchar hex_char(unsigned char c) {\n    if (c <= 9)\n        return '0' + c;\n    else\n        return 'a' + (c - 10);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure a is less than or equal to b for simplicity in iteration\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    std::vector<int> even_digits;\n\n    // Iterate through the range from start to end (inclusive)\n    for (int num = start; num <= end; ++num) {\n        // Check if the number is less than 10 and even\n        if (num < 10 && num % 2 == 0) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list and check if any two consecutive elements\n    // are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    stack<char> s;  // Stack to keep track of open parentheses\n    string current_group = \"\";  // Current group being built\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            s.pop();\n            current_group += c;\n\n            // If the stack is empty, a complete group has been formed\n            if (s.empty()) {\n                result.push_back(current_group);\n                current_group = \"\";  // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);  // Get the integer part\n    float decimal_part = number - integer_part;  // Subtract to get the decimal part\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) {\n            return true; // If balance falls below zero, return true\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size.\n    vector<int> result(result_size);\n\n    if (!numbers.empty()) {\n        int pos = 0;\n        \n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result[pos++] = numbers[i];\n            \n            if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n                result[pos++] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes.\nvoid printVector(const vector<int>& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    \n    // Function to calculate depth for a single group of parentheses\n    auto calculate_depth = [](const string& group) -> int {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (max_depth < current_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                --current_depth;\n            }\n        }\n        return max_depth;\n    };\n\n    // Split the input string into groups and calculate depth for each group\n    size_t start = 0, end = paren_string.find(' ');\n    while (end != string::npos) {\n        depths.push_back(calculate_depth(paren_string.substr(start, end - start)));\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Add the last group\n    if (start < paren_string.length()) {\n        depths.push_back(calculate_depth(paren_string.substr(start)));\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    auto result1 = filter_by_substring({}, \"a\");\n    assert(result1.empty());\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    vector<string> expected_result2{\"abc\", \"bacd\", \"vector\"};\n    for (const auto& str : expected_result2) {\n        assert(find(result2.begin(), result2.end(), str) != result2.end());\n    }\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int total_sum = 0;\n    int total_product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int number : numbers) {\n        total_sum += number;\n        total_product *= number;\n    }\n\n    return {total_sum, total_product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n\n    >>> make_palindrome(\"\") \n    \"\" \n\n    >>> make_palindrome(\"cat\") \n    \"catac\" \n\n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    if (str.empty()) {\n        return \"\";\n    }\n\n    for (int i = str.length(); i > 0; --i) {\n        string suffix = str.substr(i - 1);\n        if (is_palindrome(suffix)) {\n            string prefix = str.substr(0, i - 1);\n            return str + string(prefix.rbegin(), prefix.rend());\n        }\n    }\n\n    // If no palindromic suffix is found, the entire input should be reversed and appended\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result.\n\n    // Iterate through each character in the strings and perform XOR operation.\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both characters are the same, append '0' to the result string.\n        } else {\n            result += '1';  // If characters are different, append '1'.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // If current string is longer than the longest found so far\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) {\n        return -1; // or throw an exception/error for invalid input\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\\n\";\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase\n    for (char &ch : str) {\n        ch = std::tolower(ch);\n    }\n\n    // Use a set to store unique characters\n    std::unordered_set<char> unique_chars;\n    \n    // Insert each character into the set\n    for (char ch : str) {\n        unique_chars.insert(ch);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n\nstd::vector<int> parse_music(std::string music_string) {\n    std::vector<int> beats;\n    int i = 0;\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                // Half note\n                beats.push_back(2);\n                i += 2; // Skip the next character as well\n            } else {\n                // Whole note\n                beats.push_back(4);\n                i++;\n            }\n        } else if (i + 1 < music_string.length() && music_string.substr(i, 2) == \".|\") {\n            // Quarter note\n            beats.push_back(1);\n            i += 2; // Skip the next character as well\n        } else {\n            // Handle any unexpected characters or patterns\n            i++;\n        }\n    }\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move past the last found position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping of string representations of numbers to their integer values\n    map<string, int> number_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into individual number words\n    stringstream ss(numbers);\n    vector<int> int_numbers;\n    string word;\n\n    while (ss >> word) {\n        if (number_map.find(word) != number_map.end()) {\n            int_numbers.push_back(number_map[word]);\n        }\n    }\n\n    // Sort the list of integer values\n    sort(int_numbers.begin(), int_numbers.end());\n\n    // Convert the sorted integer values back to their corresponding string representations\n    stringstream sorted_str_numbers;\n    for (int num : int_numbers) {\n        for (const auto& entry : number_map) {\n            if (entry.second == num) {\n                sorted_str_numbers << entry.first << \" \";\n                break;\n            }\n        }\n    }\n\n    // Remove the trailing space and return the result\n    string result = sorted_str_numbers.str();\n    if (!result.empty()) {\n        result.pop_back();  // Remove the last space character\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result(0.0f, 0.0f);\n    \n    // Iterate through the sorted list to find the closest pair of elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result.first = numbers[i];\n            result.second = numbers[i + 1];\n        }\n    }\n    \n    // Return the closest pair of elements\n    return {result.first, result.second};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation: (num - min_val) / (max_val - min_val)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check_function() {\n    list_any test1 = {std::string(\"a\"), 3.14, 5};\n    auto filtered_test1 = filter_integers(test1);\n    for (int num : filtered_test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    list_any test2 = {1, 2, 3, std::string(\"abc\"), {}, {}};\n    auto filtered_test2 = filter_integers(test2);\n    for (int num : filtered_test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint strlen(const std::string& str) {\n    return str.length(); // or str.size()\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle even numbers first.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print the vector of factors for testing purposes.\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << factors[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \" \", \"world\"}) == \"hello world\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and display results\nvoid check(vector<string> input, string prefix) {\n    vector<string> filtered = filter_by_prefix(input, prefix);\n    \n    cout << \"{\";\n    for (size_t i = 0; i < filtered.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << filtered[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to return only positive numbers from the input vector.\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the vector and check if it is positive.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is greater than zero.\n            result.push_back(num);  // Add positive numbers to the result vector.\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of get_positive function.\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    for (float num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 2 5 6\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    for (float num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 5 3 2 3 9 123 1\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by 2 and 3 first, as they are the smallest primes.\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // If divisible by 2 or 3, it's not prime\n    \n    // Check for divisibility from 5 onwards, skipping even numbers.\n    long long i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false; // If divisible by any number in this range, it's not prime\n        i += 6; // Skip even numbers and multiples of 3\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(std::vector<double> xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(std::vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    \n    Example usage:\n    >>> round(find_zero({1.0, 2.0}), 2) // f(x) = 1 + 2x\n    -0.5 \n    >>> round(find_zero({-6.0, 11.0, -6.0, 1.0}), 2) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    */\n    \n    double x = xs[1] / (-xs[0]); // Initial guess for the root\n    \n    while (true) {\n        double p_x = poly(xs, x);\n        \n        if (std::abs(p_x) < 1e-6) {\n            break;\n        }\n        \n        double dp_dx = 0.0; // Derivative of the polynomial\n        for (size_t i = 1; i < xs.size(); ++i) {\n            dp_dx += i * xs[i] * std::pow(x, static_cast<int>(i - 1));\n        }\n        \n        x -= p_x / dp_dx;\n    }\n\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Create a result vector to store the final output\n    std::vector<int> result = l;\n\n    // Iterate through the input list and replace elements at indices divisible by 3 with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            result[i] = divisible_by_three[sorted_index++];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit 7\n                    count++;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract values at even indices (0-based indexing)\n    std::vector<float> even_indices_values;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    std::sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to ensure modifications do not affect the input\n    std::vector<float> result = l;\n\n    // Update even indices with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 1; i < result.size(); i += 2) {\n        if (sorted_index < even_indices_values.size()) {\n            result[i] = even_indices_values[sorted_index++];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached as we always find a result.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <iostream>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Since all cars are moving towards each other and there is no avoidance,\n    // every left-to-right car will eventually collide with a right-to-left car.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &i : l) {  // Iterate through each element and increment it by 1.\n        i += 1;\n    }\n    return l;  // Return the modified vector.\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    for (const int& elem : vec) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        \n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    return false;  // No pairs sum up to zero.\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1 || base >= 10) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    std::string result = \"\";\n    while (x > 0) {\n        // Prepend the remainder to the result string\n        result = std::to_string(x % base) + result;\n        x /= base; // Divide x by base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is (1/2) * base * height\n    return 0.5f * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\n#include <iostream>\n\nint fib4(int n) {\n    if (n == 0 || n == 1) return 0;\n    else if (n == 2) return 2;\n    \n    int a = 0, b = 0, c = 2, d = 0; // Initialize the first four elements of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int temp_d = a + b + c + d; // Calculate the next element in the sequence\n        a = b;                       // Shift values to prepare for the next iteration\n        b = c;\n        c = d;\n        d = temp_d;\n    }\n    return d; // Return the n-th element of the sequence\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    size_t n = l.size();\n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Special case for 2^0 = 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the current result by the base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        int w = ((s[i] + 5 - 'a') % 26) + 'a';\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        int w = ((s[i] - 5 - 'a' + 26) % 26) + 'a';\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Check if the character is not a vowel, considering both lowercase and uppercase.\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n            && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with provided data points.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::sort and std::unique\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from both sorted strings\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters in the string\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // First Fibonacci number\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid check_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will count the number of unmatched '<' characters.\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++; // Increment balance when an opening bracket is found.\n        } else if (c == '>') {\n            balance--; // Decrement balance when a closing bracket is found.\n            \n            // If at any point the balance goes negative, it means there's a closing\n            // bracket without a matching opening one before it.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // At the end of the string, the balance should be zero for all brackets to match correctly.\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() <= 1) return true; // A single element or empty list is trivially monotonic\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are met, the sequence is neither strictly increasing nor decreasing\n        if (increasing && decreasing) return false;\n\n    }\n    \n    return true; // The sequence is either monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    auto last_unique_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_unique_l1, l1.end());\n\n    auto last_unique_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_unique_l2, l2.end());\n\n    // Vector to store common elements\n    vector<int> result;\n\n    // Find and add common elements to the result vector\n    for (int num : l1) {\n        if (find(l2.begin(), l2.end(), num) != l2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << std::endl; // Should print 29\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << std::endl;   // Should print 2\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all opening brackets have been matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first coefficient and goes up to the last but one.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    std::string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert the string to lowercase\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (char ch : lower_s) {\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Special case: treat 'y' as a vowel only if it is at the end of the word\n    if (!lower_s.empty() && lower_s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine number of digits\n    int num_digits = num_str.length();\n    \n    // Handle case where shift is greater than or equal to the number of digits\n    if (shift >= num_digits) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Compute effective shift within the range [0, num_digits)\n    shift %= num_digits;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_digits - shift) + num_str.substr(0, num_digits - shift);\n    \n    return shifted_str;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Split the string into parts based on spaces and commas\n    istringstream iss(s);\n    string part;\n    int num_apples = 0, num_oranges = 0;\n\n    // Extract the number of apples from the string\n    if (iss >> part >> num_apples >> part >> part) {\n        // Extract the number of oranges from the string\n        if (part == \"and\") {\n            iss >> part;\n            part.erase(remove(part.begin(), part.end(), ','), part.end());\n            istringstream(part) >> num_oranges;\n        }\n    }\n\n    // Calculate the number of mangoes by subtracting the number of apples and oranges from the total number of fruits\n    int num_mangoes = n - (num_apples + num_oranges);\n\n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum integer value\n    int minIndex = -1;          // No even number found yet\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is an even number and less than or equal to the current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If it's smaller, or same but with a smaller index\n                minEvenValue = arr[i];                    // Update the smallest even value\n                minIndex = i;                             // Update the index of this value\n            }\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};  // Return an empty vector if no even number was found\n    } else {\n        return {minEvenValue, minIndex}; // Return the smallest even value and its index\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (auto num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that satisfies the condition\n    int max_val = -1; // Initialize with -1 to handle case where no such value exists\n    for (const auto& entry : freq) {\n        if (entry.first <= entry.second && entry.first > max_val) {\n            max_val = entry.first;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return lst; // Return empty vector if input is empty\n    \n    std::sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0, right = lst.size() - 1;\n    while (left <= right) {\n        if (left == right) { // If only one element is remaining\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        result.push_back(lst[left++]); // Add the minimum value and move left pointer to the right\n        result.push_back(lst[right--]); // Add the maximum value and move right pointer to the left\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet in the middle\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return total number of required changes\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> prime_factors;\n\n    // Check divisibility by the smallest primes: 2 and 3\n    for (int div = 2; div <= 3 && a > 1;) {\n        while (a % div == 0) {\n            if (!prime_factors.empty() && prime_factors.back() != div) {\n                prime_factors.push_back(div);\n            }\n            a /= div;\n        }\n        ++div;\n    }\n\n    // Check divisibility by odd numbers up to sqrt(a)\n    for (int i = 5; i * i <= a; i += 2) {\n        if (!is_prime(i)) continue;\n        while (a % i == 0) {\n            if (!prime_factors.empty() && prime_factors.back() != i) {\n                prime_factors.push_back(i);\n            }\n            a /= i;\n        }\n    }\n\n    // Check the remaining value of 'a' for any large prime factor\n    if (a > 1 && is_prime(a)) {\n        prime_factors.push_back(a);\n    }\n\n    return prime_factors.size() == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can be any number to the power of 0.\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is 1, then only x = 1 is a valid simple power\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    // Calculate the logarithm of x to base n.\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value.\n    int exponent = static_cast<int>(log_result);\n    return fabs(log_result - exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double cbrt_a = std::cbrt(a);\n    \n    // Round to the nearest integer\n    int rounded_cbrt_a = static_cast<int>(std::round(cbrt_a));\n    \n    // Check if cubing this rounded value gives back 'a'\n    return (rounded_cbrt_a * rounded_cbrt_a * rounded_cbrt_a == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    // Define which hexadecimal characters are prime numbers.\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit.\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n// Function to test and verify the correctness of the hex_key function.\nvoid check(const std::string& num, int expected) {\n    int result = hex_key(num);\n    if (result == expected)\n        std::cout << \"PASS: For \\\"\" << num << \"\\\", got \" << result << \"\\n\";\n    else\n        std::cout << \"FAIL: For \\\"\" << num << \"\\\", expected \" << expected << \", but got \" << result << \"\\n\";\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal number to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for simplicity\n    string binary = \"\";\n    \n    if (decimal == 0) { // Special case for zero\n        return \"db0db\";\n    }\n    \n    while(decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder to form the binary string\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nbool is_happy(std::string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // If any two out of three consecutive characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f && gpa <= 4.0f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f && gpa <= 3.7f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f && gpa <= 3.3f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f && gpa <= 3.0f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f && gpa <= 2.7f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f && gpa <= 2.3f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f && gpa <= 2.0f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f && gpa <= 1.7f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f && gpa <= 1.3f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f && gpa <= 1.0f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f && gpa < 0.7f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\"); // Invalid GPA\n        }\n    }\n\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    \n    // For a number of length n, there are 9^(n-2) possibilities for the middle digits (if any)\n    int count_middle_digits = pow(9, n - 2);\n    if (n <= 2) {\n        count_middle_digits = 0;\n    }\n\n    // Total count of numbers starting or ending with 1\n    return 2 * static_cast<int>(pow(10, n - 1)) + count_middle_digits - static_cast<int>(pow(10, n - 2));\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Sum all the digits of N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort()\nusing namespace std;\n\n// Function to anti-shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string after sorting each word\n    int n = s.length();\n    \n    for (int i = 0; i < n;) {\n        if (s[i] == ' ') {  // If current character is a space, add it to the result and move to next position\n            result += \" \";\n            ++i;\n        } else {\n            int j = i + 1;\n            \n            // Find the end of the word\n            while (j < n && s[j] != ' ') {\n                ++j;\n            }\n            \n            // Sort characters in this word\n            string temp = s.substr(i, j - i);\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n            \n            // Move to the next word\n            i = j;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing 'Hi': \" << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'hello': \" << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'Hello World!!!': \" << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for coordinate initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Comparator function to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col;  // Descending order for columns\n        else\n            return row < other.row;  // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through the list to find all occurrences of x and record their positions.\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x)\n                coordinates.push_back(Coordinate(row, col));\n        }\n    }\n\n    // Sort the coordinates as per the given criteria.\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> and return\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty or has only one element, return it as is.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n    \n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = tolower(c); // Convert to lowercase for simplicity\n            \n            size_t pos = ALPHABET.find(lower_c); // Find position of the letter in the alphabet\n            if (pos != std::string::npos) {\n                size_t new_pos = (pos + shift) % 26; // Calculate new position with wrapping around\n                char encrypted_char = ALPHABET[new_pos]; // Get the corresponding character\n                \n                // Preserve original case\n                c = isupper(c) ? toupper(encrypted_char) : encrypted_char;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n// Function to find the second smallest element in a vector.\nint next_smallest(vector<int> lst) {\n    // Check if there are fewer than 2 elements in the vector.\n    if (lst.size() < 2) {\n        return -1; // Indicate no valid result\n    }\n\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // Check if there are at least two unique elements in the vector.\n    if (unique_elements.size() < 2) {\n        return -1; // Indicate no valid result\n    }\n\n    auto it = unique_elements.begin();\n    advance(it, 1); // Move to the second element\n\n    return *it;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string word;\n    bool new_sentence = true; // Indicates if we are at the start of a sentence\n\n    for (char c : S) {\n        if (c == ' ') {\n            continue;\n        }\n\n        if (new_sentence && word == \"I\") {\n            boredom_count++;\n        }\n        \n        if (c == '.' || c == '?' || c == '!') {\n            new_sentence = true; // New sentence starts after a delimiter\n        } else {\n            new_sentence = false; // Inside the current sentence\n        }\n\n        if (c != ' ') {\n            word += c;\n        } else {\n            new_sentence = false; // Reset to false when encountering space\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them to their integer conversion\n    if (static_cast<int>(a) != a || static_cast<int>(b) != b || static_cast<int>(c) != c) {\n        return false;\n    }\n    \n    // Convert floats to integers for comparison\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else return tolower(c);\n}\n\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::map<char, char> shifted_vowels = {{'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n                                            {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n    std::string encoded_message = \"\";\n\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char new_char = swapCase(c);\n            \n            // Shift vowels by 2 places ahead\n            if (vowels.find(new_char) != std::string::npos) {\n                new_char = shifted_vowels[new_char];\n            }\n            \n            encoded_message += new_char;\n        } else {\n            encoded_message += c;\n        }\n    }\n\n    return encoded_message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds and returns the sum of digits of the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime number\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    return digitSum(maxPrime); // Return the sum of digits of the largest prime\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Determine case consistency\n        if (!isLowercase(key)) allLowercase = false;\n        if (!isUppercase(key)) allUppercase = false;\n\n        // If both flags are already false, no need to continue checking\n        if (!allLowercase && !allUppercase) break;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count up to n and return prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the last digit of both numbers by taking modulo 10\n    int last_digit_a = abs(a % 10);\n    int last_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return last_digit_a * last_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5)\n        return static_cast<int>(ceil(num));\n    else if (num < 0 && ceil(num) - num == 0.5)\n        return static_cast<int>(floor(num));\n\n    return static_cast<int>(round(num)); // Standard rounding\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;  // Start with 'n' stones for the first level.\n    \n    // Add the number of stones for each level to the vector.\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine if we need an odd or even next number based on whether 'n' is odd/even.\n        int increment = (n % 2 == 1) ? 2 : 2;\n        current_stones += increment;  // Increment by 2 to get the next odd/even number.\n    }\n    \n    return pile;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i = 0; i < result.size(); ++i) {\n        printf(\"%d \", result[i]);\n    }\n    // Expected output: 3 5 7\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result and reset it\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop (in case there's no trailing comma or space)\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for (const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) return -1;\n    \n    // Adjust y to be the largest even number in the range [x, y]\n    if (y % 2 != 0) { \n        y--; // If y is odd, decrement it by 1 to make it even.\n    }\n    \n    // Check if the adjusted y is still within or equal to x\n    if (y >= x) {\n        return y;\n    } else {\n        return -1; // No even number in range [x, y]\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Main function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round it down\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number has any even digit\nbool has_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false\n        n /= 10; // Move to the next digit\n    }\n    return true; // All digits are odd\n}\n\n// Function to filter and sort numbers with only odd digits\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test and print results\nvoid test() {\n    std::vector<int> example1 = {15, 33, 1422, 1};\n    std::vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(example1) == expected1);\n\n    std::vector<int> example2 = {152, 323, 1422, 10};\n    std::vector<int> expected2;\n    assert(unique_digits(example2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Map to store digit names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Filter and sort the array\n    std::vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n\n    std::sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted vector\n    std::reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert digits to their corresponding names\n    std::vector<std::string> result;\n    for (int num : filtered_sorted) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(factorial(i));\n        } else {\n            result.push_back(sum_to_i(i));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a given integer is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function to verify correctness.\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\n// Helper function to compute the sum of signed digits of a number\nint sum_of_digits(int num) {\n    if (num == 0)\n        return 0;\n    \n    std::string str_num = std::to_string(num);\n    int sum = 0;\n\n    for (size_t i = 0; i < str_num.size(); ++i) {\n        char digit_char = str_num[i];\n        int digit = (digit_char == '-') ? -1 : (digit_char - '0');\n        \n        if (num < 0 && i == 0)\n            sum += -digit;\n        else\n            sum += digit;\n    }\n\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (int number : n) {\n        if (sum_of_digits(number) > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int n = arr.size();\n    int start_index = -1;  // Initialize to a value that indicates no break point found\n    \n    // Find the index where the sequence breaks from being non-decreasing\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            start_index = (i + 1) % n;\n            break;\n        }\n    }\n\n    // If no break point is found, the array is already sorted\n    if (start_index == -1) {\n        return true;\n    }\n    \n    // Verify that rotating from this index results in a non-decreasing order\n    for (int j = 0; j < n - 1; ++j) {\n        if (arr[(start_index + j) % n] > arr[(start_index + j + 1) % n]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in the vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (const auto& num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check if there are enough even numbers in the second list\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (const auto& num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n        if (evens >= requiredCount) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = countOdd(lst1);\n    \n    // If there are no odd numbers in lst1, it's already possible\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n    \n    // Check if lst2 has enough even numbers to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to find the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n\n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output string based on the count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For std::ceil\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    // Iterate through each well (row)\n    for(const auto& row : grid) {\n        int water_units = 0; // Total units of water in the current well\n        \n        // Sum up all 1s in the current well\n        for(int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times a bucket needs to be lowered for this well\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of ones in the binary representation of an integer.\nint count_ones(int n) {\n    if (n >= 0) {\n        return __builtin_popcount(n);\n    } else {\n        // For negative numbers, use two's complement representation\n        return __builtin_popcount(-(n + 1));\n    }\n}\n\n// Custom comparator function for sorting based on the number of ones in binary representation and decimal value.\nbool custom_compare(int a, int b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n\n    if (count_a == count_b) {\n        return a < b;\n    }\n    return count_a < count_b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the vector using the custom comparator\n    std::sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from second last character to first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the current character is a vowel and both surrounding characters are consonants\n        if (is_vowel(middle_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, middle_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first = lst[0];\n    string second = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(first + second)) {\n        return \"Yes\";\n    } else if (is_balanced(second + first)) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements from the sorted vector\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the extracted elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if index is even and value at that index is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n\n    // Add the last number, which is always 1 and odd\n    odds.push_back(1);\n\n    // Sort the vector of odd numbers in increasing order\n    sort(odds.begin(), odds.end());\n\n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Find positions of '-' characters to split the date into components\n    size_t pos1 = date.find('-');\n    size_t pos2 = date.find('-', pos1 + 1);\n    \n    // Ensure there are exactly two '-' in the correct format\n    if (pos1 == string::npos || pos2 == string::npos) return false;\n    \n    // Extract month, day, and year from the string\n    int month = stoi(date.substr(0, pos1));\n    int day = stoi(date.substr(pos1 + 1, pos2 - pos1 - 1));\n    int year = stoi(date.substr(pos2 + 1));\n\n    // Validate month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate day range based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 2 && (day < 1 || day > 29))) {\n        return false;\n    } else if ((day < 1 || day > 31)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character has an odd order in the alphabet\nbool is_odd_order(char c) {\n    // Convert lowercase letter to its position in the alphabet (0 for 'a', 1 for 'b', etc.)\n    int pos = c - 'a';\n    return pos % 2 == 1;\n}\n\n// Function to count the number of characters with odd order\nint count_odd_order(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c) && is_odd_order(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on whitespace\n        size_t start = 0, end;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } else {\n        // Check for commas if no whitespace was found\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            size_t start = 0, end;\n            while ((end = txt.find(',', start)) != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n            }\n            result.push_back(txt.substr(start)); // Add the last part\n        } else {\n            // No whitespace or commas found, count odd order letters\n            int count = count_odd_order(txt);\n            result.push_back(to_string(count));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of the frequency of each number\n\n    for(int i = 0; i < lst.size(); ++i){\n        // Check ascending order\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n\n        // Count occurrences of each element\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if(countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;    \n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    int max_start = max(start1, start2);\n    int min_end = min(end1, end2);\n\n    if (max_start > min_end) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = min_end - max_start + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitude = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Calculate the magnitude\n        sum_magnitude += std::abs(num);\n\n        // Determine the sign and update the product of signs\n        if (num == 0) return 0; // Any number multiplied by zero is zero\n        else if (num > 0) continue; // Positive numbers don't change the product_of_signs\n        else product_of_signs *= -1; // Negative numbers flip the sign\n\n    }\n\n    // Return the final result: sum of magnitudes * product of signs\n    return sum_magnitude * product_of_signs;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Forward declaration of minPath to avoid compilation issues in main()\nvector<int> minPath(vector<vector<int>> grid, int k);\n\nstruct Path {\n    vector<int> values;\n    int steps;\n    int x, y;\n    \n    bool operator<(const Path& other) const {\n        return values > other.values; // Min-heap based on lexicographical order of paths.\n    }\n};\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    \n    // Initialize a priority queue with all possible starting positions.\n    priority_queue<Path> pq;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            Path path = {{grid[i][j]}, 1, i, j};\n            pq.push(path);\n        }\n    }\n\n    // Directions for moving to adjacent cells.\n    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    while (!pq.empty()) {\n        Path path = pq.top();\n        pq.pop();\n\n        if (path.steps == k) {\n            return path.values;\n        }\n\n        for (const auto& dir : directions) {\n            int nx = path.x + dir.first;\n            int ny = path.y + dir.second;\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                Path new_path = {path.values, path.steps + 1, nx, ny};\n                new_path.values.push_back(grid[nx][ny]);\n                pq.push(new_path);\n            }\n        }\n    }\n\n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0)\n        return {};\n\n    vector<int> sequence = {1};  // Initialize with the base case for tri(1)\n    \n    if (n >= 1)\n        sequence.push_back(3);  // Add tri(1)\n\n    for (int i = 2; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + (i / 2);\n        } else {\n            while ((int)sequence.size() <= i)\n                sequence.push_back(3);  // Ensure the value at index i is set\n            next_value = sequence[i - 1] + sequence[i - 2] + sequence[i];\n        }\n        \n        if (i < n || sequence.size() <= i)\n            sequence.push_back(next_value);\n    }\n\n    return sequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets;\n    bool has_nested = false;\n\n    for (char bracket : str) {\n        if (bracket == '[') {\n            brackets.push(bracket);\n        } else if (bracket == ']') {\n            if (!brackets.empty() && !has_nested && brackets.size() > 1) {\n                has_nested = true;\n            }\n            if (!brackets.empty()) {\n                brackets.pop();\n            } else {\n                // If stack is empty but we encounter a closing bracket, return false\n                return false;\n            }\n        }\n    }\n\n    // Ensure the stack is empty and there was at least one nested structure\n    return has_nested && brackets.empty();\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number to the nearest upper integer\n        float ceiling_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += pow(ceiling_num, 2);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype>  // For isspace() function\n\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Strip trailing spaces\n    size_t last_non_space_pos = txt.find_last_not_of(' ');\n    std::string stripped_txt = txt.substr(0, last_non_space_pos + 1);\n\n    char last_char = stripped_txt.back();\n\n    // Check if the last character is an alphabetical character\n    bool is_alpha = std::isalpha(static_cast<unsigned char>(last_char));\n\n    // Check if there is a space before the last character in the original string\n    bool has_space_before_last_char = (txt.find(' ', txt.length() - stripped_txt.length() - 1) != std::string::npos);\n\n    return is_alpha && !has_space_before_last_char;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to convert a string with comma as decimal separator to float\nfloat string_to_float(const std::string& str) {\n    size_t pos = str.find(',');\n    if (pos != std::string::npos) {\n        return std::stof(str.substr(0, pos) + \".\" + str.substr(pos + 1));\n    }\n    return std::stof(str);\n}\n\n// Function to compare two boost::any values\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both inputs are of the same type and handle accordingly\n    if (a.type() == typeid(int)) {\n        int val_a = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int val_b = boost::any_cast<int>(b);\n            return val_a > val_b ? val_a : val_b;\n        } else if (b.type() == typeid(float)) {\n            float val_b = boost::any_cast<float>(b);\n            return static_cast<float>(val_a) > val_b ? static_cast<float>(val_a) : val_b;\n        }\n    } else if (a.type() == typeid(float)) {\n        float val_a = boost::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int val_b = boost::any_cast<int>(b);\n            return val_a > static_cast<float>(val_b) ? val_a : static_cast<float>(val_b);\n        } else if (b.type() == typeid(float)) {\n            float val_b = boost::any_cast<float>(b);\n            return val_a > val_b ? val_a : val_b;\n        }\n    }\n\n    // If types are different or not handled above, return a default value\n    return std::string(\"None\");\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute the Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply the current factorial value with the result\n    }\n    return result;\n}\n\n// Function to test the correctness of the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << endl; // Output should be 288\n    cout << \"special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << endl; // Output should be 34560\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*(txt|exe|dll)$)\");\n\n    if (std::regex_match(file_name, pattern) && std::count(file_name.begin(), file_name.end(), '.') == 1) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n#include <algorithm>\n\nint sum_squares(const std::vector<int>& lst) {\n    int result = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            result += lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) {\n        // Check if the length of the current word is a prime number\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a string fraction into numerator and denominator integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    int numX, denX;\n    parseFraction(x, numX, denX);\n\n    int numN, denN;\n    parseFraction(n, numN, denN);\n\n    // Compute the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the result\n    int prodDen = denX * denN;  // Denominator of the result\n\n    // Simplify the fraction by dividing numerator and denominator with their GCD\n    int commonDivisor = gcd(prodNum, prodDen);\n    prodNum /= commonDivisor;\n    prodDen /= commonDivisor;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1)\n    return prodDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint sum_of_digits(int num) {\n    int digit_sum = 0;\n    bool is_negative = false;\n\n    if (num < 0) {\n        is_negative = true;\n        num = -num; // Make num positive for processing\n    }\n\n    while (num > 0) {\n        digit_sum += abs(num % 10); // Add the last digit to the sum\n        num /= 10; // Remove the last digit\n    }\n\n    if (is_negative && digit_sum != 0) {\n        digit_sum = -digit_sum + (abs(num % 10)); // Adjust for negative first digit\n    }\n    \n    return digit_sum;\n}\n\n// Custom comparator function to sort based on sum of digits and original index.\nbool custom_compare(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (a.first == b.first) {\n        return a.second < b.second; // If sums are equal, compare by original index\n    }\n    return a.first < b.first; // Otherwise, compare by sum of digits\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    int n = nums.size();\n    \n    // Create pairs of (sum_of_digits, original_index)\n    vector<pair<int, int>> indexed_nums(n);\n    for (int i = 0; i < n; ++i) {\n        indexed_nums[i] = {sum_of_digits(nums[i]), i};\n    }\n\n    // Sort the indexed list using custom comparator\n    sort(indexed_nums.begin(), indexed_nums.end(), custom_compare);\n\n    // Extract sorted integers from pairs and return them\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(nums[indexed_nums[i].second]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || \n                       firstDigit == '5' || firstDigit == '7' ||\n                       firstDigit == '9');\n    \n    bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || \n                      lastDigit == '5' || lastDigit == '7' ||\n                      lastDigit == '9');\n    \n    return isFirstOdd && isLastOdd;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula i * i - i + 1\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    bool valid_planet1 = false, valid_planet2 = false;\n\n    // Find the indices of planet1 and planet2 in the planets vector.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            valid_planet1 = true;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n            valid_planet2 = true;\n        }\n\n        // If both planets are found, break the loop.\n        if (valid_planet1 && valid_planet2)\n            break;\n    }\n\n    // Return an empty vector if either planet is not a valid name.\n    if (!valid_planet1 || !valid_planet2) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order of planets between them.\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    \n    // Collect all planets that are located between planet1 and planet2.\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test_bf() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort strings first by length and then lexicographically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;  // Alphabetical order for same lengths\n    }\n    return a.length() < b.length();  // Length-based sorting\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {  // Check even length\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    // Check if n is a prime number using the helper function\n    if (is_prime(n)) {\n        return x;  // Return x if n is prime\n    } else {\n        return y;  // Return y otherwise\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        if (num > 0 && std::floor(num) == num) { // Check if number is positive and an integer\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) { // Check if the number is odd\n                sum_of_squares += n * n;\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = compare({1,2,3,4,5,1}, {1,2,3,4,2,-2});\n    for (int i : res1) printf(\"%d \", i); // Expected: 0 0 0 0 3 3\n    \n    std::cout << \"\\n\";\n    \n    auto res2 = compare({0,5,0,0,0,4}, {4,1,1,0,0,-2});\n    for (int i : res2) printf(\"%d \", i); // Expected: 4 4 1 0 0 6\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on its name.\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) {\n            uppercase++;\n        } else if (islower(c)) {\n            lowercase++;\n        }\n    }\n    \n    return uppercase - lowercase;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() == 1)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated_a = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return concatenated_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> even_odd_count(int num) {\n    // Handle negative numbers by converting to positive\n    if (num < 0) {\n        num = -num;\n    }\n\n    int even_count = 0;\n    int odd_count = 0;\n\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},  {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},    {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with given examples\nvoid check() {\n    cout << \"19 -> \" << int_to_mini_roman(19) << endl;  // Expected: xix\n    cout << \"152 -> \" << int_to_mini_roman(152) << endl; // Expected: clii\n    cout << \"426 -> \" << int_to_mini_roman(426) << endl; // Expected: cdxxvi\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    float hypotenuse = sides[2]; // The largest value will be at index 2\n\n    // Check if it's a right-angled triangle using Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1]) == (hypotenuse * hypotenuse);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // for std::sort and std::unique\n#include <set>       // to count unique characters\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) return \"\";  // Handle empty vector case\n    \n    auto max_unique_chars = 0;\n    std::string result;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        \n        int current_unique_count = unique_chars.size();\n        \n        if (current_unique_count > max_unique_chars || \n            (current_unique_count == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_count;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total number of carrots to eat after meals\n    int totalToEat = number + need;\n    \n    // If there are enough remaining carrots, calculate the new counts\n    if (remaining >= need) {\n        return {totalToEat, remaining - need};\n    }\n    // Otherwise, eat all remaining carrots and be still hungry\n    else {\n        return {number + remaining, 0};\n    }\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    std::stringstream expression;\n    \n    // Construct the algebraic expression as a string\n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (i > 0) {\n            expression << \" \";\n        }\n        expression << operands[i];\n        \n        if (i < operators.size()) {\n            expression << \" \" << operators[i] << \" \";\n        }\n    }\n    \n    // Append the last operand\n    expression << operands[operands.size() - 1];\n\n    // Evaluate the constructed expression\n    std::stringstream ss;\n    ss << expression.rdbuf();\n    int result = 0;\n    ss >> result;\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed\n        for (char &c : s) {\n            if (isLetter(c)) c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function to convert a byte array to a hexadecimal string\nstring bytes_to_hex(const unsigned char* data, size_t len) {\n    static const char hex_chars[] = \"0123456789abcdef\";\n    string hex_str;\n    for (size_t i = 0; i < len; ++i) {\n        hex_str += hex_chars[data[i] >> 4];\n        hex_str += hex_chars[data[i] & 0x0F];\n    }\n    return hex_str;\n}\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&hash);\n\n    // Convert the byte array to a hexadecimal string\n    return bytes_to_hex(hash, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure a is less than or equal to b for simplicity in iteration\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    std::vector<int> even_digits;\n\n    // Iterate through the range from start to end + 1 (inclusive)\n    for (int num = start; num <= end; ++num) {\n        if (num < 10 && num % 2 == 0) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list and check if any two consecutive elements\n    // are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group = \"\";\n    int balance = 0; // Stack is replaced with a balance counter\n\n    for (char& ch : paren_string) {\n        if (ch == ' ') continue; // Ignore spaces\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) { // A complete group is found when balance is zero\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);  // Get the integer part\n    float decimal_part = number - integer_part;  // Subtract to get the decimal part\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) {\n            return true; // If balance falls below zero, return true\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size.\n    vector<int> result(result_size);\n\n    if (!numbers.empty()) {\n        int pos = 0;\n        \n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result[pos++] = numbers[i];\n            \n            if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n                result[pos++] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes.\nvoid printVector(const vector<int>& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    \n    // Function to calculate depth for a single group of parentheses\n    auto calculate_depth = [](const string& group) -> int {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (max_depth < current_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                --current_depth;\n            }\n        }\n        return max_depth;\n    };\n\n    // Split the input string into groups and calculate depth for each group\n    size_t start = 0, end = paren_string.find(' ');\n    while (end != string::npos) {\n        depths.push_back(calculate_depth(paren_string.substr(start, end - start)));\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Add the last group\n    if (start < paren_string.length()) {\n        depths.push_back(calculate_depth(paren_string.substr(start)));\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    auto result1 = filter_by_substring({}, \"a\");\n    assert(result1.empty());\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    vector<string> expected_result2{\"abc\", \"bacd\", \"vector\"};\n    for (const auto& str : expected_result2) {\n        assert(find(result2.begin(), result2.end(), str) != result2.end());\n    }\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int total_sum = 0;\n    int total_product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Iterate through each number in the vector and update sum and product\n    for (int number : numbers) {\n        total_sum += number;\n        total_product *= number;\n    }\n\n    // Return a vector containing the sum and product\n    return {total_sum, total_product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str_input) {\n    if (str_input.empty()) {\n        return \"\";\n    }\n\n    string prefix;\n    for (int i = 0; i <= str_input.length(); ++i) {\n        if (is_palindrome(str_input.substr(i))) {\n            prefix = str_input.substr(0, i);\n            break;\n        }\n    }\n\n    // Append the reverse of the non-palindromic prefix to make it a palindrome\n    return str_input + string(prefix.rbegin(), prefix.rend());\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result.\n\n    // Iterate through each character in the strings and perform XOR operation.\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both characters are the same, append '0' to the result string.\n        } else {\n            result += '1';  // If characters are different, append '1'.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // If current string is longer than the longest found so far\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) {\n        return -1; // or throw an exception/error for invalid input\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\\n\";\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase\n    for (char &ch : str) {\n        ch = std::tolower(ch);\n    }\n\n    // Use a set to store unique characters\n    std::unordered_set<char> unique_chars;\n    \n    // Insert each character into the set\n    for (char ch : str) {\n        unique_chars.insert(ch);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    // Dictionary for note mapping\n    unordered_map<string, int> notes = {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n    \n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if (music_string.substr(i, 3) == \"o|\" || music_string.substr(i, 3) == \".|\") {\n            string note = music_string.substr(i, 3);\n            beats.push_back(notes[note]);\n            i += 3;\n        } else if (music_string[i] == 'o') {\n            beats.push_back(4);\n            i += 1;\n        } else {\n            i += 1; // Skip unrecognized characters\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move past the last found position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <map>\n\nstd::string sort_numbers(std::string numbers) {\n    // Mapping from string representation of numbers to their integer values\n    std::map<std::string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into individual number words\n    std::istringstream iss(numbers);\n    std::vector<std::string> num_words;\n    std::string word;\n\n    while (iss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Convert the list of number words to integers and sort them\n    std::vector<int> num_list;\n    for (const auto& w : num_words) {\n        num_list.push_back(num_map[w]);\n    }\n    std::sort(num_list.begin(), num_list.end());\n\n    // Convert the sorted integer list back to a list of strings\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        auto it = num_map.begin();\n        while (it->second != num_list[i]) {\n            ++it;\n        }\n        oss << it->first;\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result;\n    \n    // Iterate through the sorted list to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result.first = numbers[i];\n            result.second = numbers[i + 1];\n        }\n    }\n    \n    // Return the closest pair in ascending order\n    return {result.first, result.second};\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation: (num - min_val) / (max_val - min_val)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check_function() {\n    list_any test1 = {std::string(\"a\"), 3.14, 5};\n    auto filtered_test1 = filter_integers(test1);\n    for (int num : filtered_test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    list_any test2 = {1, 2, 3, std::string(\"abc\"), {}, {}};\n    auto filtered_test2 = filter_integers(test2);\n    for (int num : filtered_test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint strlen(const std::string& str) {\n    return str.length(); // or str.size()\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle even numbers first.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print the vector of factors for testing purposes.\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << factors[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \" \", \"world\"}) == \"hello world\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and display results\nvoid check(vector<string> input, string prefix) {\n    vector<string> filtered = filter_by_prefix(input, prefix);\n    \n    cout << \"{\";\n    for (size_t i = 0; i < filtered.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << filtered[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to return only positive numbers from the input vector.\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the vector and check if it is positive.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is greater than zero.\n            result.push_back(num);  // Add positive numbers to the result vector.\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of get_positive function.\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    for (float num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 2 5 6\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    for (float num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 5 3 2 3 9 123 1\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by 2 and 3 first, as they are the smallest primes.\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // If divisible by 2 or 3, it's not prime\n    \n    // Check for divisibility from 5 onwards, skipping even numbers.\n    long long i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false; // If divisible by any number in this range, it's not prime\n        i += 6; // Skip even numbers and multiples of 3\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    \n    Examples:\n    >>> std::round(find_zero({1.0, 2.0}), 2); // f(x) = 1 + 2x\n    -0.5 \n    >>> std::round(find_zero({-6.0, 11.0, -6.0, 1.0}), 2); // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    double a = -1000.0;\n    double b = 1000.0;\n    const double tol = 1e-9;\n\n    while (b - a > tol) {\n        double fa = poly(xs, a);\n        double fb = poly(xs, b);\n\n        if (fa * fb >= 0) {\n            throw std::runtime_error(\"No root found in the interval\");\n        }\n\n        double c = (a + b) / 2.0;\n        double fc = poly(xs, c);\n\n        if (std::abs(fc) < tol) {\n            return c;\n        } else if (fa * fc < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n    }\n\n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices_elements.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(third_indices_elements.begin(), third_indices_elements.end());\n\n    // Create a new list to store the result\n    vector<int> l_prime = l;\n\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            // Replace elements at indices divisible by 3 with sorted values\n            l_prime[i] = third_indices_elements[sorted_index];\n            sorted_index++;\n        }\n    }\n\n    return l_prime;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> input1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(input1) == expected1);\n\n    vector<int> input2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(input2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit 7\n                    count++;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract values at even indices (0-based indexing)\n    std::vector<float> even_indices_values;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    std::sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to modify\n    std::vector<float> result = l;\n\n    // Replace even indices with sorted values\n    size_t j = 0;\n    for (size_t i = 1; i < result.size(); i += 2) {\n        if (j < even_indices_values.size()) {\n            result[i] = even_indices_values[j];\n            ++j;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached as we always find a result.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <iostream>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Since all cars are moving at a constant speed and start far apart,\n    // each left-to-right car will eventually collide with exactly one right-to-left car.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &i : l) {  // Iterate through each element and increment it by 1.\n        i += 1;\n    }\n    return l;  // Return the modified vector.\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    for (const int& elem : vec) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        \n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    return false;  // No pairs sum up to zero.\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1 || base >= 10) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    std::string result = \"\";\n    while (x > 0) {\n        // Prepend the remainder to the result string\n        result = std::to_string(x % base) + result;\n        x /= base; // Divide x by base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is (1/2) * base * height\n    return 0.5f * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Iterate from n=4 to n\n    for (int i = 4; i <= n; ++i) {\n        int next_value = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_value;\n    }\n\n    return d;\n}\n\n// Function to test the fib4 function\nvoid check_fib4() {\n    cout << \"fib4(5) = \" << fib4(5) << endl; // Expected: 4\n    cout << \"fib4(6) = \" << fib4(6) << endl; // Expected: 8\n    cout << \"fib4(7) = \" << fib4(7) << endl; // Expected: 14\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    size_t n = l.size();\n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Special case for 2^0 = 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the current result by the base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if ('a' <= c && c <= 'z') { // lowercase letters\n            int w = ((c - 'a' + 5) % 26) + 'a';\n            out += (char)w;\n        } else if ('A' <= c && c <= 'Z') { // uppercase letters\n            int w = ((c - 'A' + 5) % 26) + 'A';\n            out += (char)w;\n        } else {\n            out += c; // non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if ('a' <= c && c <= 'z') { // lowercase letters\n            int w = ((c - 'a' - 5 + 26) % 26) + 'a'; // ensure positive modulo\n            out += (char)w;\n        } else if ('A' <= c && c <= 'Z') { // uppercase letters\n            int w = ((c - 'A' - 5 + 26) % 26) + 'A'; // ensure positive modulo\n            out += (char)w;\n        } else {\n            out += c; // non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Check if the character is not a vowel, considering both lowercase and uppercase.\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n            && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with provided data points.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::sort and std::unique\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from both sorted strings\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters in the string\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // First Fibonacci number\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid check_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will count the number of unmatched '<' characters.\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++; // Increment balance when an opening bracket is found.\n        } else if (c == '>') {\n            balance--; // Decrement balance when a closing bracket is found.\n            \n            // If at any point the balance goes negative, it means there's a closing\n            // bracket without a matching opening one before it.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // At the end of the string, the balance should be zero for all brackets to match correctly.\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() <= 1) return true; // A single element or empty list is trivially monotonic\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are met, the sequence is neither strictly increasing nor decreasing\n        if (increasing && decreasing) return false;\n\n    }\n    \n    return true; // The sequence is either monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    auto last_unique_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_unique_l1, l1.end());\n\n    auto last_unique_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_unique_l2, l2.end());\n\n    // Vector to store common elements\n    vector<int> result;\n\n    // Find and add common elements to the result vector\n    for (int num : l1) {\n        if (find(l2.begin(), l2.end(), num) != l2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << std::endl; // Should print 29\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << std::endl;   // Should print 2\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all opening brackets have been matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first coefficient and goes up to the last but one.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    std::string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert the string to lowercase\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (char ch : lower_s) {\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Special case: treat 'y' as a vowel only if it is at the end of the word\n    if (!lower_s.empty() && lower_s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine number of digits\n    int num_digits = num_str.length();\n    \n    // Handle case where shift is greater than or equal to the number of digits\n    if (shift >= num_digits) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Compute effective shift within the range [0, num_digits)\n    shift %= num_digits;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_digits - shift) + num_str.substr(0, num_digits - shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nint fruit_distribution(std::string s, int n) {\n    // Split the string into parts based on spaces and commas\n    std::istringstream iss(s);\n    std::string part;\n    int num_apples = 0, num_oranges = 0;\n\n    // Extract the number of apples\n    if (iss >> part >> part >> num_apples) {\n        // Skip \"and\"\n        iss.ignore();\n        // Extract the number of oranges\n        if (iss >> part >> num_oranges) {\n            // Calculate the number of mangoes by subtracting the total number of apples and oranges from n\n            int num_mangoes = n - (num_apples + num_oranges);\n            return num_mangoes;\n        }\n    }\n\n    // If parsing fails, return a default value or handle error appropriately\n    return -1;  // Return an error code if the string format is incorrect\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum integer value\n    int minIndex = -1;          // No even number found yet\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is an even number and less than or equal to the current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If it's smaller, or same but with a smaller index\n                minEvenValue = arr[i];                    // Update the smallest even value\n                minIndex = i;                             // Update the index of this value\n            }\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};  // Return an empty vector if no even number was found\n    } else {\n        return {minEvenValue, minIndex}; // Return the smallest even value and its index\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (auto num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that satisfies the condition\n    int max_val = -1; // Initialize with -1 to handle case where no such value exists\n    for (const auto& entry : freq) {\n        if (entry.first <= entry.second && entry.first > max_val) {\n            max_val = entry.first;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return lst; // Return empty vector if input is empty\n    \n    std::sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0, right = lst.size() - 1;\n    while (left <= right) {\n        if (left == right) { // If only one element is remaining\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        result.push_back(lst[left++]); // Add the minimum value and move left pointer to the right\n        result.push_back(lst[right--]); // Add the maximum value and move right pointer to the left\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet in the middle\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return total number of required changes\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> prime_factors;\n\n    // Check divisibility by small primes: 2 and 3\n    for (int p = 2; p <= 3 && a > 1;) {\n        while (a % p == 0) {\n            if (!prime_factors.empty() && prime_factors.back() != p) {\n                prime_factors.push_back(p);\n            }\n            a /= p;\n        }\n        ++p;\n    }\n\n    // Check divisibility by primes from 5 to 97\n    for (int i = 5; i * i <= a; i += 2) {\n        if (is_prime(i) && a % i == 0) {\n            prime_factors.push_back(i);\n            while (a % i == 0) {\n                a /= i;\n            }\n        }\n    }\n\n    // Check for remaining large primes\n    for (int i = 5; i <= 97; ++i) {\n        if (is_prime(i) && a % i == 0) {\n            prime_factors.push_back(i);\n            while (a % i == 0) {\n                a /= i;\n            }\n        }\n    }\n\n    // Check if exactly three distinct prime factors are found and no further division is possible\n    return prime_factors.size() == 1 && a > 1 ? false : prime_factors.size() == 3 && a == 1;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can be any number to the power of 0.\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is 1, then only x = 1 is a valid simple power\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    // Calculate the logarithm of x to base n.\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value.\n    int exponent = static_cast<int>(log_result);\n    return fabs(log_result - exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double cbrt_a = std::cbrt(a);\n    \n    // Round to the nearest integer\n    int rounded_cbrt_a = static_cast<int>(std::round(cbrt_a));\n    \n    // Check if cubing this rounded value gives back 'a'\n    return (rounded_cbrt_a * rounded_cbrt_a * rounded_cbrt_a == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    // Define which hexadecimal characters are prime numbers.\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit.\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n// Function to test and verify the correctness of the hex_key function.\nvoid check(const std::string& num, int expected) {\n    int result = hex_key(num);\n    if (result == expected)\n        std::cout << \"PASS: For \\\"\" << num << \"\\\", got \" << result << \"\\n\";\n    else\n        std::cout << \"FAIL: For \\\"\" << num << \"\\\", expected \" << expected << \", but got \" << result << \"\\n\";\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal number to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for simplicity\n    string binary = \"\";\n    \n    if (decimal == 0) { // Special case for zero\n        return \"db0db\";\n    }\n    \n    while(decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder to form the binary string\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nbool is_happy(std::string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // If any two out of three consecutive characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f && gpa <= 4.0f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f && gpa <= 3.7f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f && gpa <= 3.3f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f && gpa <= 3.0f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f && gpa <= 2.7f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f && gpa <= 2.3f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f && gpa <= 2.0f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f && gpa <= 1.7f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f && gpa <= 1.3f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f && gpa <= 1.0f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f && gpa <= 0.7f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\"); // For invalid GPAs below zero\n        }\n    }\n\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    \n    // Calculate the number of possibilities for the middle digits.\n    int count_middle_digits = std::pow(9, n - 2);\n    \n    // Total count is twice this number minus one to avoid double counting those that start and end with 1.\n    int total_count = 2 * count_middle_digits + 1;\n    \n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Sum all the digits of N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort()\nusing namespace std;\n\n// Function to anti-shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string after sorting each word\n    int n = s.length();\n    \n    for (int i = 0; i < n;) {\n        if (s[i] == ' ') {  // If current character is a space, add it to the result and move to next position\n            result += \" \";\n            ++i;\n        } else {\n            int j = i + 1;\n            \n            // Find the end of the word\n            while (j < n && s[j] != ' ') {\n                ++j;\n            }\n            \n            // Sort characters in this word\n            string temp = s.substr(i, j - i);\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n            \n            // Move to the next word\n            i = j;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing 'Hi': \" << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'hello': \" << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'Hello World!!!': \" << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for coordinate initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Comparator function to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col;  // Descending order for columns\n        else\n            return row < other.row;  // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through the list to find all occurrences of x and record their positions.\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x)\n                coordinates.push_back(Coordinate(row, col));\n        }\n    }\n\n    // Sort the coordinates as per the given criteria.\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> and return\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty or has only one element, return it as is.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n    \n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = tolower(c); // Convert to lowercase for simplicity\n            \n            size_t pos = ALPHABET.find(lower_c); // Find position of the letter in the alphabet\n            if (pos != std::string::npos) {\n                size_t new_pos = (pos + shift) % 26; // Calculate new position with wrapping around\n                char encrypted_char = ALPHABET[new_pos]; // Get the corresponding character\n                \n                // Preserve original case\n                c = isupper(c) ? toupper(encrypted_char) : encrypted_char;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <optional>\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Remove duplicates and sort the list\n    auto unique_end = std::unique(lst.begin(), lst.end());\n    lst.erase(unique_end, lst.end());\n    std::sort(lst.begin(), lst.end());\n\n    // Check if there are at least two distinct elements\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Return the second smallest element\n    return lst[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Split the string into sentences using '.', '?' or '!'\n    vector<string> sentences;\n    string current_sentence = \"\";\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            if (!current_sentence.empty()) {\n                sentences.push_back(current_sentence);\n                current_sentence = \"\";\n            }\n        } else {\n            current_sentence += c;\n        }\n    }\n    // Add the last sentence if it exists\n    if (!current_sentence.empty()) {\n        sentences.push_back(current_sentence);\n    }\n\n    for (string sentence : sentences) {\n        size_t question_mark_pos = sentence.find('?');\n        size_t exclamation_mark_pos = sentence.find('!');\n        \n        // Split by '?' and '!' to handle sub-sentences\n        if (question_mark_pos != string::npos || exclamation_mark_pos != string::npos) {\n            vector<string> sub_sentences;\n            if (question_mark_pos < exclamation_mark_pos && question_mark_pos != string::npos) {\n                sub_sentences.push_back(sentence.substr(0, question_mark_pos));\n                sentence = sentence.substr(question_mark_pos + 1);\n            }\n            if (exclamation_mark_pos != string::npos) {\n                sub_sentences.push_back(sentence.substr(0, exclamation_mark_pos));\n                sentence = sentence.substr(exclamation_mark_pos + 1);\n            }\n            \n            // Add the remaining part of the sentence\n            if (!sentence.empty()) {\n                sub_sentences.push_back(sentence);\n            }\n\n            for (string sub_sentence : sub_sentences) {\n                string trimmed_sub_sentence = sub_sentence;\n                while (trimmed_sub_sentence.front() == ' ') {\n                    trimmed_sub_sentence.erase(trimmed_sub_sentence.begin());\n                }\n                while (trimmed_sub_sentence.back() == ' ') {\n                    trimmed_sub_sentence.pop_back();\n                }\n\n                if (!trimmed_sub_sentence.empty() && trimmed_sub_sentence[0] == 'I') {\n                    boredom_count++;\n                }\n            }\n        } else {\n            string trimmed_sentence = sentence;\n            while (trimmed_sentence.front() == ' ') {\n                trimmed_sentence.erase(trimmed_sentence.begin());\n            }\n            while (trimmed_sentence.back() == ' ') {\n                trimmed_sentence.pop_back();\n            }\n\n            if (!trimmed_sentence.empty() && trimmed_sentence[0] == 'I') {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath> // For floor function\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them to their integer conversion\n    if (std::floor(a) != a || std::floor(b) != b || std::floor(c) != c) {\n        return false;\n    }\n\n    // Check if one number is the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else return tolower(c);\n}\n\n// Function to shift vowels by 2 places ahead in the alphabet\nchar shiftVowel(char c) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string shifted_vowels = \"cgeikqwuCGIKQW\";\n\n    for (size_t i = 0; i < vowels.size(); ++i) {\n        if (vowels[i] == c) return shifted_vowels[i];\n    }\n    return c;\n}\n\n// Main encode function\nstd::string encode(std::string message) {\n    std::string encoded_message;\n\n    for (char& c : message) {\n        // Swap case of the character\n        char new_char = swapCase(c);\n\n        // Shift vowels by 2 places ahead in the alphabet\n        if (new_char == 'a' || new_char == 'e' || new_char == 'i' || new_char == 'o' || new_char == 'u' ||\n            new_char == 'A' || new_char == 'E' || new_char == 'I' || new_char == 'O' || new_char == 'U') {\n            new_char = shiftVowel(new_char);\n        }\n\n        // Append the transformed character to the encoded message\n        encoded_message += new_char;\n    }\n\n    return encoded_message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds and returns the sum of digits of the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime number\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    return digitSum(maxPrime); // Return the sum of digits of the largest prime\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Determine case consistency\n        if (!isLowercase(key)) allLowercase = false;\n        if (!isUppercase(key)) allUppercase = false;\n\n        // If both flags are already false, no need to continue checking\n        if (!allLowercase && !allUppercase) break;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function to count up to n and return prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the last digit of both numbers by taking modulo 10\n    int last_digit_a = abs(a % 10);\n    int last_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return last_digit_a * last_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5)\n        return static_cast<int>(ceil(num));\n    else if (num < 0 && ceil(num) - num == 0.5)\n        return static_cast<int>(floor(num));\n\n    return static_cast<int>(round(num)); // Standard rounding\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;  // Start with 'n' stones for the first level.\n    \n    // Add the number of stones for each level to the vector.\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine if we need an odd or even next number based on whether 'n' is odd/even.\n        int increment = (n % 2 == 1) ? 2 : 2;\n        current_stones += increment;  // Increment by 2 to get the next odd/even number.\n    }\n    \n    return pile;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i = 0; i < result.size(); ++i) {\n        printf(\"%d \", result[i]);\n    }\n    // Expected output: 3 5 7\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result and reset it\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop (in case there's no trailing comma or space)\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for (const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) return -1;\n    \n    // Adjust y to be the largest even number in the range [x, y]\n    if (y % 2 != 0) { \n        y--; // If y is odd, decrement it by 1 to make it even.\n    }\n    \n    // Check if the adjusted y is still within or equal to x\n    if (y >= x) {\n        return y;\n    } else {\n        return -1; // No even number in range [x, y]\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Main function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round it down\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number has any even digit\nbool has_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false\n        n /= 10; // Move to the next digit\n    }\n    return true; // All digits are odd\n}\n\n// Function to filter and sort numbers with only odd digits\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test and print results\nvoid test() {\n    std::vector<int> example1 = {15, 33, 1422, 1};\n    std::vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(example1) == expected1);\n\n    std::vector<int> example2 = {152, 323, 1422, 10};\n    std::vector<int> expected2;\n    assert(unique_digits(example2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Map to store digit names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Filter and sort the array\n    std::vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n\n    std::sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted vector\n    std::reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert digits to their corresponding names\n    std::vector<std::string> result;\n    for (int num : filtered_sorted) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n\n// Helper function to calculate factorial\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate sum of numbers from 1 to i\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\n// Main function that returns a vector based on the given rules\nstd::vector<int> f(int n) {\n    std::vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sum_to_i(i);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a given integer is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function to verify correctness.\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Helper function to calculate the sum of signed digits of a number\nint sum_of_digits(int num) {\n    if (num == 0) return 0;\n\n    int sum = 0;\n    bool is_negative = false;\n\n    // Handle negative numbers by converting them to positive and marking as negative\n    if (num < 0) {\n        is_negative = true;\n        num = -num;  // Convert to positive for digit extraction\n    }\n\n    while (num > 0) {\n        int digit = num % 10;\n        sum += (is_negative && !sum ? -digit : digit);\n        num /= 10;\n\n        // Toggle the negative flag after processing the first digit of a negative number\n        if (!sum && is_negative)\n            is_negative = false;\n    }\n\n    return sum;\n}\n\n// Main function to count numbers with sum of digits > 0\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (const auto& number : n) {\n        if (sum_of_digits(number) > 0)\n            count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the vector is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    \n    // Find the break point where the sequence breaks from being non-decreasing\n    int i = 0; // Initialize i here to make it accessible in later scopes\n    for (; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            break;\n        }\n    }\n\n    // If no break point is found, the vector is already sorted\n    if (i == n - 2) {\n        return true;\n    }\n\n    // Create a rotated vector to simulate right shifts\n    vector<int> rotated_arr(arr.begin() + i + 1, arr.end());\n    rotated_arr.insert(rotated_arr.end(), arr.begin(), arr.begin() + i + 1);\n\n    // Check if the rotated vector is in non-decreasing order\n    for (int j = 0; j < n - 1; ++j) {\n        if (rotated_arr[j] > rotated_arr[j + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in the vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (const auto& num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check if there are enough even numbers in the second list\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (const auto& num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n        if (evens >= requiredCount) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = countOdd(lst1);\n    \n    // If there are no odd numbers in lst1, it's already possible\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n    \n    // Check if lst2 has enough even numbers to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to find the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n\n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output string based on the count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For std::ceil\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    // Iterate through each well (row)\n    for(const auto& row : grid) {\n        int water_units = 0; // Total units of water in the current well\n        \n        // Sum up all 1s in the current well\n        for(int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times a bucket needs to be lowered for this well\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Helper function to count the number of ones in the binary representation of n.\nint count_ones(int n) {\n    if (n >= 0) {\n        return std::bitset<32>(n).count(); // Count bits for non-negative integers\n    } else {\n        return std::bitset<32>(-(n + 1)).count(); // Count bits for negative integers\n    }\n}\n\n// Custom comparator function.\nbool custom_compare(int a, int b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n\n    if (count_a == count_b) {\n        return std::abs(a) < std::abs(b); // Sort by absolute value for ties\n    }\n    return count_a < count_b; // Primary sort by number of ones in binary representation\n}\n\n// Main function to sort the array.\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from second last character to first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the current character is a vowel and both surrounding characters are consonants\n        if (is_vowel(middle_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, middle_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first = lst[0];\n    string second = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(first + second)) {\n        return \"Yes\";\n    } else if (is_balanced(second + first)) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements from the sorted vector\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the extracted elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if index is even and value at that index is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n\n    // Add the last number, which is always 1 and odd\n    odds.push_back(1);\n\n    // Sort the vector of odd numbers in increasing order\n    sort(odds.begin(), odds.end());\n\n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Find positions of '-' characters to split the date into components\n    size_t pos1 = date.find('-');\n    size_t pos2 = date.find('-', pos1 + 1);\n    \n    // Ensure there are exactly two '-' in the correct format\n    if (pos1 == string::npos || pos2 == string::npos) return false;\n    \n    // Extract month, day, and year from the string\n    int month = stoi(date.substr(0, pos1));\n    int day = stoi(date.substr(pos1 + 1, pos2 - pos1 - 1));\n    int year = stoi(date.substr(pos2 + 1));\n\n    // Validate month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate day range based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 2 && (day < 1 || day > 29))) {\n        return false;\n    } else if ((day < 1 || day > 31)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character has an odd order in the alphabet\nbool is_odd_order(char c) {\n    // Convert lowercase letter to its position in the alphabet (0 for 'a', 1 for 'b', etc.)\n    int pos = c - 'a';\n    return pos % 2 == 1;\n}\n\n// Function to count the number of characters with odd order\nint count_odd_order(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c) && is_odd_order(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on whitespace\n        size_t start = 0, end;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } else {\n        // Check for commas if no whitespace was found\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            size_t start = 0, end;\n            while ((end = txt.find(',', start)) != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n            }\n            result.push_back(txt.substr(start)); // Add the last part\n        } else {\n            // No whitespace or commas found, count odd order letters\n            int count = count_odd_order(txt);\n            result.push_back(to_string(count));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of the frequency of each number\n\n    for(int i = 0; i < lst.size(); ++i){\n        // Check ascending order\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n\n        // Count occurrences of each element\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if(countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;    \n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n    return is_prime(length_of_intersection) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitude = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Calculate the magnitude\n        sum_magnitude += std::abs(num);\n\n        // Determine the sign and update the product of signs\n        if (num == 0) return 0; // Any number multiplied by zero is zero\n        else if (num > 0) continue; // Positive numbers don't change the product_of_signs\n        else product_of_signs *= -1; // Negative numbers flip the sign\n\n    }\n\n    // Return the final result: sum of magnitudes * product of signs\n    return sum_magnitude * product_of_signs;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Path {\n    vector<int> values;\n    \n    bool operator<(const Path& other) const {\n        for (size_t i = 0; i < min(values.size(), other.values.size()); ++i) {\n            if (values[i] != other.values[i]) return values[i] < other.values[i];\n        }\n        return values.size() < other.values.size();\n    }\n};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Initialize a map to store the minimum path for each cell and length\n    unordered_map<string, Path> dp;\n    \n    vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    auto dfs = [&](int x, int y, int steps) -> Path& {\n        string key = to_string(x) + \",\" + to_string(y) + \",\" + to_string(steps);\n        \n        if (dp.find(key) != dp.end()) return dp[key];\n        \n        if (steps == 0) {\n            Path empty;\n            dp[key] = empty;\n            return dp[key];\n        }\n        \n        Path min_path{vector<int>(k, INT_MAX)};\n        \n        for (const auto& [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            \n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                Path path = dfs(nx, ny, steps - 1);\n                path.values.push_back(grid[x][y]);\n                dp[key] = min(dp[key], path);\n            }\n        }\n        \n        return dp[key];\n    };\n    \n    // Start DFS from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dfs(i, j, k - 1);\n        }\n    }\n    \n    Path min_path{vector<int>(k, INT_MAX)};\n    \n    // Find the minimum path across all cells and lengths\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp.find(to_string(i) + \",\" + to_string(j) + \",\" + to_string(k - 1)) != dp.end()) {\n                min_path = min(min_path, dp[to_string(i) + \",\" + to_string(j) + \",\" + to_string(k - 1)]);\n            }\n        }\n    }\n    \n    return min_path.values;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\n\nstd::vector<int> tri(int n) {\n    if (n == 0) {\n        return {};\n    }\n    \n    std::vector<int> sequence = {1};  // Initialize with the base case\n    \n    for (int i = 2; i <= n + 1; ++i) {\n        if (i % 2 == 0) {\n            sequence.push_back(1 + (i / 2));\n        } else {\n            int value;\n            if (sequence.size() >= 3) {\n                value = sequence[i - 3] + sequence[i - 2] + sequence[i - 1];\n            } else {\n                // Handle the initial conditions for small i values\n                value = sequence[0];  // tri(3) depends on tri(4), which is not yet calculated, so use base case\n            }\n            sequence.push_back(value);\n        }\n    }\n\n    return std::vector<int>(sequence.begin() + 1, sequence.end());  // Return the sequence starting from index 1\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets;\n    bool has_nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            brackets.push(c);\n        } else if (c == ']') {\n            // Check if there are at least two open brackets to ensure nesting\n            if (!brackets.empty()) {  // Ensure the stack is not empty before calling top()\n                char top = brackets.top();\n                brackets.pop();  // Pop the top element\n\n                if (!brackets.empty()) {  // Check for nested condition after popping\n                    has_nested = true;\n                }\n            } else {\n                return false;  // Early exit if there's an unmatched closing bracket\n            }\n        }\n    }\n\n    return has_nested && brackets.empty();\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number to the nearest upper integer\n        float ceiling_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += pow(ceiling_num, 2);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    char last_char = txt.back();\n    \n    // Determine if the last character is a letter and not part of a word\n    if (isalpha(last_char)) {\n        if (txt.length() == 1 || !isalpha(txt[txt.length() - 2])) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n\n// Function to convert double to string representation\nstd::string convert_to_float_str(double value) {\n    return std::to_string(value);\n}\n\n// Function to compare two boost::any objects and return the larger one or \"None\" if they are equal\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check types of a and b\n    if (a.type() == typeid(int)) {\n        int ia = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (ia > ib ? boost::any(ia) : (ia < ib ? boost::any(ib) : \"None\"));\n        } else if (b.type() == typeid(double)) {\n            double db = boost::any_cast<double>(b);\n            return (ia > db ? boost::any(ia) : (ia < db ? boost::any(db) : \"None\"));\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = convert_to_float_str(boost::any_cast<double>(boost::any_cast<std::string>(b)));\n            return (ia > stod(sb) ? boost::any(ia) : (ia < stod(sb) ? boost::any(stod(sb)) : \"None\"));\n        }\n    } else if (a.type() == typeid(double)) {\n        double da = boost::any_cast<double>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (da > ib ? boost::any(da) : (da < ib ? boost::any(ib) : \"None\"));\n        } else if (b.type() == typeid(double)) {\n            double db = boost::any_cast<double>(b);\n            return (da > db ? boost::any(da) : (da < db ? boost::any(db) : \"None\"));\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = convert_to_float_str(boost::any_cast<double>(boost::any_cast<std::string>(b)));\n            return (da > stod(sb) ? boost::any(da) : (da < stod(sb) ? boost::any(stod(sb)) : \"None\"));\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string sa = boost::any_cast<std::string>(a);\n        double da = stod(sa);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (da > ib ? boost::any(da) : (da < ib ? boost::any(ib) : \"None\"));\n        } else if (b.type() == typeid(double)) {\n            double db = boost::any_cast<double>(b);\n            return (da > db ? boost::any(da) : (da < db ? boost::any(db) : \"None\"));\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            double db = stod(sb);\n            return (da > db ? boost::any(da) : (da < db ? boost::any(db) : \"None\"));\n        }\n    }\n\n    // If types are not compatible, return \"None\"\n    return \"None\";\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute the Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply the current factorial value with the result\n    }\n    return result;\n}\n\n// Function to test the correctness of the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << endl; // Output should be 288\n    cout << \"special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << endl; // Output should be 34560\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Regular expression pattern for validating the file name\n    regex pattern(R\"(^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*(txt|exe|dll)$)\");\n\n    if (regex_match(file_name, pattern) && count(file_name.begin(), file_name.end(), '.') == 1) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n#include <iostream>\n\nint sum_squares(const std::vector<int>& lst) {\n    int total_sum = 0;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i]; // Square the value\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total_sum += lst[i] * lst[i] * lst[i]; // Cube the value\n        }\n    }\n\n    return total_sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) {\n        // Check if the length of the current word is a prime number\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a string fraction into numerator and denominator integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    int numX, denX;\n    parseFraction(x, numX, denX);\n\n    int numN, denN;\n    parseFraction(n, numN, denN);\n\n    // Compute the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the result\n    int prodDen = denX * denN;  // Denominator of the result\n\n    // Simplify the fraction by dividing numerator and denominator with their GCD\n    int commonDivisor = gcd(prodNum, prodDen);\n    prodNum /= commonDivisor;\n    prodDen /= commonDivisor;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1)\n    return prodDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint sum_of_digits(int num) {\n    if (num == 0)\n        return 0;\n    \n    int is_negative = num < 0;\n    int digits_sum = 0;\n    num = std::abs(num);\n    \n    while (num > 0) {\n        digits_sum += num % 10;\n        num /= 10;\n    }\n    \n    return is_negative ? -digits_sum : digits_sum;\n}\n\n// Custom comparator for sorting\nbool custom_compare(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (sum_of_digits(a.second) == sum_of_digits(b.second)) {\n        return a.first < b.first; // Compare by original index if digit sums are equal\n    }\n    return sum_of_digits(a.second) < sum_of_digits(b.second); // Otherwise compare by digit sum\n}\n\n// Function to sort the vector based on the sum of digits and then by original index\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> enumerated_nums;\n    \n    // Enumerate the list with indices\n    for (int i = 0; i < nums.size(); ++i) {\n        enumerated_nums.push_back({i, nums[i]});\n    }\n    \n    // Sort using custom comparator\n    std::sort(enumerated_nums.begin(), enumerated_nums.end(), custom_compare);\n    \n    // Extract the sorted numbers from the enumerated list\n    std::vector<int> result;\n    for (const auto& pair : enumerated_nums) {\n        result.push_back(pair.second);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || \n                       firstDigit == '5' || firstDigit == '7' ||\n                       firstDigit == '9');\n    \n    bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || \n                      lastDigit == '5' || lastDigit == '7' ||\n                      lastDigit == '9');\n    \n    return isFirstOdd && isLastOdd;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula i * i - i + 1\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    bool valid_planet1 = false, valid_planet2 = false;\n\n    // Find the indices of planet1 and planet2 in the planets vector.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            valid_planet1 = true;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n            valid_planet2 = true;\n        }\n\n        // If both planets are found, break the loop.\n        if (valid_planet1 && valid_planet2)\n            break;\n    }\n\n    // Return an empty vector if either planet is not a valid name.\n    if (!valid_planet1 || !valid_planet2) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order of planets between them.\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    \n    // Collect all planets that are located between planet1 and planet2.\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test_bf() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort strings first by length and then lexicographically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;  // Alphabetical order for same lengths\n    }\n    return a.length() < b.length();  // Length-based sorting\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {  // Check even length\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    // Check if n is a prime number using the helper function\n    if (is_prime(n)) {\n        return x;  // Return x if n is prime\n    } else {\n        return y;  // Return y otherwise\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num) {  // Check if the number is positive and an integer\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {  // Check if the number is odd\n                sum_of_squares += n * n;  // Add the square of the odd number to the sum\n            }\n        }\n    }\n    \n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = compare({1,2,3,4,5,1}, {1,2,3,4,2,-2});\n    for (int i : res1) printf(\"%d \", i); // Expected: 0 0 0 0 3 3\n    \n    std::cout << \"\\n\";\n    \n    auto res2 = compare({0,5,0,0,0,4}, {4,1,1,0,0,-2});\n    for (int i : res2) printf(\"%d \", i); // Expected: 4 4 1 0 0 6\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on its name.\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) {\n            uppercase++;\n        } else if (islower(c)) {\n            lowercase++;\n        }\n    }\n    \n    return uppercase - lowercase;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() == 1)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the integer to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each character in the string representation of the number\n    for (char ch : str_num) {\n        int digit = ch - '0';  // Convert char to integer\n        \n        // Check if the digit is even or odd and increment the respective counter\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},  {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},    {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with given examples\nvoid check() {\n    cout << \"19 -> \" << int_to_mini_roman(19) << endl;  // Expected: xix\n    cout << \"152 -> \" << int_to_mini_roman(152) << endl; // Expected: clii\n    cout << \"426 -> \" << int_to_mini_roman(426) << endl; // Expected: cdxxvi\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    float hypotenuse = sides[2]; // The largest value will be at index 2\n\n    // Check if it's a right-angled triangle using Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1]) == (hypotenuse * hypotenuse);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // for std::sort and std::unique\n#include <set>       // to count unique characters\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) return \"\";  // Handle empty vector case\n    \n    auto max_unique_chars = 0;\n    std::string result;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        \n        int current_unique_count = unique_chars.size();\n        \n        if (current_unique_count > max_unique_chars || \n            (current_unique_count == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_count;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total number of carrots to eat after meals\n    int totalToEat = number + need;\n    \n    // If there are enough remaining carrots, calculate the new counts\n    if (remaining >= need) {\n        return {totalToEat, remaining - need};\n    }\n    // Otherwise, eat all remaining carrots and be still hungry\n    else {\n        return {number + remaining, 0};\n    }\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    // Initialize the expression string with the first operand\n    std::stringstream expression;\n    expression << operands[0];\n\n    // Iterate through each operator and append it along with the next operand to the expression\n    for (size_t i = 0; i < operators.size(); ++i) {\n        const auto& op = operators[i];\n        int operand_value = operands[i + 1];\n\n        if (op == \"+\") {\n            expression << \" + \" << operand_value;\n        } else if (op == \"-\") {\n            expression << \" - \" << operand_value;\n        } else if (op == \"*\") {\n            expression << \" * \" << operand_value;\n        } else if (op == \"//\") {\n            expression << \" / \" << operand_value; // Note: C++ uses '/' for integer division\n        } else if (op == \"**\") {\n            expression << \" ^ \" << operand_value; // Note: C++ does not have '**', use '^' or pow()\n        }\n    }\n\n    // Evaluate the constructed expression using std::stringstream and return the result\n    int result;\n    expression >> result;\n\n    // Handle exponentiation separately since C++ does not support '**'\n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"**\") {\n            operands[i + 1] = std::pow(operands[i], operands[i + 1]);\n            expression.clear();\n            expression << operands[0];\n            for (size_t j = 0; j < operators.size(); ++j) {\n                const auto& op = operators[j];\n                int operand_value = operands[j + 1];\n\n                if (op == \"+\") {\n                    expression << \" + \" << operand_value;\n                } else if (op == \"-\") {\n                    expression << \" - \" << operand_value;\n                } else if (op == \"*\") {\n                    expression << \" * \" << operand_value;\n                } else if (op == \"//\") {\n                    expression << \" / \" << operand_value; // Note: C++ uses '/' for integer division\n                }\n            }\n        }\n    }\n\n    return std::stoi(expression.str());\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed\n        for (char &c : s) {\n            if (isLetter(c)) c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function to convert a byte array to a hexadecimal string\nstring bytes_to_hex(const unsigned char* data, size_t len) {\n    static const char hex_chars[] = \"0123456789abcdef\";\n    string hex_str;\n    for (size_t i = 0; i < len; ++i) {\n        hex_str += hex_chars[(data[i] >> 4) & 0x0F];\n        hex_str += hex_chars[data[i] & 0x0F];\n    }\n    return hex_str;\n}\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), hash);\n\n    return bytes_to_hex(hash, MD5_DIGEST_LENGTH);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is less than or equal to 'b'\n    int start = std::min(a, b);\n    int end = std::max(a, b) + 1;\n\n    std::vector<int> even_digits;\n\n    for (int num = start; num < end; ++num) {\n        if (num % 2 == 0 && num < 10) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list and check if any two consecutive elements\n    // are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::stack<char> stack;\n    std::string current_group = \"\";\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n            current_group += ch;\n        } else if (ch == ')') {\n            stack.pop();\n            current_group += ch;\n\n            // If the stack is empty, it means a complete group has been processed\n            if (stack.empty()) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);  // Get the integer part\n    float decimal_part = number - integer_part;  // Subtract to get the decimal part\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) {\n            return true; // If balance falls below zero, return true\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size.\n    vector<int> result(result_size);\n\n    if (!numbers.empty()) {\n        int pos = 0;\n        \n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result[pos++] = numbers[i];\n            \n            if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n                result[pos++] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes.\nvoid printVector(const vector<int>& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    \n    // Function to calculate depth for a single group of parentheses\n    auto calculate_depth = [](const string& group) -> int {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (max_depth < current_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                --current_depth;\n            }\n        }\n        return max_depth;\n    };\n\n    // Split the input string into groups and calculate depth for each group\n    size_t start = 0, end = paren_string.find(' ');\n    while (end != string::npos) {\n        depths.push_back(calculate_depth(paren_string.substr(start, end - start)));\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Add the last group\n    if (start < paren_string.length()) {\n        depths.push_back(calculate_depth(paren_string.substr(start)));\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    auto result1 = filter_by_substring({}, \"a\");\n    assert(result1.empty());\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    vector<string> expected_result2{\"abc\", \"bacd\", \"vector\"};\n    for (const auto& str : expected_result2) {\n        assert(find(result2.begin(), result2.end(), str) != result2.end());\n    }\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    // Initialize variables for sum and product\n    int total_sum = 0;\n    int total_product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Iterate through each number in the vector\n    for (int number : numbers) {\n        total_sum += number;  // Add the current number to the sum\n        total_product *= number;  // Multiply the current number with the product\n    }\n\n    // Return a vector containing the sum and product\n    return {total_sum, total_product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n\n    >>> make_palindrome(\"\")\n    \"\"\n    \n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    \n    >>> make_palindrome(\"cata\")\n    \"catac\"\n     */\n    if (str.empty()) {\n        return \"\";\n    }\n\n    // Find the longest palindromic suffix\n    int i = 0;\n    for (; i < str.size(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            break;\n        }\n    }\n\n    // Extract the prefix before the palindromic suffix and reverse it\n    string prefix = str.substr(0, str.size() - i);\n    return str + string(prefix.rbegin(), prefix.rend());\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result.\n\n    // Iterate through each character in the strings and perform XOR operation.\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both characters are the same, append '0' to the result string.\n        } else {\n            result += '1';  // If characters are different, append '1'.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // If current string is longer than the longest found so far\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) {\n        return -1; // or throw an exception/error for invalid input\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\\n\";\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase\n    for (char &ch : str) {\n        ch = std::tolower(ch);\n    }\n\n    // Use a set to store unique characters\n    std::unordered_set<char> unique_chars;\n    \n    // Insert each character into the set\n    for (char ch : str) {\n        unique_chars.insert(ch);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<int> parse_music(std::string music_string) {\n    std::istringstream iss(music_string);\n    std::vector<int> notes;\n    \n    for (std::string note; iss >> note;) {\n        if (note == \"o\") {\n            notes.push_back(4);\n        } else if (note == \"o|\") {\n            notes.push_back(2);\n        } else if (note == \".|\") {\n            notes.push_back(1);\n        }\n    }\n\n    return notes;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move past the last found position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <map>\n\n// Mapping from string representation of numbers to their integer values\nstd::map<std::string, int> number_map = {\n    {\"zero\", 0},\n    {\"one\", 1},\n    {\"two\", 2},\n    {\"three\", 3},\n    {\"four\", 4},\n    {\"five\", 5},\n    {\"six\", 6},\n    {\"seven\", 7},\n    {\"eight\", 8},\n    {\"nine\", 9}\n};\n\nstd::string sort_numbers(std::string numbers) {\n    // Split the input string into individual number words\n    std::istringstream iss(numbers);\n    std::vector<std::string> number_words;\n    std::string word;\n\n    while (iss >> word) {\n        number_words.push_back(word);\n    }\n\n    // Convert each word to its corresponding integer value using the map\n    std::vector<int> number_values;\n    for (const auto& w : number_words) {\n        number_values.push_back(number_map[w]);\n    }\n\n    // Sort the list of integers\n    std::sort(number_values.begin(), number_values.end());\n\n    // Convert the sorted integers back to their string representation\n    std::ostringstream oss;\n    for (size_t i = 0; i < number_values.size(); ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        for (const auto& entry : number_map) {\n            if (entry.second == number_values[i]) {\n                oss << entry.first;\n                break;\n            }\n        }\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> result;\n    \n    // Iterate through the sorted list to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    // Return the closest pair in ascending order\n    return {result.first, result.second};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation: (num - min_val) / (max_val - min_val)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check_function() {\n    list_any test1 = {std::string(\"a\"), 3.14, 5};\n    auto filtered_test1 = filter_integers(test1);\n    for (int num : filtered_test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    list_any test2 = {1, 2, 3, std::string(\"abc\"), {}, {}};\n    auto filtered_test2 = filter_integers(test2);\n    for (int num : filtered_test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint strlen(const std::string& str) {\n    return str.length(); // or str.size()\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle even numbers first.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print the vector of factors for testing purposes.\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << factors[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \" \", \"world\"}) == \"hello world\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and display results\nvoid check(vector<string> input, string prefix) {\n    vector<string> filtered = filter_by_prefix(input, prefix);\n    \n    cout << \"{\";\n    for (size_t i = 0; i < filtered.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << filtered[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to return only positive numbers from the input vector.\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the vector and check if it is positive.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is greater than zero.\n            result.push_back(num);  // Add positive numbers to the result vector.\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of get_positive function.\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    for (float num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 2 5 6\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    for (float num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 5 3 2 3 9 123 1\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by 2 and 3 first, as they are the smallest primes.\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // If divisible by 2 or 3, it's not prime\n    \n    // Check for divisibility from 5 onwards, skipping even numbers.\n    long long i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false; // If divisible by any number in this range, it's not prime\n        i += 6; // Skip even numbers and multiples of 3\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    */\n    double sum = 0.0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    Finds the root of a polynomial with coefficients xs such that poly(x) = 0.\n    Assumes xs has an even number of coefficients and guarantees a solution.\n    */\n    double x = xs[1] / (2 * xs[0]);  // Initial guess based on quadratic formula for ax^2 + bx + c = 0\n    const double epsilon = 1e-6;     // Tolerance level\n\n    while (true) {\n        double fx = poly(xs, x);\n        if (std::abs(fx) < epsilon) {\n            break;\n        }\n        \n        double dfx = 0.0;\n        for (size_t i = 1; i < xs.size(); ++i) { // Derivative of the polynomial\n            dfx += static_cast<double>(i) * xs[i] * std::pow(x, static_cast<int>(i - 1));\n        }\n        \n        x -= fx / dfx;\n    }\n\n    return x;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices_elements;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices_elements.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(third_indices_elements.begin(), third_indices_elements.end());\n\n    // Create a new vector to store the result\n    vector<int> l_prime;\n    \n    int third_index = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l_prime.push_back(third_indices_elements[third_index]);\n            third_index++;\n        } else {\n            l_prime.push_back(l[i]);\n        }\n    }\n\n    return l_prime;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit 7\n                    count++;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract values at even indices (0-based)\n    vector<float> even_indices_values;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the extracted values\n    sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Create a copy of the original list to store the result\n    vector<float> result = l;\n\n    // Update the even indices in the result with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 1; i < result.size() && sorted_index < even_indices_values.size(); i += 2) {\n        result[i] = even_indices_values[sorted_index++];\n    }\n\n    return result;\n}\n\n// Function to print the vector elements\nvoid print_vector(const vector<float>& v) {\n    for (const auto& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached as we always find a result.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <iostream>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Since all cars are moving towards each other at a constant speed and there are equal numbers of cars on both sides,\n    // every left-to-right car will eventually collide with exactly one right-to-left car.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &i : l) {  // Iterate through each element and increment it by 1.\n        i += 1;\n    }\n    return l;  // Return the modified vector.\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    for (const int& elem : vec) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        \n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    return false;  // No pairs sum up to zero.\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1 || base >= 10) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    std::string result = \"\";\n    while (x > 0) {\n        // Prepend the remainder to the result string\n        result = std::to_string(x % base) + result;\n        x /= base; // Divide x by base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is (1/2) * base * height\n    return 0.5f * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n    \n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 4; i <= n; ++i) {\n        int next_value = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_value;\n    }\n    \n    return d;\n}\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    size_t n = l.size();\n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Special case for 2^0 = 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the current result by the base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Check if the character is not a vowel, considering both lowercase and uppercase.\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n            && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with provided data points.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::sort and std::unique\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from both sorted strings\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters in the string\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // First Fibonacci number\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid check_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will count the number of unmatched '<' characters.\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++; // Increment balance when an opening bracket is found.\n        } else if (c == '>') {\n            balance--; // Decrement balance when a closing bracket is found.\n            \n            // If at any point the balance goes negative, it means there's a closing\n            // bracket without a matching opening one before it.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // At the end of the string, the balance should be zero for all brackets to match correctly.\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() <= 1) return true; // A single element or empty list is trivially monotonic\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are met, the sequence is neither strictly increasing nor decreasing\n        if (increasing && decreasing) return false;\n\n    }\n    \n    return true; // The sequence is either monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    auto last_unique_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_unique_l1, l1.end());\n\n    auto last_unique_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_unique_l2, l2.end());\n\n    // Vector to store common elements\n    vector<int> result;\n\n    // Find and add common elements to the result vector\n    for (int num : l1) {\n        if (find(l2.begin(), l2.end(), num) != l2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << std::endl; // Should print 29\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << std::endl;   // Should print 2\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all opening brackets have been matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first coefficient and goes up to the last but one.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    std::string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert the string to lowercase\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (char ch : lower_s) {\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Special case: treat 'y' as a vowel only if it is at the end of the word\n    if (!lower_s.empty() && lower_s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(int x, int shift) {\n    // Convert integer to string\n    std::string num_str = std::to_string(x);\n    \n    // Determine length of number\n    int num_length = num_str.length();\n    \n    // Handle case where shift is greater than the number of digits\n    if (shift > num_length) {\n        return std::string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Compute effective shift within bounds of digit count\n    shift %= num_length;\n    \n    // Perform circular shift\n    std::string shifted_str = num_str.substr(num_length - shift, shift) + num_str.substr(0, num_length - shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Split the string based on spaces\n    stringstream ss(s);\n    vector<string> parts;\n    string part;\n    \n    while (getline(ss, part, ' ')) {\n        if (!part.empty()) {\n            parts.push_back(part);\n        }\n    }\n\n    // Extract the number of apples and oranges\n    int num_apples = stoi(parts[0]);\n    int num_oranges = stoi(parts[3].substr(0, parts[3].size() - 8)); // Remove \"oranges\" suffix\n\n    // Calculate the number of mangoes\n    int num_mangoes = n - num_apples - num_oranges;\n\n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum integer value\n    int minIndex = -1;          // No even number found yet\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is an even number and less than or equal to the current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If it's smaller, or same but with a smaller index\n                minEvenValue = arr[i];                    // Update the smallest even value\n                minIndex = i;                             // Update the index of this value\n            }\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};  // Return an empty vector if no even number was found\n    } else {\n        return {minEvenValue, minIndex}; // Return the smallest even value and its index\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (auto num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that satisfies the condition\n    int max_val = -1; // Initialize with -1 to handle case where no such value exists\n    for (const auto& entry : freq) {\n        if (entry.first <= entry.second && entry.first > max_val) {\n            max_val = entry.first;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return lst; // Return empty vector if input is empty\n    \n    std::sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0, right = lst.size() - 1;\n    while (left <= right) {\n        if (left == right) { // If only one element is remaining\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        result.push_back(lst[left++]); // Add the minimum value and move left pointer to the right\n        result.push_back(lst[right--]); // Add the maximum value and move right pointer to the left\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet in the middle\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return total number of required changes\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the given number can be expressed as the product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    std::vector<int> prime_factors;\n\n    // Handle divisibility by 2\n    while (a % 2 == 0 && prime_factors.size() < 3) {\n        prime_factors.push_back(2);\n        a /= 2;\n    }\n\n    // Check for odd divisors starting from 3 up to the square root of 'a'\n    for (int i = 3; i <= std::sqrt(a); i += 2) {\n        while (a % i == 0 && prime_factors.size() < 3) {\n            if (is_prime(i)) {\n                prime_factors.push_back(i);\n            }\n            a /= i;\n        }\n    }\n\n    // Check the remaining value of 'a' itself\n    if (a > 1 && is_prime(a) && prime_factors.size() < 3) {\n        prime_factors.push_back(a);\n    }\n\n    return prime_factors.size() == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can be any number to the power of 0.\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is 1, then only x = 1 is a valid simple power\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    // Calculate the logarithm of x to base n.\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value.\n    int exponent = static_cast<int>(log_result);\n    return fabs(log_result - exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double cbrt_a = std::cbrt(a);\n    \n    // Round to the nearest integer\n    int rounded_cbrt_a = static_cast<int>(std::round(cbrt_a));\n    \n    // Check if cubing this rounded value gives back 'a'\n    return (rounded_cbrt_a * rounded_cbrt_a * rounded_cbrt_a == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    // Define which hexadecimal characters are prime numbers.\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit.\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n// Function to test and verify the correctness of the hex_key function.\nvoid check(const std::string& num, int expected) {\n    int result = hex_key(num);\n    if (result == expected)\n        std::cout << \"PASS: For \\\"\" << num << \"\\\", got \" << result << \"\\n\";\n    else\n        std::cout << \"FAIL: For \\\"\" << num << \"\\\", expected \" << expected << \", but got \" << result << \"\\n\";\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal number to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for simplicity\n    string binary = \"\";\n    \n    if (decimal == 0) { // Special case for zero\n        return \"db0db\";\n    }\n    \n    while(decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder to form the binary string\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nbool is_happy(std::string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // If any two out of three consecutive characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");  // For invalid or extremely low GPAs\n        }\n    }\n\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    \n    // For numbers of length n, there are 9^(n-2) possibilities for the middle digits.\n    long count = 2 * static_cast<long>(pow(10, n - 1)) - static_cast<long>(pow(9, n - 1));\n    \n    return static_cast<int>(count);\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Sum all the digits of N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort()\nusing namespace std;\n\n// Function to anti-shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string after sorting each word\n    int n = s.length();\n    \n    for (int i = 0; i < n;) {\n        if (s[i] == ' ') {  // If current character is a space, add it to the result and move to next position\n            result += \" \";\n            ++i;\n        } else {\n            int j = i + 1;\n            \n            // Find the end of the word\n            while (j < n && s[j] != ' ') {\n                ++j;\n            }\n            \n            // Sort characters in this word\n            string temp = s.substr(i, j - i);\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n            \n            // Move to the next word\n            i = j;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing 'Hi': \" << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'hello': \" << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'Hello World!!!': \" << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for coordinate initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Comparator function to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col;  // Descending order for columns\n        else\n            return row < other.row;  // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through the list to find all occurrences of x and record their positions.\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x)\n                coordinates.push_back(Coordinate(row, col));\n        }\n    }\n\n    // Sort the coordinates as per the given criteria.\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> and return\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty or has only one element, return it as is.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n    \n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = tolower(c); // Convert to lowercase for simplicity\n            \n            size_t pos = ALPHABET.find(lower_c); // Find position of the letter in the alphabet\n            if (pos != std::string::npos) {\n                size_t new_pos = (pos + shift) % 26; // Calculate new position with wrapping around\n                char encrypted_char = ALPHABET[new_pos]; // Get the corresponding character\n                \n                // Preserve original case\n                c = isupper(c) ? toupper(encrypted_char) : encrypted_char;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <utility>\n\nstd::pair<bool, int> next_smallest(const std::vector<int>& lst) {\n    if (lst.size() < 2) {\n        return {false, -1};\n    }\n\n    // Remove duplicates by inserting elements into a set and then back to a vector\n    std::set<int> unique_elements(lst.begin(), lst.end());\n    if (unique_elements.size() < 2) {\n        return {false, -1};\n    }\n\n    // Convert the set back to a vector and get the second element\n    auto sorted_unique_elements = std::vector<int>(unique_elements.begin(), unique_elements.end());\n    return {true, sorted_unique_elements[1]};\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Split the string into sentences based on '.', '?' or '!'\n    vector<string> sentences;\n    string current_sentence = \"\";\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            if (!current_sentence.empty()) {\n                sentences.push_back(current_sentence);\n                current_sentence = \"\";\n            }\n        } else {\n            current_sentence += c;\n        }\n    }\n    // Add the last sentence if it exists\n    if (!current_sentence.empty()) {\n        sentences.push_back(current_sentence);\n    }\n\n    for (string sentence : sentences) {\n        string trimmed_sentence = sentence.substr(0, 2); // Get first two characters to check \"I \"\n        if (trimmed_sentence == \"I \") {\n            boredom_count++;\n        } else {\n            size_t question_mark_pos = sentence.find('?');\n            size_t exclamation_mark_pos = sentence.find('!');\n            \n            if (question_mark_pos != string::npos) {\n                // Split the sentence at '?'\n                vector<string> parts;\n                size_t start = 0;\n                for (size_t pos = 0; pos <= question_mark_pos; pos++) {\n                    if (sentence[pos] == '?') {\n                        parts.push_back(sentence.substr(start, pos - start));\n                        start = pos + 1;\n                    }\n                }\n                parts.push_back(sentence.substr(start));\n\n                // Check each part\n                for (string part : parts) {\n                    string trimmed_part = part.substr(0, 2);\n                    if (trimmed_part == \"I \") {\n                        boredom_count++;\n                    }\n                }\n            } else if (exclamation_mark_pos != string::npos) {\n                // Split the sentence at '!'\n                vector<string> parts;\n                size_t start = 0;\n                for (size_t pos = 0; pos <= exclamation_mark_pos; pos++) {\n                    if (sentence[pos] == '!') {\n                        parts.push_back(sentence.substr(start, pos - start));\n                        start = pos + 1;\n                    }\n                }\n                parts.push_back(sentence.substr(start));\n\n                // Check each part\n                for (string part : parts) {\n                    string trimmed_part = part.substr(0, 2);\n                    if (trimmed_part == \"I \") {\n                        boredom_count++;\n                    }\n                }\n            } else {\n                string trimmed_sentence = sentence.substr(0, 2);\n                if (trimmed_sentence == \"I \") {\n                    boredom_count++;\n                }\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != static_cast<int>(a) || b != static_cast<int>(b) || c != static_cast<int>(c)) {\n        return false;\n    }\n\n    // Convert to integers for sum checks\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if one number is equal to the sum of the other two\n    if (ia == ib + ic || ib == ia + ic || ic == ia + ib) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    // Define vowels and their shifted counterparts\n    string vowels = \"aeiouAEIOU\";\n    char shifted_vowels[] = {'c', 'g', 'k', 'q', 'w',  // lowercase\n                              'C', 'G', 'K', 'Q', 'W'}; // uppercase\n    \n    for (char &ch : message) {\n        if (isalpha(ch)) {  // Check if the character is an alphabetic letter\n            // Swap case\n            ch = islower(ch) ? toupper(ch) : tolower(ch);\n            \n            // Find and replace vowels with shifted counterparts\n            size_t vowel_index = vowels.find(ch);\n            if (vowel_index != string::npos) {\n                ch = shifted_vowels[vowel_index];\n            }\n        }\n    }\n    \n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds and returns the sum of digits of the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime number\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    return digitSum(maxPrime); // Return the sum of digits of the largest prime\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Determine case consistency\n        if (!isLowercase(key)) allLowercase = false;\n        if (!isUppercase(key)) allUppercase = false;\n\n        // If both flags are already false, no need to continue checking\n        if (!allLowercase && !allUppercase) break;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function to count up to n and return prime numbers less than n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the last digit of both numbers by taking modulo 10\n    int last_digit_a = abs(a % 10);\n    int last_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return last_digit_a * last_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5)\n        return static_cast<int>(ceil(num));\n    else if (num < 0 && ceil(num) - num == 0.5)\n        return static_cast<int>(floor(num));\n\n    return static_cast<int>(round(num)); // Standard rounding\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;  // Start with 'n' stones for the first level.\n    \n    // Add the number of stones for each level to the vector.\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine if we need an odd or even next number based on whether 'n' is odd/even.\n        int increment = (n % 2 == 1) ? 2 : 2;\n        current_stones += increment;  // Increment by 2 to get the next odd/even number.\n    }\n    \n    return pile;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i = 0; i < result.size(); ++i) {\n        printf(\"%d \", result[i]);\n    }\n    // Expected output: 3 5 7\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result and reset it\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop (in case there's no trailing comma or space)\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for (const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) return -1;\n    \n    // Adjust y to be the largest even number in the range [x, y]\n    if (y % 2 != 0) { \n        y--; // If y is odd, decrement it by 1 to make it even.\n    }\n    \n    // Check if the adjusted y is still within or equal to x\n    if (y >= x) {\n        return y;\n    } else {\n        return -1; // No even number in range [x, y]\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Main function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round it down\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number has any even digit\nbool has_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false\n        n /= 10; // Move to the next digit\n    }\n    return true; // All digits are odd\n}\n\n// Function to filter and sort numbers with only odd digits\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test and print results\nvoid test() {\n    std::vector<int> example1 = {15, 33, 1422, 1};\n    std::vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(example1) == expected1);\n\n    std::vector<int> example2 = {152, 323, 1422, 10};\n    std::vector<int> expected2;\n    assert(unique_digits(example2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Map to store digit names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Filter and sort the array\n    std::vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n\n    std::sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted vector\n    std::reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert digits to their corresponding names\n    std::vector<std::string> result;\n    for (int num : filtered_sorted) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate factorial of a number\nint factorial(int i) {\n    if (i == 0 || i == 1)\n        return 1;\n    int result = 1;\n    for (int j = 2; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to i\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\n// Main function that constructs and returns the vector based on the given rules\nstd::vector<int> f(int n) {\n    std::vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        int value_i_plus_1 = i + 1;\n        if (value_i_plus_1 % 2 == 0) {\n            result[i] = factorial(value_i_plus_1);\n        } else {\n            result[i] = sum_to_i(value_i_plus_1);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a given integer is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function to verify correctness.\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of signed digits of an integer.\nint sum_of_digits(int num) {\n    if (num == 0) return 0;\n\n    bool is_negative = num < 0;\n    int digit_sum = 0;\n\n    while (num != 0) {\n        // Extract the last digit and add its absolute value to digit_sum\n        digit_sum += abs(num % 10);\n        // Remove the last digit from num\n        num /= (is_negative ? -10 : 10);\n    }\n\n    return digit_sum;\n}\n\n// Main function that counts the number of elements with a sum of digits > 0.\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (const auto& number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) {\n        return true;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        // Check if the array is already sorted or can be made sorted with a single cycle\n        if (arr[i] <= arr[(i + 1) % n]) {\n            continue;\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in the vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (const auto& num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check if there are enough even numbers in the second list\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (const auto& num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n        if (evens >= requiredCount) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = countOdd(lst1);\n    \n    // If there are no odd numbers in lst1, it's already possible\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n    \n    // Check if lst2 has enough even numbers to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to find the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n\n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output string based on the count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For std::ceil\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    // Iterate through each well (row)\n    for(const auto& row : grid) {\n        int water_units = 0; // Total units of water in the current well\n        \n        // Sum up all 1s in the current well\n        for(int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times a bucket needs to be lowered for this well\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to count the number of ones in the binary representation of an integer.\nint count_ones(int n) {\n    if (n >= 0) {\n        return __builtin_popcount(n);\n    } else {\n        // For negative numbers, calculate the two's complement and count the ones\n        unsigned int abs_n = -static_cast<unsigned int>(n + 1);\n        return __builtin_popcount(abs_n);\n    }\n}\n\n// Function to sort an array based on the number of ones in their binary representation.\nstd::vector<int> sort_array(std::vector<int> arr) {\n    // Sort using a custom lambda function as the key\n    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n\n        if (count_a == count_b) {\n            return abs(a) < abs(b); // Sort by absolute value for the same number of ones\n        }\n        return count_a < count_b; // Primary sort by number of ones\n    });\n\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from second last character to first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the current character is a vowel and both surrounding characters are consonants\n        if (is_vowel(middle_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, middle_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first = lst[0];\n    string second = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(first + second)) {\n        return \"Yes\";\n    } else if (is_balanced(second + first)) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements from the sorted vector\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the extracted elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if index is even and value at that index is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n\n    // Add the last number, which is always 1 and odd\n    odds.push_back(1);\n\n    // Sort the vector of odd numbers in increasing order\n    sort(odds.begin(), odds.end());\n\n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Find positions of '-' characters to split the date into components\n    size_t pos1 = date.find('-');\n    size_t pos2 = date.find('-', pos1 + 1);\n    \n    // Ensure there are exactly two '-' in the correct format\n    if (pos1 == string::npos || pos2 == string::npos) return false;\n    \n    // Extract month, day, and year from the string\n    int month = stoi(date.substr(0, pos1));\n    int day = stoi(date.substr(pos1 + 1, pos2 - pos1 - 1));\n    int year = stoi(date.substr(pos2 + 1));\n\n    // Validate month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate day range based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 2 && (day < 1 || day > 29))) {\n        return false;\n    } else if ((day < 1 || day > 31)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character has an odd order in the alphabet\nbool is_odd_order(char c) {\n    // Convert lowercase letter to its position in the alphabet (0 for 'a', 1 for 'b', etc.)\n    int pos = c - 'a';\n    return pos % 2 == 1;\n}\n\n// Function to count the number of characters with odd order\nint count_odd_order(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c) && is_odd_order(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on whitespace\n        size_t start = 0, end;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } else {\n        // Check for commas if no whitespace was found\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            size_t start = 0, end;\n            while ((end = txt.find(',', start)) != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n            }\n            result.push_back(txt.substr(start)); // Add the last part\n        } else {\n            // No whitespace or commas found, count odd order letters\n            int count = count_odd_order(txt);\n            result.push_back(to_string(count));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of the frequency of each number\n\n    for(int i = 0; i < lst.size(); ++i){\n        // Check ascending order\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n\n        // Count occurrences of each element\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if(countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;    \n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath> // For std::sqrt\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n    return is_prime(length_of_intersection) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitude = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Calculate the magnitude\n        sum_magnitude += std::abs(num);\n\n        // Determine the sign and update the product of signs\n        if (num == 0) return 0; // Any number multiplied by zero is zero\n        else if (num > 0) continue; // Positive numbers don't change the product_of_signs\n        else product_of_signs *= -1; // Negative numbers flip the sign\n\n    }\n\n    // Return the final result: sum of magnitudes * product of signs\n    return sum_magnitude * product_of_signs;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nclass Path {\npublic:\n    std::vector<int> values;\n    int x, y;\n\n    // Constructor accepting const reference to vector\n    Path(const std::vector<int>& v, int i, int j) : values(v), x(i), y(j) {}\n\n    // Comparison operator for priority queue\n    bool operator>(const Path& other) const {\n        return this->values.back() > other.values.back();\n    }\n};\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int m = grid.size(), n = grid[0].size();\n    std::priority_queue<Path, std::vector<Path>, std::greater<Path>> pq;\n\n    // Initialize priority queue with starting positions\n    for (int i = 0; i < m; ++i) {\n        Path path({grid[i][0]}, i, 0);\n        pq.push(path);\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n\n        if (current.x == m - 1 && current.y == n - 1)\n            return current.values;\n\n        // Explore right\n        if (current.y + 1 < n) {\n            Path next(current.values, current.x, current.y + 1);\n            next.values.push_back(grid[current.x][current.y + 1]);\n            pq.push(next);\n        }\n\n        // Explore down\n        if (current.x + 1 < m) {\n            Path next(current.values, current.x + 1, current.y);\n            next.values.push_back(grid[current.x + 1][current.y]);\n            pq.push(next);\n        }\n    }\n\n    return {};  // Return empty vector if no path is found\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) {\n        return {};\n    }\n\n    vector<int> sequence = {1};\n    \n    for (int i = 1; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + (i / 2);\n        } else {\n            // Handle the case where (i+1) might exceed current sequence length\n            next_value = sequence[i - 1] + sequence[i - 2] + ((i + 1 <= n) ? sequence[(i + 1)] : sequence[0]);\n        }\n        sequence.push_back(next_value);\n    }\n\n    // Adjust the first value if it's at index 0\n    if (n > 0 && sequence[0] == 1) {\n        sequence[0] = 3;\n    }\n\n    return sequence;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets;\n    bool has_nested = false;\n\n    for (char bracket : str) {\n        if (bracket == '[') {\n            brackets.push(bracket);\n        } else if (bracket == ']') {\n            if (!brackets.empty() && !has_nested && brackets.size() > 1) {\n                has_nested = true;\n            }\n            if (!brackets.empty()) {\n                brackets.pop();\n            } else {\n                // If the stack is empty but we encounter a closing bracket, it's invalid\n                return false;\n            }\n        }\n    }\n\n    // The string must have at least one nested pair and all brackets must be balanced\n    return has_nested && brackets.empty();\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number to the nearest upper integer\n        float ceiling_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += pow(ceiling_num, 2);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype>  // For isalpha function\n\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char last_char = txt.back();\n    \n    // Check if the last character is an alphabetical character and not part of a word\n    if (std::isalpha(last_char) && (txt.length() == 1 || !std::isalpha(txt[txt.length() - 2]))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\n\nint can_arrange(std::vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n\n// Helper function to convert any type to float if necessary\nfloat convert_to_float(const boost::any& value) {\n    if (value.type() == typeid(float)) {\n        return boost::any_cast<float>(value);\n    } else if (value.type() == typeid(int)) {\n        return static_cast<float>(boost::any_cast<int>(value));\n    } else if (value.type() == typeid(std::string)) {\n        std::string str = boost::any_cast<std::string>(value);\n        std::replace(str.begin(), str.end(), ',', '.');\n        float result;\n        std::istringstream iss(str);\n        iss >> result;\n        return result;\n    }\n    throw std::runtime_error(\"Unsupported type\");\n}\n\nstd::string compare_one(boost::any a, boost::any b) {\n    // Convert inputs to floats if necessary\n    float val_a = convert_to_float(a);\n    float val_b = convert_to_float(b);\n\n    // Compare the values and determine the larger one or \"None\"\n    if (val_a == val_b) {\n        return \"None\";\n    } else if (val_a > val_b) {\n        return a.type() == typeid(float) ? std::to_string(val_a) : boost::any_cast<std::string>(a);\n    } else {\n        return b.type() == typeid(float) ? std::to_string(val_b) : boost::any_cast<std::string>(b);\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute the Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply the current factorial value with the result\n    }\n    return result;\n}\n\n// Function to test the correctness of the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << endl; // Output should be 288\n    cout << \"special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << endl; // Output should be 34560\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += \"-\";\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <regex>\n#include <string>\n\nstd::string file_name_check(std::string file_name) {\n    // Regular expression pattern for validating the file name\n    std::regex pattern(R\"(^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*(txt|exe|dll)$)\");\n\n    // Check if the file name matches the pattern and has exactly one dot\n    if (std::regex_match(file_name, pattern) && std::count(file_name.begin(), file_name.end(), '.') == 1) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n#include <algorithm>\n\nint sum_squares(const std::vector<int>& lst) {\n    int total_sum = 0;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            total_sum += lst[i] * lst[i]; // Square the value\n        } else if ((i + 1) % 4 == 0) {\n            total_sum += lst[i] * lst[i] * lst[i]; // Cube the value\n        }\n    }\n\n    return total_sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) {\n        // Check if the length of the current word is a prime number\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a string fraction into numerator and denominator integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    int numX, denX;\n    parseFraction(x, numX, denX);\n\n    int numN, denN;\n    parseFraction(n, numN, denN);\n\n    // Compute the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the result\n    int prodDen = denX * denN;  // Denominator of the result\n\n    // Simplify the fraction by dividing numerator and denominator with their GCD\n    int commonDivisor = gcd(prodNum, prodDen);\n    prodNum /= commonDivisor;\n    prodDen /= commonDivisor;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1)\n    return prodDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint sum_of_digits(int num) {\n    if (num == 0)\n        return 0;\n    \n    bool is_negative = num < 0;\n    int digits_sum = 0;\n\n    while (num != 0) {\n        int digit = abs(num % 10);\n        digits_sum += (digit * (!is_negative ? 1 : -1));\n        num /= 10;\n        if (num >= 0)\n            is_negative = false;\n    }\n    \n    return digits_sum;\n}\n\n// Function to sort the vector of integers based on the sum of their digits\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Create a list of tuples with the sum of digits, original index, and number itself\n    std::vector<std::tuple<int, int, int>> indexed_nums;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back(std::make_tuple(sum_of_digits(nums[i]), i, nums[i]));\n    }\n    \n    // Sort the list of tuples by the sum of digits and then by original index\n    std::sort(indexed_nums.begin(), indexed_nums.end(),\n              [](const auto& a, const auto& b) {\n                  if (std::get<0>(a) == std::get<0>(b))\n                      return std::get<1>(a) < std::get<1>(b);\n                  else\n                      return std::get<0>(a) < std::get<0>(b);\n              });\n    \n    // Extract and return the sorted numbers based on the new order\n    std::vector<int> result;\n    for (const auto& tuple : indexed_nums) {\n        result.push_back(std::get<2>(tuple));\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || \n                       firstDigit == '5' || firstDigit == '7' ||\n                       firstDigit == '9');\n    \n    bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || \n                      lastDigit == '5' || lastDigit == '7' ||\n                      lastDigit == '9');\n    \n    return isFirstOdd && isLastOdd;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula i * i - i + 1\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    bool valid_planet1 = false, valid_planet2 = false;\n\n    // Find the indices of planet1 and planet2 in the planets vector.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            valid_planet1 = true;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n            valid_planet2 = true;\n        }\n\n        // If both planets are found, break the loop.\n        if (valid_planet1 && valid_planet2)\n            break;\n    }\n\n    // Return an empty vector if either planet is not a valid name.\n    if (!valid_planet1 || !valid_planet2) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order of planets between them.\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    \n    // Collect all planets that are located between planet1 and planet2.\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test_bf() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort strings first by length and then lexicographically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;  // Alphabetical order for same lengths\n    }\n    return a.length() < b.length();  // Length-based sorting\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {  // Check even length\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    // Check if n is a prime number using the helper function\n    if (is_prime(n)) {\n        return x;  // Return x if n is prime\n    } else {\n        return y;  // Return y otherwise\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        if (num >= 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum_of_squares += std::pow(static_cast<int>(num), 2);\n        }\n    }\n\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = compare({1,2,3,4,5,1}, {1,2,3,4,2,-2});\n    for (int i : res1) printf(\"%d \", i); // Expected: 0 0 0 0 3 3\n    \n    std::cout << \"\\n\";\n    \n    auto res2 = compare({0,5,0,0,0,4}, {4,1,1,0,0,-2});\n    for (int i : res2) printf(\"%d \", i); // Expected: 4 4 1 0 0 6\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on its name.\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) {\n            uppercase++;\n        } else if (islower(c)) {\n            lowercase++;\n        }\n    }\n    \n    return uppercase - lowercase;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() == 1)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated_a = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return concatenated_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n\nstd::vector<int> even_odd_count(int num) {\n    // Handle negative numbers by converting to positive\n    if (num < 0) {\n        num = -num;\n    }\n    \n    int even_count = 0;\n    int odd_count = 0;\n\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},  {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},    {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with given examples\nvoid check() {\n    cout << \"19 -> \" << int_to_mini_roman(19) << endl;  // Expected: xix\n    cout << \"152 -> \" << int_to_mini_roman(152) << endl; // Expected: clii\n    cout << \"426 -> \" << int_to_mini_roman(426) << endl; // Expected: cdxxvi\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    float hypotenuse = sides[2]; // The largest value will be at index 2\n\n    // Check if it's a right-angled triangle using Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1]) == (hypotenuse * hypotenuse);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // for std::sort and std::unique\n#include <set>       // to count unique characters\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) return \"\";  // Handle empty vector case\n    \n    auto max_unique_chars = 0;\n    std::string result;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        \n        int current_unique_count = unique_chars.size();\n        \n        if (current_unique_count > max_unique_chars || \n            (current_unique_count == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_count;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total number of carrots to eat after meals\n    int totalToEat = number + need;\n    \n    // If there are enough remaining carrots, calculate the new counts\n    if (remaining >= need) {\n        return {totalToEat, remaining - need};\n    }\n    // Otherwise, eat all remaining carrots and be still hungry\n    else {\n        return {number + remaining, 0};\n    }\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n\n// Function signature changed to use const references\nint do_algebra(const std::vector<std::string>& operators, const std::vector<int>& operands) {\n    int result = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // Note: This will perform integer division\n        } else if (operators[i] == \"**\") {\n            int power = operands[i + 1];\n            for (int j = 0; j < power - 1; ++j) {\n                result *= operands[i + 1];\n            }\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed\n        for (char &c : s) {\n            if (isLetter(c)) c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\n// Function to convert byte array to hexadecimal string\nstring bytes_to_hex(const unsigned char* data, size_t len) {\n    static const char hex_digits[] = \"0123456789abcdef\";\n    string hex;\n    for (size_t i = 0; i < len; ++i) {\n        hex += hex_digits[(data[i] >> 4) & 0x0F];\n        hex += hex_digits[data[i] & 0x0F];\n    }\n    return hex;\n}\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure that `a` is less than or equal to `b`\n    int start = min(a, b);\n    int end = max(a, b);\n\n    vector<int> even_digits;\n    \n    // Iterate through the range from start to end\n    for (int num = start; num <= end; ++num) {\n        if (num % 2 == 0 && num < 10) {\n            even_digits.push_back(num);\n        }\n    }\n\n    return even_digits;\n}\n"}
