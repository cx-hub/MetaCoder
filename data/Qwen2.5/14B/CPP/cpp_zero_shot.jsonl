{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>  // For std::fabs\n\nbool has_close_elements(const std::vector<float>& numbers, float threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    int balance = 0; // Tracks the number of open parentheses without a matching close parenthesis.\n    size_t start_index = 0; // Start index for each group.\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(' || paren_string[i] == ')') { // Only consider parentheses, ignore spaces.\n            if (paren_string[i] == '(') {\n                balance++;\n            } else if (paren_string[i] == ')') {\n                balance--;\n            }\n\n            // When the balance is zero, we've found a complete group of parentheses.\n            if (balance == 0 && i > start_index) {\n                groups.push_back(paren_string.substr(start_index, i - start_index + 1));\n                start_index = i + 1; // Update the start index for the next group.\n            }\n        } else if (paren_string[i] != ' ') { // If it's not a parenthesis and not a space, ignore it.\n            throw std::invalid_argument(\"Input string contains invalid characters.\");\n        }\n    }\n\n    return groups;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For std::floor\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);\n    return number - integer_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n    \n    return false; // If no point where balance is below zero, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    std::size_t result_size = numbers.size() * 2 - (numbers.empty() ? 0 : 1);\n    \n    // Create a new vector and reserve space to avoid reallocations.\n    std::vector<int> result;\n    result.reserve(result_size);\n\n    if (!numbers.empty()) {\n        for (std::size_t i = 0; i < numbers.size(); ++i) {\n            result.push_back(numbers[i]);\n            if (i != numbers.size() - 1) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector elements\nvoid print_vector(const std::vector<int>& vec) {\n    for (const auto& elem : vec) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    int current_depth = 0, max_depth = 0;\n\n    for (size_t i = 0; i <= paren_string.length(); ++i) {\n        if (i == paren_string.length() || paren_string[i] == ' ') { // End of a group or end of string\n            result.push_back(max_depth);\n            current_depth = max_depth = 0;\n            continue;\n        }\n\n        if (paren_string[i] == '(') {\n            ++current_depth;\n            if (current_depth > max_depth) {\n                max_depth = current_depth;\n            }\n        } else if (paren_string[i] == ')') {\n            --current_depth;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Create an empty vector to store filtered strings\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n\nstd::pair<int, int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;       // Add each number to the sum\n        product *= num;   // Multiply each number with the product\n    }\n\n    return {sum, product}; // Return a pair of sum and product\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    auto result1 = sum_product({});\n    std::cout << \"Sum: \" << result1.first << \", Product: \" << result1.second << std::endl; // Should print Sum: 0, Product: 1\n\n    auto result2 = sum_product({1, 2, 3, 4});\n    std::cout << \"Sum: \" << result2.first << \", Product: \" << result2.second << std::endl; // Should print Sum: 10, Product: 24\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm> // for std::max\n\nstd::vector<int> rolling_max(const std::vector<int>& numbers) {\n    std::vector<int> max_values;\n    int current_max = INT_MIN; // Initialize with the smallest possible integer value\n    \n    for (int num : numbers) {\n        current_max = std::max(current_max, num); // Update the current maximum\n        max_values.push_back(current_max); // Add the current maximum to the result vector\n    }\n    \n    return max_values;\n}\n\n// Example usage and verification function\nvoid check_rolling_max() {\n    std::vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    std::vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    \n    std::vector<int> result = rolling_max(input);\n    \n    bool is_correct = true;\n    for (size_t i = 0; i < expected_output.size(); ++i) {\n        if (result[i] != expected_output[i]) {\n            is_correct = false;\n            break;\n        }\n    }\n\n    if (is_correct) {\n        printf(\"The function works correctly.\\n\");\n    } else {\n        printf(\"There seems to be an error in the function implementation.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    return string(str.rbegin(), str.rend()) == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n     Find the shortest palindrome that begins with a supplied string. \n     Algorithm idea: - Find the longest postfix of supplied string that is a palindrome.\n                      - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    \n    // Start from the full length and decrease until we find the longest palindromic suffix\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Found a palindromic suffix starting at index i\n            string prefix_to_reverse = str.substr(0, i);\n            return str + string(prefix_to_reverse.rbegin(), prefix_to_reverse.rend());\n        }\n    }\n\n    // If the entire string is already a palindrome, no need to add anything.\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of the same length\");\n    }\n\n    std::string result = \"\";\n    \n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR on each pair of characters\n        if (a[i] == b[i]) {\n            result += '0';  // Both bits are the same, so XOR is 0\n        } else {\n            result += '1';  // Bits are different, so XOR is 1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings.\n    }\n\n    string longest_string = strings[0];  // Initialize with the first string in the list\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_string.length()) {  // Check if current string is longer\n            longest_string = str;  // Update longest_string to the current one\n        }\n    }\n\n    return longest_string;\n}\n\n// Example usage and check function\nvoid check_longest() {\n    assert(longest({}) == \"\");\n    assert(longest({\"a\", \"b\", \"c\"}) == \"a\");\n    assert(longest({\"a\", \"bb\", \"ccc\"}) == \"ccc\");\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\n// Function to calculate GCD using Euclidean algorithm\nint gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    \n    // Iterate through each character in the string and add substrings from start to current index as prefixes.\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    \n    return prefixes;\n}\n\n// Function to print vector of strings\nvoid print_vector(const vector<string>& vec){\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i){\n        if(i != 0) cout << \", \";\n        cout << \"\\\"\" << vec[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";  // Initialize an empty string for the result\n    \n    for (int i = 0; i <= n; ++i) {  // Loop from 0 to n inclusive\n        result += to_string(i);      // Convert integer to string and append it\n        if (i < n) {\n            result += \" \";           // Append a space, except after the last number\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of string_sequence function\nvoid check_function() {\n    cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\" << endl;  // Expected: \"0\"\n    cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\" << endl;  // Expected: \"0 1 2 3 4 5\"\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert all characters to lowercase and store unique ones in a set\n    unordered_set<char> distinct_chars;\n    \n    for (char c : str) {\n        distinct_chars.insert(tolower(c));\n    }\n    \n    return distinct_chars.size();\n}\n\n// Function to test the implementation with given examples\nvoid check_function() {\n    cout << \"count_distinct_characters(\\\"xyzXYZ\\\") = \" \n         << count_distinct_characters(\"xyzXYZ\") << endl; // Expected output: 3\n    cout << \"count_distinct_characters(\\\"Jerry\\\") = \"\n         << count_distinct_characters(\"Jerry\") << endl; // Expected output: 4\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    int i = 0, n = music_string.length();\n    \n    while (i < n) {\n        if (music_string[i] == 'o') { // whole note\n            result.push_back(4);\n            i++;\n        } else if (music_string.substr(i, 2) == \"o|\") { // half note\n            result.push_back(2);\n            i += 2;\n        } else if (music_string.substr(i, 2) == \".|\") { // quarter note\n            result.push_back(1);\n            i += 2;\n        } else {\n            // Handle unexpected characters or sequences\n            cout << \"Unexpected character sequence at index: \" << i << endl;\n            return {};\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move to the next character for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n// Function to sort numbers represented as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Map of number words to their integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values of the input words\n    vector<int> num_values;\n\n    // Split the string into individual words and convert them to integers\n    stringstream ss(numbers);\n    string word;\n    while (ss >> word) {\n        if (num_map.find(word) != num_map.end()) {\n            num_values.push_back(num_map[word]);\n        }\n    }\n\n    // Sort the vector of integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert sorted integers back to words and concatenate them into a single string\n    stringstream result;\n    for (int i = 0; i < num_values.size(); ++i) {\n        if (i > 0) result << \" \";\n        for (auto const& entry : num_map) {\n            if (entry.second == num_values[i]) {\n                result << entry.first;\n                break;\n            }\n        }\n    }\n\n    return result.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    // Iterate through the sorted vector to find the closest elements.\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if ((numbers[i] - numbers[i-1]) < min_diff) {\n            min_diff = numbers[i] - numbers[i-1];\n            closest_pair = make_pair(numbers[i-1], numbers[i]);\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            integers.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return integers;\n}\n\n// Example usage and check function\n#include <iostream>\n#include <cassert>\n\nvoid check_filter_integers() {\n    list_any test1 = { \"a\", 3.14, 5 };\n    assert((filter_integers(test1) == std::vector<int>{5}));\n\n    list_any test2 = { 1, 2, 3, \"abc\", {}, {} };\n    assert((filter_integers(test2) == std::vector<int>{1, 2, 3}));\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the length of a C-string\nint strlen(const char* str) {\n    int len = 0;\n    while (*str++) // Increment pointer and check if it points to '\\0'\n        ++len;     // If not, increment length counter\n    return len;    // Return the calculated length\n}\n\n// Function to test the implementation with provided data points\nvoid test_strlen() {\n    cout << \"strlen(\\\"\\\") = \" << strlen(\"\") << endl;\n    cout << \"strlen(\\\"abc\\\") = \" << strlen(\"abc\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start checking from n-1 and go downwards until we find a divisor.\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen with positive integers,\n    // return -1 or throw an exception.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide n by 2 as many times as possible\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2 && is_prime(n)) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Example usage and verification function\nvoid check_factorize() {\n    vector<int> result1 = factorize(8);\n    for(int i : result1) printf(\"%d \", i); // Expected: 2 2 2\n\n    printf(\"\\n\");\n\n    vector<int> result2 = factorize(25);\n    for(int i : result2) printf(\"%d \", i); // Expected: 5 5\n\n    printf(\"\\n\");\n\n    vector<int> result3 = factorize(70);\n    for(int i : result3) printf(\"%d \", i); // Expected: 2 5 7\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Count occurrences of each element\n    map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Step 2: Add elements that occur only once to the result vector\n    vector<int> uniqueNumbers;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            uniqueNumbers.push_back(num);\n        }\n    }\n\n    return uniqueNumbers;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    printf(\"{\");\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) printf(\", \");\n        printf(\"%d\", vec[i]);\n    }\n    printf(\"}\\n\");\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate through each character in the string\n        if (islower(c)) {  // If it is a lowercase letter\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // If it is an uppercase letter\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with given examples\nvoid check() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the input vector\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is positive\n            result.push_back(num);  // Add it to the result vector\n        }\n    }\n\n    return result;  // Return the vector containing only positive numbers\n}\n\n// Function to print elements of a float vector for testing purposes\nvoid print_vector(const vector<float>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << static_cast<int>(vec[i]);  // Casting to int for cleaner output\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    \n    // If no divisors were found, n is prime.\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); ++i)\n        sum += xs[i] * pow(x, i);\n    return sum;\n}\n\ndouble dpoly(const std::vector<double>& xs, double x) {\n    // Derivative of the polynomial\n    double sum = 0;\n    int i;\n    for (i = 1; i < xs.size(); ++i)\n        sum += i * xs[i] * pow(x, i - 1);\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Newton-Raphson method to find a root of the polynomial\n    double x0 = 0; // Initial guess\n    const double epsilon = 1e-7; // Precision for stopping criterion\n\n    while (true) {\n        double fx = poly(xs, x0);\n        if (fabs(fx) < epsilon)\n            break;\n        \n        double dfx = dpoly(xs, x0); // Derivative of the polynomial\n        if (dfx == 0) { \n            std::cerr << \"Derivative is zero. No solution found.\" << std::endl;\n            return NAN; \n        }\n        \n        x0 -= fx / dfx; // Newton-Raphson iteration\n    }\n\n    return x0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    // Step 1: Extract elements that are at indices divisible by three.\n    std::vector<int> to_sort;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Note: We use (i+1) because we want indices that are divisible by 3, not the elements themselves.\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort those extracted elements.\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Step 3: Replace original elements at indices divisible by three with sorted elements.\n    size_t sort_index = 0; // Index in the 'to_sort' vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0 && sort_index < to_sort.size()) { // Ensure we don't go out of bounds.\n            l[i] = to_sort[sort_index++];\n        }\n    }\n\n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm> // for sort and unique algorithms\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the vector to bring duplicates together\n    sort(l.begin(), l.end());\n    \n    // Step 2: Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end()); \n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) { // Check if vector is empty\n        return NAN; // Return Not a Number if the vector is empty\n    }\n    \n    float max_value = l[0]; // Initialize with the first element\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        max_value = std::max(max_value, l[i]); // Update max_value if current element is greater\n    }\n\n    return max_value;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<float> v1 = {1.0f, 2.0f, 3.0f};\n    printf(\"Max of [1, 2, 3]: %.0f\\n\", max_element(v1)); // Should print: Max of [1, 2, 3]: 3\n\n    vector<float> v2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n    printf(\"Max of [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]: %.0f\\n\", max_element(v2)); // Should print: Max of [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]: 123\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n\nint count_sevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7)\n            count++;\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n\n    for (int i = 1; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0)) {\n            total_count += count_sevens(i);\n        }\n    }\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract elements at even indices and store them in a separate vector.\n    std::vector<float> evens;\n    \n    // Populate the 'evens' vector with values from even indices of 'l'.\n    for (size_t i = 1; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements.\n    std::sort(evens.begin(), evens.end());\n    \n    // Create a new vector to hold the result, initially copying all of 'l'.\n    std::vector<float> sorted_l = l;\n    \n    // Replace even indices in 'sorted_l' with sorted values from 'evens'.\n    size_t j = 0; // Index for iterating through 'evens'\n    for (size_t i = 1; i < sorted_l.size(); i += 2) {\n        if (j < evens.size()) { // Ensure we don't go out of bounds\n            sorted_l[i] = evens[j++];\n        }\n    }\n\n    return sorted_l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string decoded;\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract the current group of three characters\n        string group = s.substr(i * 3, 3);\n        \n        if (group.length() == 3) {\n            // For groups with exactly 3 characters, move the last character to the beginning\n            decoded += group.substr(2, 1) + group.substr(0, 2);\n        } else {\n            // Append any remaining characters as they are\n            decoded += group;\n        }\n    }\n\n    return decoded;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1, fib3 = 1;\n    int count = 0;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached if input is valid\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector first for efficient searching\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Test cases\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Each car going in one direction will collide with each car going in the opposite direction.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nstd::vector<int> incr_vector(const std::vector<int>& l) {\n    std::vector<int> result;\n    for (int i : l) {\n        result.push_back(i + 1);\n    }\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a hash set to store elements as we iterate through the vector.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set.\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    // If no such pair is found, return false.\n    return false;\n}\n\n// Function to test the pairs_sum_to_zero function with given examples\nvoid check_function() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1) { // Handle invalid bases\n        return \"\";\n    }\n\n    std::string result = \"\"; // Initialize the result string\n\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder when divided by the base\n        result = char('0' + remainder) + result; // Convert to character and prepend to result\n        x /= base; // Divide x by the base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result; // Return \"0\" if result is empty (which happens when x was 0)\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float base, float height) {\n    return 0.5 * base * height;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases for the first few values of n\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    \n    // Initialize an array to hold the last four elements in the sequence\n    int fib[4] = {0, 0, 2, 0};\n    \n    // If n is less than or equal to 3, we've already handled it above.\n    if (n <= 3)\n        return fib[n];\n    \n    // Compute the next values iteratively until reaching n\n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib[0] + fib[1] + fib[2] + fib[3];\n        \n        // Shift elements in the array to make room for the new value\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_value;\n    }\n    \n    return fib[3];  // The last element will hold the result for n\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::floor and std::ceil\n\nfloat median(std::vector<float> l) {\n    size_t n = l.size();\n    \n    // Sort the vector in ascending order.\n    std::sort(l.begin(), l.end());\n    \n    if (n % 2 == 0) { // If even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // If odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // If characters at the current positions do not match, it's not a palindrome\n        }\n        left++; // Move towards the center from the left side\n        right--; // Move towards the center from the right side\n    }\n\n    return true; // The string is a palindrome if all corresponding characters matched\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Base case: any number to the power of 0 is 1.\n    \n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply result by base and take modulo p\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adjusting the formula to shift back by 5\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Convert character to lowercase to handle both cases uniformly.\n        char lower_c = std::tolower(c);\n        \n        // Check if the character is not a vowel and add it to the result string.\n        if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with given examples.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage and check function\nvoid check_function() {\n    bool result1 = below_threshold({1, 2, 4, 10}, 100);\n    printf(\"below_threshold({1, 2, 4, 10}, 100) should be true: %d\\n\", result1);\n\n    bool result2 = below_threshold({1, 20, 4, 10}, 5);\n    printf(\"below_threshold({1, 20, 4, 10}, 5) should be false: %d\\n\", result2);\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Use C++ iostream for input/output\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from the first string\n    auto new_end = std::unique(s0.begin(), s0.end());\n    s0.erase(new_end, s0.end());\n\n    // Remove duplicates from the second string\n    new_end = std::unique(s1.begin(), s1.end());\n    s1.erase(new_end, s1.end());\n\n    // Compare both strings after sorting and removing duplicates\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    // Base case: return 0 for n=0, and 1 for n=1\n    if (n <= 1) {\n        return n;\n    }\n    \n    // Recursive call to calculate the nth Fibonacci number\n    return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (!stack.empty() && stack.top() == '<') {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all brackets are correctly matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // If the vector has less than two elements, it is trivially monotonic.\n    if (l.size() < 2) return true;\n    \n    bool increasing = l[1] >= l[0];\n    \n    for (size_t i = 2; i < l.size(); ++i) {\n        // Check if the sequence breaks the initial trend\n        if ((increasing && l[i] < l[i - 1]) || (!increasing && l[i] > l[i - 1])) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get sorted unique common elements from two vectors\nvector<int> common(vector<int>& l1, vector<int>& l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates within each vector\n    auto last_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_l1, l1.end());\n\n    auto last_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_l2, l2.end());\n\n    // Find common elements using set_intersection\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    return result;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start checking from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number and greater than 2\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << \"\\n\";\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << \"\\n\";\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test and print results\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \"\\n\";\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \"\\n\";\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \"\\n\";\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \"\\n\";\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \"\\n\";\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0; // Initialize balance to track open and closed parentheses\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            balance++; // Increment balance for an opening parenthesis\n        } else if (c == ')') {\n            balance--; // Decrement balance for a closing parenthesis\n        }\n\n        if (balance < 0) {\n            return false; // If balance is negative, there are more closing brackets than opening ones before this point\n        }\n    }\n\n    return balance == 0; // Return true only if the final balance is zero\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // The result starts with one less coefficient than the input.\n    vector<float> result(xs.size() - 1);\n\n    for (size_t i = 0; i < xs.size() - 1; ++i) {\n        result[i] = static_cast<float>(i + 1) * xs[i + 1];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize an array to store FibFib values up to n\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n]; // Return the computed value of fibfib(n)\n}\n\n// Function to test and print results\nvoid check(int n, int expected) {\n    cout << \"fibfib(\" << n << \") = \" << fibfib(n);\n    if (expected == fibfib(n))\n        cout << \", Correct\" << endl;\n    else\n        cout << \", Incorrect\" << endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert entire string to lowercase\n    transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Iterate through each character in the string\n    for (int i = 0; i < lower_s.length(); ++i) {\n        char c = lower_s[i];\n        \n        // Check if current character is a vowel\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Special case for 'y'\n    if (!lower_s.empty() && lower_s[lower_s.length() - 1] == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert integer x into a string representation\nstring intToString(int x) {\n    if (x == 0) return \"0\";\n    bool isNegative = false;\n    if (x < 0) {\n        isNegative = true;\n        x = -x; // Make x positive for conversion\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        result += '0' + (x % 10); // Convert last digit to char and append\n        x /= 10; // Remove the last digit from x\n    }\n\n    if (isNegative)\n        result += '-'; // Add negative sign if necessary\n\n    reverse(result.begin(), result.end()); // Reverse the string to get correct order\n    return result;\n}\n\n// Function to perform circular shift on digits of integer x by shift positions\nstring circular_shift(int x, int shift) {\n    string str_x = intToString(x); // Convert integer to string\n    \n    if (shift >= str_x.length()) { // If shift is greater than or equal to number of digits\n        reverse(str_x.begin(), str_x.end()); // Reverse the string\n        return str_x;\n    }\n    \n    // Perform circular right shift by moving last 'shift' characters to front\n    int n = str_x.length();\n    string shifted_str = str_x.substr(n - shift) + str_x.substr(0, n - shift);\n    \n    return shifted_str;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    cout << \"circular_shift(12, 1): \" << circular_shift(12, 1) << endl; // Expected: \"21\"\n    cout << \"circular_shift(12, 2): \" << circular_shift(12, 2) << endl; // Expected: \"12\"\n    cout << \"circular_shift(-34567, 3): \" << circular_shift(-34567, 3) << endl; // Expected: \"-73456\"\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract numbers from the string using stringstream\n    int apples = 0;\n    int oranges = 0;\n    \n    // Use stringstream to parse the input string\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Read number of apples\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Read number of oranges\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX;\n    int minIndex = -1;\n\n    // Iterate through the vector to find the smallest even value and its index.\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if it's an even number and smaller or equal to current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // Ensure we pick the smallest index in case of ties.\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector.\n    if (minIndex == -1)\n        return {};\n    \n    // Return the result as a vector containing {smallest_even_value, its_index}.\n    return {minEvenValue, minIndex};\n}\n\n// Example usage and check function\nvoid check() {\n    assert(pluck({4,2,3}) == vector<int>({2, 1}));\n    assert(pluck({1,2,3}) == vector<int>({2, 1}));\n    assert(pluck({}) == vector<int>({}));\n    assert(pluck({5,0,3,0,4,2}) == vector<int>({0, 1}));\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that meets the condition\n    int result = -1; // Initialize result to -1 if no such element exists\n    for (const auto& entry : freq) {\n        int num = entry.first;\n        int count = entry.second;\n\n        // Check if the frequency is greater than or equal to the number itself\n        if (count >= num && num > result) {\n            result = num; // Update result with the maximum valid integer found so far\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    std::sort(lst.begin(), lst.end());  // Sort the list first\n    \n    int start = 0;  // Start index (minimum value)\n    int end = lst.size() - 1;  // End index (maximum value)\n    \n    std::vector<int> result;\n    \n    while (start <= end) {\n        if (start == end) {  // If only one element is left\n            result.push_back(lst[start]);\n            break;\n        }\n        \n        result.push_back(lst[start++]);  // Add the minimum and increment start index\n        result.push_back(lst[end--]);   // Add the maximum and decrement end index\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath> // For sqrt() function\n\n// Function to calculate the area of a triangle given its three sides.\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter of the triangle\n    float s = (a + b + c) / 2.0f;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements in q is less than or equal to w.\n    int sum = 0;\n    for (int i : q) {\n        sum += i;\n    }\n    \n    // If the sum exceeds the maximum possible weight, return false.\n    if (sum > w) {\n        return false;\n    }\n\n    // Check if the vector is balanced (palindromic).\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    // If both conditions are satisfied, the object will fly.\n    return true;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0; // Start from the beginning of the vector\n    int right = arr.size() - 1; // Start from the end of the vector\n\n    while (left < right) { // Continue until pointers meet or cross\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change counter when elements do not match\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return the total number of required changes\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count total number of characters in a vector of strings\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Count the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector or both if equal\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if they are equal\n    }\n}\n\n// Example usage and verification\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Utility function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the number can be expressed as a product of exactly three primes\nbool is_multiply_prime(int num) {\n    // Early exit for numbers less than the smallest cube of prime (2*2*2=8)\n    if (num < 8) return false;\n\n    int count = 0;\n    for (int i = 2; i <= 100 && count < 3; ++i) {\n        // Check if 'i' is a factor and also prime\n        if (num % i == 0 && isPrime(i)) {\n            num /= i;\n            count++;\n        }\n    }\n\n    // If the remaining number after division by primes is not 1, it means there's an extra prime or non-prime factor.\n    return count == 3 && num == 1;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: only 1^k = 1 for any k.\n    }\n    \n    double log_result = std::log(x) / std::log(n);\n    \n    // Check if the result of the logarithm is an integer\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a' and round it to the nearest integer.\n    int cubeRoot = std::round(std::cbrt(a));\n    \n    // Check if the cube of the rounded value equals 'a'.\n    return (cubeRoot * cubeRoot * cubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    int prime_count = 0;\n    \n    // Mapping of hexadecimal characters to their decimal values for easy checking.\n    const char* primes_hex = \"2357BD\";\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime digit by looking it up in the primes_hex string.\n        if (std::strchr(primes_hex, c)) {\n            ++prime_count;\n        }\n    }\n\n    return prime_count;\n}\n\n// Function to test the correctness of hex_key function with given data points.\nvoid check_function() {\n    assert(hex_key(\"AB\") == 1);\n    assert(hex_key(\"1077E\") == 2);\n    assert(hex_key(\"ABED1A33\") == 4);\n    assert(hex_key(\"123456789ABCDEF0\") == 6);\n    assert(hex_key(\"2020\") == 2);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert decimal to binary and format it with 'db' prefix and suffix\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary string\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    \n    // Add \"db\" at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string to check every 3 consecutive letters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        char first = s[i];\n        char second = s[i + 1];\n        char third = s[i + 2];\n\n        // Check if all three characters are distinct\n        if (first == second || second == third || first == third)\n            return false;\n    }\n    \n    // If the loop completes without returning false, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    // Define the mapping from GPA ranges to letter grades.\n    vector<pair<float, string>> grade_map = {\n        {4.0f, \"A+\"}, \n        {3.7f, \"A\"}, \n        {3.3f, \"A-\"},\n        {3.0f, \"B+\"},\n        {2.7f, \"B\"},\n        {2.3f, \"B-\"},\n        {2.0f, \"C+\"},\n        {1.7f, \"C\"},\n        {1.3f, \"C-\"},\n        {1.0f, \"D+\"},\n        {0.7f, \"D\"},\n        {0.0f, \"D-\"},\n        {-1.0f, \"E\"} // This is a placeholder for GPAs below 0.0\n    };\n\n    vector<string> letter_grades;\n\n    for (float gpa : grades) {\n        string grade = \"E\"; // Default to E if GPA does not match any range.\n        \n        for (const auto& entry : grade_map) {\n            if (gpa >= entry.first) {\n                grade = entry.second;\n                break; // Once a matching or higher GPA is found, stop searching.\n            }\n        }\n\n        letter_grades.push_back(grade);\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to count numbers that start or end with 1\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Only one number, which is '1'\n    \n    // For n-digit numbers:\n    // - There are 9 * (10^(n-2)) numbers starting with 1 but not ending with 1\n    // - There are 9 * (10^(n-2)) numbers ending with 1 but not starting with 1\n    // - There is exactly one number that both starts and ends with 1 for n > 1\n    \n    int count = 2 * (9 * pow(10, n - 2)); // Counting those that start or end with 1\n    if (n > 1) {\n        count += 1; // Adding the one number that starts and ends with 1\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 == 1 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sum = 0;\n\n    // Sum all digits of the number\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to sum\n        N /= 10;        // Remove the last digit from N\n    }\n\n    // Convert the sum into binary and return it\n    return intToBinary(sum);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) { // Check if the element at this index is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n// Function to sort characters of a string\nvoid sortWord(string &word) {\n    sort(word.begin(), word.end());\n}\n\n// Main function that takes a sentence and returns an ordered version of it.\nstring anti_shuffle(const string& s) {\n    string result;\n    size_t start = 0; // Start index of the current word\n    for (size_t i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] == ' ') { // End of a word or end of sentence\n            string word = s.substr(start, i - start);\n            sortWord(word); // Sort the characters in the word\n            result += word;\n            if (i < s.length()) {\n                result += ' '; // Add space after each word except the last one\n            }\n            start = i + 1; // Move to the next word\n        }\n    }\n    return result;\n}\n\n// Function to test the anti_shuffle function with some examples.\nvoid check() {\n    cout << \"anti_shuffle(\\\"Hi\\\") returns \\\"\" << anti_shuffle(\"Hi\") << \"\\\"\\n\";\n    cout << \"anti_shuffle(\\\"hello\\\") returns \\\"\" << anti_shuffle(\"hello\") << \"\\\"\\n\";\n    cout << \"anti_shuffle(\\\"Hello World!!!\\\") returns \\\"\" << anti_shuffle(\"Hello World!!!\") << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for convenience\n    Coordinate(int r, int c) : row(r), col(c) {}\n\n    // Overload operator< to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row) return col > other.col;  // Descending order for columns\n        return row < other.row;                        // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through each row and column to find occurrences of x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back(Coordinate(i, j));\n            }\n        }\n    }\n\n    // Sort the coordinates as per the requirements\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects back to vector<int> for the final result\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage and verification function\nvoid check() {\n    auto res1 = get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1);\n    for (const auto& coord : res1) {\n        printf(\"{%d, %d} \", coord[0], coord[1]);\n    }\n    // Expected output: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n\n    auto res2 = get_row({}, 1);\n    printf(\"\\n\");\n    for (const auto& coord : res2) {\n        printf(\"{%d, %d} \", coord[0], coord[1]);\n    }\n    // Expected output: {}\n\n    auto res3 = get_row({{}, {1}, {1, 2, 3}}, 3);\n    printf(\"\\n\");\n    for (const auto& coord : res3) {\n        printf(\"{%d, %d} \", coord[0], coord[1]);\n    }\n    // Expected output: {{2, 2}}\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the input vector is empty or contains only one element, return a copy.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Create a copy of the input vector to sort\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    std::string result = \"\";\n    \n    for (char c : s) {\n        // Check if character is lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            char rotated_char = ((c - 'a' + 4) % 26) + 'a';\n            result += rotated_char;\n        }\n        // If the character is not a lowercase letter, leave it as is.\n        else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n#include <optional>  // For returning std::nullopt\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) return std::nullopt; // If there are less than two elements, return nullopt\n    \n    // Sort the vector\n    std::sort(lst.begin(), lst.end());\n    \n    // Remove duplicates by creating a new vector with unique elements\n    auto last = std::unique(lst.begin(), lst.end());\n    lst.erase(last, lst.end()); // Erase the non-unique elements from the vector\n    \n    if (lst.size() < 2) return std::nullopt; // If there are less than two unique elements, return nullopt\n    \n    // Return the second smallest element\n    return lst[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string current_sentence = \"\";\n    \n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            // Check the last sentence before delimiter\n            size_t start_index = current_sentence.find_first_not_of(\" \");\n            if (start_index != string::npos && current_sentence.substr(start_index, 2) == \"I \") {\n                boredom_count++;\n            }\n            current_sentence.clear(); // Reset for next sentence\n        } else {\n            current_sentence += c;\n        }\n    }\n\n    // Check the last sentence after loop ends\n    size_t start_index = current_sentence.find_first_not_of(\" \");\n    if (start_index != string::npos && current_sentence.substr(start_index, 2) == \"I \") {\n        boredom_count++;\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool isInteger(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    if (!isInteger(a) || !isInteger(b) || !isInteger(c)) {\n        return false;\n    }\n\n    // Convert floats to integers since they are actually integers\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if one number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\n// Function to replace vowels with the letter two places ahead in the alphabet\nchar replaceVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    string shifted_vowels = \"cgikmoCGIKMO\"; // 'a' -> 'c', 'e' -> 'g', etc.\n    \n    size_t pos = vowels.find(c);\n    if (pos != string::npos) return shifted_vowels[pos];\n    else return c;\n}\n\nstring encode(string message) {\n    for (char &c : message) {\n        // Swap case\n        c = swapCase(c);\n        \n        // Replace vowel with the letter two places ahead in the alphabet\n        if (isalpha(c)) { // Check if it's a letter before replacing vowels\n            c = replaceVowel(c);\n        }\n    }\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumDigits(int num) {\n    int sum = 0;\n    while(num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds the largest prime and returns the sum of its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a value less than any possible prime in the list\n    \n    for(int num : lst) {\n        if(isPrime(num)) { // Check if the number is prime\n            if(num > maxPrime) { // Update maxPrime if current number is larger and prime\n                maxPrime = num;\n            }\n        }\n    }\n\n    return (maxPrime == -1) ? 0 : sumDigits(maxPrime); // Return the sum of digits of the largest prime or 0 if no primes found\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // If any key is not lowercase, set allLowercase to false\n        if (!isLowercase(key)) allLowercase = false;\n        \n        // If any key is not uppercase, set allUppercase to false\n        if (!isUppercase(key)) allUppercase = false;\n\n        // Early exit optimization: if both flags are already false, return false immediately\n        if (!allLowercase && !allUppercase) return false;\n    }\n\n    // Return true only if either all keys are lowercase or all uppercase\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> primes_below_n(int n) {\n    vector<int> result;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digit of both numbers by taking modulo 10\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) { \n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if ((c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    // Parse the string as a floating-point number\n    double num = std::stod(value);\n\n    // Get the integer part and fractional part separately\n    int integer_part = static_cast<int>(num);\n    double fractional_part = num - integer_part;\n\n    // Determine if we need to round up or down based on the fractional part\n    if (fractional_part > 0.5 || (fractional_part == 0.5 && (integer_part % 2 != 0))) {\n        return static_cast<int>(std::copysign(std::ceil(num), num));\n    } else if (fractional_part < -0.5 || (fractional_part == -0.5 && (integer_part % 2 != 0))) {\n        return static_cast<int>(std::copysign(std::floor(num), num));\n    } else {\n        return integer_part;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> levels;\n    \n    // Determine if n is odd or even\n    bool isOdd = (n % 2 != 0);\n    int nextStoneCount = n; // Start with the initial number of stones\n    \n    for (int i = 0; i < n; ++i) {\n        levels.push_back(nextStoneCount); // Add current level's stone count to vector\n        if (isOdd) {\n            // If odd, add 2 to get next odd number\n            nextStoneCount += 2;\n        } else {\n            // If even, add 2 to get next even number\n            nextStoneCount += 2;\n        }\n    }\n\n    return levels;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i : result) {\n        printf(\"%d \", i); // Output should be: 3 5 7\n    }\n    printf(\"\\n\");\n    \n    result = make_a_pile(4);\n    for (int i : result) {\n        printf(\"%d \", i); // Output should be: 4 6 8 10\n    }\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    \n    // Process each token in the input string.\n    while (getline(ss, word, ',')) {  // Split by comma first\n        stringstream wordStream(word);  // Now split this part by spaces\n        string subWord;\n        \n        while (wordStream >> subWord) {\n            result.push_back(subWord);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector of strings for testing purposes.\nvoid printVector(const vector<string>& v) {\n    for (const auto& str : v) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and move backwards until we find an even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {  // Check if the number is even\n            return i;       // Return the first even number found, which will be the largest in this range\n        }\n    }\n\n    // If no even number was found within the range [x, y]\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n through m\n    long total_sum = ((long)m - (long)n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round down to the nearest integer\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <vector>\n#include <algorithm>\n\nbool has_only_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false.\n        n /= 10; // Move to the next digit.\n    }\n    return true; // The number has only odd digits.\n}\n\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_only_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    std::sort(result.begin(), result.end()); // Sort the vector in increasing order.\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    auto res1 = unique_digits({15, 33, 1422, 1});\n    for (int num : res1) std::cout << num << \" \"; // Expected: 1 15 33\n\n    std::cout << \"\\n\";\n\n    auto res2 = unique_digits({152, 323, 1422, 10});\n    for (int num : res2) std::cout << num << \" \"; // Expected: (empty output)\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Function to map digits 1-9 to their names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n    {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Step 1: Filter out integers that are not between 1 and 9\n    std::vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers in ascending order\n    std::sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector to get descending order\n    std::reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map each integer to its corresponding string representation\n    std::vector<std::string> result;\n    for (int num : filtered) {\n        result.push_back(digit_names[num]);\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Function to compute factorial\nint factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the sum of numbers from 1 to n\nint arithmeticSum(int n) {\n    return (n * (n + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int valueAtI;\n        \n        // Calculate factorial or sum based on whether i is even or odd\n        if ((i + 1) % 2 == 0) { // Even index, but we need to calculate for i-1 (which would be odd)\n            valueAtI = arithmeticSum(i);\n        } else {\n            valueAtI = factorial((i + 1));\n        }\n        \n        result[i] = valueAtI;\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int left = 0, right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2); // Initialize the result vector with two elements: [even, odd]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Increment even palindrome count\n            } else {\n                result[1]++; // Increment odd palindrome count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = even_odd_palindrome(3);\n    printf(\"(Even: %d, Odd: %d)\\n\", result[0], result[1]); // Expected output (1, 2)\n    \n    result = even_odd_palindrome(12);\n    printf(\"(Even: %d, Odd: %d)\\n\", result[0], result[1]); // Expected output (4, 6)\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    \n    for(int num : n) {\n        if(num == 0) continue; // Skip zero as it has sum of digits equal to 0\n        \n        int sum_of_digits = 0;\n        bool is_negative = (num < 0);\n        \n        if(is_negative) num = -num; // Work with positive version for simplicity\n        \n        while(num > 0) {\n            int digit = num % 10;\n            sum_of_digits += (is_negative ? -digit : digit); // Adjust sign based on original number\n            is_negative = !is_negative; // Flip the sign flag after each digit\n            num /= 10;\n        }\n        \n        if(sum_of_digits > 0) count++;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the vector is empty, return true.\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    \n    // Find the break point where the order breaks in the array.\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            // Check if the sequence can be sorted by shifting.\n            bool isSortedAfterShift = true;\n            for (int j = i + 1, k = 0; k <= i && isSortedAfterShift; ++k, ++j) {\n                if (j == n) j = 0; // Wrap around to the beginning of the array\n                if (arr[j] < arr[k]) {\n                    isSortedAfterShift = false;\n                }\n            }\n            return isSortedAfterShift;\n        }\n    }\n\n    // If no break point found, the vector is already sorted.\n    return true;\n}\n\n// Example usage and test cases can be added here to verify correctness.\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    \n    // Count the number of odd numbers in lst1.\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCount;\n        }\n    }\n\n    // Check how many even numbers are available in lst2 to replace odd numbers from lst1.\n    int evenCount = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCount;\n        }\n    }\n\n    // If there are enough even numbers in lst2, return \"YES\".\n    if (oddCount <= evenCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Variable to track the highest count\n    int maxCount = 0;\n    \n    // Iterate through each character in the string (ignoring spaces)\n    for (char ch : test) {\n        if (ch != ' ') { // Skip spaces\n            charCount[ch]++;\n            maxCount = max(maxCount, charCount[ch]);\n        }\n    }\n\n    // Filter out characters that do not have the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    bool is_pal = is_palindrome(s);\n\n    vector<string> result;\n    result.push_back(s);\n    if (is_pal) {\n        result.push_back(\"True\");\n    } else {\n        result.push_back(\"False\");\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0; // Count of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        std::string sentence = \"the number of odd elements \";\n        sentence += std::to_string(count);\n        sentence += \"n the str\";\n        sentence += std::to_string(count);\n        sentence += \"ng \";\n        sentence += std::to_string(count);\n        sentence += \" of the \";\n        sentence += std::to_string(count);\n        sentence += \"nput.\";\n\n        result.push_back(sentence);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long current_min = nums[0];\n    long long global_min = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum\n        current_min = std::min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum if needed\n        global_min = std::min(global_min, current_min);\n    }\n    \n    return global_min;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert(minSubArraySum({-1, -2, -3}) == -6);\n    assert(minSubArraySum({1, -3, 2, 1, -1}) == -3);\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_buckets = 0;\n    \n    // Iterate through each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0; // Count of water units in the current well\n        \n        // Sum up all the water units in the current well\n        for (int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        total_buckets += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_buckets;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert(max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert(max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Custom comparator function\nbool customComparator(int a, int b) {\n    // Count the number of 1s in binary representation\n    int countA = std::bitset<32>(a).count();\n    int countB = std::bitset<32>(b).count();\n\n    // If both numbers have the same number of ones, sort by their decimal value\n    if (countA == countB) {\n        return a < b;\n    }\n\n    // Otherwise, sort based on the number of ones in ascending order\n    return countA < countB;\n}\n\nvector<int> sort_array(vector<int> arr){\n    // Sort using custom comparator\n    std::sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words.\n    size_t start = 0;\n    while (start < s.length()) {\n        size_t end = s.find(' ', start);\n        if (end == string::npos) {\n            end = s.length();\n        }\n        \n        // Extract word\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word.\n        int consonant_count = 0;\n        for (char c : word) {\n            if (is_consonant(c)) {\n                ++consonant_count;\n            }\n        }\n\n        // Check if the number of consonants matches n\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n\n        // Move to the next word.\n        start = end + 1;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel\nbool isVowel(char ch) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(ch) != string::npos;\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the first character\n    for (int i = n - 2; i > 0; --i) {\n        char ch = word[i];\n        \n        // Check if the current character is a vowel and surrounded by consonants\n        if (!isVowel(word[i-1]) && !isVowel(ch) && isVowel(word[i+1])) {\n            return string(1, ch);\n        }\n    }\n\n    // Return an empty string if no such vowel exists\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a given string is good (balanced parentheses)\nbool is_good(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n        }\n        // If at any point the number of closing parentheses exceeds opening ones, return false\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // The string is good only if balance is zero at the end\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    bool result1 = is_good(lst[0] + lst[1]);\n    bool result2 = is_good(lst[1] + lst[0]);\n\n    if (result1 || result2) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order.\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Take the first k elements from the sorted vector.\n    vector<int> result;\n    for (int i = 0; i < k && i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the resulting vector in ascending order before returning it.\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> example1 = {-3, -4, 5};\n    vector<int> expected1 = {-4, -3, 5};\n    assert(maximum(example1, 3) == expected1);\n\n    vector<int> example2 = {4, -4, 4};\n    vector<int> expected2 = {4, 4};\n    assert(maximum(example2, 2) == expected2);\n\n    vector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\n    vector<int> expected3 = {2};\n    assert(maximum(example3, 1) == expected3);\n    \n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the vector with a step of 2 to get elements at even positions (considering 0-based indexing)\n    for(size_t i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array.\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits.\n        if (-99 <= arr[i] && arr[i] <= 99) { \n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    int result = add_elements(arr, k);\n    printf(\"Output: %d\\n\", result); // Expected output is 24\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) { // Continue until reaching the number 1\n        if (n % 2 == 1) { // Check if current number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n\n    // Add the last element, which is always 1 and odd\n    odds.push_back(1);\n\n    return odds; // The vector of odd numbers in the Collatz sequence for n\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    int month, day, year;\n    sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n    \n    // Validate the parsed values.\n    if (month < 1 || month > 12) return false; // Month must be between 1 and 12.\n    \n    int max_days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (month == 2 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) {\n        max_days[2] = 29; // Leap year check.\n    }\n    \n    if (day < 1 || day > max_days[month]) return false; // Day must be valid for the month and year.\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a lowercase letter with an odd order.\nbool is_odd_order(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a') % 2 == 1);\n    }\n    return false;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace and split accordingly\n    size_t start = 0, end = txt.find(' ');\n    while (end != string::npos) {\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n        end = txt.find(' ', start);\n    }\n    result.push_back(txt.substr(start));\n\n    // If the result is a single element and contains no whitespace\n    if (result.size() == 1 && result[0].find(' ') == string::npos) {\n        // Check for commas and split accordingly\n        size_t comma_pos = result[0].find(',');\n        if (comma_pos != string::npos) {\n            vector<string> temp;\n            start = 0, end = comma_pos;\n            while (end != string::npos) {\n                temp.push_back(result[0].substr(start, end - start));\n                start = end + 1;\n                end = result[0].find(',', start);\n            }\n            temp.push_back(result[0].substr(start));\n            return temp;\n        } else {\n            // Count the number of lowercase letters with odd order\n            int count_odd_order = 0;\n            for (char c : result[0]) {\n                if (is_odd_order(c)) {\n                    ++count_odd_order;\n                }\n            }\n            // Return a vector containing this count as a string\n            return {to_string(count_odd_order)};\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(const std::vector<int>& lst) {\n    // Edge case: empty or single-element list\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of the number of occurrences\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if current element is greater than next, not sorted in ascending order\n        if (i + 1 < lst.size() && lst[i] > lst[i + 1]) return false;\n\n        // If the same number appears more than twice, return false\n        if (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset count for a new number\n        }\n    }\n\n    return true;\n}\n\n// Example usage and check function\nvoid check_function() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n\n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to determine the intersection length and check if it's prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // If there is no intersection, return \"NO\"\n    if (start > end) return \"NO\";\n\n    int length = end - start + 1;\n\n    // Check if the length of the intersection is a prime number\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    // Check for empty vector and return -32768 as specified.\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1; // Initialize product of signs\n    int magnitude_sum = 0; // Initialize sum of magnitudes\n\n    for (int num : arr) {\n        if (num == 0) {\n            // If there's a zero in the array, the result is 0.\n            return 0;\n        }\n        sign_product *= (num > 0 ? 1 : -1); // Update product of signs\n        magnitude_sum += std::abs(num); // Add absolute value to sum of magnitudes\n    }\n\n    // Return the sum of magnitudes multiplied by the product of all signs.\n    return magnitude_sum * sign_product;\n}\n\n// Example usage and check function (not part of the solution, for testing purposes)\nvoid check() {\n    assert(prod_signs({1, 2, 2, -4}) == -9);\n    assert(prod_signs({0, 1}) == 0);\n    assert(prod_signs({}) == -32768);\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <climits>\n\nusing namespace std;\n\n// Directions for moving to adjacent cells (up, down, left, right)\nconst vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nvoid findMinPath(vector<vector<int>>& grid, int k, int x, int y, int pathLength, vector<int>& currentPath, vector<int>& minPath) {\n    // If the current path length is equal to k, compare it with the minimum path found so far\n    if (pathLength == k) {\n        for (int i = 0; i < k; ++i) {\n            if (currentPath[i] < minPath[i]) {\n                minPath.assign(currentPath.begin(), currentPath.end());\n                return;\n            } else if (minPath[i] < currentPath[i]) {\n                return;\n            }\n        }\n    } else {\n        // Add the current cell value to the path\n        currentPath.push_back(grid[x][y]);\n        \n        // Explore all adjacent cells\n        for (auto& dir : directions) {\n            int newX = x + dir.first, newY = y + dir.second;\n            \n            // Check if the new position is within bounds of the grid\n            if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n                findMinPath(grid, k, newX, newY, pathLength + 1, currentPath, minPath);\n            }\n        }\n\n        // Backtrack: remove the last cell from the current path\n        currentPath.pop_back();\n    }\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    vector<int> minPath(N * k + 1, INT_MAX); // Initialize with a large value\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath;\n            findMinPath(grid, grid[i][j], i, j, 1, currentPath, minPath);\n        }\n    }\n\n    return minPath;\n}\n\n// Example usage\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result;\n    \n    // Base cases for the first few terms\n    if (n >= 1) result.push_back(3);\n    if (n >= 2) result.push_back((1 + 2 / 2)); // tri(2)\n    \n    // Compute the sequence up to n\n    for(int i = 3; i <= n; ++i) {\n        int nextTerm;\n        \n        if(i % 2 == 0) { // For even indices\n            nextTerm = 1 + (i / 2);\n        } else { // For odd indices, using corrected recurrence relation\n            nextTerm = result[i - 3] + result[i - 2] + result[i - 4];\n        }\n        \n        result.push_back(nextTerm);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return the product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int depth = 0;\n    \n    for (char c : str) {\n        if (c == '[') {\n            depth++;\n            // If the depth is greater than 1, there's a nested bracket.\n            if (depth > 1) return true;\n        } else if (c == ']') {\n            depth--;\n            // Ensure we don't close without opening\n            if (depth < 0) return false; \n        }\n    }\n\n    // If the loop completes and depth is not zero, it means there are unmatched brackets.\n    return false;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        float rounded_num = ceil(num); // Round up to the nearest integer\n        sum += pow(rounded_num, 2); // Square the rounded number and add it to the sum\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check for empty string\n    if (txt.empty()) return false;\n    \n    int n = txt.length();\n    char lastChar = txt[n - 1];\n    \n    // Check if the last character is an alphabet\n    if (!isalpha(lastChar)) return false;\n\n    // If there's only one character, it must be a letter and not part of a word\n    if (n == 1) return true;\n    \n    // Check if the second to last character is a space or if it doesn't exist\n    char prevChar = n > 1 ? txt[n - 2] : ' ';\n    \n    // If the previous character is a space, then the last character is not part of a word\n    return prevChar == ' ';\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if the current element is not greater than or equal to its predecessor\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of the violating element\n        }\n    }\n    // If no such element exists, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n    \n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    vector<int> result1 = largest_smallest_integers({2, 4, 1, 3, 5, 7});\n    printf(\"Result: (%d, %d)\\n\", result1[0], result1[1]); // Expected: (0, 1)\n\n    vector<int> result2 = largest_smallest_integers({});\n    printf(\"Result: (%d, %d)\\n\", result2[0], result2[1]); // Expected: (0, 0)\n\n    vector<int> result3 = largest_smallest_integers({0});\n    printf(\"Result: (%d, %d)\\n\", result3[0], result3[1]); // Expected: (0, 0)\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Helper function to convert string with comma to float\nfloat parse_float(const std::string& str) {\n    std::replace(str.begin(), str.end(), ',', '.');\n    return std::stof(str);\n}\n\n// Function to compare two boost::any objects and return the larger one in its original type or \"None\"\nboost::any compare_one(boost::any a, boost::any b) {\n    // Extract types\n    using namespace boost;\n    \n    if (a.type() == typeid(int)) {\n        int ai = any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int bi = any_cast<int>(b);\n            return ai > bi ? a : (ai < bi ? b : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float bf = any_cast<float>(b);\n            return static_cast<float>(ai) > bf ? a : (static_cast<float>(ai) < bf ? b : \"None\");\n        } else if (b.type() == typeid(std::string)) {\n            std::string bs = any_cast<std::string>(b);\n            float bfloat = parse_float(bs);\n            return static_cast<float>(ai) > bfloat ? a : (static_cast<float>(ai) < bfloat ? b : \"None\");\n        }\n    } else if (a.type() == typeid(float)) {\n        float af = any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int bi = any_cast<int>(b);\n            return af > static_cast<float>(bi) ? a : (af < static_cast<float>(bi) ? b : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float bf = any_cast<float>(b);\n            return af > bf ? a : (af < bf ? b : \"None\");\n        } else if (b.type() == typeid(std::string)) {\n            std::string bs = any_cast<std::string>(b);\n            float bfloat = parse_float(bs);\n            return af > bfloat ? a : (af < bfloat ? b : \"None\");\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string as = any_cast<std::string>(a);\n        float afloat = parse_float(as);\n        \n        if (b.type() == typeid(int)) {\n            int bi = any_cast<int>(b);\n            return afloat > static_cast<float>(bi) ? a : (afloat < static_cast<float>(bi) ? b : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float bf = any_cast<float>(b);\n            return afloat > bf ? a : (afloat < bf ? b : \"None\");\n        } else if (b.type() == typeid(std::string)) {\n            std::string bs = any_cast<std::string>(b);\n            float bfloat = parse_float(bs);\n            return afloat > bfloat ? a : (afloat < bfloat ? b : \"None\");\n        }\n    }\n\n    // If types are not covered above, return None\n    return \"None\";\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the number is less than 8 or odd.\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    // If the number is even and greater than or equal to 8, it can be expressed as a sum of four positive even numbers.\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            // If there are more than two consecutive spaces, append '-' and reset count\n            if (spaceCount > 2) continue; \n            else result += '_';\n        } else {\n            // Reset the space counter when a non-space character is encountered\n            spaceCount = 0;\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_valid_extension(const string& extension) {\n    return extension == \".txt\" || extension == \".exe\" || extension == \".dll\";\n}\n\nint count_digits(const string& str) {\n    int digit_count = 0;\n    for (char c : str) {\n        if (c >= '0' && c <= '9') {\n            ++digit_count;\n        }\n    }\n    return digit_count;\n}\n\nstring file_name_check(string file_name) {\n    size_t dot_position = file_name.find('.');\n    \n    // Check if there is exactly one dot\n    if (dot_position == string::npos || file_name.rfind('.', 1) != dot_position)\n        return \"No\";\n    \n    // Split the filename into name and extension parts\n    string name_part = file_name.substr(0, dot_position);\n    string extension_part = file_name.substr(dot_position);\n\n    // Check if the name part starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0]))\n        return \"No\";\n    \n    // Count digits in the name part and ensure it's less than or equal to 3\n    int digit_count = count_digits(name_part);\n    if (digit_count > 3)\n        return \"No\";\n\n    // Check if the extension is valid\n    if (!is_valid_extension(extension_part))\n        return \"No\";\n    \n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the entry and add to sum\n        } else if ((i + 1) % 4 == 0) { // Index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the entry and add to sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime length from the sentence\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::string word, result = \"\";\n    bool firstWord = true;\n\n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            // Append the word to the result string with a space\n            if (!firstWord) {\n                result += \" \";\n            }\n            result += word;\n            firstWord = false;  // After adding the first word, set this flag to false\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to parse a string fraction into its numerator and denominator\nvoid parseFraction(const string& fraction, int &numerator, int &denominator) {\n    size_t slashPos = fraction.find('/');\n    numerator = stoi(fraction.substr(0, slashPos));\n    denominator = stoi(fraction.substr(slashPos + 1));\n}\n\n// Function to check if the product of two fractions is an integer\nbool simplify(string x, string n) {\n    int numX, denX;\n    int numN, denN;\n\n    // Parse both fractions into numerators and denominators\n    parseFraction(x, numX, denX);\n    parseFraction(n, numN, denN);\n\n    // Calculate the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the product\n    int prodDen = denX * denN;  // Denominator of the product\n\n    // Simplify the fraction by finding the greatest common divisor (GCD)\n    int gcd = __gcd(prodNum, prodDen);\n\n    // After simplification, if the denominator is 1, it means the result is an integer\n    return (prodDen / gcd) == 1;\n}\n\n// Function to test the simplify function with given examples\nvoid check() {\n    cout << boolalpha;  // Print boolean values as 'true' or 'false'\n    cout << \"simplify(\\\"1/5\\\", \\\"5/1\\\") = \" << simplify(\"1/5\", \"5/1\") << endl;\n    cout << \"simplify(\\\"1/6\\\", \\\"2/1\\\") = \" << simplify(\"1/6\", \"2/1\") << endl;\n    cout << \"simplify(\\\"7/10\\\", \\\"10/2\\\") = \" << simplify(\"7/10\", \"10/2\") << endl;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    \n    // Handle negative numbers by converting them to positive and adjusting the first digit.\n    if (is_negative) {\n        num = -num; // Convert to positive for easier processing\n        while (num >= 10) { // Sum all digits except the first one\n            sum += num % 10;\n            num /= 10;\n        }\n        sum -= num; // Subtract the first digit since it's negative\n    } else {\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n    }\n\n    return is_negative ? -sum : sum;\n}\n\n// Main function to sort integers based on the sum of their digits.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Create a vector of pairs (index, value) for sorting\n    std::vector<std::pair<int, int>> indexed_nums(nums.size());\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums[i] = {i, nums[i]};\n    }\n\n    // Sort the vector of pairs based on digit sum and then by original index\n    std::sort(indexed_nums.begin(), indexed_nums.end(),\n              [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                  return digit_sum(a.second) != digit_sum(b.second)\n                         ? digit_sum(a.second) < digit_sum(b.second)\n                         : a.first < b.first;\n              });\n\n    // Extract the sorted values back into the original vector\n    for (size_t i = 0; i < nums.size(); ++i) {\n        nums[i] = indexed_nums[i].second;\n    }\n\n    return nums;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> test1 = {1, 11, -1, -11, -12};\n    std::vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n\n    std::vector<int> test2 = {};\n    std::vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately as it doesn't have a first or last digit\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isOddFirst = (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n                       firstDigit == '7' || firstDigit == '9');\n    bool isOddLast = (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n                      lastDigit == '7' || lastDigit == '9');\n\n    return isOddFirst && isOddLast;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the given formula.\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples (a[i], a[j], a[k]) where i < j < k\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find the index of a planet in the ordered list\nint getPlanetIndex(const string& planet) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    for (size_t i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet) return static_cast<int>(i);\n    }\n    \n    // Return -1 if the planet is not found\n    return -1;\n}\n\n// Function to get the list of planets between two given planets\nvector<string> bf(string planet1, string planet2) {\n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n\n    // If either planet is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) return {};\n\n    // Ensure index1 < index2 for correct order\n    if (index1 > index2) swap(index1, index2);\n    \n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    vector<string> result;\n\n    // Add all planets between the two indices to the result\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n\n// Function to test and print the results\nvoid test(string planet1, string planet2) {\n    vector<string> result = bf(planet1, planet2);\n    \n    if (result.empty()) {\n        cout << \"No planets found between \" << planet1 << \" and \" << planet2 << endl;\n    } else {\n        for (const auto& planet : result) {\n            cout << planet << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator for sorting strings first by length and then alphabetically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // Alphabetical order if lengths are equal\n    }\n    return a.length() < b.length(); // Length-based sort otherwise\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) { // Check if the string's length is even\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Function to test and print results for verification\nvoid check(vector<string> input, vector<string> expected) {\n    vector<string> output = sorted_list_sum(input);\n    if (output == expected) {\n        printf(\"Test passed: \");\n    } else {\n        printf(\"Test failed: \");\n    }\n    printf(\"[\");\n    for (size_t i = 0; i < output.size(); ++i) {\n        printf(\"\\\"%s\\\"\", output[i].c_str());\n        if (i != output.size() - 1) {\n            printf(\", \");\n        }\n    }\n    printf(\"]\\n\");\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) { // Check divisibility up to the square root of n\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function that returns x if n is prime, otherwise y\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long sum_of_odd_squares(const std::vector<float>& lst) {\n    long long result = 0;\n    \n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == ceil(num) && static_cast<int>(num) % 2 != 0) {\n            int n = static_cast<int>(num);\n            result += n * n; // Square the number and add to result\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    // Ensure both vectors are of equal length\n    if (game.size() != guess.size()) {\n        throw std::invalid_argument(\"The input vectors must be of the same size.\");\n    }\n\n    for(size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to calculate strength of an extension\nint calculate_strength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    // Initialize variables to track the strongest extension\n    int max_strength = INT_MIN;\n    size_t strongest_index = 0;\n\n    for (size_t i = 0; i < extensions.size(); ++i) {\n        int strength = calculate_strength(extensions[i]);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_index = i;\n        }\n    }\n\n    // Return the class name concatenated with the strongest extension's name\n    return class_name + \".\" + extensions[strongest_index];\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate 'a' with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to a positive if it's negative\n    int abs_num = abs(num);\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    while (abs_num > 0) {\n        int digit = abs_num % 10; // Get the last digit\n        \n        if (digit % 2 == 0) {\n            even_count++; // Increment even count\n        } else {\n            odd_count++; // Increment odd count\n        }\n        \n        abs_num /= 10; // Remove the last digit\n    }\n\n    return {even_count, odd_count}; // Return a vector with counts of even and odd digits\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    \n    string roman;\n    for (int i = 0; i < values.size(); ++i) {\n        while (number >= values[i]) {\n            number -= values[i];\n            roman += symbols[i];\n        }\n    }\n    return roman;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side\n    if (a > c) std::swap(a, c);\n    if (b > c) std::swap(b, c);\n\n    // Check Pythagorean theorem: a^2 + b^2 == c^2\n    return std::abs((a * a) + (b * b) - (c * c)) < 1e-6;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the number of unique characters in a string.\nint unique_chars(const string& word) {\n    int char_count[256] = {0}; // Assuming ASCII character set for simplicity\n    for (char c : word) {\n        char_count[c]++;\n    }\n    \n    int count_unique = 0;\n    for (int i = 0; i < 256; ++i) {\n        if (char_count[i] > 0) {\n            count_unique++;\n        }\n    }\n    return count_unique;\n}\n\n// Main function to find the word with maximum number of unique characters.\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = -1;\n\n    for (const auto& word : words) {\n        int current_unique_chars = unique_chars(word);\n        \n        // Update if we found a new maximum or equal but lexicographically smaller\n        if (current_unique_chars > max_unique_chars || \n            (current_unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = current_unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<string> words1 = {\"name\", \"of\", \"string\"};\n    printf(\"The result is: %s\\n\", find_max(words1).c_str()); // Expected output: string\n    \n    vector<string> words2 = {\"name\", \"enam\", \"game\"};\n    printf(\"The result is: %s\\n\", find_max(words2).c_str()); // Expected output: enam\n\n    vector<string> words3 = {\"aaaaaaa\", \"bb\", \"cc\"};\n    printf(\"The result is: %s\\n\", find_max(words3).c_str()); // Expected output: aaaaaaa\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots can be eaten based on available stock\n    int toEat = min(need, remaining);\n    \n    // Update total number of carrots eaten and remaining carrots in stock\n    int totalEaten = number + toEat;\n    int leftOver = remaining - toEat;\n\n    return {totalEaten, leftOver};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <cmath>\n\nint do_algebra(std::vector<std::string> operato, std::vector<int> operand) {\n    int result = operand[0]; // Start with the first element as initial value\n    \n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            // Floor division\n            result /= operand[i + 1]; // Note: C++ integer division already floors the result for positive numbers.\n        } else if (operato[i] == \"**\") {\n            result = std::pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is an alphabet letter.\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to reverse the case of a letter.\nchar reverseCase(char c) {\n    if(c >= 'a' && c <= 'z')\n        return c - 32; // Convert lowercase to uppercase\n    else if(c >= 'A' && c <= 'Z')\n        return c + 32; // Convert uppercase to lowercase\n    return c;\n}\n\n// Function to solve the problem as described.\nstring solve(string s) {\n    bool hasLetters = false;\n    string result;\n\n    // First pass: check for letters and build the result string with transformations.\n    for(char c : s) {\n        if(isLetter(c)) {\n            hasLetters = true;\n            result += reverseCase(c);\n        } else {\n            result += c;\n        }\n    }\n\n    // If no letters were found, reverse the entire string.\n    if(!hasLetters)\n        return string(result.rbegin(), result.rend());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nstd::string string_to_md5(std::string text) {\n    if (text.empty()) return \"\"; // Return an empty string instead of None as C++ doesn't have a concept of None\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&hash);\n\n    std::stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is the lower bound and 'b' is the upper bound.\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    std::vector<int> even_digits;\n    \n    // Iterate through all possible even digits (2, 4, 6, 8)\n    for(int digit : {2, 4, 6, 8}) {\n        if(digit >= start && digit <= end) {\n            even_digits.push_back(digit);\n        }\n    }\n\n    return even_digits;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> result1 = generate_integers(2, 8);\n    for(int num : result1) printf(\"%d \", num); // Expected: 2 4 6 8\n    printf(\"\\n\");\n\n    std::vector<int> result2 = generate_integers(8, 2);\n    for(int num : result2) printf(\"%d \", num); // Expected: 2 4 6 8\n    printf(\"\\n\");\n\n    std::vector<int> result3 = generate_integers(10, 14);\n    if(result3.empty()) printf(\"No even digits in range\\n\"); // Expected: No even digits in range\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Iterate through all pairs of elements in the vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            // Check if the absolute difference between any two elements is less than the threshold\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    int balance = 0; // Tracks the number of open parentheses that haven't been closed yet.\n    size_t start_index = 0; // The index where a new group starts.\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(' || paren_string[i] == ')') { // Only consider parentheses, ignore spaces\n            if (paren_string[i] == '(') {\n                balance++;\n            } else if (paren_string[i] == ')') {\n                balance--;\n            }\n\n            // When balance is zero, it means we've closed all open parentheses for the current group.\n            if (balance == 0 && i > start_index) {\n                result.push_back(paren_string.substr(start_index, i - start_index + 1));\n                start_index = i + 1; // Start of a new potential group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<std::string> expected = {\"()\", \"(())\", \"(()())\"};\n    std::vector<std::string> actual = separate_paren_groups(\"( ) (( )) (( )( ))\");\n    \n    // Assuming a simple way to compare vectors of strings for demonstration purposes.\n    if (expected == actual) {\n        printf(\"Correct!\\n\");\n    } else {\n        printf(\"Incorrect.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For std::floor\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);\n    return number - integer_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    std::size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Reserve space for the new vector to avoid reallocations.\n    std::vector<int> result;\n    result.reserve(result_size);\n\n    // Insert elements and delimiters into the resulting vector.\n    if (!numbers.empty()) {\n        bool first = true;\n        for (const auto& num : numbers) {\n            if (!first) {\n                result.push_back(delimeter);\n            }\n            result.push_back(num);\n            first = false;\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid print_vector(const std::vector<int>& vec) {\n    for (const auto& elem : vec) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    int current_depth = 0, max_depth = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') {\n            current_depth--;\n        } else if (c != ' ') { // Handle unexpected characters\n            cout << \"Unexpected character: \" << c << endl;\n        }\n\n        // When a space is encountered or the end of string, record max depth and reset counters.\n        if (c == ' ' || &c == &paren_string.back()) {\n            result.push_back(max_depth);\n            current_depth = 0;\n            max_depth = 0;\n\n            // Skip spaces\n            while(paren_string.find(' ', c) != -1 && c < paren_string.size())\n                c++;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the specified substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<string> input1 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    string substring1 = \"a\";\n    vector<string> expected_output1 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input1, substring1) == expected_output1);\n\n    vector<string> input2 = {};\n    string substring2 = \"a\";\n    vector<string> expected_output2 = {};\n    assert(filter_by_substring(input2, substring2) == expected_output2);\n    \n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n\nusing namespace std;\n\n// Function that returns a pair of sum and product of elements in the vector.\nstd::pair<int, int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1; // Product starts with 1 because multiplying by 1 doesn't change the value.\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n// Function to test and print results\nvoid check(const std::vector<int>& input) {\n    auto result = sum_product(input);\n    cout << \"Sum: \" << result.first << \", Product: \" << result.second << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm> // for std::max\n\nstd::vector<int> rolling_max(const std::vector<int>& numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n    \n    std::vector<int> result;\n    int current_max = numbers[0];  // Initialize the first element as the initial max value\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);  // Update the current maximum value\n        result.push_back(current_max);  // Append the current maximum to the result vector\n    }\n    \n    return result;\n}\n\n// Example usage and verification function\nvoid check_rolling_max() {\n    std::vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    std::vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    std::vector<int> output = rolling_max(input);\n    \n    if (output == expected_output) {\n        printf(\"Test passed: Correct rolling max values.\\n\");\n    } else {\n        printf(\"Test failed: Incorrect rolling max values.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(const string& str, int start, int end) {\n    while (start <= end) {\n        if (str[start++] != str[end--]) return false;\n    }\n    return true;\n}\n\nint longest_palindromic_suffix_length(const string& str) {\n    for (int i = 0; i < str.length(); ++i) {\n        // Check if the substring from start to end is a palindrome\n        if (is_palindrome(str, i, str.length() - 1)) return str.length() - i;\n    }\n    return 0;\n}\n\nstring make_palindrome(const string& str) {\n    int suffix_length = longest_palindromic_suffix_length(str);\n    // The prefix that needs to be reversed and appended\n    string prefix_to_reverse = str.substr(0, str.length() - suffix_length);\n    reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n    \n    return prefix_to_reverse + str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings have the same length for XOR operation\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of the same length\");\n    }\n\n    std::string result = \"\";\n    \n    // Perform XOR on each pair of bits from a and b\n    for(size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == '1' && b[i] == '0') {\n            result += \"1\";\n        } else if (a[i] == '0' && b[i] == '1') {\n            result += \"1\";\n        } else {\n            result += \"0\";\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings.\n    }\n\n    string longest_str = strings[0];  // Initialize with the first element\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // Check if current string is longer\n            longest_str = str;  // Update longest_str to the current string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    while(b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    \n    // Iterate through each character in the string and add substrings from start to current index as prefixes.\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    \n    return prefixes;\n}\n\n// Function to print vector of strings\nvoid print_vector(const vector<string>& vec){\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i){\n        if(i != 0) cout << \", \";\n        cout << \"\\\"\" << vec[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    // Initialize an empty string for the sequence.\n    string sequence = \"\";\n    \n    // Iterate through numbers from 0 to n inclusive.\n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the sequence.\n        sequence += std::to_string(i);\n        \n        // Append a space after each number except the last one.\n        if (i < n) {\n            sequence += \" \";\n        }\n    }\n\n    return sequence;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << string_sequence(0) << endl;  // Expected: \"0\"\n    cout << string_sequence(5) << endl;  // Expected: \"0 1 2 3 4 5\"\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nint count_distinct_characters(std::string str) {\n    // Convert the string to lowercase (or uppercase)\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Use an unordered set to store unique characters\n    std::unordered_set<char> distinct_chars;\n    \n    for (char c : str) {\n        if (isalpha(c)) {  // Ensure only alphabetic characters are considered\n            distinct_chars.insert(c);\n        }\n    }\n\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    \n    // Iterate through the string and identify each note\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') { // whole note\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // half note\n                i++; // skip the '|' character\n            } else {\n                beats.push_back(4); // whole note\n            }\n        } else if (music_string[i] == '.') { // quarter note\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1);\n                i++; // skip the '|' character\n            }\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move to the next character for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n\nstd::string sort_numbers(std::string numbers) {\n    // Mapping from string to integer value\n    std::map<std::string, int> number_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2},\n        {\"three\", 3}, {\"four\", 4}, {\"five\", 5},\n        {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Convert the input string to a vector of integers\n    std::istringstream iss(numbers);\n    std::vector<int> number_values;\n    std::string word;\n    while (iss >> word) {\n        if (number_map.find(word) != number_map.end()) {\n            number_values.push_back(number_map[word]);\n        }\n    }\n\n    // Sort the vector of integers\n    std::sort(number_values.begin(), number_values.end());\n\n    // Convert sorted integers back to strings and join them\n    std::ostringstream oss;\n    for (size_t i = 0; i < number_values.size(); ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        for (const auto& entry : number_map) {\n            if (entry.second == number_values[i]) {\n                oss << entry.first;\n                break;\n            }\n        }\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <limits>    // For std::numeric_limits\n\n// Function to find and return the closest pair of elements from a vector.\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"The input vector must contain at least two elements.\");\n    }\n\n    // Sort the vector to make it easier to find the closest pair.\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    // Iterate through the sorted vector and find the minimum difference between consecutive elements.\n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        float diff = sorted_numbers[i] - sorted_numbers[i-1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i-1], sorted_numbers[i]};\n        }\n    }\n\n    return closest_pair;\n}\n\n// Function to test the correctness of find_closest_elements function.\nvoid check() {\n    auto result1 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2});\n    std::cout << \"Closest pair: (\" << result1.first << \", \" << result1.second << \")\" << std::endl;\n\n    auto result2 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0});\n    std::cout << \"Closest pair: (\" << result2.first << \", \" << result2.second << \")\" << std::endl;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            // Cast the boost::any to int and add it to the vector\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n// Function to print a list of integers for testing purposes\nvoid print_int_vector(const std::vector<int>& vec) {\n    std::cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) std::cout << \", \";\n        std::cout << vec[i];\n    }\n    std::cout << \"}\" << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\nusing namespace std;\n\nint strlen(const string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for n > 1, return -1 or throw an exception.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <cmath> // For std::sqrt\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 as many times as possible\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If there's any prime factor greater than 2 left, add it to the list\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Example usage and testing function\nvoid test_factorize() {\n    vector<int> result1 = factorize(8); // Expected: {2, 2, 2}\n    for(int i : result1) printf(\"%d \", i);\n    printf(\"\\n\");\n\n    vector<int> result2 = factorize(25); // Expected: {5, 5}\n    for(int i : result2) printf(\"%d \", i);\n    printf(\"\\n\");\n\n    vector<int> result3 = factorize(70); // Expected: {2, 5, 7}\n    for(int i : result3) printf(\"%d \");\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Count occurrences of each element\n    unordered_map<int, int> count;\n    for (int num : numbers) {\n        count[num]++;\n    }\n\n    // Step 2: Construct a new vector with elements that occur exactly once\n    vector<int> result;\n    for (int num : numbers) {\n        if (count[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate through each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result\n    std::string result;\n\n    // Iterate through each string in the vector and append it to the result\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \"world\"}) == \"helloworld\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers;\n    \n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n\n    return positive_numbers;\n}\n\n// Function to print the elements of a vector\nvoid print_vector(const vector<float>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble poly_derivative(const std::vector<double>& xs, double x) {\n    double derivative_sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) { // Start from the first non-constant term\n        derivative_sum += static_cast<int>(i) * xs[i] * pow(x, static_cast<int>(i - 1));\n    }\n    return derivative_sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    double x = 0.5; // Initial guess\n    const double tolerance = 1e-7;\n    const int max_iterations = 100;\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double f_x = poly(xs, x);\n        if (fabs(f_x) < tolerance) break; // Check if we are close enough to a root\n        double df_dx = poly_derivative(xs, x); // Derivative of the polynomial at x\n\n        if (df_dx == 0.0) {\n            std::cerr << \"Derivative is zero. No solution found.\" << std::endl;\n            return NAN; // Return NaN if derivative is zero to avoid division by zero\n        }\n\n        double next_x = x - f_x / df_dx; // Newton-Raphson iteration\n\n        if (fabs(next_x - x) < tolerance) break; // Check for convergence\n\n        x = next_x;\n    }\n    \n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort; // To store elements at indices divisible by 3\n\n    // Extract elements at indices divisible by 3 and add them to the 'to_sort' vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Check if index is divisible by 3, considering C++ indexing starts at 0\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace original elements with sorted values\n    int j = 0; // Index for 'to_sort' vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0 && j < to_sort.size()) { // Check and replace elements at indices divisible by 3\n            l[i] = to_sort[j++];\n        }\n    }\n\n    return l;\n}\n\n// Function to print vector for testing purposes\nvoid print_vector(const vector<int>& v) {\n    for (int num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm> // for sort\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the input vector\n    sort(l.begin(), l.end());\n\n    // Step 2: Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n    \n    float max_value = l[0];  // Initialize with the first element\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n\n    return max_value;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<float> test1 = {1, 2, 3};\n    std::vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n\n    printf(\"Max element in test1: %.0f\\n\", max_element(test1)); // Expected output: 3\n    printf(\"Max element in test2: %.0f\\n\", max_element(test2)); // Expected output: 123\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    // Loop through all numbers less than n\n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            std::string num_str = std::to_string(i); // Convert number to string\n            \n            for (char c : num_str) { // Iterate through each character in the string\n                if (c == '7') {\n                    count++; // Increment count if digit is 7\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract even-indexed elements and store them in a separate vector.\n    std::vector<float> even_elements;\n    \n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 1) { // Check if the index is even, considering C++ indexing starts at 0\n            even_elements.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements.\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Replace original even-indexed elements with sorted ones.\n    size_t j = 0; // Index for the sorted vector of even elements\n    for (size_t i = 1; i < l.size() && j < even_elements.size(); ++i, ++j) {\n        if (i % 2 == 1) { // Check if the index is even\n            l[i] = even_elements[j];\n        }\n    }\n\n    return l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1;\n    int count = 0; // Count of prime Fibonacci numbers found\n\n    while (true) {\n        int next_fib = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = next_fib;\n\n        if (is_prime(next_fib)) {\n            ++count;\n            if (count == n)\n                return next_fib;\n        }\n    }\n\n    // The loop will always find the nth prime Fibonacci number, so no need to return anything here.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to make finding triplets easier.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Increase the left index to increase the sum\n            } else {\n                --right; // Decrease the right index to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero\n}\n\n// Example usage and check function (not part of the solution but for testing)\n#include <iostream>\nbool test(vector<int> nums) {\n    bool result = triples_sum_to_zero(nums);\n    cout << \"Input: {\";\n    for(int num : nums) {\n        cout << num << \", \";\n    }\n    cout << \"}\\nOutput: \" << (result ? \"true\" : \"false\") << \"\\n\\n\";\n    return result;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Each car moving from left to right will collide with each car moving from right to left.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        seen.insert(num);  // Add the current number to the set.\n    }\n\n    return false;  // No pairs found that sum to zero.\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    std::string result = \"\";\n    \n    // Handle the case where x is zero separately.\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    while (x > 0) {\n        // Append the remainder of x divided by base to the result string.\n        char digit = '0' + (x % base);\n        result = digit + result;\n        \n        // Divide x by base for the next iteration.\n        x /= base;\n    }\n\n    return result;\n}\n\n// Function to test the change_base function with provided data points\nvoid check_function() {\n    assert(change_base(8, 3) == \"22\");\n    assert(change_base(8, 2) == \"1000\");\n    assert(change_base(7, 2) == \"111\");\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\n\n// Function to calculate the area of a triangle given its base (a) and height (h)\nfloat triangle_area(float a, float h) {\n    return (a * h) / 2;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    \n    // Initialize the first four values of the sequence.\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute fib4(n) for n > 3\n    for(int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    \n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::floor and std::ceil\n\nfloat median(std::vector<float> l) {\n    size_t n = l.size();\n    \n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters at the current positions do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // The string is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    long long result = 1; // Initialize result\n    long long base = 2;   // Base\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the base with result\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2;                   // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "string decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adjusting the formula to shift back by 5\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char ch : text) {\n        // Convert character to lowercase to simplify the check\n        char lower_ch = tolower(ch);\n        \n        // Check if the character is not a vowel and add it to the result string.\n        if (lower_ch != 'a' && lower_ch != 'e' && lower_ch != 'i' && lower_ch != 'o' && lower_ch != 'u') {\n            result += ch;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with given examples.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage and check function\nvoid check_function() {\n    bool result1 = below_threshold({1, 2, 4, 10}, 100);\n    printf(\"below_threshold({1, 2, 4, 10}, 100) should return true: %s\\n\", result1 ? \"true\" : \"false\");\n\n    bool result2 = below_threshold({1, 20, 4, 10}, 5);\n    printf(\"below_threshold({1, 20, 4, 10}, 5) should return false: %s\\n\", result2 ? \"true\" : \"false\");\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Compare the sorted versions of both strings\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid test_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '<') {\n            // Push opening bracket onto the stack.\n            stack.push(c);\n        } else if (c == '>') {\n            // Check if there's a corresponding opening bracket.\n            if (!stack.empty() && stack.top() == '<') {\n                stack.pop();  // Pop the matching opening bracket.\n            } else {\n                return false; // No matching opening bracket found.\n            }\n        }\n    }\n\n    // If the stack is empty, all brackets are correctly matched.\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Edge case: empty vector or single element vector is considered monotonic.\n    if (l.size() <= 1) return true;\n    \n    bool increasing = false, decreasing = false;\n    \n    for(size_t i = 0; i < l.size() - 1; ++i) {\n        if(l[i] < l[i + 1]) {\n            // Found an increasing sequence\n            if(decreasing) return false; // If we've already found a decreasing sequence, it's not monotonic.\n            increasing = true;\n        } else if (l[i] > l[i + 1]) {\n            // Found a decreasing sequence\n            if(increasing) return false; // If we've already found an increasing sequence, it's not monotonic.\n            decreasing = true;\n        }\n    }\n\n    // If the vector is either entirely increasing or entirely decreasing, return true.\n    return increasing || decreasing;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort, unique\n\nusing namespace std;\n\n// Function to remove duplicates from a vector\nvoid removeDuplicates(vector<int>& vec) {\n    auto last = unique(vec.begin(), vec.end());\n    vec.erase(last, vec.end()); // Erase the part of the vector after the new end (duplicates)\n}\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    removeDuplicates(l1);\n    removeDuplicates(l2);\n\n    // Initialize iterators for both vectors and a result vector\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n    vector<int> commonElements;\n\n    // Find the intersection of two sorted vectors\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            commonElements.push_back(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    return commonElements;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true; // Special cases for smallest primes\n    if (num % 2 == 0 || num % 3 == 0) return false; // Exclude multiples of 2 and 3\n\n    int i = 5, w = 2;\n    while (i * i <= num) {\n        if (num % i == 0)\n            return false;\n        i += w;\n        w = 6 - w;\n    }\n    return true;\n}\n\n// Function to find the largest prime factor of n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n\n    // Divide out factors of 2 first for efficiency\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1; // equivalent to n /= 2\n    }\n\n    // Check odd numbers up to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2 && is_prime(n))\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int n = brackets.length();\n    // Use an integer as a stack to keep track of the balance between '(' and ')'\n    int balance = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            // If there's no matching opening bracket, return false\n            if (balance == 0) {\n                return false;\n            }\n            balance--;\n        }\n    }\n\n    // If the stack is empty at the end, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first-degree term (index 1).\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of floats.\nvoid printVector(const vector<float>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n    \n    // Compute the sequence iteratively\n    for(int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n    \n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    // Define the set of vowels for easy checking.\n    const std::string vowels = \"aeiouAEIOU\";\n    \n    // Iterate through each character in the string.\n    for (char c : s) {\n        if (vowels.find(c) != std::string::npos) {\n            count++;\n        }\n    }\n\n    // Check if 'y' or 'Y' is at the end of the word and treat it as a vowel.\n    char lastChar = s.back();\n    if ((lastChar == 'y' || lastChar == 'Y') && count > 0) {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string num = to_string(x);\n    \n    // Determine the length of the number\n    int len = num.length();\n    \n    // If shift is greater than or equal to the length, reverse the digits\n    if (shift >= len) {\n        return string(num.rbegin(), num.rend());\n    }\n    \n    // Perform circular right shift\n    shift %= len;  // Ensure shift is within bounds of number's length\n    string result = num.substr(len - shift) + num.substr(0, len - shift);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract numbers from the string using stringstream\n    int apples = 0;\n    int oranges = 0;\n    \n    // Create a stringstream object and extract integers from it\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Extract the number of apples\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Extract the number of oranges\n        }\n    }\n\n    // Calculate and return the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum possible integer value\n    int index = -1;             // Index of the found even number\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if it's an even number and smaller or equal to current minimum\n            minEvenValue = arr[i];                       // Update the smallest even value found so far\n            index = i;                                    // Update the index of this value\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (index == -1) {\n        return {};\n    } else {\n        return {minEvenValue, index};\n    }\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(const std::vector<int>& lst) {\n    // Step 1: Count the frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    // Step 2 & 3: Iterate through unique integers and check their frequencies\n    int result = -1; // Initialize result to -1 if no valid integer is found\n    \n    for (const auto& entry : freq) {\n        int num = entry.first;\n        int count = entry.second;\n        \n        // Check if the frequency of the number is greater than or equal to the number itself\n        if (count >= num && num > result) {\n            result = num; // Update result with the maximum valid integer found so far\n        }\n    }\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    std::vector<int> result;\n    \n    // Sort the list to make it easier to pick min and max values.\n    std::sort(lst.begin(), lst.end());\n    \n    int left = 0; // Pointer for minimum value\n    int right = lst.size() - 1; // Pointer for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the smallest remaining element.\n        result.push_back(lst[left++]);\n        // Add the largest remaining element.\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool is_palindrome(const std::vector<int>& q) {\n    int left = 0;\n    int right = q.size() - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    \n    return true;\n}\n\nbool will_it_fly(const std::vector<int>& q, int w) {\n    // Check if the sum of elements is less than or equal to w\n    int total_weight = std::accumulate(q.begin(), q.end(), 0);\n    \n    // Check if the vector is palindromic and the weight condition is met\n    return (total_weight <= w && is_palindrome(q));\n}\n\n// Example usage:\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\n\nint smallest_change(const std::vector<int>& arr) {\n    int changes = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate total number of characters in a vector of strings\nint count_total_chars(const vector<string>& lst) {\n    int totalChars = 0;\n    for (const string& str : lst) {\n        totalChars += str.length();\n    }\n    return totalChars;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int total_chars_lst1 = count_total_chars(lst1);\n    int total_chars_lst2 = count_total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else if (total_chars_lst2 < total_chars_lst1) {\n        return lst2;\n    } else {  // If both vectors have the same number of characters, return the first one\n        return lst1;\n    }\n}\n\n// Example usage and verification\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate all primes less than max_value\nstd::vector<int> generate_primes(int max_value) {\n    std::vector<int> primes;\n    for (int i = 2; i < max_value; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int n, const std::vector<int>& primes) {\n    int count = 0; // To keep track of how many prime factors we have found\n\n    for (int i = 0; i < primes.size() && count <= 3; ++i) {\n        if (n % primes[i] == 0) {\n            n /= primes[i];\n            count++;\n            // If the remaining number is also a prime and not equal to the last divisor, increment count\n            if (is_prime(n)) {\n                count++;\n                break;\n            }\n        }\n    }\n\n    return count == 3 && n == 1; // The number should be divisible by exactly three primes\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can only be a simple power of itself.\n    if (x == 1 && n == 1) return true;\n    if (n <= 1 || x <= 1) return false;\n\n    // Calculate the exponent using logarithm\n    double exponent = log(x) / log(n);\n\n    // Check if the exponent is an integer by comparing it to its rounded value.\n    int integer_exponent = round(exponent);\n    \n    // If the difference between the calculated and rounded exponents is within a small tolerance,\n    // they are considered equal, meaning x is indeed n raised to an integer power.\n    return fabs(exponent - integer_exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a' and round it to the nearest integer.\n    int cube_root = std::round(std::cbrt(a));\n    \n    // Check if the cube of this rounded value equals 'a'.\n    return (cube_root * cube_root * cube_root == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\nint hex_key(std::string num) {\n    // Define a string containing all prime hexadecimal digits.\n    std::string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is one of the prime digits.\n        if (primes.find(c) != std::string::npos) {\n            ++count; // Increment the count if it's a prime digit.\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nstd::string decimal_to_binary(int decimal) {\n    std::string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        if (decimal % 2 == 1)\n            binary += '1';\n        else\n            binary += '0';\n        \n        decimal /= 2;\n    }\n    \n    // Reverse the string since we built it from least significant bit to most significant bit\n    std::reverse(binary.begin(), binary.end());\n    \n    // Add \"db\" prefix and suffix as required by the problem statement\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string starting from the second character to the third last character\n    for (size_t i = 1; i < s.length() - 1; ++i) {\n        // Check if any three consecutive characters are not distinct.\n        if (s[i] == s[i-1] || s[i] == s[i+1]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy.\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\"); // In case of a GPA less than 0, which is not expected but handled here.\n        }\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Only one number, which is '1'\n    \n    int count = 0;\n    // Count numbers starting with 1\n    count += pow(10, n - 1); // There are 10^(n-1) such numbers\n    \n    // Count numbers ending with 1 but not starting with 1\n    if (n > 1) {\n        count += (pow(10, n - 2)) * 9; // For each of the remaining digits, there are 9 possibilities for the first digit\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\n// Function to calculate the sum of digits and convert it to a binary string\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Calculate the sum of all digits in N\n    while (N > 0) {\n        sumOfDigits += N % 10; // Add the last digit to the sum\n        N /= 10;               // Remove the last digit from N\n    }\n\n    // Convert the sum of digits into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) { \n        if (lst[i] % 2 == 0) { // Check if the element at the current index is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort characters of a given word\nvoid sortWord(string &word) {\n    sort(word.begin(), word.end());\n}\n\nstring anti_shuffle(const string& s) {\n    string result;\n    string currentWord;\n\n    for (size_t i = 0; i <= s.length(); ++i) {\n        // If we have reached the end of a word or the end of the string\n        if (i == s.length() || s[i] == ' ') {\n            sortWord(currentWord); // Sort the current word\n            result += currentWord + (i < s.length() ? \" \" : \"\"); // Append sorted word and space if not at end\n            currentWord.clear(); // Clear for next word\n        } else {\n            currentWord += s[i]; // Accumulate characters to form a word\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor to initialize coordinates\n    Coordinate(int r, int c) : row(r), col(c) {}\n\n    // Overload operator< for sorting\n    bool operator<(const Coordinate& other) const {\n        if (row != other.row)\n            return row < other.row;  // Sort by row in ascending order\n        else\n            return col > other.col;  // Sort by column in descending order within the same row\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through each element to find occurrences of x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back(Coordinate(i, j));\n            }\n        }\n    }\n\n    // Sort the coordinates\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate vector to vector of vectors<int>\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array){\n    // If the input vector is empty, return an empty vector.\n    if (array.empty()) {\n        return {};\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the original vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>{});\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n\n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = std::tolower(c); // Convert to lowercase for simplicity\n            int original_pos = alphabet.find(lower_c);\n            \n            // Calculate new position, wrapping around if necessary\n            int new_pos = (original_pos + shift) % 26;\n            char encrypted_char = alphabet[new_pos];\n            \n            // Preserve the case of the original character\n            c = isupper(c) ? std::toupper(encrypted_char) : encrypted_char;\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <optional>  // For std::nullopt\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    if (lst.size() <= 1) return std::nullopt; // Early exit for small vectors\n    \n    std::sort(lst.begin(), lst.end()); // Sort the vector\n    auto last = std::unique(lst.begin(), lst.end()); // Remove duplicates\n    lst.erase(last, lst.end());\n\n    if (lst.size() < 2) return std::nullopt; // Check if there are at least two unique elements\n\n    return lst[1]; // Return the second smallest element\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(const string& S) {\n    int boredom_count = 0;\n    bool new_sentence = true; // Indicates start of a sentence\n\n    for (size_t i = 0; i < S.length(); ++i) {\n        if (new_sentence && S.substr(i, 2) == \"I \") { // Check if the sentence starts with \"I \"\n            boredom_count++;\n        }\n        \n        new_sentence = S[i] == '.' || S[i] == '?' || S[i] == '!'; // Mark start of a new sentence\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n\n    // Convert floats to integers for comparison\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is equal to the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "char swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c; // Return the original character if it's not an alphabet letter.\n}\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Helper function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds the largest prime and returns the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime in the list\n\n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num); // Update maxPrime if current number is larger and prime\n        }\n    }\n\n    return digitSum(maxPrime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool is_lowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool is_uppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool all_lowercase = true;\n    bool all_uppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (!is_lowercase(key)) all_lowercase = false;\n        if (!is_uppercase(key)) all_uppercase = false;\n        \n        // If both flags are already false, no need to continue checking\n        if (!all_lowercase && !all_uppercase) return false;\n    }\n\n    // Return true if either all keys are lowercase or all uppercase\n    return all_lowercase || all_uppercase;\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> primes_below_n(int n) {\n    vector<int> result;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digit of both numbers by taking modulo 10\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(const std::string& value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0) { // Positive number logic\n        if (std::floor(num + 0.5) - num == 0.5)\n            return static_cast<int>(std::ceil(num));\n        else\n            return static_cast<int>(round(num));\n    } else { // Negative number logic\n        if (num < 0 && std::ceil(num - 0.5) - num == -0.5)\n            return static_cast<int>(std::floor(num));\n        else\n            return static_cast<int>(round(num));\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Determine if we start with an odd or even increment\n    int next_stone_count = n;  // First level has 'n' stones\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(next_stone_count);\n        \n        // Increment by the next odd/even number based on initial parity of n\n        if (n % 2 == 0) {  // If n is even, increment by 2 to get the next even number\n            next_stone_count += 2;\n        } else {  // If n is odd, increment by 2 to get the next odd number\n            next_stone_count += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage and check function (not part of the original problem but for testing)\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    printf(\"{\");\n    for(int i = 0; i < result.size(); ++i) {\n        if(i != 0) printf(\", \");\n        printf(\"%d\", result[i]);\n    }\n    printf(\"}\\n\");\n\n    // Expected output: {3, 5, 7}\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for(char c : s) {\n        if(c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result\n            if(!word.empty()) {\n                result.push_back(word);\n                word.clear();  // Clear the word buffer\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop ends (in case there's no trailing comma or space)\n    if(!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector of strings for testing purposes\nvoid print_vector(const vector<string>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << \"\\\"\" << v[i] << \"\\\"\";\n        if(i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x <= y for simplicity\n    if (x > y) {\n        return -1;\n    }\n    \n    // Start from the largest number in the range and work backwards to find an even number.\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {  // Check if the number is even\n            return i;       // Return the first even number found, which will be the largest in this range.\n        }\n    }\n\n    // If no even number was found within the range [x, y]\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    // Calculate the sum of integers from n to m using arithmetic series formula\n    long total_sum = (long)(m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round down to nearest integer\n    int avg = floor(total_sum / (m - n + 1));\n    \n    // Convert the rounded average to binary string\n    if (avg == 0) return \"0\"; // Special case for zero\n    \n    string result = \"\";\n    while (avg > 0) {\n        result = to_string(avg % 2) + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a number has any even digit.\nbool has_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if it's an even digit\n            return true;\n        }\n        n /= 10; // Remove the last digit\n    }\n    return false;\n}\n\n// Function to filter and sort numbers with only odd digits.\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers that have even digits\n    for (int num : x) {\n        if (!has_even_digit(num)) { // If the number has no even digit, add it to the result\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test and print results.\nvoid check(vector<int> input) {\n    vector<int> output = unique_digits(input);\n    for (int num : output) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map integers 1-9 to their respective string names\nconst map<int, string> digit_to_word = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n    {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out integers that are not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector to get descending order\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map each integer to its corresponding word representation\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(digit_to_word[num]);\n    }\n\n    return result;\n}\n\n// Example usage and verification function\nvoid check_solution() {\n    vector<int> test1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(test1) == expected1);\n\n    vector<int> test2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(test2) == expected2);\n\n    vector<int> test3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(test3) == expected3);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Function to compute factorial of a number\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the sum from 1 to num\nint arithmeticSum(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the number is even\n            result[i] = factorial(i + 1); // Calculate factorial of i+1\n        } else {\n            result[i] = arithmeticSum(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function (not part of the original problem)\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> output = f(5);\n    \n    bool isCorrect = true;\n    for(int i = 0; i < expected.size(); ++i) {\n        if(expected[i] != output[i]) {\n            isCorrect = false;\n            break;\n        }\n    }\n\n    printf(isCorrect ? \"Correct\\n\" : \"Incorrect\\n\");\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0, right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) return false;\n        ++left; --right;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements set to zero\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                ++result[0]; // Increment even count\n            } else {\n                ++result[1]; // Increment odd count\n            }\n        }\n    }\n\n    return result;\n}\n\n// Example usage and verification function\nvoid check() {\n    vector<int> result = even_odd_palindrome(3);\n    printf(\"Output: (%d, %d)\\n\", result[0], result[1]); // Expected output: (1, 2)\n\n    result = even_odd_palindrome(12);\n    printf(\"Output: (%d, %d)\\n\", result[0], result[1]); // Expected output: (4, 6)\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of signed digits of an integer.\nint sum_of_signed_digits(int num) {\n    int sum = 0;\n    bool is_negative = (num < 0);\n    \n    while(num != 0) {\n        // Get the last digit, considering negative numbers\n        int digit = num % 10;\n        \n        if(is_negative && digit == 0) { \n            // Skip leading zeros in negative numbers\n            continue; \n        }\n        \n        sum += (is_negative ? -digit : digit);\n        num /= 10;\n    }\n\n    return sum;\n}\n\n// Function to count how many numbers have a sum of digits > 0.\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for(int i = 0; i < n.size(); ++i) {\n        if(sum_of_signed_digits(n[i]) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Function to test the correctness of count_nums function.\nvoid check() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // If vector is empty, it's trivially sortable\n\n    int n = arr.size();\n    \n    // Find the index where the sequence breaks from being non-decreasing\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) { // Found a break point\n            // Check if the array can be sorted by right shifting\n            int j;\n            for (j = i + 2; j < n && arr[j] >= arr[0]; ++j); // Ensure elements after break are greater than or equal to first element\n            \n            // If we reached the end of the vector without breaking, it's sortable\n            if (j == n) return true;\n            \n            // Otherwise, it cannot be sorted by right shifting\n            return false;\n        }\n    }\n\n    // If no break point is found, array is already in non-decreasing order\n    return true;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in a vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (auto num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check the number of even numbers in a vector\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (auto num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n    }\n    return evens >= requiredCount;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of odd numbers in lst1\n    int oddCount = countOdd(lst1);\n    \n    // Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to split a string by spaces and return a vector of substrings\nvector<string> split(const string &s) {\n    vector<string> tokens;\n    size_t start = 0, end = 0;\n    while ((end = s.find(\" \", start)) != string::npos) {\n        if (end - start > 0)\n            tokens.push_back(s.substr(start, end - start));\n        start = end + 1;\n    }\n    // Add the last token\n    if (start < s.length())\n        tokens.push_back(s.substr(start));\n    return tokens;\n}\n\nmap<char,int> histogram(string test) {\n    map<char, int> charCount; // Map to store character counts\n    vector<string> words = split(test); // Split input string into individual characters\n\n    // Count occurrences of each character\n    for (const auto &word : words) {\n        if (!word.empty()) { // Ensure the word is not an empty string due to multiple spaces\n            charCount[word[0]]++;\n        }\n    }\n\n    int maxCount = 0;\n    \n    // Find the maximum count among all characters\n    for (auto const& [chara, count] : charCount) {\n        if (count > maxCount)\n            maxCount = count;\n    }\n\n    // Create a map with only those characters that have the maximum count\n    map<char,int> result;\n    for (auto const& [chara, count] : charCount) {\n        if (count == maxCount)\n            result[chara] = count;\n    }\n    \n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto &entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPalindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool isPal = isPalindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(isPal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0; // Initialize the count of odd digits\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the result string with the count of odd digits\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output); // Add constructed string to result\n    }\n\n    return result;\n}\n\n// Example usage and check function (not part of the solution, for testing purposes)\nvoid check() {\n    auto result1 = odd_count({\"1234567\"});\n    assert(result1[0] == \"the number of odd elements 4n the str4ng 4 of the 4nput.\");\n\n    auto result2 = odd_count({\"3\", \"11111111\"});\n    assert(result2[0] == \"the number of odd elements 1n the str1ng 1 of the 1nput.\");\n    assert(result2[1] == \"the number of odd elements 8n the str8ng 8 of the 8nput.\");\n\n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>  // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0;  // Handle empty vector case\n    \n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // If current sum becomes negative, start new sub-array from the current element\n        if (current_sum > 0) {\n            current_sum = nums[i];  // Start a new sub-array with the current element\n        } else {\n            current_sum += nums[i];  // Continue the existing sub-array\n        }\n        \n        // Update min_sum if current_sum is less than min_sum\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n    }\n\n    return min_sum;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert(minSubArraySum({-1, -2, -3}) == -6);\n    assert(minSubArraySum({1, 2, 3, -6, 5}) == -6);\n    assert(minSubArraySum({10, -3, -4, 7, 2, -5}) == -9); // Minimum sum sub-array is {-3, -4, 7, 2, -5} = -9\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    // Calculate total water in each well and sum up the number of times buckets need to be used.\n    int total_buckets = 0;\n    \n    for (const auto& row : grid) {\n        int water_units_in_row = 0; // Count units of water in current well\n        for (int unit : row) {\n            if (unit == 1) {\n                water_units_in_row++;\n            }\n        }\n        \n        // Calculate the number of times a bucket needs to be lowered.\n        total_buckets += (water_units_in_row + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of set bits in an integer\nint countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator function for sorting\nbool customComparator(int a, int b) {\n    // Count set bits in both numbers\n    int bitCountA = countSetBits(a);\n    int bitCountB = countSetBits(b);\n\n    // If the number of set bits is different, sort by that\n    if (bitCountA != bitCountB)\n        return bitCountA < bitCountB;\n\n    // If the number of set bits is the same, sort by decimal value\n    return a < b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort using custom comparator\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n// Function to test and print sorted array\nvoid testSortArray() {\n    vector<int> test1 = {1, 5, 2, 3, 4};\n    vector<int> result1 = sort_array(test1);\n    for (int num : result1) cout << num << \" \";\n    cout << endl;\n\n    vector<int> test2 = {-2, -3, -4, -5, -6};\n    vector<int> result2 = sort_array(test2);\n    for (int num : result2) cout << num << \" \";\n    cout << endl;\n\n    vector<int> test3 = {1, 0, 2, 3, 4};\n    vector<int> result3 = sort_array(test3);\n    for (int num : result3) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert to lowercase for simplicity\n    char lower_c = tolower(c);\n    return !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || \n             lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        int consonant_count = 0;\n        \n        // Count consonants in the current word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                ++consonant_count;\n            }\n        }\n        \n        // Check if the number of consonants matches n\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<string> expected1 = {\"little\"};\n    assert(select_words(\"Mary had a little lamb\", 4) == expected1);\n\n    vector<string> expected2 = {\"Mary\", \"lamb\"};\n    assert(select_words(\"Mary had a little lamb\", 3) == expected2);\n\n    vector<string> expected3;\n    assert(select_words(\"\\\"simple white space\\\"\", 2).empty());\n\n    vector<string> expected4 = {\"world\"};\n    assert(select_words(\"Hello world\", 4) == expected4);\n\n    vector<string> expected5 = {\"Uncle\"};\n    assert(select_words(\"Uncle sam\", 3) == expected5);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char ch) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(ch) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char mid_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the middle character is a vowel and both surrounding characters are consonants\n        if (is_vowel(mid_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, mid_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        // If at any point the balance goes negative, it's unbalanced\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // The string is balanced only if the final balance is zero\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both concatenation orders\n    bool order1_balanced = is_balanced(lst[0] + lst[1]);\n    bool order2_balanced = is_balanced(lst[1] + lst[0]);\n\n    if (order1_balanced || order2_balanced) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> maximum(std::vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order.\n    std::sort(arr.begin(), arr.end(), std::greater<int>());\n    \n    // Step 2: Take the first k elements from the sorted vector.\n    std::vector<int> result;\n    for (int i = 0; i < k && i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the resulting vector in ascending order before returning it.\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    assert((maximum({-3, -4, 5}, 3) == std::vector<int>{-4, -3, 5}));\n    assert((maximum({4, -4, 4}, 2) == std::vector<int>{4, 4}));\n    assert((maximum({-3, 2, 1, 2, -1, -2, 1}, 1) == std::vector<int>{2}));\n    \n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-based index)\n    for(size_t i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element at position 'i' is odd\n            sum += lst[i]; // Add it to the sum if it's odd\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the vector\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) { \n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function (not part of the solution, for testing purposes)\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> odds;\n    \n    while (n != 1) { // Continue until reaching 1\n        if (n % 2 == 1) { // If the number is odd, add it to the vector\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    \n    // Add the last element of the sequence which is always 1\n    odds.push_back(1);\n\n    std::sort(odds.begin(), odds.end()); // Sort in increasing order\n    \n    return odds;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty\n    if (date.empty()) return false;\n    \n    // Split the date into month, day, and year components\n    size_t first_dash = date.find('-');\n    size_t second_dash = date.find('-', first_dash + 1);\n    \n    if (first_dash == string::npos || second_dash == string::npos) {\n        return false; // Incorrect format\n    }\n    \n    int month = stoi(date.substr(0, first_dash));\n    int day = stoi(date.substr(first_dash + 1, second_dash - first_dash - 1));\n    int year = stoi(date.substr(second_dash + 1));\n\n    // Validate the month\n    if (month < 1 || month > 12) return false;\n\n    // Validate the day based on the month\n    bool is_leap_year = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    \n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day < 1 || day > 31) {\n        return false;\n    } else if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if (month == 2) {\n        if (is_leap_year && (day < 1 || day > 29)) {\n            return false;\n        } else if (!is_leap_year && (day < 1 || day > 28)) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> split_words(string txt){\n    // Helper function to check if the string contains any whitespace or commas.\n    bool hasWhitespaceOrComma = false;\n    \n    for (char c : txt) {\n        if (c == ' ' || c == ',') {\n            hasWhitespaceOrComma = true;\n            break;\n        }\n    }\n\n    vector<string> result;\n\n    // Split on whitespace\n    if (hasWhitespaceOrComma && txt.find(' ') != string::npos) {\n        size_t start = 0, end = 0;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        // Add the last word\n        if (start < txt.length()) {\n            result.push_back(txt.substr(start));\n        }\n    } \n    // Split on comma if no whitespace was found\n    else if (hasWhitespaceOrComma && txt.find(',') != string::npos) {\n        size_t start = 0, end = 0;\n        while ((end = txt.find(',', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        // Add the last word\n        if (start < txt.length()) {\n            result.push_back(txt.substr(start));\n        }\n    } \n    // Count lowercase letters with odd order indices in the alphabet\n    else {\n        int countOddOrderLetters = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                int index = c - 'a';\n                if (index % 2 == 1) {\n                    ++countOddOrderLetters;\n                }\n            }\n        }\n        result.push_back(to_string(countOddOrderLetters));\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if(lst.size() <= 1) {\n        return true;\n    }\n\n    // Map to count occurrences of each number\n    unordered_map<int, int> occurrence;\n\n    // Iterate through the vector and check for ascending order and count occurrences\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false; // Not in ascending order\n        }\n        \n        occurrence[lst[i]]++;\n        if(occurrence[lst[i]] > 2) {\n            return false; // Number appears more than twice\n        }\n    }\n\n    return true;\n}\n\n// Example usage and check function (not part of the solution, for testing purposes)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to determine the intersection length and check if it's prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start_max > end_min) return \"NO\";\n\n    // Calculate the length of the intersection\n    int intersection_length = end_min - start_max + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(intersection_length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) {  // Check for empty vector\n        return -32768;\n    }\n\n    int totalMagnitude = 0;  // Sum of magnitudes\n    int signProduct = 1;     // Product of signs\n\n    for (int num : arr) {\n        totalMagnitude += std::abs(num);  // Add magnitude to totalMagnitude\n        \n        if (num == 0) {  // If any number is zero, the product will be zero\n            return 0;\n        } else if (num < 0) {  // Update signProduct for negative numbers\n            signProduct *= -1;\n        }\n    }\n\n    return totalMagnitude * signProduct;  // Return final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Path {\n    vector<int> cells;\n    int row, col; // Current position in the grid\n};\n\n// Function to check if a move is within bounds of the grid\nbool isValid(int r, int c, int N) {\n    return r >= 0 && r < N && c >= 0 && c < N;\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Initialize a queue to perform BFS\n    queue<Path> q;\n    \n    // Start from every cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            Path start;\n            start.cells.push_back(grid[i][j]);\n            start.row = i, start.col = j;\n            q.push(start);\n        }\n    }\n\n    vector<int> minPath(N * N + 1, INT_MAX); // Initialize with a large value\n    int minVal = INT_MAX;\n\n    while (!q.empty()) {\n        Path current = q.front();\n        q.pop();\n\n        if (current.cells.size() == k) { // If the path length is reached\n            vector<int> pathCopy(current.cells);\n            if (pathCopy < minPath || (pathCopy == minPath && pathCopy[0] < minVal)) {\n                minPath = pathCopy;\n                minVal = current.cells.front();\n            }\n        } else {\n            // Explore neighbors\n            int r = current.row, c = current.col;\n            for (int dr = -1; dr <= 1; ++dr) {\n                for (int dc = -1; dc <= 1; dc++) {\n                    if ((abs(dr + dc) == 1) && isValid(r + dr, c + dc, N)) { // Only consider up/down/left/right moves\n                        Path next;\n                        next.cells = current.cells;\n                        next.cells.push_back(grid[r + dr][c + dc]);\n                        next.row = r + dr, next.col = c + dc;\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n\n    return minPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result;\n    \n    // Base cases\n    if (n >= 1) result.push_back(3); // tri(1)\n    if (n >= 2) result.push_back(2); // tri(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int nextValue;\n        \n        // Determine the value based on whether i is even or odd\n        if (i % 2 == 0) {\n            nextValue = 1 + i / 2;\n        } else {\n            // Calculate tri(i - 1), tri(i - 2), and tri(i + 1)\n            int prev1, prev2, next;\n            \n            // Handle edge cases for calculating tri(i + 1)\n            if (i == 3) {\n                next = result[0]; // tri(4) = tri(1)\n            } else {\n                next = i < n ? result[i] : result[i - 1];\n            }\n            \n            prev1 = result[result.size() - 1]; // tri(i - 1)\n            prev2 = result[result.size() - 2]; // tri(i - 2)\n\n            nextValue = prev1 + prev2 + next;\n        }\n\n        result.push_back(nextValue);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false; // To check if there is at least one odd digit\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOddDigit ? product : 0; // Return the product or 0 if no odd digits were found\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool is_nested(const std::string& str) {\n    std::stack<char> brackets;\n    \n    for (char c : str) {\n        if (c == '[') {\n            // Push opening bracket onto the stack\n            brackets.push(c);\n        } else if (c == ']' && !brackets.empty()) {\n            // Pop a matching opening bracket from the stack\n            brackets.pop();\n            \n            // If there's still an unmatched `[` in the stack, it means we have nested brackets\n            if (!brackets.empty() && c == ']') {\n                return true;\n            }\n        } else {\n            // Invalid character encountered (should not happen as input is guaranteed to be only square brackets)\n            return false;\n        }\n    }\n\n    // If there are unmatched opening brackets, the string is invalid but we don't care about this case here\n    return false;  // Return true if nested structure was found during traversal\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        int rounded_num = static_cast<int>(ceil(num)); // Round up to the nearest integer\n        sum += rounded_num * rounded_num; // Square and add to sum\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n\nbool check_if_last_char_is_a_letter(const std::string& txt) {\n    // Check for empty string\n    if (txt.empty()) return false;\n\n    int len = txt.length();\n    \n    // Find the last non-space character\n    while (len > 0 && txt[len - 1] == ' ') {\n        --len;\n    }\n\n    // If there's only one character and it's a letter, return true\n    if (len == 1) {\n        char ch = txt[0];\n        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n    }\n    \n    // Check the last non-space character is a letter and it's not part of a word\n    if (len > 1) {\n        char lastChar = txt[len - 1];\n        char prevChar = txt[len - 2];\n\n        return ((lastChar >= 'a' && lastChar <= 'z') || (lastChar >= 'A' && lastChar <= 'Z')) &&\n               (prevChar == ' ');\n    }\n\n    // If the string ends with a letter but there's no preceding space, it is part of a word\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if the current element is not greater than or equal to the previous one\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    // If no such element was found, return -1\n    return -1;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {1, 2, 4, 3, 5};\n    vector<int> test2 = {1, 2, 3};\n\n    printf(\"can_arrange({1,2,4,3,5}) = %d (Expected: 3)\\n\", can_arrange(test1));\n    printf(\"can_arrange({1,2,3}) = %d (Expected: -1)\\n\", can_arrange(test2));\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative number was found, set max_negative to 0\n    if (max_negative == INT_MIN) {\n        max_negative = 0;\n    }\n    \n    // If no positive number was found, set min_positive to 0\n    if (min_positive == INT_MAX) {\n        min_positive = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(test1);\n    printf(\"Test 1: (%d, %d)\\n\", result1[0], result1[1]); // Expected (0, 1)\n\n    vector<int> test2 = {};\n    vector<int> result2 = largest_smallest_integers(test2);\n    printf(\"Test 2: (%d, %d)\\n\", result2[0], result2[1]); // Expected (0, 0)\n\n    vector<int> test3 = {0};\n    vector<int> result3 = largest_smallest_integers(test3);\n    printf(\"Test 3: (%d, %d)\\n\", result3[0], result3[1]); // Expected (0, 0)\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to float\nfloat parse_float(const std::string& str) {\n    size_t pos = str.find(',');\n    if (pos != std::string::npos) {\n        return std::stof(str.substr(0, pos) + \".\" + str.substr(pos + 1));\n    }\n    return std::stof(str);\n}\n\n// Function to compare two values of any type and return the larger one\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(int)) {\n        int ai = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int bi = boost::any_cast<int>(b);\n            return ai > bi ? ai : (ai < bi ? bi : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float bf = boost::any_cast<float>(b);\n            return static_cast<float>(ai) > bf ? ai : (static_cast<float>(ai) < bf ? bf : \"None\");\n        } else { // b is a string\n            std::string bs = boost::any_cast<std::string>(b);\n            float ba = parse_float(bs);\n            return static_cast<float>(ai) > ba ? ai : (static_cast<float>(ai) < ba ? bs : \"None\");\n        }\n    } else if (a.type() == typeid(float)) {\n        float af = boost::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int bi = boost::any_cast<int>(b);\n            return af > static_cast<float>(bi) ? af : (af < static_cast<float>(bi) ? bi : \"None\");\n        } else { // b is a float or string\n            if (b.type() == typeid(float)) {\n                float bf = boost::any_cast<float>(b);\n                return af > bf ? af : (af < bf ? bf : \"None\");\n            } else { // b is a string\n                std::string bs = boost::any_cast<std::string>(b);\n                float ba = parse_float(bs);\n                return af > ba ? af : (af < ba ? bs : \"None\");\n            }\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string as = boost::any_cast<std::string>(a);\n        if (b.type() == typeid(int)) {\n            int bi = boost::any_cast<int>(b);\n            float ba = parse_float(as);\n            return ba > static_cast<float>(bi) ? as : (ba < static_cast<float>(bi) ? bi : \"None\");\n        } else { // b is a float or string\n            if (b.type() == typeid(float)) {\n                float bf = boost::any_cast<float>(b);\n                float ba = parse_float(as);\n                return ba > bf ? as : (ba < bf ? std::to_string(bf) : \"None\");\n            } else { // b is a string\n                std::string bs = boost::any_cast<std::string>(b);\n                float ba = parse_float(as);\n                float bb = parse_float(bs);\n                return ba > bb ? as : (ba < bb ? bs : \"None\");\n            }\n        }\n    }\n\n    return \"None\"; // Fallback in case of unexpected types\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8, return false as it cannot be expressed as sum of four positive even numbers.\n    if (n < 8)\n        return false;\n    \n    // If n is at least 8 and even, then it can always be written as the sum of four positive even numbers.\n    return n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\n\n// Function to compute factorial of n\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Example usage and test function\nvoid check() {\n    printf(\"special_factorial(4) = %lld\\n\", special_factorial(4)); // Should output 288\n    printf(\"special_factorial(3) = %lld\\n\", special_factorial(3)); // Should output 12 (3! * 2! * 1!)\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n    \n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            // If there are more than two consecutive spaces, append '-' and reset count\n            if (spaceCount > 2) continue; \n            else result += '_';\n        } else {\n            // Reset the space counter when a non-space character is encountered\n            spaceCount = 0;\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nbool is_valid_start(const std::string& name) {\n    // Check if the first character is a letter and there are no more than three digits.\n    bool has_digit = false;\n    int digit_count = 0;\n\n    for (size_t i = 0; i < name.length(); ++i) {\n        char c = name[i];\n        if (!isalpha(c)) { // Check if the first character is a letter\n            return false;\n        }\n        if (isdigit(c)) { // Count digits and ensure there are no more than three\n            digit_count++;\n            has_digit = true;\n        }\n    }\n\n    return has_digit && digit_count <= 3;\n}\n\nbool is_valid_extension(const std::string& extension) {\n    // Check if the extension matches one of the allowed extensions.\n    static const char* valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    for (const auto& ext : valid_extensions) {\n        if (extension == ext) return true;\n    }\n    return false;\n}\n\nstd::string file_name_check(const std::string& file_name) {\n    size_t dot_pos = file_name.find('.');\n    \n    // Check if there is exactly one dot in the filename\n    if (dot_pos == std::string::npos || file_name.rfind('.', 1) != dot_pos)\n        return \"No\";\n    \n    // Split the filename into name and extension parts\n    std::string name = file_name.substr(0, dot_pos);\n    std::string extension = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is valid\n    if (!is_valid_start(name))\n        return \"No\";\n    \n    // Check if the extension part matches one of the allowed extensions\n    if (!is_valid_extension(extension))\n        return \"No\";\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the entry and add to sum\n        } else if ((i + 1) % 4 == 0) { // Index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the entry and add to sum\n        } else {\n            sum += lst[i]; // Add the entry as it is, since no transformation needed\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i)\n        if (n % i == 0) return false;\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::string word, result;\n    \n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to parse fraction and return numerator and denominator as integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to multiply two fractions and check if the result is a whole number\nbool simplify(string x, string n) {\n    int numeratorX, denominatorX;\n    int numeratorN, denominatorN;\n\n    // Parse the fractions\n    parseFraction(x, numeratorX, denominatorX);\n    parseFraction(n, numeratorN, denominatorN);\n\n    // Multiply the numerators and denominators separately\n    long long resultNum = (long long)numeratorX * numeratorN;  // Use long long to avoid overflow\n    long long resultDen = (long long)denominatorX * denominatorN;\n\n    // Simplify the fraction by finding the greatest common divisor (GCD)\n    int gcdResult = __gcd(resultNum, resultDen);\n\n    // Divide both numerator and denominator by their GCD\n    resultNum /= gcdResult;\n    resultDen /= gcdResult;\n\n    // Check if the simplified denominator is 1, meaning it's a whole number\n    return resultDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\n// Helper function to calculate the sum of digits of an integer.\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += abs(num % 10);\n        num /= 10;\n    }\n    return sum;\n}\n\n// Function to sort vector based on digit sums and original indices\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Create a vector of pairs (index, value)\n    std::vector<std::pair<int, int>> indexed_nums(nums.size());\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums[i] = {i, nums[i]};\n    }\n\n    // Sort based on digit sum and then by original index\n    std::sort(indexed_nums.begin(), indexed_nums.end(),\n              [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                  int sum_a = sum_of_digits(a.second);\n                  int sum_b = sum_of_digits(b.second);\n\n                  if (sum_a == sum_b) return a.first < b.first;\n                  return sum_a < sum_b;\n              });\n\n    // Extract the sorted values back into a vector\n    std::vector<int> result(nums.size());\n    for (size_t i = 0; i < nums.size(); ++i) {\n        result[i] = indexed_nums[i].second;\n    }\n\n    return result;\n}\n\n// Function to test and print results\nvoid check(const std::vector<int>& input, const std::vector<int>& expected) {\n    auto output = order_by_points(input);\n    if (output == expected) {\n        std::cout << \"Correct: \";\n    } else {\n        std::cout << \"Incorrect: \";\n    }\n    for (int num : output) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (auto num : nums) {\n        if (num <= 10) continue; // Skip numbers less than or equal to 10\n        \n        string strNum = to_string(abs(num)); // Convert number to string and take absolute value\n        char firstDigit = strNum[0];\n        char lastDigit = strNum[strNum.length() - 1];\n        \n        bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n                           firstDigit == '7' || firstDigit == '9');\n        bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n                          lastDigit == '7' || lastDigit == '9');\n\n        if (isFirstOdd && isLastOdd) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the vector 'a' based on the formula.\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // For std::sort\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    // List of planets ordered by their proximity to the Sun.\n    const std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find indices for planet1 and planet2\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planet1 == planets[i]) index1 = i;\n        if (planet2 == planets[i]) index2 = i;\n    }\n    \n    // Check if both planet names are valid\n    if (index1 == -1 || index2 == -1) return std::vector<std::string>(); // Return empty vector\n    \n    // Ensure index1 < index2 for correct order\n    if (index1 > index2) {\n        std::swap(index1, index2);\n    }\n    \n    // Extract planets between index1 and index2\n    std::vector<std::string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function for sorting strings by length and lexicographically.\nbool compare_strings(const string& a, const string& b) {\n    // First compare by length in ascending order.\n    if (a.length() != b.length()) return a.length() < b.length();\n    // If lengths are the same, sort alphabetically.\n    return a < b;\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(),\n                        [](const string& s) { return s.length() % 2 != 0; }),\n              lst.end());\n\n    // Sort the remaining strings by length and lexicographically.\n    sort(lst.begin(), lst.end(), compare_strings);\n\n    return lst;\n}\n\n// Function to check if the solution is correct\nvoid check(vector<string> input, vector<string> expected) {\n    vector<string> result = sorted_list_sum(input);\n    for (const auto& str : result) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) { // Check divisibility up to the square root of n\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Main function that returns x if n is prime, otherwise y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y; // Use ternary operator to decide the value based on primality of n\n}\n\n// Function to test the correctness of x_or_y\nvoid check() {\n    cout << \"x_or_y(7, 34, 12): Expected: 34, Got: \" << x_or_y(7, 34, 12) << endl;\n    cout << \"x_or_y(15, 8, 5): Expected: 5, Got: \" << x_or_y(15, 8, 5) << endl;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long sum_of_odd_squares(const std::vector<float>& lst) {\n    long long result = 0;\n    \n    for (float num : lst) {\n        // Check if number is an integer and positive\n        if ((int)num == num && num > 0) {\n            int n = static_cast<int>(num);\n            // Check if the number is odd\n            if (n % 2 != 0) {\n                result += std::pow(n, 2); \n            }\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate the strength of an extension\nint calculate_strength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer\n\n    for (const auto& extension : extensions) {\n        int strength = calculate_strength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate 'a' with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    int even = 0, odd = 0;\n    \n    // Handle negative numbers by converting to positive\n    num = abs(num);\n    \n    while (num > 0) {\n        int digit = num % 10;  // Get the last digit\n        \n        if (digit % 2 == 0)\n            even++;  // Increment even count\n        else\n            odd++;   // Increment odd count\n        \n        num /= 10;  // Remove the last digit\n    }\n    \n    return {even, odd};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to lowercase roman numeral\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> mappings = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},\n        {400, \"cd\"},  {100, \"c\"},   {90, \"xc\"},\n        {50, \"l\"},    {40, \"xl\"},   {10, \"x\"},\n        {9, \"ix\"},    {5, \"v\"},     {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string roman = \"\";\n    \n    for (const auto& mapping : mappings) {\n        while (number >= mapping.first) {\n            roman += mapping.second;\n            number -= mapping.first;\n        }\n    }\n\n    return roman;\n}\n\n// Function to test the conversion\nvoid check(int num, const string& expected) {\n    string result = int_to_mini_roman(num);\n    cout << \"int_to_mini_roman(\" << num << \") == \\\"\" << result << \"\\\"\";\n    if (result == expected)\n        cout << \" (Correct)\";\n    else\n        cout << \" (Incorrect: Expected \\\"\" << expected << \"\\\")\";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::sqrt\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    \n    // Check Pythagorean theorem\n    return (std::pow(sides[0], 2) + std::pow(sides[1], 2)) == std::pow(sides[2], 2);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false}; // Assuming ASCII character set\n    int unique_count = 0;\n    \n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            ++unique_count;\n        }\n    }\n    \n    return unique_count;\n}\n\n// Function to find the string with maximum number of unique characters\nstring find_max(vector<string> words) {\n    // Initialize result with an empty string and a count of 0\n    string max_unique_word = \"\";\n    int max_unique_count = 0;\n\n    for (const auto& word : words) {\n        int current_unique_count = count_unique_chars(word);\n        \n        if (current_unique_count > max_unique_count || \n            (current_unique_count == max_unique_count && word < max_unique_word)) {\n            max_unique_word = word;\n            max_unique_count = current_unique_count;\n        }\n    }\n\n    return max_unique_word;\n}\n\n// Example usage\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots that will be eaten\n    int to_eat = min(need, remaining);  // Eat up to what is available or needed.\n    \n    // Update the total number of carrots eaten and remaining carrots in stock\n    int total_eaten = number + to_eat;\n    int left_over = remaining - to_eat;\n\n    return {total_eaten, left_over};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    // Construct the algebraic expression as a string\n    std::stringstream expr;\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (i > 0) { // Add operand only after first operator\n            expr << \" \";\n        }\n        expr << operands[i];\n        \n        if (i < operators.size()) {\n            expr << \" \" << operators[i] << \" \";\n        }\n    }\n\n    // Append the last operand\n    expr << operands[operands.size() - 1];\n\n    std::string expression = expr.str();\n    \n    // Evaluate the constructed algebraic expression\n    int result;\n    std::stringstream ss(expression);\n    ss >> result; // Read first number\n    \n    char op;\n    while (ss >> op) {\n        int next_operand;\n        ss >> next_operand;\n        \n        if (op == '+') {\n            result += next_operand;\n        } else if (op == '-') {\n            result -= next_operand;\n        } else if (op == '*') {\n            result *= next_operand;\n        } else if (op == '/') {\n            // Assuming floor division for simplicity\n            result /= next_operand;\n        } else if (op == '^' || op == \"**\") { // Exponentiation\n            result = pow(result, next_operand);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Iterate through each character of the string\n    for (char &c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            hasLetters = true;  // Mark that there is at least one letter in the string\n            \n            // Reverse case of the character\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    // If no letters are found, reverse the entire string\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nstd::string string_to_md5(std::string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), hash);\n\n    std::stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is always less than or equal to 'b'\n    if (a > b) {\n        std::swap(a, b);\n    }\n\n    std::vector<int> even_digits = {2, 4, 6, 8};\n    std::vector<int> result;\n\n    // Find the first occurrence of an even digit in the range [a, b]\n    auto it = std::lower_bound(even_digits.begin(), even_digits.end(), a);\n\n    // Add all even digits from 'it' to the end of 'even_digits'\n    for (; it != even_digits.end() && *it <= b; ++it) {\n        result.push_back(*it);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Check each pair of consecutive elements for closeness.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close pairs were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::stack<int> stack; // Stack to keep track of opening parentheses positions.\n    \n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    for (int i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i); // Push position of opening parenthesis.\n        } else if (!stack.empty() && paren_string[i] == ')') {\n            int start_pos = stack.top();\n            stack.pop();\n\n            // If the current group is a single pair or it's not nested within another, add to result\n            if (start_pos - 1 >= 0 && paren_string[start_pos - 1] != '(') {\n                std::string group(paren_string.begin() + start_pos, paren_string.begin() + i + 1);\n                result.push_back(group);\n            }\n        }\n    }\n\n    // Handle nested groups\n    for (int i = 0; i < paren_string.length(); ++i) {\n        if (!stack.empty()) continue;\n\n        int balance = 0;\n        std::string group = \"\";\n        \n        while (i < paren_string.length() && balance >= 0) {\n            char c = paren_string[i];\n            if (c == '(') balance++;\n            else if (c == ')') balance--;\n\n            group += c;\n            i++;\n\n            // If we have a balanced group, add it to the result and reset\n            if (balance == 0 && !group.empty()) {\n                result.push_back(group);\n                group = \"\";\n            }\n        }\n\n        i--; // Adjust for the extra increment in the loop\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Declare variables to hold the integer and decimal parts.\n    long int integerPart;\n    \n    // Use modf to split the number into its integer and fractional parts.\n    float decimalPart = modf(number, &integerPart);\n    \n    return decimalPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n    \n    return false; // If we've gone through all operations and never fell below zero, return false\n}\n\n// Example usage:\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    std::size_t newSize = numbers.size() * 2 - 1;\n    \n    if (newSize <= 0) return {};  // If input is empty or has only one element\n    \n    // Reserve space for the new vector to avoid reallocations\n    std::vector<int> result(newSize);\n    \n    // Insert elements and delimiters into the result vector.\n    auto it = result.begin();\n    for (auto num : numbers) {\n        *it++ = num;\n        if (it != result.end()) {  // Avoid inserting delimiter after the last element\n            *it++ = delimeter;\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const std::vector<int>& vec) {\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase the depth when encountering an opening parenthesis\n            current_depth++;\n            if (current_depth > max_depth) {\n                max_depth = current_depth;\n            }\n        } else if (c == ')') {\n            // Decrease the depth when encountering a closing parenthesis\n            current_depth--;\n        } else if (c == ' ') {\n            // Reset for the next group of parentheses\n            depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Push back the last calculated maximum depth\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Create an empty vector to store the filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add the string to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    assert(filter_by_substring({}, \"a\") == vector<string>());\n    assert((filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")) == (vector<string>{\"abc\", \"bacd\", \"vector\"}));\n    \n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n\nstd::pair<int, int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;       // Add each number to the sum\n        product *= num;   // Multiply each number to the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test and print the result of sum_product\nvoid test_sum_product(const std::vector<int>& input) {\n    auto [sum, product] = sum_product(input);\n    std::cout << \"Sum: \" << sum << \", Product: \" << product << std::endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n    \n    std::vector<int> result;\n    int current_max = numbers[0];  // Initialize the first element as the initial maximum\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);  // Update the current max value\n        result.push_back(current_max);  // Append the current max to the result vector\n    }\n    \n    return result;\n}\n\n// Example usage and verification function\nvoid check_rolling_max() {\n    std::vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    std::vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    \n    std::vector<int> output = rolling_max(input);\n    \n    if (output == expected_output) {\n        printf(\"Test passed: Correct rolling max vector generated.\\n\");\n    } else {\n        printf(\"Test failed: Incorrect rolling max vector generated.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    return string(str.rbegin(), str.rend()) == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n     Find the shortest palindrome that begins with a supplied string. \n     Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n     - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    \n    // Start from the full length and decrease until we find the first palindromic suffix\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(i - 1))) { // Check if substring starting at i-1 is a palindrome\n            string prefix = str.substr(0, i - 1); // Get the non-palindromic part of the string\n            return str + string(prefix.rbegin(), prefix.rend()); // Append reverse of this prefix to the original string\n        }\n    }\n\n    // If no palindromic suffix is found (which shouldn't happen for any non-empty string), just return the input string reversed.\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";  // Return an empty string or handle error appropriately\n    }\n\n    string result = \"\";\n    \n    // Iterate through each character in both strings and perform XOR operation\n    for(int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // Both bits are the same, so XOR is 0\n        } else {\n            result += '1';  // Bits are different, so XOR is 1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ does not have a direct equivalent to Python's None for strings.\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // Check if current string is longer\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n// Example usage and check function (not part of the original problem but for testing)\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) return -1; // or throw an exception/error\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    \n    // Iterate through each character of the string\n    for (size_t i = 1; i <= str.length(); ++i) {\n        // Add substring from start to current index as a prefix\n        prefixes.push_back(str.substr(0, i));\n    }\n    \n    return prefixes;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    vector<string> result = all_prefixes(\"abc\");\n    for (const auto& prefix : result) {\n        printf(\"%s\\n\", prefix.c_str());\n    }\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\" << std::endl; // Should print: 0\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\" << std::endl; // Should print: 0 1 2 3 4 5\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase (or uppercase, but let's choose lowercase for consistency)\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    std::set<char> distinct_chars;\n    \n    // Insert each character into the set\n    for(char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // Return the size of the set, which is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int i = 0; // Index for iterating through the string\n\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') { // Whole note\n            beats.push_back(4);\n            i++; // Move to the next character\n        } else if (music_string.substr(i, 2) == \"o|\") { // Half note\n            beats.push_back(2);\n            i += 2; // Move past the two characters for half note\n        } else if (music_string.substr(i, 2) == \".|\") { // Quarter note\n            beats.push_back(1);\n            i += 2; // Move past the two characters for quarter note\n        } else {\n            // Handle unexpected input or whitespace\n            cout << \"Unexpected character at position: \" << i << endl;\n            i++; // Skip to next character\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    int count = 0;\n    size_t pos = 0; // Start position\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next character for overlapping\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n// Function to convert input string into sorted output string\nstring sort_numbers(string numbers) {\n    // Mapping from number words to their integer values\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Convert string to vector of integers\n    stringstream ss(numbers);\n    string word;\n    vector<int> nums;\n    while (ss >> word) {\n        if (num_map.find(word) != num_map.end()) {\n            nums.push_back(num_map[word]);\n        }\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Convert sorted integers back to words and join them into a string\n    stringstream result;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i > 0) result << \" \";\n        for (const auto& entry : num_map) {\n            if (entry.second == nums[i]) {\n                result << entry.first;\n                break;\n            }\n        }\n    }\n\n    return result.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    // Ensure there are at least two elements to compare.\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a, closest_b;\n\n    // Sort the numbers first to ensure we only need to check consecutive pairs.\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_a = sorted_numbers[i];\n            closest_b = sorted_numbers[i + 1];\n        }\n    }\n\n    return std::make_pair(closest_a, closest_b);\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\n// Function to rescale a vector of floats such that the minimum value is 0 and the maximum value is 1.\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw runtime_error(\"Vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        throw runtime_error(\"All elements are identical; cannot rescale.\");\n    }\n\n    // Apply linear transformation to each element in the vector\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}\n\n// Function to print a vector of floats\nvoid print_vector(const vector<float>& vec) {\n    for (const float& val : vec) {\n        printf(\"%.2f \", val);\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector of integers\nvoid print_vector(const std::vector<int>& vec) {\n    std::cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) std::cout << \", \";\n        std::cout << vec[i];\n    }\n    std::cout << \"}\" << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <cstring> // For strlen\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards to find the largest divisor.\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle the case of 2 separately to make the loop simpler later.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If there's any prime factor left, it must be greater than sqrt(n)\n    if (n > 2) {\n        factors.push_back(n); // The remaining value of n is a prime number\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Count occurrences of each element\n    map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Step 2: Create a new vector with elements that occur only once\n    vector<int> result;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate through each character in the string\n        if (islower(c)) {   // Check if the character is lowercase\n            c = toupper(c); // Convert to uppercase\n        } else if (isupper(c)) { // Check if the character is uppercase\n            c = tolower(c); // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to hold the result\n    std::string result;\n\n    // Iterate through each string in the vector and append it to the result\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Function to print elements of a vector<string>\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element in the input vector.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is positive.\n            result.push_back(num);  // Add it to the result vector.\n        }\n    }\n\n    return result;  // Return the vector containing only positive numbers.\n}\n\n// Example usage and check function\nvoid check() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    assert(get_positive(test1) == expected1);\n\n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    assert(get_positive(test2) == expected2);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0.0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble poly_derivative(const std::vector<double>& xs, double x) {\n    double derivative = 0.0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        derivative += i * xs[i] * pow(x, static_cast<int>(i - 1));\n    }\n    return derivative;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    double x = 0.5; // Initial guess\n    const double tolerance = 1e-6;\n    const int max_iterations = 100;\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double fx = poly(xs, x);\n        if (fabs(fx) < tolerance) break; // Convergence criterion\n\n        double dfx = poly_derivative(xs, x); // Derivative of the polynomial\n        if (dfx == 0.0) return x; // Avoid division by zero\n        \n        x -= fx / dfx;\n    }\n    \n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort; // To store elements divisible by three\n\n    // Extract elements at indices divisible by 3 (0-based index)\n    for (size_t i = 2; i < l.size(); i += 3) { \n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace original elements with sorted ones\n    size_t j = 0;\n    for (size_t i = 2; i < l.size() && j < to_sort.size(); i += 3) {\n        l[i] = to_sort[j++];\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Remove duplicates\n    auto last = unique(l.begin(), l.end()); // This function removes consecutive duplicates\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<float> vec1 = {1, 2, 3};\n    std::vector<float> vec2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n\n    printf(\"Max element in vec1: %.0f\\n\", max_element(vec1)); // Expected output: 3\n    printf(\"Max element in vec2: %.0f\\n\", max_element(vec2)); // Expected output: 123\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count occurrences of digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract even-indexed elements and store them in a separate vector.\n    std::vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements.\n    std::sort(evens.begin(), evens.end());\n\n    // Replace original even-indexed elements with sorted ones.\n    size_t j = 0;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        l[i] = evens[j++];\n    }\n\n    return l;\n}\n\n// Example usage and check function\n#include <iostream>\nvoid print_vector(const std::vector<float>& v) {\n    for (float val : v) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[1] + x[0] + x[2];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[1] + x[2] + x[0];\n        else if (x.length() == 2) x = x[1] + x[0];\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate Fibonacci numbers and check if they are prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1, fib3 = 1; // Initialize first three Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        fib3 = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib3;\n\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n)\n                return fib3; // Return the nth prime Fibonacci number\n        }\n    }\n\n    return -1; // This line should never be reached, but it's here for completeness.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to make it easier to avoid duplicates and use two-pointer technique.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move left pointer rightward\n            } else {\n                --right; // Need a smaller number, move right pointer leftward\n            }\n            \n            // Skip duplicates for the second and third elements of the triplet\n            while (left < right && l[left] == l[left - 1]) ++left;\n            while (left < right && l[right] == l[right + 1]) --right;\n        }\n    }\n    \n    return false; // No triplet found that sums to zero\n}\n\n// Example usage and testing function\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Each car moving left to right collides with each car moving right to left.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n\n// Function to print the elements of a vector\nvoid print_vector(const vector<int>& v) {\n    printf(\"{\");\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) printf(\", \");\n        printf(\"%d\", v[i]);\n    }\n    printf(\"}\\n\");\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to keep track of seen numbers.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement exists in the set.\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    // If no such pair is found, return false.\n    return false;\n}\n\n// Example usage and check function\n#include <iostream>\nbool check() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    return true;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    std::string result = \"\";\n    \n    // Loop until x is reduced to 0\n    while (x > 0) {\n        // Prepend the remainder of x divided by base to the result string.\n        // Convert the remainder to a character ('0' + remainder)\n        result = char('0' + (x % base)) + result;\n        \n        // Update x for the next iteration\n        x /= base;\n    }\n    \n    return result.empty() ? \"0\" : result;  // Return \"0\" if result is empty, otherwise return result.\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\n// Function to calculate the area of a triangle given its base (a) and height (h)\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\n\nint fib4(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n\n    // Initialize the first four values of the sequence.\n    int a = 0, b = 0, c = 2, d = 0; // fib4(0), fib4(1), fib4(2), fib4(3)\n\n    if (n == 3)\n        return d;\n\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::floor and std::ceil\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    if (n % 2 == 0) { // If even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // If odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match, so it's not a palindrome\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1.\n    \n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply result by base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adjusted formula to shift back by 5\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(const std::string& text) {\n    const std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n\n    // Iterate through each character in the input string.\n    for (char ch : text) {\n        if (vowels.find(ch) == std::string::npos) {  // Check if char is not a vowel\n            result += ch;                            // Add non-vowel characters to the result\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of remove_vowels function.\nvoid check_function() {\n    assert(remove_vowels(\"\") == \"\");\n    assert(remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert(remove_vowels(\"abcdef\") == \"bcdf\");\n    assert(remove_vowels(\"aaaaa\") == \"\");\n    assert(remove_vowels(\"aaBAA\") == \"B\");\n    assert(remove_vowels(\"zbcd\") == \"zbcd\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage and check function\n#include <iostream>\nbool check() {\n    bool result1 = below_threshold({1, 2, 4, 10}, 100);\n    bool result2 = below_threshold({1, 20, 4, 10}, 5);\n\n    if (result1 && !result2) {\n        std::cout << \"Correct!\" << std::endl;\n        return true;\n    } else {\n        std::cout << \"Incorrect.\" << std::endl;\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicates from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters to keep only unique ones.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting strings for equality.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\n// Function prototype declaration\nint fib(int n);\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int open_count = 0; // Counter for tracking open brackets\n\n    for (char c : brackets) {\n        if (c == '<') {\n            open_count++; // Increment count when an opening bracket is found\n        } else if (c == '>') {\n            open_count--; // Decrement count when a closing bracket is found\n            if (open_count < 0) {\n                return false; // If there are more closing brackets than opening ones, return false\n            }\n        }\n    }\n\n    return open_count == 0; // Return true only if all brackets are matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to remove duplicates from a sorted vector\nvoid removeDuplicates(vector<int>& vec) {\n    auto last = unique(vec.begin(), vec.end());\n    vec.erase(last, vec.end()); // Erase the unnecessary elements\n}\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    removeDuplicates(l1);\n    removeDuplicates(l2);\n\n    // Initialize result vector\n    vector<int> commonElements;\n\n    // Find common elements\n    set_intersection(l1.begin(), l1.end(),\n                     l2.begin(), l2.end(),\n                     back_inserter(commonElements));\n\n    return commonElements;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of first n natural numbers: n*(n+1)/2\n    return (n * (n + 1)) / 2;\n}\n\n// Function to test and demonstrate the use of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30) = \" << sum_to_n(30) << \"\\n\";\n    std::cout << \"sum_to_n(100) = \" << sum_to_n(100) << \"\\n\";\n    std::cout << \"sum_to_n(5) = \" << sum_to_n(5) << \"\\n\";\n    std::cout << \"sum_to_n(10) = \" << sum_to_n(10) << \"\\n\";\n    std::cout << \"sum_to_n(1) = \" << sum_to_n(1) << \"\\n\";\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0; // This will keep track of the balance between '(' and ')'\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            balance++; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            balance--; // Decrement balance for a closing bracket\n            \n            // If at any point balance is negative, it means there's a closing bracket without a matching opening one.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n\n    // At the end of the string, balance should be zero to have all brackets correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(const vector<float>& xs) {\n    // The resulting coefficients for the derivative polynomial.\n    vector<float> result;\n    \n    // Compute each coefficient of the derivative polynomial.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of floats.\nvoid printVector(const vector<float>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n    int result;\n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c;\n        a = b;\n        b = c;\n        c = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a character is a vowel\nbool is_vowel(char ch) {\n    // Convert character to lowercase for case-insensitive comparison\n    char lower_ch = tolower(ch);\n    \n    return (lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || \n            lower_ch == 'o' || lower_ch == 'u');\n}\n\n// Function to count the number of vowels in a string\nint vowels_count(string s) {\n    int vowel_count = 0;\n    \n    // Count all vowels except for the last character if it's 'y'\n    for (size_t i = 0; i < s.length() - 1; ++i) {\n        if (is_vowel(s[i])) {\n            ++vowel_count;\n        }\n    }\n\n    // Check if the last character is a vowel, including 'Y' as a special case\n    char last_char = tolower(s[s.length() - 1]);\n    \n    if (last_char == 'y') {\n        ++vowel_count;\n    } else if (is_vowel(last_char)) {\n        ++vowel_count;\n    }\n    \n    return vowel_count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string digits = to_string(x);\n    \n    // If shift is greater than or equal to the number of digits,\n    // return the reversed string.\n    if (shift >= digits.length()) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    \n    // Perform circular right shift by 'shift' positions\n    int n = digits.length();\n    shift %= n;  // In case shift is greater than number of digits\n    \n    // Rotate the string to the right by 'shift'\n    string result = digits.substr(n - shift) + digits.substr(0, n - shift);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract numbers from the string using stringstream\n    int apples = 0;\n    int oranges = 0;\n    \n    // Create a stringstream object and extract integers from the string\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Extract number of apples\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Extract number of oranges\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX;\n    int minIndex = -1;\n\n    // Iterate through each element in the vector.\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if it's even and smaller or equal to current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If the value is strictly smaller, or same but with a smaller index.\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    // Prepare the result vector based on whether we found an even number.\n    if (minIndex != -1) {\n        return {minEvenValue, minIndex};\n    } else {\n        return {};  // Return empty vector if no even value was found or input is empty\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(const std::vector<int>& lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    // Initialize result to -1 as default value if no valid number is found\n    int max_val = -1;\n\n    // Step 2: Iterate through unique integers and check the condition\n    for (const auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        \n        // Check if frequency of the integer is greater than or equal to the integer itself\n        if (num <= count && num > max_val) {\n            max_val = num;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the list first\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0;       // Pointer to the start of the vector\n    int right = lst.size() - 1; // Pointer to the end of the vector\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it and break\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add minimum value from the start\n        result.push_back(lst[left++]);\n        // Add maximum value from the end\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the given sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter of the triangle\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced, so it won't fly\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count total number of characters in a vector of strings\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list based on the character counts\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the total_match function with given examples\nvoid check() {\n    vector<string> empty_list = {};\n    vector<string> list1 = {\"hi\", \"admin\"};\n    vector<string> list2 = {\"hI\", \"Hi\"};\n    vector<string> list3 = {\"hi\", \"hi\", \"admin\", \"project\"};\n    vector<string> list4 = {\"hI\", \"hi\", \"hi\"};\n    vector<string> list5 = {\"4\"};\n    vector<string> list6 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n\n    // Example 1\n    cout << \"Example 1: \";\n    for (const string& str : total_match(empty_list, empty_list)) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 2\n    cout << \"Example 2: \";\n    for (const string& str : total_match(list1, list2)) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 3\n    cout << \"Example 3: \";\n    for (const string& str : total_match(list1, list3)) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 4\n    cout << \"Example 4: \";\n    for (const string& str : total_match(list1, list4)) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 5\n    cout << \"Example 5: \";\n    for (const string& str : total_match(list5, list6)) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true; // Special cases for smallest primes\n    if (n % 2 == 0 || n % 3 == 0) return false; // Exclude multiples of 2 and 3\n\n    int i = 5, w = 2;\n    while (i * i <= n) {\n        if (n % i == 0)\n            return false;\n        i += w;\n        w = 6 - w;\n    }\n    return true;\n}\n\n// Function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    int count = 0; // Count how many prime factors we have found\n\n    for (int i = 2; i <= 100 && count < 3; ++i) { // Limit to primes less than 100\n        if (!is_prime(i)) continue;\n\n        while (a % i == 0) {\n            a /= i;\n            count++;\n        }\n    }\n\n    return count == 3 && a == 1; // Check if exactly three prime factors and no remainder left\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle base cases\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is less than or equal to 1 and x is not 1, it's false.\n    if (n <= 1 && x != 1)\n        return false;\n\n    double log_result = log(x) / log(n);\n    \n    // Check if the result of the logarithm division is an integer\n    int rounded_log_result = round(log_result);\n\n    // If the difference between the actual and rounded value is very small,\n    // it means they are essentially the same (due to floating point precision issues).\n    return fabs(log_result - rounded_log_result) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Compute the cube root and round it to the nearest integer\n    int root = std::round(std::cbrt(a));\n    \n    // Check if the rounded value cubed equals the original number\n    return (root * root * root == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    int prime_count = 0;\n    \n    // Loop through each character in the input string.\n    for (char c : num) {\n        switch(c) {\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D': \n                ++prime_count;  // Increment count if digit is prime.\n                break;\n        }\n    }\n\n    return prime_count;\n}\n\n// Function to test the hex_key function with given examples.\nvoid check() {\n    assert(hex_key(\"AB\") == 1);\n    assert(hex_key(\"1077E\") == 2);\n    assert(hex_key(\"ABED1A33\") == 4);\n    assert(hex_key(\"123456789ABCDEF0\") == 6);\n    assert(hex_key(\"2020\") == 2);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert decimal to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal number to binary string\n    string binary = \"\";\n    while (decimal > 0) {\n        int bit = decimal % 2;\n        binary = to_string(bit) + binary; // Prepend the current bit to the result\n        decimal /= 2;\n    }\n\n    // Add \"db\" at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3)\n        return false;\n    \n    // Iterate through the string to check every set of 3 consecutive characters\n    for (int i = 0; i < s.length() - 2; ++i) {\n        char first = s[i];\n        char second = s[i + 1];\n        char third = s[i + 2];\n\n        // Check if all three characters are distinct\n        if (first == second || first == third || second == third)\n            return false;\n    }\n\n    // If the function hasn't returned false by now, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> result;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            result.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            result.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            result.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            result.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            result.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            result.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            result.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            result.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            result.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            result.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            result.push_back(\"D\");\n        } else if (gpa >= 0.0f) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\"); // In case of an invalid GPA value\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nlong long power(long long base, int exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result *= base;\n        exp /= 2;\n        base *= base;\n    }\n    return result;\n}\n\nint starts_one_ends(int n) {\n    if (n <= 0) return 0; // Edge case: non-positive n\n    long long count_start = power(9, n - 1); // Count of numbers starting with 1\n    long long count_end = power(9, n - 1);   // Count of numbers ending with 1\n    long long overlap = (n > 2) ? power(8, n - 2) : 0; // Overlap count\n\n    return static_cast<int>(count_start + count_end - overlap);\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to its binary representation as a string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\n// Function to calculate the sum of digits of a number and convert it to binary\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Calculate the sum of all digits in N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum of digits into binary and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to anti_shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string\n    int n = s.length();\n    \n    for (int i = 0; i < n; ++i) {\n        if (s[i] != ' ') {  // If it's not a space, start of word\n            string temp = \"\";\n            \n            // Collect all characters until next space or end of string\n            while (i < n && s[i] != ' ') {\n                temp += s[i];\n                ++i;\n            }\n            \n            // Sort the collected characters\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n        } else {  // If it's a space, append space to result\n            result += ' ';\n        }\n    }\n\n    return result;\n}\n\n// Function to test the anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing anti_shuffle...\" << endl;\n    \n    string input1 = \"Hi\";\n    string expected1 = \"Hi\";\n    assert(anti_shuffle(input1) == expected1);\n    \n    string input2 = \"hello\";\n    string expected2 = \"ehllo\";\n    assert(anti_shuffle(input2) == expected2);\n    \n    string input3 = \"Hello World!!!\";\n    string expected3 = \"Hello !!!Wdlor\";\n    assert(anti_shuffle(input3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for easier initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Overload the less-than operator to sort by row in ascending order and column in descending order\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col; // Descending order for columns within the same row\n        return row < other.row;\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through each row and column to find occurrences of x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back(CustomCoordinate(i, j));\n            }\n        }\n    }\n\n    // Sort the coordinates as per the requirement\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate vector to vector<vector<int>>\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = get_row({{1,2,3,4,5,6}, {1,2,3,4,1,6}, {1,2,3,4,5,1}}, 1);\n    for (const auto& coord : res1) {\n        printf(\"{%d, %d} \", coord[0], coord[1]);\n    }\n    // Expected output: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n\n    auto res2 = get_row({}, 1);\n    if (res2.empty()) {\n        printf(\"{{}}\\n\");\n    }\n\n    auto res3 = get_row({{}, {1}, {1, 2, 3}}, 3);\n    for (const auto& coord : res3) {\n        printf(\"{%d, %d} \", coord[0], coord[1]);\n    }\n    // Expected output: {{2, 2}}\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the input vector is empty or has only one element, return a copy of it.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Create a copy of the input vector to avoid modifying the original one\n    std::vector<int> sorted_array(array);\n\n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        // If the sum is even, sort in descending order\n        std::sort(sorted_array.begin(), sorted_array.end(), std::greater<int>());\n    } else {\n        // If the sum is odd, sort in ascending order\n        std::sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function (not part of the solution)\nvoid check() {\n    assert(sort_array({}) == std::vector<int>());\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    std::string result = \"\";\n    \n    for (char c : s) {\n        // Check if character is lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            char rotated_char = ((c - 'a' + 4) % 26) + 'a';\n            result += rotated_char;\n        }\n        // Check if character is uppercase letter\n        else if (c >= 'A' && c <= 'Z') {\n            char rotated_char = ((c - 'A' + 4) % 26) + 'A';\n            result += rotated_char;\n        }\n        // If not a letter, just append the original character\n        else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm> // for sort()\n#include <optional>   // For std::optional to return None\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) { // If there are less than two elements, return None\n        return {};\n    }\n\n    std::sort(lst.begin(), lst.end()); // Sort the vector\n    \n    // Remove duplicates\n    auto last = std::unique(lst.begin(), lst.end());\n    lst.erase(last, lst.end());\n\n    if (lst.size() < 2) { // If there are less than two unique elements, return None\n        return {};\n    }\n\n    return lst[1]; // Return the second smallest element\n}\n\n// Example usage and check function\n#include <iostream>\nvoid check_next_smallest() {\n    std::cout << \"Checking next_smallest...\" << std::endl;\n    \n    auto result = next_smallest({1, 2, 3, 4, 5});\n    if (result.has_value()) std::cout << \"next_smallest({1, 2, 3, 4, 5}) == \" << *result << std::endl; // Should be 2\n    \n    result = next_smallest({5, 1, 4, 3, 2});\n    if (result.has_value()) std::cout << \"next_smallest({5, 1, 4, 3, 2}) == \" << *result << std::endl; // Should be 2\n    \n    result = next_smallest({});\n    if (!result) std::cout << \"next_smallest({}) is None\" << std::endl;\n    \n    result = next_smallest({1, 1});\n    if (!result) std::cout << \"next_smallest({1, 1}) is None\" << std::endl;\n\n    // Additional checks\n    result = next_smallest({2, 2, 3});\n    if (result.has_value()) std::cout << \"next_smallest({2, 2, 3}) == \" << *result << std::endl; // Should be 3\n    \n    result = next_smallest({10, 9, 8, 7, 6, 5});\n    if (result.has_value()) std::cout << \"next_smallest({10, 9, 8, 7, 6, 5}) == \" << *result << std::endl; // Should be 9\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nint is_bored(const std::string& S) {\n    int boredom_count = 0;\n    \n    // Split the string into sentences based on delimiters.\n    const char* delimiters = \".?!\";\n    size_t start_index = 0, end_index = 0;\n\n    while ((end_index = S.find_first_of(delimiters, start_index)) != std::string::npos) {\n        std::string sentence = S.substr(start_index, end_index - start_index);\n        \n        // Trim leading and trailing spaces\n        size_t first_non_space = sentence.find_first_not_of(\" \");\n        if (first_non_space == std::string::npos)\n            continue;  // Skip empty sentences\n        \n        size_t last_non_space = sentence.find_last_not_of(\" \");\n        sentence = sentence.substr(first_non_space, last_non_space - first_non_space + 1);\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.size() > 0 && sentence[0] == 'I') {\n            boredom_count++;\n        }\n        \n        start_index = end_index + 1;\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath> // For std::round\n\nusing namespace std;\n\nbool is_integer(float num) {\n    return round(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n\n    // Convert floats to integers since they are now guaranteed to be integers\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message as per the given rules\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string replacements = \"cgeikquwCGEIQUW\"; // 2 places ahead of each vowel\n\n    for (char &ch : message) {\n        // Swap case\n        if (islower(ch)) ch = toupper(ch);\n        else if (isupper(ch)) ch = tolower(ch);\n\n        // Replace vowels with the corresponding replacement character\n        size_t pos = vowels.find(toupper(ch));\n        if (pos != string::npos) {\n            char replacement = replacements[pos];\n            if (islower(ch)) replacement = tolower(replacement);\n            ch = replacement;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds the largest prime and returns the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime in the list\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) { // Check if the number is prime\n            if (num > maxPrime) { // Update maxPrime if the current number is larger and prime\n                maxPrime = num;\n            }\n        }\n    }\n\n    return sumOfDigits(maxPrime); // Return the sum of digits of the largest prime found\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        if (!isLowercase(key)) {\n            allLowercase = false;\n        }\n        if (!isUppercase(key)) {\n            allUppercase = false;\n        }\n\n        // If both flags are false, we can stop early\n        if (!allLowercase && !allUppercase) {\n            return false;\n        }\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> primes_below_n(int n) {\n    vector<int> result;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digit of both numbers by taking modulo 10\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (index % 2 == 0)\n    for (size_t i = 0; i < s.length(); i += 2) { \n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if ((c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    // Convert string to double\n    double num = std::stod(value);\n\n    // Get fractional part of the number\n    double fraction = num - floor(num);\n    \n    // Check if the number is equidistant from two integers (fraction == 0.5 or -0.5)\n    bool roundAwayFromZero = false;\n    if (fabs(fraction) >= 0.5 && fabs(fraction) < 1.0) {\n        roundAwayFromZero = true;\n    }\n\n    // Round the number\n    int roundedNum;\n    if (roundAwayFromZero) {\n        // If equidistant, round away from zero\n        roundedNum = num > 0 ? std::ceil(num) : std::floor(num);\n    } else {\n        // Otherwise, use standard rounding\n        roundedNum = static_cast<int>(std::round(num));\n    }\n\n    return roundedNum;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    \n    // Determine if the first level should be even or odd based on n\n    int current_stones = (n % 2 == 0) ? n : n + 1; // If n is even, start with n. Otherwise, start with next odd number.\n    \n    for(int i = 0; i < n; ++i) {\n        stones.push_back(current_stones);\n        current_stones += 2; // Increment by 2 to get the next odd/even number\n    }\n    \n    return stones;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for(int stone : result) {\n        printf(\"%d \", stone); // Output should be: 4 6 8 (since n=3, next even number after 3 is 4)\n    }\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    \n    // Use comma as delimiter initially\n    char prev_delimiter = ',';\n    while (getline(ss, word, ',')) {\n        // Now use space as delimiter within the current segment\n        stringstream segment(word);\n        string subword;\n        while (segment >> subword) {\n            result.push_back(subword);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector of strings for testing purposes\nvoid print_vector(const vector<string>& v) {\n    for (const auto& str : v) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure that x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and work backwards\n    for (int i = y; i >= x; --i) {\n        // Check if the number is even\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number was found, return -1\n    return -1;\n}\n\n// Function to test the correctness of choose_num function\nvoid check(int x, int y) {\n    cout << \"choose_num(\" << x << \", \" << y << \") = \" << choose_num(x, y) << endl;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    // Calculate the sum of integers from n to m\n    long total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n\n    // Number of terms in the sequence\n    int num_terms = m - n + 1;\n\n    // Calculate average and round down\n    double avg = static_cast<double>(total_sum) / num_terms;\n    long rounded_avg = floor(avg);\n\n    // Convert to binary string\n    if (rounded_avg == 0) return \"0\";\n    \n    string result = \"\";\n    while (rounded_avg > 0) {\n        result = to_string(rounded_avg % 2) + result;\n        rounded_avg /= 2;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if all digits of a number are odd\nbool has_only_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        n /= 10;\n    }\n    return true; // All digits are odd\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers with only odd digits\n    for (int num : x) {\n        if (has_only_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered results\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to print vector elements\nvoid print_vector(const vector<int>& v) {\n    for (int num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Define the mapping from digits to their corresponding names.\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter and sort the array\n    vector<int> filtered_sorted_arr;\n    \n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in ascending order.\n    sort(filtered_sorted_arr.begin(), filtered_sorted_arr.end());\n\n    // Reverse the sorted vector\n    reverse(filtered_sorted_arr.begin(), filtered_sorted_arr.end());\n\n    // Map each number to its corresponding name and store it in a result vector.\n    vector<string> result;\n    for (int num : filtered_sorted_arr) {\n        if (digit_to_name.find(num) != digit_to_name.end()) {\n            result.push_back(digit_to_name[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Function to compute factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute sum of numbers from 1 to n\nint arithmetic_sum(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Because we start from 1\n        if (index % 2 == 0) { // Even number, calculate factorial of (index - 1)\n            result[i] = factorial(index - 1);\n        } else { // Odd number, calculate sum from 1 to index\n            result[i] = arithmetic_sum(index);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> actual = f(5);\n\n    if (expected == actual) {\n        printf(\"Correct!\\n\");\n    } else {\n        printf(\"Incorrect.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0, right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) return false;\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and verification\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of signed digits of an integer\nint sum_of_signed_digits(int num) {\n    int sum = 0;\n    if (num == 0) return 1; // Special case for zero, as its digit sum is considered positive.\n    \n    bool is_negative = num < 0;\n    if (is_negative) num = -num; // Work with the absolute value to simplify digit extraction\n    \n    while (num > 0) {\n        int digit = num % 10;\n        if (is_negative && digit != 0) sum -= digit; // Subtract non-zero digits for negative numbers\n        else sum += digit; // Add all positive digits and zero\n        \n        num /= 10;\n    }\n    \n    return is_negative ? -sum : sum; // Adjust the sign of the sum based on original number's sign\n}\n\n// Function to count numbers with a sum of signed digits greater than 0\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (auto num : n) {\n        if (sum_of_signed_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty or has only one element, it's trivially sorted.\n    if (arr.empty() || arr.size() == 1) return true;\n    \n    int n = arr.size();\n    int min_index = 0; // Index of the minimum element\n    \n    // Find the index of the smallest element\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n\n    // Check if the array is already sorted starting from the min_index.\n    int count = 0;\n    for (int i = min_index, j = min_index + 1; j < n; ++i, ++j) {\n        if (arr[i] > arr[j]) break;\n        count++;\n    }\n    \n    // Check the remaining part of the array from the end to the start.\n    for (int i = n - 1, j = 0; j <= min_index && i > min_index; --i, ++j) {\n        if (arr[i] > arr[j]) break;\n        count++;\n    }\n    \n    // If we have checked all elements in a non-decreasing manner, return true.\n    return count == n - 1;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count the number of even and odd elements in a vector.\npair<int, int> countEvenOdd(const vector<int>& lst) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int num : lst) {\n        if (num % 2 == 0)\n            evenCount++;\n        else\n            oddCount++;\n    }\n    \n    return {evenCount, oddCount};\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of even and odd numbers in both lists.\n    auto [lst1Even, lst1Odd] = countEvenOdd(lst1);\n    auto [lst2Even, lst2Odd] = countEvenOdd(lst2);\n\n    // If there are no odd numbers in lst1, it's already possible to make all elements of lst1 even.\n    if (lst1Odd == 0)\n        return \"YES\";\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2.\n    if (lst2Even >= lst1Odd) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to split string into individual characters and count their frequencies\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Iterate through the input string and populate the frequency map\n    for (size_t i = 0; i < test.length(); ++i) {\n        if (test[i] != ' ') {  // Skip spaces\n            charCount[test[i]]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (const auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum frequency\n    map<char, int> result;\n    for (const auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map in a readable format\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (str[i] != str[n - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0; // Initialize the count of odd digits\n        \n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output sentence with the correct count\n        std::stringstream ss;\n        ss << \"the number of odd elements \" << count \n           << \"n the str\" << count << \"ng \" << count \n           << \" of the \" << count << \"nput.\";\n        \n        result.push_back(ss.str());\n    }\n    \n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    auto output1 = odd_count({\"1234567\"});\n    assert(output1.size() == 1);\n    assert(output1[0] == \"the number of odd elements 4n the str4ng 4 of the 4nput.\");\n    \n    auto output2 = odd_count({\"3\", \"11111111\"});\n    assert(output2.size() == 2);\n    assert(output2[0] == \"the number of odd elements 1n the str1ng 1 of the 1nput.\");\n    assert(output2[1] == \"the number of odd elements 8n the str8ng 8 of the 8nput.\");\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_buckets = 0;\n    \n    // Iterate through each well (row in the grid)\n    for(const auto& row : grid) {\n        int water_units = 0; // Count of water units in the current well\n        \n        // Sum up all the water units in the current well\n        for(int unit : row) {\n            if(unit == 1) {\n                water_units++;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        total_buckets += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_buckets;\n}\n\n// Example usage and check function (not part of the solution but useful for testing)\nvoid check() {\n    assert(max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert(max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert(max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Custom comparator function\nbool customComparator(int a, int b) {\n    // Count the number of 1s in binary representation\n    std::bitset<32> bit_a(a);\n    std::bitset<32> bit_b(b);\n\n    int ones_a = bit_a.count();\n    int ones_b = bit_b.count();\n\n    if (ones_a == ones_b) {\n        // If the number of 1s is equal, sort by decimal value\n        return a < b;\n    } else {\n        // Otherwise, sort by the number of 1s in ascending order\n        return ones_a < ones_b;\n    }\n}\n\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase and check if it's a consonant.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nchar get_closest_vowel(const string& word) {\n    for (int i = word.length() - 2; i > 0; --i) { // Start from the second last character\n        if (!isVowel(word[i-1]) && isVowel(word[i]) && !isVowel(word[i+1])) {\n            return word[i];\n        }\n    }\n    return '\\0'; // Return null character to indicate no vowel found\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n        }\n        // If at any point the balance goes negative, it's unbalanced\n        if (balance < 0) return false;\n    }\n    // The string is balanced only if the final balance is zero\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    bool first_option = is_balanced(lst[0] + lst[1]);\n    bool second_option = is_balanced(lst[1] + lst[0]);\n\n    if (first_option || second_option) return \"Yes\";\n    else return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> maximum(std::vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order.\n    std::sort(arr.begin(), arr.end(), std::greater<int>());\n\n    // Step 2: Take the first k elements from the sorted vector.\n    std::vector<int> result;\n    for (int i = 0; i < k && i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n\n    // Step 3: Sort these k elements in ascending order before returning them.\n    std::sort(result.begin(), result.end());\n\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector and check for odd elements in even positions.\n    for (size_t i = 0; i < lst.size(); i += 2) { // Increment by 2 to only consider even indices\n        if (lst[i] % 2 != 0) { // Check if the element at index i is odd\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the number has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) { // Continue until the sequence reaches 1\n        if (n % 2 == 1) { // Check if the number is odd\n            odd_numbers.push_back(n); // Add to the list of odd numbers\n        }\n        \n        // Generate next term in Collatz sequence\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n\n    // The final number 1 is always odd, so add it explicitly\n    odd_numbers.push_back(1);\n\n    return odd_numbers; // Return the sorted vector of odd numbers\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty or does not match \"mm-dd-yyyy\" format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    int month, day, year;\n    sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n    \n    // Validate the month\n    if (month < 1 || month > 12) return false;\n\n    // Validate the number of days based on the month\n    int max_days = 31;\n    switch(month) {\n        case 4:\n        case 6:\n        case 9:\n        case 11: \n            max_days = 30; break;\n        case 2:\n            if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                // Leap year\n                max_days = 29;\n            } else {\n                max_days = 28;\n            }\n    }\n\n    // Validate the day\n    if (day < 1 || day > max_days) return false;\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace first\n    size_t spacePos = txt.find(' ');\n    if (spacePos != string::npos) {\n        istringstream iss(txt);\n        vector<string> words;\n        string word;\n        while (iss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // Check for commas next\n    size_t commaPos = txt.find(',');\n    if (commaPos != string::npos) {\n        istringstream iss(txt, istringstream::in | istringstream::out);\n        vector<string> words;\n        string word;\n        while (getline(iss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // If no whitespace or commas, count lowercase letters with odd order\n    int oddCount = 0;\n    for (char c : txt) {\n        if (islower(c) && ((c - 'a') % 2 == 1)) {\n            ++oddCount;\n        }\n    }\n    \n    vector<string> result(1);\n    result[0] = to_string(oddCount);\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int>& lst) {\n    // Check if the list is empty or has only one element, it's trivially sorted.\n    if (lst.size() <= 1) return true;\n\n    // Map to count occurrences of each number.\n    std::unordered_map<int, int> frequencyMap;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the current element is greater than the next one, meaning it's not sorted.\n        if (i > 0 && lst[i] < lst[i - 1]) return false;\n\n        // Increment frequency of the current number.\n        frequencyMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if (frequencyMap[lst[i]] > 2) return false;\n    }\n\n    return true;\n}\n\n// Example usage and check function\n#include <iostream>\nbool check(const std::vector<int>& lst) {\n    bool result = is_sorted(lst);\n    std::cout << \"is_sorted({\";\n    for (size_t i = 0; i < lst.size(); ++i) {\n        std::cout << lst[i];\n        if (i != lst.size() - 1) std::cout << \", \";\n    }\n    std::cout << \"}) \u279e \" << result << \"\\n\";\n    return result;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to determine the intersection and its length\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    // If there is no intersection, return \"NO\"\n    if (start_max > end_min) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end_min - start_max + 1;\n\n    // Check if the length is a prime number and return the result\n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (const auto& num : arr) {\n        if (num == 0) {\n            sign_product = 0; // If any number is zero, the product of signs will be zero\n            break;\n        }\n        sign_product *= (num > 0 ? 1 : -1); // Update sign product based on current number's sign\n        magnitude_sum += std::abs(num); // Add absolute value to sum of magnitudes\n    }\n\n    return sign_product * magnitude_sum; // Return the final result\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    vector<int> path;\n    int row, col; // Current cell position\n};\n\n// Function to check if the given state is within grid boundaries.\nbool isValid(int N, int r, int c) {\n    return (r >= 0 && r < N && c >= 0 && c < N);\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Initialize the minimum path with a large value.\n    vector<int> min_path(N * N + 1, INT_MAX);\n\n    // Directions for moving to adjacent cells (up, down, left, right).\n    int dr[] = {-1, 0, 1, 0};\n    int dc[] = {0, -1, 0, 1};\n\n    // BFS queue.\n    queue<State> q;\n\n    // Start from every cell in the grid.\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> initial_path;\n            initial_path.push_back(grid[i][j]);\n            State start_state = {initial_path, i, j};\n            q.push(start_state);\n        }\n    }\n\n    // Perform BFS.\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.path.size() == k) {\n            vector<int> &path = current.path;\n            for (int i = 0; i < k; ++i) {\n                if (min_path[i] > path[i]) {\n                    min_path.assign(path.begin(), path.end());\n                    break;\n                } else if (min_path[i] == path[i]) continue;\n                else break;\n            }\n        }\n\n        // Explore neighbors.\n        for (int i = 0; i < 4; ++i) {\n            int new_row = current.row + dr[i];\n            int new_col = current.col + dc[i];\n\n            if (!isValid(N, new_row, new_col)) continue;\n\n            vector<int> next_path(current.path);\n            next_path.push_back(grid[new_row][new_col]);\n            \n            State next_state = {next_path, new_row, new_col};\n            q.push(next_state);\n        }\n    }\n\n    return min_path;\n}\n\n// Example usage\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base cases\n    if (n >= 0) result[0] = 1; // Assuming the sequence starts with 1 for simplicity, as per your example.\n    if (n >= 1) result[1] = 3;\n    \n    for(int i = 2; i <= n; ++i) {\n        if(i % 2 == 0) { \n            // For even indices\n            result[i] = 1 + i / 2;\n        } else {\n            // For odd indices, we need to calculate based on previous terms.\n            // Note: The formula provided in the problem statement is incorrect as it references future terms (tri(n+1)).\n            // Assuming a corrected version where tri(n) = tri(n-1) + tri(n-2).\n            result[i] = result[i - 1] + result[i - 2];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool foundOddDigit = false;\n\n    while (n > 0) {\n        int lastDigit = n % 10; // Get the last digit\n\n        if (lastDigit % 2 != 0) { // Check if it's odd\n            product *= lastDigit;\n            foundOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return foundOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int open_brackets = 0;\n    bool has_nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            // Increment the count of open brackets\n            open_brackets++;\n        } else if (c == ']') {\n            // Decrement the count of open brackets\n            if (open_brackets > 1) {\n                has_nested = true; // Found a nested pair\n            }\n            open_brackets--;\n        }\n\n        // If we have found at least one nested pair, return true immediately\n        if (has_nested) {\n            return true;\n        }\n    }\n\n    // Return false if no nested pairs are found\n    return false;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nint sum_squares(std::vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        float ceiling_value = std::ceil(num);\n        sum += static_cast<int>(std::pow(ceiling_value, 2));\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt){\n    // Check for empty string\n    if(txt.empty()) return false;\n    \n    // Trim trailing spaces\n    size_t last_non_space = txt.find_last_not_of(' ');\n    if(last_non_space == string::npos) {\n        // The entire string is composed of spaces, so the last character isn't a letter.\n        return false;\n    }\n    txt.erase(last_non_space + 1);\n\n    // Check if the last character is an alphabetical letter\n    char last_char = txt.back();\n    \n    // Ensure it's not part of a word (i.e., there should be a space before it)\n    size_t pos_of_last_letter = txt.find_last_of(' ');\n    bool is_not_part_of_word = (pos_of_last_letter != string::npos && \n                                txt[pos_of_last_letter + 1] == last_char);\n\n    return isalpha(last_char) && !is_not_part_of_word;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if the current element is smaller than the previous one.\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of this element.\n        }\n    }\n    \n    // If no such element was found, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative number was found, set to 0\n    int largest_negative = (max_negative == INT_MIN) ? 0 : max_negative;\n\n    // If no positive number was found, set to 0\n    int smallest_positive = (min_positive == INT_MAX) ? 0 : min_positive;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(test1);\n    printf(\"Result for [2, 4, 1, 3, 5, 7]: (%d, %d)\\n\", result1[0], result1[1]);\n\n    vector<int> test2 = {};\n    vector<int> result2 = largest_smallest_integers(test2);\n    printf(\"Result for []: (%d, %d)\\n\", result2[0], result2[1]);\n\n    vector<int> test3 = {0};\n    vector<int> result3 = largest_smallest_integers(test3);\n    printf(\"Result for [0]: (%d, %d)\\n\", result3[0], result3[1]);\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to double\ndouble stringToDouble(const std::string& str) {\n    size_t pos = str.find(',');\n    if (pos != std::string::npos) {\n        return std::stod(str.substr(0, pos) + \".\" + str.substr(pos + 1));\n    }\n    return std::stod(str);\n}\n\n// Function to compare two boost::any objects\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are of the same type and handle accordingly\n    if (a.type() == typeid(int)) {\n        int ia = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (ia > ib) ? a : ((ib > ia) ? b : \"None\");\n        } else if (b.type() == typeid(double)) {\n            double db = boost::any_cast<double>(b);\n            return (static_cast<double>(ia) > db) ? a : ((db > static_cast<double>(ia)) ? b : \"None\");\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            double db = stringToDouble(sb);\n            return (static_cast<double>(ia) > db) ? a : ((db > static_cast<double>(ia)) ? b : \"None\");\n        }\n    } else if (a.type() == typeid(double)) {\n        double da = boost::any_cast<double>(a);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (da > static_cast<double>(ib)) ? a : ((static_cast<double>(ib) > da) ? b : \"None\");\n        } else if (b.type() == typeid(double)) {\n            double db = boost::any_cast<double>(b);\n            return (da > db) ? a : ((db > da) ? b : \"None\");\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            double db = stringToDouble(sb);\n            return (da > db) ? a : ((db > da) ? b : \"None\");\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string sa = boost::any_cast<std::string>(a);\n        double da = stringToDouble(sa);\n        if (b.type() == typeid(int)) {\n            int ib = boost::any_cast<int>(b);\n            return (da > static_cast<double>(ib)) ? a : ((static_cast<double>(ib) > da) ? b : \"None\");\n        } else if (b.type() == typeid(double)) {\n            double db = boost::any_cast<double>(b);\n            return (da > db) ? a : ((db > da) ? b : \"None\");\n        } else if (b.type() == typeid(std::string)) {\n            std::string sb = boost::any_cast<std::string>(b);\n            double db = stringToDouble(sb);\n            return (da > db) ? a : ((db > da) ? b : \"None\");\n        }\n    }\n\n    // If types are not compatible, return None\n    return \"None\";\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and at least 8\n    if (n % 2 != 0 || n < 8) return false;\n    \n    // Since we need exactly four positive even numbers, the smallest sum is 8.\n    // Any number that is a multiple of 4 and greater than or equal to 8 can be expressed as such a sum.\n    if (n % 4 == 0 && n >= 8) return true;\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a single number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    \n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";  // Initialize an empty string for the result.\n    int space_count = 0; // Counter to keep track of consecutive spaces.\n\n    for (char ch : text) { \n        if (ch == ' ') {\n            space_count++; // Increment the counter for each space encountered.\n            \n            // If there are more than two consecutive spaces, append '-' and reset the counter.\n            if (space_count > 2) continue;\n            \n            // Append '_' for single or double spaces.\n            result += '_';\n        } else {\n            // Reset the space count when a non-space character is found.\n            space_count = 0;\n            result += ch; // Add the current character to the result string.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nbool is_valid_start(const std::string& name) {\n    if (name.empty()) return false;\n    char first_char = name[0];\n    return (first_char >= 'a' && first_char <= 'z') || (first_char >= 'A' && first_char <= 'Z');\n}\n\nint count_digits(const std::string& name) {\n    int digit_count = 0;\n    for (char c : name) {\n        if (c >= '0' && c <= '9') {\n            ++digit_count;\n        }\n    }\n    return digit_count;\n}\n\nbool has_valid_extension(const std::string& extension, const std::set<std::string>& valid_extensions) {\n    return valid_extensions.find(extension) != valid_extensions.end();\n}\n\nstd::string file_name_check(std::string file_name) {\n    size_t dot_position = file_name.find('.');\n    \n    // Check for exactly one dot\n    if (dot_position == std::string::npos || file_name.rfind('.', dot_position + 1) != dot_position) {\n        return \"No\";\n    }\n    \n    // Split the name into before and after the dot\n    std::string name_before_dot = file_name.substr(0, dot_position);\n    std::string extension_after_dot = file_name.substr(dot_position + 1);\n\n    // Check if the part before the dot is valid\n    if (!is_valid_start(name_before_dot)) {\n        return \"No\";\n    }\n\n    // Count digits in the entire name\n    int digit_count = count_digits(file_name);\n    if (digit_count > 3) {\n        return \"No\";\n    }\n    \n    // Define a set of valid extensions\n    std::set<std::string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n    \n    // Check the extension after the dot\n    if (!has_valid_extension(extension_after_dot, valid_extensions)) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the value and add to sum\n        } else if ((i + 1) % 4 == 0) { // Index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the value and add to sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime length from the sentence\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::string word, result = \"\";\n    bool first_word = true;\n\n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            // Add a space before each word except for the first one\n            if (!first_word) result += \" \";\n            result += word;\n            first_word = false;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check_solution() {\n    std::cout << words_in_sentence(\"This is a test\") << std::endl; // Output: \"is\"\n    std::cout << words_in_sentence(\"lets go for swimming\") << std::endl; // Output: \"go for\"\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse fraction and return numerator and denominator as integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    int numeratorX, denominatorX;\n    parseFraction(x, numeratorX, denominatorX);\n\n    int numeratorN, denominatorN;\n    parseFraction(n, numeratorN, denominatorN);\n\n    // Multiply the two fractions: (numeratorX/denominatorX) * (numeratorN/denominatorN)\n    long long resultNum = static_cast<long long>(numeratorX) * numeratorN;\n    long long resultDen = static_cast<long long>(denominatorX) * denominatorN;\n\n    // Simplify the fraction by dividing both numerator and denominator by their GCD\n    long long gcdValue = __gcd(resultNum, resultDen);\n    \n    // The fraction is a whole number if its simplified denominator is 1\n    return (resultDen / gcdValue == 1);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\n// Helper function to calculate sum of digits of a number.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = (num < 0);\n    while (num != 0) {\n        int digit = num % 10;\n        if (is_negative && digit > 0)\n            sum -= digit; // Adjust for negative digits\n        else\n            sum += digit;\n        num /= 10;\n        is_negative = false; // Once we have the first digit, it's not negative anymore.\n    }\n    return sum;\n}\n\n// Comparator function to sort based on custom criteria (sum of digits and original index).\nbool compare_by_points(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (a.second == b.second)\n        return a.first < b.first; // Preserve original order\n    else\n        return a.second < b.second;\n}\n\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexed_nums;\n\n    // Create pairs of (index, digit sum)\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({i, sum_of_digits(nums[i])});\n    }\n\n    // Sort based on custom comparator\n    std::stable_sort(indexed_nums.begin(), indexed_nums.end(), compare_by_points);\n\n    // Reconstruct the sorted vector using original indices and values.\n    std::vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(nums[p.first]);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string to easily access first and last digit\n    if (num == 0) return false; // Handle zero case separately\n\n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    bool isOddFirst = (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n                       firstDigit == '7' || firstDigit == '9');\n    \n    bool isOddLast = (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n                      lastDigit == '7' || lastDigit == '9');\n\n    return isOddFirst && isOddLast;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (const auto& num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with sample data points\nvoid check() {\n    vector<int> vec1 = {15, -73, 14, -15};\n    cout << \"specialFilter({15, -73, 14, -15}) => \" << specialFilter(vec1) << endl; // Expected output: 1\n\n    vector<int> vec2 = {33, -2, -3, 45, 21, 109};\n    cout << \"specialFilter({33, -2, -3, 45, 21, 109}) => \" << specialFilter(vec2) << endl; // Expected output: 2\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array 'a'\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count the number of valid triples\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    \n    // Find indices of planet1 and planet2 in the list\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either of the indices is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order\n    if (index1 > index2) swap(index1, index2);\n\n    // Create and fill the result vector with planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n\n// Function to test the bf function\nvoid check() {\n    vector<string> res;\n\n    // Test cases\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res) cout << planet << ' ';\n    cout << endl;  // Expected: Saturn Uranus\n\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res) cout << planet << ' ';\n    cout << endl;  // Expected: Venus\n\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res) cout << planet << ' ';\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator for sorting strings by length, and lexicographically if lengths are equal\nbool customSort(const string& a, const string& b) {\n    // First compare by length\n    if (a.length() != b.length()) return a.length() < b.length();\n    // If lengths are the same, sort alphabetically\n    return a < b;\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Remove strings with odd lengths\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n\n    // Sort the resulting list by length and then alphabetically\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // Return x if n is a prime number\n    } else {\n        return y; // Otherwise, return y\n    }\n}\n\n// Function to test the correctness of x_or_y function\nvoid check() {\n    cout << \"x_or_y(7, 34, 12) == \" << x_or_y(7, 34, 12) << endl;\n    cout << \"x_or_y(15, 8, 5) == \" << x_or_y(15, 8, 5) << endl;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long sum_of_odd_squares(const std::vector<float>& lst) {\n    long long result = 0;\n    \n    for (float num : lst) {\n        // Check if the number is an integer, non-negative, and odd.\n        int n = static_cast<int>(num);\n        if (n == num && n >= 0 && n % 2 != 0) {\n            result += std::pow(n, 2);  // Add square of the number to the result\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on uppercase and lowercase letters.\nint calculate_strength(const string& name) {\n    int cap = 0, sm = 0;\n    for (char c : name) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    size_t index_of_strongest_extension = 0;\n\n    for (size_t i = 0; i < extensions.size(); ++i) {\n        int strength = calculate_strength(extensions[i]);\n        if (strength > max_strength) {\n            max_strength = strength;\n            index_of_strongest_extension = i;\n        }\n    }\n\n    return class_name + \".\" + extensions[index_of_strongest_extension];\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate 'a' with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of 'doubled_a'\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Make sure we work with a positive number\n    if (num < 0) {\n        num = -num;\n    }\n\n    int evenCount = 0, oddCount = 0;\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n\n        if (digit % 2 == 0) {\n            evenCount++; // Increment even count\n        } else {\n            oddCount++; // Increment odd count\n        }\n\n        num /= 10; // Remove the last digit\n    }\n\n    return {evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},   {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},    {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},     {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            result += pair.second;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath> // For std::sqrt and std::pow\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure the variables are sorted to make sure 'c' is the longest side.\n    if (a > b && a > c) return false; // If 'a' is the largest, function won't work correctly\n    if (b > a && b > c) std::swap(a, b); // Make sure 'b' or 'c' isn't larger than it should be.\n    \n    float hypotenuse = std::max({a, b, c}); // Find the longest side\n    float other_side1 = a + b + c - hypotenuse; // Sum of remaining sides minus hypotenuse\n    \n    if (hypotenuse == a) {\n        other_side1 -= b;\n    } else if (hypotenuse == b) {\n        other_side1 -= a;\n    }\n    \n    float other_side2 = std::sqrt(std::pow(hypotenuse, 2) - std::pow(other_side1, 2));\n    \n    // Check Pythagorean theorem\n    return std::abs(std::pow(hypotenuse, 2) - (std::pow(a, 2) + std::pow(b, 2))) < 0.0001;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to count unique characters in a string\nint count_unique_chars(const string& str) {\n    int char_set[256] = {0}; // Assuming ASCII character set\n    for (char c : str) {\n        char_set[c]++;\n    }\n    return count(char_set, char_set + 256, 1);\n}\n\n// Main function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = -1;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n\n        // Update if this word has more unique characters or is lexicographically smaller with the same number of unique characters\n        if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots to be eaten after meals\n    int totalEaten = number + (need <= remaining ? need : remaining);\n    \n    // Calculate the number of remaining carrots left in stock\n    int remainingCarrots = max(0, remaining - need);\n\n    return {totalEaten, remainingCarrots};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nint do_algebra(std::vector<std::string> operators, std::vector<int> operands) {\n    int result = operands[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            // Integer division\n            result /= operands[i + 1];\n        } else if (operators[i] == \"**\") {\n            // Exponentiation, but ensure the result is an integer\n            int exp_result = static_cast<int>(pow(result, operands[i + 1]));\n            result = exp_result;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) {\n        return toupper(c);\n    } else if (isupper(c)) {\n        return tolower(c);\n    }\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters are present, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed and build the result string\n        for (char &c : s) {\n            c = isLetter(c) ? reverseCase(c) : c;\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert string to md5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) return \"\";  // Return empty string for empty input\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    std::stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n// Function to test the correctness of string_to_md5 function\nvoid check_function() {\n    std::string result = string_to_md5(\"Hello world\");\n    if(result == \"3e25960a79dbc69b674cd4ec67a72c62\") {\n        std::cout << \"Test passed: Correct MD5 hash for 'Hello world'\" << std::endl;\n    } else {\n        std::cout << \"Test failed: Incorrect MD5 hash\" << std::endl;\n    }\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nstd::vector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is less than or equal to 'b'\n    if (a > b) {\n        std::swap(a, b);\n    }\n\n    // Define the even digits\n    const std::vector<int> even_digits = {2, 4, 6, 8};\n\n    // Initialize an empty vector to store results\n    std::vector<int> result;\n\n    // Iterate through the even digits and add them if they are within the range [a, b]\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted vector and check consecutive elements.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements are found, return false.\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    int balance = 0; // Counter for open parentheses\n    size_t start_index = 0; // Start index of the current group\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            balance++;\n        } else if (paren_string[i] == ')') {\n            balance--;\n        }\n\n        // When the balance is zero, we have a complete group\n        if (balance == 0 && i > start_index) {\n            groups.push_back(paren_string.substr(start_index, i - start_index + 1));\n            start_index = i + 1; // Move to the next character after closing parenthesis\n        }\n    }\n\n    return groups;\n}\n\n// Example usage and check function\n#include <iostream>\nvoid print_groups(const std::vector<std::string>& groups) {\n    for (const auto& group : groups) {\n        std::cout << \"\\\"\" << group << \"\\\" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number using floor.\n    float intPart = std::floor(number);\n    \n    // Subtract the integer part from the original number to get the decimal part.\n    float decimalPart = number - intPart;\n    \n    return decimalPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize account balance to zero\n    \n    for (int op : operations) { // Iterate through each operation in the vector\n        balance += op; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // If no point where balance is below zero, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>  // For std::abs\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f;  // Handle empty vector case\n    \n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    // Calculate the size of the resulting vector\n    std::size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size\n    std::vector<int> result(result_size);\n\n    // Index for the result vector\n    std::size_t index = 0;\n\n    // Iterate through the original vector and insert elements along with delimiters\n    for (std::size_t i = 0; i < numbers.size(); ++i) {\n        result[index++] = numbers[i];\n        if (i != numbers.size() - 1) {  // Avoid adding delimiter after the last element\n            result[index++] = delimiter;\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const std::vector<int>& vec) {\n    for (const auto& elem : vec) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    int current_depth = 0, max_depth = 0;\n\n    for (size_t i = 0; i <= paren_string.length(); ++i) {\n        if (i == paren_string.length() || paren_string[i] == ' ') { // End of a group or end of string\n            if (current_depth > max_depth) {\n                result.push_back(current_depth);\n            } else {\n                result.push_back(max_depth);\n            }\n            current_depth = 0;\n            max_depth = 0;\n        } else if (paren_string[i] == '(') {\n            ++current_depth;\n            if (current_depth > max_depth) {\n                max_depth = current_depth;\n            }\n        } else if (paren_string[i] == ')') {\n            --current_depth;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of strings for testing purposes\nvoid print_vector(const vector<string>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << vec[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n\nstd::pair<int, int> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;       // Add each number to the sum\n        product *= num;   // Multiply each number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test and print results\nvoid check(const std::vector<int>& input) {\n    auto result = sum_product(input);\n    std::cout << \"Sum: \" << result.first << \", Product: \" << result.second << std::endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    return string(str.rbegin(), str.rend()) == str;\n}\n\nint longest_palindromic_suffix_length(const string& str, int start, int end) {\n    while (start >= 0 && end < str.size() && str[start] == str[end]) {\n        --start;\n        ++end;\n    }\n    return (str.size() - end);\n}\n\nstring make_palindrome(string str) {\n    // Find the longest palindromic suffix of the input string\n    int len = longest_palindromic_suffix_length(str, 0, str.size() - 1);\n\n    // If the entire string is a palindrome, return it as-is\n    if (len == str.size()) {\n        return str;\n    }\n\n    // Otherwise, reverse the prefix that comes before the palindromic suffix and append it to the original string\n    string prefix = str.substr(0, str.size() - len);\n    reverse(prefix.begin(), prefix.end());\n    return prefix + str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure that both strings are of equal length for XOR operation.\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of the same length\");\n    }\n\n    std::string result = \"\";\n    \n    // Iterate through each character in the string and perform XOR\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both bits are same, result is 0\n        } else {\n            result += '1';  // If bits are different, result is 1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string>& strings) {\n    // Check if the input vector is empty.\n    if (strings.empty()) {\n        return \"\";  // Return an empty string for None equivalent in C++\n    }\n\n    // Initialize variables to track the longest string and its length\n    size_t maxLength = 0;\n    std::string longestString;\n\n    // Iterate through each string in the vector\n    for (const auto& str : strings) {\n        if (str.length() > maxLength) {\n            maxLength = str.length();\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n\n// Example usage and check function\n#include <iostream>\n#include <cassert>\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>  // Only for printf if you want to test\n\nint greatest_common_divisor(int a, int b) {\n    while(b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Test cases\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    \n    // Iterate through each character in the input string\n    for (size_t i = 1; i <= str.length(); ++i) {\n        // Add substring from start to current index as a prefix\n        prefixes.push_back(str.substr(0, i));\n    }\n    \n    return prefixes;\n}\n\n// Function to print vector of strings\nvoid print_vector(const vector<string>& vec){\n    for (const auto& s : vec) {\n        cout << \"\\\"\" << s << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::string result = \"\";  // Initialize an empty string\n\n    for (int i = 0; i <= n; ++i) {\n        if (result.length() > 0) {  // If the result is not empty, append a space\n            result += \" \";\n        }\n        result += std::to_string(i);  // Convert integer to string and append it\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check_function() {\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nint count_distinct_characters(std::string str) {\n    std::set<char> unique_chars;\n\n    // Convert string to lowercase and insert characters into set\n    for (char c : str) {\n        char lower_c = std::tolower(c);\n        unique_chars.insert(lower_c);\n    }\n\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int i = 0, n = music_string.length();\n    \n    while (i < n) {\n        if (music_string[i] == 'o') { // whole note\n            beats.push_back(4);\n            i += 1; // skip one character for \"o\"\n        } else if (music_string.substr(i, 2) == \"o|\") { // half note\n            beats.push_back(2);\n            i += 2; // skip two characters for \"o|\"\n        } else if (music_string.substr(i, 2) == \".|\") { // quarter note\n            beats.push_back(1);\n            i += 2; // skip two characters for \".|\"\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move to the next character for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n\nstd::string sort_numbers(std::string numbers) {\n    // Mapping from number names to their integer values.\n    std::map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2},\n        {\"three\", 3}, {\"four\", 4}, {\"five\", 5},\n        {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Convert the input string into a vector of number words.\n    std::istringstream iss(numbers);\n    std::vector<std::string> num_words;\n    std::string word;\n    while (iss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Convert each number word to its integer value and sort them.\n    std::vector<int> nums;\n    for (const auto& w : num_words) {\n        nums.push_back(num_map[w]);\n    }\n    std::sort(nums.begin(), nums.end());\n\n    // Convert the sorted integers back into words.\n    std::ostringstream oss;\n    for (int n : nums) {\n        if (&oss != &std::cout) {  // Avoid adding space before first word\n            oss << \" \";\n        }\n        for (const auto& entry : num_map) {\n            if (entry.second == n) {\n                oss << entry.first;\n                break;\n            }\n        }\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw runtime_error(\"Vector must contain at least two elements\");\n    }\n\n    float min_diff = numeric_limits<float>::max();\n    pair<int, int> closest_indices;\n    \n    // Sort the vector to make finding the closest elements easier\n    sort(numbers.begin(), numbers.end());\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_indices.first = i;\n            closest_indices.second = i + 1;\n        }\n    }\n\n    return make_pair(numbers[closest_indices.first], numbers[closest_indices.second]);\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw runtime_error(\"Vector must contain at least two elements.\");\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Linear transformation formula: y = (x - x_min) / (x_max - x_min)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            integers.push_back(intValue);\n        } else if (value.type() == typeid(long)) { // Also check for long, in case you want to include it\n            long longValue = boost::any_cast<long>(value);\n            integers.push_back(static_cast<int>(longValue)); // Cast to int before adding\n        }\n    }\n\n    return integers;\n}\n\n// Example usage and verification function (not part of the original problem but for testing purposes)\nvoid check() {\n    list_any test1 = {boost::any(\"a\"), boost::any(3.14), boost::any(5)};\n    auto result1 = filter_integers(test1);\n    // Expected output: [5]\n\n    list_any test2 = {boost::any(1), boost::any(2), boost::any(3), boost::any(\"abc\"), boost::any({}), boost::any({})};\n    auto result2 = filter_integers(test2);\n    // Expected output: [1, 2, 3]\n\n    std::cout << \"Test passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until finding a divisor.\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen as 1 always divides any number,\n    // we can return -1 or throw an exception. However, for simplicity, let's just return 1.\n    return 1; \n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    \n    // Divide n by 2 until it's no longer divisible by 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2, add it to the list\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print vector elements for testing purposes\nvoid printFactors(const std::vector<int>& factors) {\n    for (int factor : factors) {\n        std::cout << factor << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Count occurrences of each element\n    map<int, int> countMap;\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Step 2: Add elements to the result vector if they occur only once\n    vector<int> uniqueNumbers;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            uniqueNumbers.push_back(num);\n        }\n    }\n\n    return uniqueNumbers;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // If the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // If the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string\n    std::string result;\n\n    // Iterate through each element and append it to the result\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<string> empty_vector = {};\n    vector<string> test_vector = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    \n    assert(filter_by_prefix(empty_vector, \"a\").empty());\n    assert((filter_by_prefix(test_vector, \"a\") == vector<string>{\"abc\", \"vector\"}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    for (float num : l) {\n        if (num > 0) { // Check if the number is positive\n            result.push_back(num); // Add it to the result vector\n        }\n    }\n    \n    return result;\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<float>& vec) {\n    for (float num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble poly_derivative(const std::vector<double>& xs, double x) {\n    double derivative = 0;\n    int n = xs.size() - 1; // Degree of the polynomial\n    for (size_t i = 1; i < xs.size(); ++i) { // Skip constant term as its derivative is zero\n        derivative += xs[i] * static_cast<double>(n--) * pow(x, static_cast<int>(n));\n    }\n    return derivative;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    double x = 1.0; // Initial guess\n    const double epsilon = 1e-7; // Precision for the root\n\n    while (true) {\n        double fx = poly(xs, x);\n        if (fabs(fx) < epsilon) break;\n\n        double dfx = poly_derivative(xs, x); // Derivative of polynomial at x\n        if (dfx == 0) { // Avoid division by zero\n            std::cerr << \"Derivative is zero. Cannot proceed with Newton's method.\" << std::endl;\n            return NAN; // Return NaN to indicate failure\n        }\n\n        x -= fx / dfx; // Update the guess using Newton-Raphson formula\n    }\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort; // To store elements that need sorting\n\n    // Extract elements at indices divisible by 3 (0-based index)\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i % 3) == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace original elements at indices divisible by 3 with sorted ones\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i % 3) == 0 && sorted_index < to_sort.size()) {\n            l[i] = to_sort[sorted_index++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <vector>\n#include <algorithm> // for sort and unique algorithms\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end()); // The unique function returns a past-the-end iterator for the new sequence\n    \n    // Erase the elements after the last unique element\n    l.erase(last, l.end());\n\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n    \n    float max_value = l[0];  // Initialize with the first element of the vector\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n\n    return max_value;\n}\n\n// Example usage\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    // Loop through all numbers less than n\n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int num = i;\n            while (num > 0) { // Count the number of times digit '7' appears in the number\n                if (num % 10 == 7)\n                    count++;\n                num /= 10; // Move to the next digit\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract even-indexed elements and store them in a separate vector.\n    std::vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements.\n    std::sort(evens.begin(), evens.end());\n\n    // Replace original even-indexed elements with sorted values.\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (j < evens.size()) {\n            l[i] = evens[j++];\n        }\n    }\n\n    return l;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<float> v1 = {1, 2, 3};\n    std::vector<float> expected_v1 = {1, 2, 3};\n    assert(sort_even(v1) == expected_v1);\n\n    std::vector<float> v2 = {5, 6, 3, 4};\n    std::vector<float> expected_v2 = {3, 6, 5, 4};\n    assert(sort_even(v2) == expected_v2);\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Shift the last character to the front\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate Fibonacci numbers and check for primality\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1, fib3 = 1; // Initialize the first three Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        if (is_prime(fib3)) { // Check if the current Fibonacci number is prime\n            ++count;\n            if (count == n)\n                return fib3; // Return when we find the nth prime Fibonacci number\n        }\n        // Generate next Fibonacci number\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2;\n    }\n\n    return -1; // This line should never be reached if n is valid\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    // If no triplet is found that sums to zero, return false\n    return false;\n}\n\n// Example usage and check function\n#include <iostream>\nbool check(vector<int> nums, bool expected) {\n    bool result = triples_sum_to_zero(nums);\n    if (result == expected)\n        printf(\"Correct: %s\\n\", result ? \"true\" : \"false\");\n    else\n        printf(\"Incorrect: Expected %s but got %s\\n\", expected ? \"true\" : \"false\", result ? \"true\" : \"false\");\n    return result;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    std::unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (!seen.insert(num).second) { // If the number is already in the set, it's a duplicate and we skip\n            continue;\n        }\n        \n        int complement = -num; // The number that would sum to zero with `num`\n        \n        if (seen.find(complement) != seen.end()) {\n            return true; // Found two distinct elements that sum to zero\n        }\n    }\n    \n    return false; // No such pair found\n}\n\n// Example usage and test cases:\n#include <iostream>\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    string result = \"\";\n    \n    // Edge case: if the number is 0, return \"0\"\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    while (x > 0) {\n        // Prepend the remainder to the result\n        result = to_string(x % base) + result;\n        \n        // Divide x by the base for the next iteration\n        x /= base;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h> // For printf\n\nfloat triangle_area(float base, float height) {\n    return 0.5 * base * height;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases for the first few elements of the sequence.\n    if (n == 0 || n == 1 || n == 3)\n        return 0;\n    else if (n == 2)\n        return 2;\n\n    // Initialize an array to store the last four values in the sequence.\n    int fibValues[4] = {0, 0, 2, 0};\n\n    // If n is less than or equal to 3, we've already handled it above.\n    if (n <= 3)\n        return fibValues[n];\n\n    // Compute the next elements iteratively until reaching n.\n    for (int i = 4; i <= n; ++i) {\n        int nextValue = fibValues[0] + fibValues[1] + fibValues[2] + fibValues[3];\n        // Shift the values to make room for the new value at index 0.\n        fibValues[0] = fibValues[1];\n        fibValues[1] = fibValues[2];\n        fibValues[2] = fibValues[3];\n        fibValues[3] = nextValue;\n    }\n\n    // The last computed value is now in fibValues[3].\n    return fibValues[3];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::floor and std::ceil\n\nfloat median(std::vector<float> l) {\n    size_t n = l.size();\n    \n    if (n == 0)\n        return 0.0f; // Return a default value or throw an exception if the vector is empty\n    \n    std::sort(l.begin(), l.end()); // Sort the elements in ascending order\n\n    float median;\n    if (n % 2 == 1) { // If odd, return the middle element\n        size_t mid = n / 2;\n        median = l[mid];\n    } else { // If even, return the average of the two middle elements\n        size_t mid_left = (n - 1) / 2;\n        size_t mid_right = mid_left + 1;\n        median = (l[mid_left] + l[mid_right]) / 2.0f;\n    }\n    \n    return median;\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a given string is a palindrome.\nbool is_palindrome(std::string text) {\n    int left = 0; // Start index of the string\n    int right = text.length() - 1; // End index of the string\n\n    while (left < right) {\n        if (text[left] != text[right]) { // If characters at both ends are not equal, it's not a palindrome.\n            return false;\n        }\n        left++; // Move towards the center from the start\n        right--; // Move towards the center from the end\n    }\n\n    return true; // The string is a palindrome if all corresponding characters match\n}\n\n// Function to test the is_palindrome function with given examples\nvoid check_palindrome() {\n    std::cout << (is_palindrome(\"\") ? \"true\" : \"false\") << std::endl;\n    std::cout << (is_palindrome(\"aba\") ? \"true\" : \"false\") << std::endl;\n    std::cout << (is_palindrome(\"aaaaa\") ? \"true\" : \"false\") << std::endl;\n    std::cout << (is_palindrome(\"zbcd\") ? \"false\" : \"true\") << std::endl; // Corrected to match expected output format\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    // Base case: 2^0 % p is always 1 for any prime p > 1.\n    if (n == 0) return 1;\n\n    long long result = 1;  // Use long long to avoid overflow\n    long long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current value of base and take modulo p.\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        // Square the base and reduce it modulo p to avoid overflow.\n        base = (base * base) % p;\n\n        // Divide n by 2\n        n /= 2;\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adjusting the formula to shift back by 5\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char ch : text) {\n        // Convert character to lowercase to handle both cases uniformly.\n        char lower_ch = tolower(ch);\n        \n        // Check if the character is not a vowel and add it to the result string.\n        if (lower_ch != 'a' && lower_ch != 'e' && lower_ch != 'i' && lower_ch != 'o' && lower_ch != 'u') {\n            result += ch;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with given examples.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage and check function\n#include <iostream>\nbool test_below_threshold() {\n    bool result = true;\n\n    // Test case 1: All elements are below the threshold\n    std::vector<int> vec1 = {1, 2, 4, 10};\n    if (!below_threshold(vec1, 100)) {\n        std::cout << \"Test failed for input (1, 2, 4, 10) with threshold 100\" << std::endl;\n        result = false;\n    }\n\n    // Test case 2: At least one element is not below the threshold\n    std::vector<int> vec2 = {1, 20, 4, 10};\n    if (below_threshold(vec2, 5)) {\n        std::cout << \"Test failed for input (1, 20, 4, 10) with threshold 5\" << std::endl;\n        result = false;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\nvoid check_add() {\n    printf(\"2 + 3 = %d, expected: 5\\n\", add(2, 3));\n    printf(\"5 + 7 = %d, expected: 12\\n\", add(5, 7));\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each string\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicates and shrink the strings to their unique elements\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // Base case for first Fibonacci number\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b; // Return the nth Fibonacci number\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n\n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance;\n        } else if (c == '>') {\n            --balance;\n        }\n\n        // If at any point the balance is negative, return false\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check to ensure all brackets are balanced\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Edge case: empty or single-element vector\n    if (l.size() <= 1) return true;\n    \n    int dir = 0; // 0 - unknown, 1 - increasing, -1 - decreasing\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        if (dir == 0 && l[i] != l[i-1]) { // Determine initial direction\n            if (l[i] > l[i-1])\n                dir = 1;\n            else\n                dir = -1;\n        }\n        \n        if ((dir == 1 && l[i] < l[i-1]) || (dir == -1 && l[i] > l[i-1])) {\n            return false; // Found a break in monotonicity\n        }\n    }\n    \n    return true; // Passed all checks, vector is monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort and std::set_intersection\n\nusing namespace std;\n\n// Function to return sorted unique common elements of two vectors.\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both input vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Initialize iterators for the result and both input vectors\n    vector<int>::iterator it1 = l1.begin();\n    vector<int>::iterator it2 = l2.begin();\n\n    vector<int> common_elements;\n    \n    // Use set_intersection to find common elements\n    set_intersection(it1, l1.end(), it2, l2.end(), back_inserter(common_elements));\n\n    return common_elements;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result;\n\n    result = common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121});\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    result = common({5, 3, 2, 8}, {3, 2});\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\n// Function to return the largest prime factor of n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int sum = (n * (n + 1)) / 2; // Using the formula for the sum of first n natural numbers: n(n+1)/2\n    return sum;\n}\n\n// Function to test and display results\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30) = \" << sum_to_n(30) << std::endl; // Should print 465\n    std::cout << \"sum_to_n(100) = \" << sum_to_n(100) << std::endl; // Should print 5050\n    std::cout << \"sum_to_n(5) = \" << sum_to_n(5) << std::endl; // Should print 15\n    std::cout << \"sum_to_n(10) = \" << sum_to_n(10) << std::endl; // Should print 55\n    std::cout << \"sum_to_n(1) = \" << sum_to_n(1) << std::endl; // Should print 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            // If balance is negative, there's a closing bracket without an opening one\n            if (balance < 0) return false;\n        }\n    }\n\n    // If balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // The resulting vector will be one element shorter than the input.\n    std::vector<float> result(xs.size() - 1);\n\n    for (size_t i = 0; i < result.size(); ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n    int result;\n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c;\n        a = b;\n        b = c;\n        c = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    const std::string vowels = \"aeiouAEIOU\";\n    \n    // Check each character in the string\n    for (char c : s) {\n        if (vowels.find(c) != std::string::npos) {\n            ++count; // Increment count if it's a vowel\n        }\n    }\n\n    // Special case: 'y' at the end of the word is considered a vowel\n    if (!s.empty() && s.back() == 'y') {\n        ++count;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string num = to_string(x);\n    \n    // If shift is greater than or equal to the length of the number,\n    // return the reversed number.\n    if (shift >= num.length()) {\n        reverse(num.begin(), num.end());\n        return num;\n    }\n    \n    // Perform circular right shift by moving last 'shift' digits\n    // to the front and appending the remaining part at the end.\n    string shifted = num.substr(num.length() - shift) + \n                     num.substr(0, num.length() - shift);\n                     \n    return shifted;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') { // Check if the character is an uppercase letter.\n            sum += static_cast<int>(c); // Add ASCII value of the uppercase character to sum.\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract the number of apples\n    size_t pos_apples = s.find(\"apples\");\n    string num_apples_str = s.substr(0, pos_apples);\n    int num_apples = stoi(num_apples_str);\n\n    // Extract the number of oranges\n    size_t pos_oranges = s.find(\"oranges\") + 8; // \"oranges\" starts after \"and \"\n    string num_oranges_str = s.substr(pos_oranges);\n    int num_oranges = stoi(num_oranges_str);\n\n    // Calculate the number of mangoes\n    int num_mangoes = n - (num_apples + num_oranges);\n\n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int>& arr) {\n    int minEvenValue = INT_MAX;\n    int minIndex = -1;\n\n    // Iterate through the vector to find the minimum even value and its index.\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) {\n            if (arr[i] < minEvenValue || (arr[i] == minEvenValue && i < minIndex)) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector.\n    if (minIndex == -1) {\n        return {};\n    } else {\n        return {minEvenValue, minIndex};\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freq;\n    \n    // Count the frequency of each integer in the vector\n    for (auto num : lst) {\n        freq[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check if any number meets the criteria\n    for (const auto& entry : freq) {\n        int value = entry.first;\n        int count = entry.second;\n        \n        if (value <= count && value > result) {\n            result = value;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the input list to easily access min and max values.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0;   // Pointer for minimum value\n    int right = lst.size() - 1;  // Pointer for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add minimum value\n        result.push_back(lst[left++]);\n        // Add maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage and check function (not part of the solution, for testing purposes)\nvoid check() {\n    std::vector<int> test1 = {1, 2, 3, 4};\n    std::vector<int> expected1 = {1, 4, 2, 3};\n    assert(strange_sort_list(test1) == expected1);\n\n    std::vector<int> test2 = {5, 5, 5, 5};\n    std::vector<int> expected2 = {5, 5, 5, 5};\n    assert(strange_sort_list(test2) == expected2);\n\n    std::vector<int> test3 = {};\n    std::vector<int> expected3 = {};\n    assert(strange_sort_list(test3) == expected3);\n    \n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\n// Function to calculate and return the area of a triangle rounded to 2 decimal points.\nfloat triangle_area(float a, float b, float c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        // Not a valid triangle\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter of the triangle\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet or cross each other\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move the left pointer to the right\n        right--; // Move the right pointer to the left\n    }\n\n    return changes; // Return the total number of required changes\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to calculate total number of characters in a vector<string>\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (count1 < count2) {\n        return lst1;\n    } else if (count2 < count1) {\n        return lst2;\n    } else {  // If both have the same number of characters, return the first list\n        return lst1;\n    }\n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    vector<string> empty_list = {};\n    vector<string> list1 = {\"hi\", \"admin\"};\n    vector<string> list2 = {\"hI\", \"Hi\"};\n    vector<string> list3 = {\"hi\", \"hi\", \"admin\", \"project\"};\n\n    assert(total_match(empty_list, empty_list) == empty_list);\n    assert(total_match(list1, list2) == list2);\n    assert(total_match(list1, list3) == list1);\n    assert(total_match(list1, {\"hI\", \"hi\", \"hi\"}) == {\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == {\"4\"});\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the number can be expressed as a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // We need at least three factors, so start checking from the smallest prime number\n    for (int i = 2; i <= 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        int b = a / i;\n        for (int j = i; j <= 100 && j * j <= b; ++j) {\n            if (!is_prime(j)) continue;\n\n            int k = b / j;\n            if ((b % j == 0) && is_prime(k) && (i * j * k == a))\n                return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle base cases\n    if (x == 1 && n != 0)\n        return true;\n    \n    if (n <= 1 || x <= 0)\n        return false;\n\n    double log_result = log(x) / log(n);\n    \n    // Check if the result of the logarithm is an integer\n    int potential_exponent = round(log_result);\n\n    // Verify that n raised to this exponent equals x\n    if (pow(n, potential_exponent) == x)\n        return true;\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Compute the cube root and round it to the nearest integer\n    int candidate = std::round(std::cbrt(a));\n    \n    // Check if the candidate cubed equals the original number\n    return (candidate * candidate * candidate == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given hex string\nint hex_key(const std::string& num) {\n    // Array representing prime hexadecimal digits\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the current character is a prime digit\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert a decimal number to its binary representation as a string\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\"; // Special case for zero\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int bit = decimal % 2;\n        binary = to_string(bit) + binary; // Prepend the current bit\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        char a = s[i];\n        char b = s[i + 1];\n        char c = s[i + 2];\n\n        // Check if all three characters are distinct\n        if (a == b || b == c || a == c) return false;\n    }\n    \n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7) letter_grades.push_back(\"A\");\n        else if (gpa > 3.3) letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0) letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7) letter_grades.push_back(\"B\");\n        else if (gpa > 2.3) letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0) letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7) letter_grades.push_back(\"C\");\n        else if (gpa > 1.3) letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0) letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7) letter_grades.push_back(\"D\");\n        else if (gpa >= 0.0) letter_grades.push_back(\"D-\"); // Covers the edge case of gpa == 0\n        else letter_grades.push_back(\"E\"); // In case there's a GPA below 0, though it shouldn't happen here.\n    }\n    \n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= num; ++i) { // Check divisibility from 2 up to the square root of num\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function that checks if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the count of n-digit positive integers starting or ending with 1.\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Only one such number exists for single digit: 1 itself.\n\n    // Count numbers that start with 1\n    int start_with_1 = 9 * pow(10, n - 2); // First digit is fixed as 1, remaining digits can be anything from 0-9 except the first.\n    \n    // Count numbers that end with 1\n    int ends_with_1 = 9 * pow(10, n - 2); // Last digit is fixed as 1, remaining digits can be anything from 0-9 except the last.\n\n    // Count numbers that both start and end with 1 (to avoid double counting)\n    int starts_and_ends_with_1 = pow(10, n - 2);\n\n    return start_with_1 + ends_with_1 - starts_and_ends_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Function to calculate the sum of digits and convert it to binary\nstring solve(int N) {\n    int digitSum = 0;\n\n    // Sum up all the digits in N\n    while (N > 0) {\n        digitSum += N % 10;  // Add the last digit to the sum\n        N /= 10;             // Remove the last digit from N\n    }\n\n    // Convert the sum of digits into binary and return it\n    return intToBinary(digitSum);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n// Function to sort characters of a string\nvoid sortString(string &str) {\n    sort(str.begin(), str.end());\n}\n\n// Main function that takes a sentence and returns an ordered version of it\nstring anti_shuffle(const string& s) {\n    string result;\n    size_t start = 0, end = 0;\n    \n    // Iterate through the input string to process each word\n    while (end != string::npos) {\n        // Find the next space or the end of the string\n        end = s.find(' ', start);\n        \n        // If there is no more space, end will be string::npos\n        if (end == string::npos) {\n            end = s.length();\n        }\n        \n        // Extract the current word and sort its characters\n        string word = s.substr(start, end - start);\n        sortString(word);\n        \n        // Append the sorted word to the result string\n        result += word;\n        \n        // If there are more words left in the sentence, append a space\n        if (end != s.length()) {\n            result += ' ';\n        }\n        \n        // Move to the next word\n        start = end + 1;\n    }\n\n    return result;\n}\n\n// Function to test the anti_shuffle function with some examples\nvoid testAntiShuffle() {\n    cout << \"anti_shuffle(\\\"Hi\\\") returns \\\"\" << anti_shuffle(\"Hi\") << \"\\\"\" << endl;\n    cout << \"anti_shuffle(\\\"hello\\\") returns \\\"\" << anti_shuffle(\"hello\") << \"\\\"\" << endl;\n    cout << \"anti_shuffle(\\\"Hello World!!!\\\") returns \\\"\" << anti_shuffle(\"Hello World!!!\") << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for easier initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Overload the less-than operator to sort by row in ascending order and column in descending order\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row) return col > other.col; // Descending for columns within the same row\n        return row < other.row;\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through each row and column to find occurrences of x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back(CustomCoordinate(i, j));\n            }\n        }\n    }\n\n    // Sort the coordinates as per the requirement\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> for the final result\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    auto res1 = get_row({{1,2,3,4,5,6}, {1,2,3,4,1,6}, {1,2,3,4,5,1}}, 1);\n    for (const auto& r : res1) {\n        printf(\"{%d,%d} \", r[0], r[1]);\n    }\n    // Expected output: {{0,0} {1,4} {1,0} {2,5} {2,0}}\n\n    auto res2 = get_row({}, 1);\n    if (res2.empty()) {\n        printf(\"{{}}\\n\");\n    }\n\n    auto res3 = get_row({{}, {1}, {1, 2, 3}}, 3);\n    for (const auto& r : res3) {\n        printf(\"{%d,%d} \", r[0], r[1]);\n    }\n    // Expected output: {{2,2}}\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty, return an empty vector.\n    if (array.empty()) {\n        return {};\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the original vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    const int shift = 2 * 2; // Shift by 4 positions\n    const char a = 'a';      // Starting character of lowercase alphabet\n    \n    for (char &c : s) {      // Iterate over each character in the string\n        if (isalpha(c)) {    // Check if the character is an alphabetic letter\n            c = tolower(c);  // Convert to lowercase to handle both cases uniformly\n            \n            // Calculate new position, wrapping around if necessary\n            int pos = ((c - a + shift) % 26);\n            \n            // Set the character to its new value in the alphabet\n            c = a + pos;\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <optional>  // To return an optional value\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) { \n        return {}; // Return empty optional for less than two elements\n    }\n\n    // Sort the vector to easily find the smallest and second smallest elements\n    std::sort(lst.begin(), lst.end());\n\n    // Check if all elements are the same or there's only one unique element\n    if (std::unique(lst.begin(), lst.end()) == lst.begin() || lst.size() < 2) {\n        return {}; // Return empty optional for no second smallest element\n    }\n\n    // The second element in the sorted list is the next smallest, unless it's a duplicate of the first.\n    int second_smallest = lst[1];\n    \n    if (second_smallest == lst.front()) { \n        return {}; // If duplicates, there's no distinct second smallest\n    }\n    \n    return second_smallest;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(!next_smallest({})); // Returns std::nullopt for empty vector\n    assert(!next_smallest({1, 1})); // Returns std::nullopt if all elements are the same\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(const string& S) {\n    int boredom_count = 0;\n    bool in_sentence = false;\n    for (size_t i = 0; i <= S.length(); ++i) { // Include the end to process last sentence\n        char c = i < S.length() ? S[i] : '\\n'; // Treat end of string as a delimiter\n\n        if (c == '.' || c == '?' || c == '!') {\n            in_sentence = false;\n        } else if (!in_sentence && c == 'I' && (i + 1 < S.length() && (S[i+1] == ' ' || S[i+1] == '\\n'))) {\n            // Check for \"I\" at the start of a sentence\n            boredom_count++;\n            in_sentence = true;\n        } else if (!in_sentence) {\n            in_sentence = c != '.' && c != '?' && c != '!'; // Start new sentence\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath> // For std::round\n\nbool any_int(float a, float b, float c) {\n    // Function to check if a number is an integer\n    bool is_integer(float num) {\n        return round(num) == num;\n    }\n\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n    \n    // Convert floats to integers since they are now known to be whole numbers\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if one number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to specified rules\nstring encode(string message) {\n    // Define mappings for vowel replacements and case swapping\n    string vowels = \"aeiouAEIOU\";\n    string shiftedVowelsLower = \"cdefgCDEFG\";  // 'a' -> 'c', 'e' -> 'g'\n    string shiftedVowelsUpper = \"CGIJKcgijk\";  // 'A' -> 'C', 'E' -> 'G'\n\n    for (char &ch : message) {\n        // Swap case\n        if (islower(ch)) ch = toupper(ch);\n        else if (isupper(ch)) ch = tolower(ch);\n\n        // Replace vowels with shifted characters\n        size_t pos = vowels.find(ch);\n        if (pos != string::npos) {\n            if (ch == 'A' || ch == 'E') {\n                ch = (ch >= 'a') ? 'c' : 'C';\n            } else if (ch == 'I') {\n                ch = (ch >= 'a') ? 'k' : 'K';\n            } else if (ch == 'O') {\n                ch = (ch >= 'a') ? 'q' : 'Q';\n            } else if (ch == 'U') {\n                ch = (ch >= 'a') ? 'w' : 'W';\n            }\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds the largest prime and returns the sum of its digits\nint largestPrimeDigitSum(vector<int> lst) {\n    int max_prime = -1; // Initialize with a value less than any possible prime in the list\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            max_prime = max(max_prime, num);\n        }\n    }\n\n    return digitSum(max_prime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (!isLowercase(key)) {\n            allLower = false;\n        }\n        if (!isUppercase(key)) {\n            allUpper = false;\n        }\n\n        // If both flags are already set to false, no need to continue\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true only if either all keys are lowercase or all uppercase\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to print the elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0)\n            cout << \",\";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digit of both numbers by taking modulo 10\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) { \n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if ((c == 'A') || (c == 'E') || (c == 'I') || (c == 'O') || (c == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value);  // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5) {\n        return static_cast<int>(floor(num + 0.1));  // Round up away from zero\n    } else if (num < 0 && ceil(num) - num == 0.5) {\n        return static_cast<int>(ceil(num - 0.1));  // Round down away from zero\n    } else {\n        return static_cast<int>(round(num));  // Standard rounding\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    // Determine if n is odd or even to decide the starting point for the next level.\n    int start = (n % 2 == 0) ? n + 1 : n;\n    \n    vector<int> pile(n);\n    for (int i = 0; i < n; ++i) {\n        // Calculate the number of stones in each level based on the starting point and parity.\n        pile[i] = start + (i * 2);  // Adding 2*i to get the next odd/even number\n    }\n    \n    return pile;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for(char c : s) {\n        if(c == ',' || c == ' ') {  // If the character is a comma or space\n            if(!word.empty()) {     // Add the current word to the result if it's not empty\n                result.push_back(word);\n                word = \"\";          // Reset the word string for the next word\n            }\n        } else {\n            word += c;              // Append the character to the current word\n        }\n    }\n\n    // Add the last word if there is one (after the loop ends)\n    if(!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for(const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure that x <= y\n    if (x > y)\n        return -1;\n    \n    // Start from the largest number in the range and work downwards to find an even number.\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {  // Check if the number is even\n            return i;       // Return the first even number found, which will be the largest in this range.\n        }\n    }\n\n    // If no even number was found within the range [x, y], return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    // Calculate the sum of integers from n to m using arithmetic series formula\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round down to nearest integer\n    int avg = floor(total_sum / (m - n + 1));\n    \n    // Convert the rounded average to binary string\n    if (avg == 0) return \"0\"; // Special case for zero\n    \n    string result = \"\";\n    while (avg > 0) {\n        result = to_string(avg % 2) + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number contains any even digit\nbool has_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return true; // If the last digit is even, return true.\n        n /= 10; // Remove the last digit and check the next one.\n    }\n    return false; // The number contains only odd digits.\n}\n\n// Function to filter out numbers with even digits and sort the result\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> filtered;\n    \n    for (int num : x) {\n        if (!has_even_digit(num)) { // If the number does not have any even digit, add it to the filtered vector.\n            filtered.push_back(num);\n        }\n    }\n\n    std::sort(filtered.begin(), filtered.end()); // Sort the filtered numbers in increasing order\n    return filtered;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map numbers to their corresponding string representations.\nconst map<int, string> number_to_word = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered array in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted array\n    reverse(filtered.begin(), filtered.end());\n\n    // Convert each number to its corresponding word and store it in a vector of strings\n    vector<string> result;\n    for (int num : filtered) {\n        if (number_to_word.find(num) != number_to_word.end()) {\n            result.push_back(number_to_word[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Helper function to calculate sum from 1 to n\nint arithmeticSum(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int valueAtIPlusOne = i + 1; // Since index starts from 0 but problem statement starts from 1\n        if ((valueAtIPlusOne % 2) == 0) { // If even\n            result[i] = factorial(valueAtIPlusOne);\n        } else { // If odd\n            result[i] = arithmeticSum(valueAtIPlusOne);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and verification function (not part of the original problem, just for testing)\nvoid checkFunction() {\n    vector<int> expected1 = {1, 2, 6, 24, 15};\n    vector<int> result1 = f(5);\n    \n    bool isCorrect = true;\n    for(int i = 0; i < expected1.size(); ++i) {\n        if (expected1[i] != result1[i]) {\n            isCorrect = false;\n            break;\n        }\n    }\n\n    printf(isCorrect ? \"Test passed\\n\" : \"Test failed\\n\");\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n// Main function to count even and odd palindromes\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return vector<int>({even_count, odd_count});\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Helper function to calculate sum of signed digits for an integer.\nint sum_of_signed_digits(int num) {\n    int sum = 0;\n    bool is_negative = (num < 0);\n    \n    // Handle negative numbers by converting them to positive and marking the first digit as negative\n    if (is_negative) {\n        num = -num; // Convert to positive for easier processing\n    }\n    \n    while (num > 0) {\n        int digit = num % 10;\n        sum += is_negative ? -digit : digit;\n        \n        // Toggle the sign flag after processing the first digit of a negative number\n        if (is_negative && digit != 0) {\n            is_negative = false;\n        }\n        \n        num /= 10; // Move to the next digit\n    }\n\n    return sum;\n}\n\n// Main function to count numbers with sum of signed digits > 0.\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (const auto& num : n) {\n        if (sum_of_signed_digits(num) > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is trivially sorted\n\n    int n = arr.size();\n    int break_point = -1;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) { // Found a point where the sequence breaks\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no breakpoint is found, the array is already sorted\n    if (break_point == -1) return true;\n\n    // Check if all elements before the break point are greater than or equal to all after it\n    for (int i = 0; i <= break_point; ++i) {\n        if (arr[i] < arr[(i + break_point + 2) % n]) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0; // Count of odd numbers in lst1\n    int evenCount = 0; // Count of even numbers in lst2\n\n    // Count odd numbers in lst1 and even numbers in lst2\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (oddCount <= evenCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to split the string and return a map of character frequencies\nmap<char, int> histogram(string test) {\n    // Map to store frequency of each character\n    map<char, int> freqMap;\n    \n    // Count occurrences of each character in the input string\n    for (char ch : test) {\n        if (ch != ' ') {  // Ignore spaces\n            freqMap[ch]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& pair : freqMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a result map containing only those characters with the max count\n    map<char, int> result;\n    for (auto& pair : freqMap) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the map in a readable format\nvoid printHistogram(const map<char, int>& hist) {\n    cout << \"{\";\n    for (const auto& [ch, count] : hist) {\n        cout << \"\\\"\" << ch << \"\\\", \" << count;\n        if (&hist != &*(hist.end())) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\";\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count the number of odd digits in a given string.\nint count_odd_digits(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if ((c - '0') % 2 != 0) { // Check if digit is odd\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to generate the output message based on the number of odd digits.\nstring generate_message(int num_odd_digits, int index) {\n    string result = \"the number of odd elements \";\n    for (int i = 0; i < num_odd_digits + strlen(\"n the str\"); ++i) { // Adjusting length to fit the pattern\n        if (i == num_odd_digits || i == strlen(\"n the str\")) {\n            result += index % 10 + '0'; // Insert index digit at correct position\n        } else {\n            result += \"n the str\";\n        }\n    }\n    return result;\n}\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> output;\n    for (int i = 0; i < lst.size(); ++i) {\n        int num_odd_digits = count_odd_digits(lst[i]);\n        string message = generate_message(num_odd_digits, i);\n        output.push_back(message + \" of the \" + to_string(i) + \"nput.\");\n    }\n    return output;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<string> input1 = {\"1234567\"};\n    auto result1 = odd_count(input1);\n    for (const string& s : result1) cout << s << endl;\n\n    vector<string> input2 = {\"3\", \"11111111\"};\n    auto result2 = odd_count(input2);\n    for (const string& s : result2) cout << s << endl;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // If current sum becomes negative, start new subarray from the current element\n        if (current_sum > 0) {\n            current_sum = nums[i]; // Start a new sub-array with the current element\n        } else {\n            current_sum += nums[i]; // Continue the existing sub-array\n        }\n        \n        // Update min_sum if needed\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_drops = 0;\n\n    // Iterate through each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n\n        // Calculate how many times a bucket needs to be lowered to empty this well\n        total_drops += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Custom comparator function\nbool customComparator(int a, int b) {\n    // Count the number of 1s in binary representation for both numbers\n    std::bitset<32> bit_a(a);\n    std::bitset<32> bit_b(b);\n\n    int ones_a = bit_a.count();\n    int ones_b = bit_b.count();\n\n    // If they have the same number of 1s, sort by decimal value\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n\n    // Otherwise, sort based on the number of 1s in binary representation\n    return ones_a < ones_b;\n}\n\nvector<int> sort_array(vector<int> arr){\n    // Sort using the custom comparator\n    std::sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a consonant\nbool is_consonant(char c) {\n    char lower_c = tolower(c);\n    return !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\n// Function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string current_word;\n\n    // Iterate through the input string\n    for (size_t i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] == ' ') {  // End of a word or end of string\n            if (!current_word.empty()) {\n                int consonant_count = count_consonants(current_word);\n                if (consonant_count == n) {\n                    result.push_back(current_word);\n                }\n                current_word.clear();\n            }\n        } else {\n            current_word += s[i];\n        }\n    }\n\n    return result;\n}\n\n// Function to test the select_words function\nvoid test_select_words() {\n    vector<string> expected1 = {\"little\"};\n    assert(select_words(\"Mary had a little lamb\", 4) == expected1);\n\n    vector<string> expected2 = {\"Mary\", \"lamb\"};\n    assert(select_words(\"Mary had a little lamb\", 3) == expected2);\n\n    vector<string> expected3;\n    assert(select_words(\"\\\"simple white space\\\"\", 2).empty());\n\n    vector<string> expected4 = {\"world\"};\n    assert(select_words(\"Hello world\", 4) == expected4);\n\n    vector<string> expected5 = {\"Uncle\"};\n    assert(select_words(\"Uncle sam\", 3) == expected5);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to find the closest vowel between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if both surrounding characters are consonants and the middle one is a vowel\n        if (!is_vowel(left_char) && !is_vowel(right_char) && is_vowel(middle_char)) {\n            return string(1, middle_char);  // Return the found vowel as a single-character string\n        }\n    }\n\n    // If no such vowel exists, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') ++balance;\n        else --balance;\n        if (balance < 0) return false; // More closing parentheses than opening ones\n    }\n    return balance == 0; // Balanced string has equal number of open and close parentheses\n}\n\nstring match_parens(vector<string> lst) {\n    int total_open = 0, total_close = 0;\n    \n    for (const auto& s : lst) {\n        for (char c : s) {\n            if (c == '(') ++total_open;\n            else ++total_close;\n        }\n    }\n\n    // If the total number of open and close parentheses are not equal, return \"No\"\n    if (total_open != total_close) return \"No\";\n\n    // Check both possible concatenation orders\n    string order1 = lst[0] + lst[1];\n    string order2 = lst[1] + lst[0];\n\n    if (is_balanced(order1) || is_balanced(order2)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> maximum(std::vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order.\n    std::sort(arr.begin(), arr.end(), std::greater<int>());\n    \n    // Step 2: Take the first k elements from the sorted vector.\n    std::vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort these k elements in ascending order before returning them.\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for(int i = 1; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it's an odd number\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function (not part of the solution)\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 9); // Odd elements in even positions are 8 and 1\n    assert(solution({3, 3, 3, 3, 3}) == 6); // Odd elements in even positions are 3 and 3\n    assert(solution({30, 13, 24, 321}) == 321); // Only one odd element at an even position is 321\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the vector\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) { \n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> odds;\n    \n    // Generate Collatz sequence and collect odd numbers\n    while (n != 1) {\n        if (n % 2 == 1) {  // Check if the number is odd\n            odds.push_back(n);\n        }\n        if (n % 2 == 0) {  // If even, halve it\n            n /= 2;\n        } else {           // If odd, apply the formula: 3 * n + 1\n            n = 3 * n + 1;\n        }\n    }\n    \n    // The number 1 is always part of the sequence and should be included if not already present\n    odds.push_back(1);\n    \n    // Sort the vector in increasing order\n    std::sort(odds.begin(), odds.end());\n    \n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty or does not match \"mm-dd-yyyy\" format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    int month, day, year;\n    sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n    \n    // Validate the month\n    if (month < 1 || month > 12) return false;\n\n    // Validate the day based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) return false;\n    else if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) return false;\n    else if (month == 2) {\n        // Check for leap year\n        bool isLeapYear = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!isLeapYear && (day < 1 || day > 28)) return false;\n        else if (isLeapYear && (day < 1 || day > 29)) return false;\n    }\n    \n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to count lowercase letters with odd order indices in the alphabet\nint count_odd_lowercase(const string& s) {\n    int count = 0;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Calculate the position of the letter in the alphabet and check if it's odd\n            if ((c - 'a') % 2 == 1) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Try splitting on whitespace first\n    stringstream ss(txt);\n    string word;\n    while (ss >> word) {\n        result.push_back(word);\n    }\n\n    if (!result.empty()) {\n        return result;  // Return the words if there were any splits\n    } else {\n        // If no whitespaces, try splitting on commas\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        // Add the last segment if there are no more commas\n        result.push_back(txt.substr(start));\n\n        if (!result.empty()) {\n            return result;  // Return the words if there were any splits on commas\n        } else {\n            // If no whitespaces or commas, count odd lowercase letters and return as a single-element vector\n            int count = count_odd_lowercase(txt);\n            result.push_back(to_string(count));\n            return result;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is empty or has only one element\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of occurrences\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check ascending order\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n\n        // Count occurrences\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert(is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nvector<int> getIntersection(vector<int>& interval1, vector<int>& interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    if (start > end) return {}; // No intersection\n\n    return {start, end};\n}\n\n// Function to determine if the length of the intersection is a prime number\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    vector<int> intersect = getIntersection(interval1, interval2);\n    \n    if (intersect.empty()) return \"NO\"; // No intersection\n\n    int length = intersect[1] - intersect[0] + 1;\n    \n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    // Check for empty vector\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (auto num : arr) {\n        // If the number is zero, the product of signs will be zero.\n        if (num == 0) {\n            sign_product = 0;\n            break;\n        }\n\n        // Add the absolute value to the sum\n        magnitude_sum += std::abs(num);\n\n        // Update the sign product based on the current number's sign\n        sign_product *= num > 0 ? 1 : -1;\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct State {\n    int x, y;\n    vector<int> path;\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool isValid(int x, int y, int N) {\n    return x >= 0 && x < N && y >= 0 && y < N;\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Initialize the result with a large value\n    vector<int> best_path(N * N + 1);\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            queue<State> q;\n            State start = {{i, j}, {grid[i][j]}};\n            q.push(start);\n\n            while (!q.empty()) {\n                State curr = q.front();\n                q.pop();\n\n                if (curr.path.size() == k) {\n                    // Compare and update the best path\n                    for (int l = 0; l < k; ++l) {\n                        if (curr.path[l] < best_path[l]) {\n                            best_path = curr.path;\n                            break;\n                        } else if (curr.path[l] > best_path[l]) {\n                            break;\n                        }\n                    }\n                } else {\n                    for (int d = 0; d < 4; ++d) {\n                        int nx = curr.x + dx[d];\n                        int ny = curr.y + dy[d];\n\n                        if (isValid(nx, ny, N)) {\n                            State next = {{nx, ny}, curr.path};\n                            next.path.push_back(grid[nx][ny]);\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return best_path;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1, 0); // Initialize a vector to store results\n    \n    if (n >= 0) result[0] = 1; // Base case for even index 0\n    if (n >= 1) result[1] = 3; // Base case for odd index 1\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) { // If the index is even, use the given formula\n            result[i] = 1 + i / 2;\n        } else { // If the index is odd, calculate using previous values\n            int next_value = i + 1; // Since we need tri(n+1), which isn't yet calculated, we'll handle it separately.\n            if (next_value <= n) {\n                result[i] = result[i - 1] + result[i - 2] + result[next_value];\n            } else { // If next_value > n, we can only use the values up to 'n'.\n                result[i] = result[i - 1] + result[i - 2]; \n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false; // To check if there is at least one odd digit\n\n    while (n > 0) {\n        int last_digit = n % 10; // Get the last digit\n        if (last_digit % 2 != 0) { // Check if it's an odd digit\n            product *= last_digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return product or 0 based on presence of odd digits\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n\nbool is_nested(std::string str) {\n    int balance = 0; // Keeps track of the number of open brackets without a matching close\n\n    for (char c : str) {\n        if (c == '[') {\n            balance++;\n        } else if (c == ']') {\n            if (balance > 1) { // If there is already an unmatched opening bracket, we have nesting\n                return true;\n            }\n            balance--;\n        }\n\n        // Early exit optimization: if balance goes negative, the string is invalid and cannot be nested.\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // The string must end with a balanced number of brackets to be valid.\n    return balance == 0 && str.length() > 2; // Length check ensures there's at least one nesting\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::ceil\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        float ceil_num = ceil(num); // Round up to the nearest integer\n        sum += ceil_num * ceil_num; // Square and add to sum\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check for empty string\n    if (txt.empty()) return false;\n    \n    int last_space_pos = -1;  // Position of the last space in the string\n    \n    // Find the position of the last space\n    for (int i = txt.length() - 1; i >= 0; --i) {\n        if (txt[i] == ' ') {\n            last_space_pos = i;\n            break;\n        }\n    }\n\n    // If there is no space in the string, then the last character cannot be outside a word\n    if (last_space_pos == -1) return false;\n\n    // Check if the last character is an alphabetical letter and it's not part of a word\n    char last_char = txt[txt.length() - 1];\n    if ((last_char >= 'a' && last_char <= 'z') || (last_char >= 'A' && last_char <= 'Z')) {\n        // Check if the character is after a space and it's not followed by another word\n        return last_space_pos == txt.length() - 1;\n    }\n\n    return false;  // If none of the conditions are met, return false\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if the current element is not greater than or equal to the previous one\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of this element\n        }\n    }\n    return -1; // If no such element exists, return -1\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to smallest possible integer\n    int min_positive = INT_MAX; // Initialize to largest possible integer\n    \n    for (int num : lst) {\n        if (num > 0 && num < min_positive) {\n            min_positive = num;\n        } else if (num < 0 && num > max_negative) {\n            max_negative = num;\n        }\n    }\n\n    // If no positive or negative integers were found, set them to 0\n    int largest_negative = (max_negative == INT_MIN) ? 0 : max_negative;\n    int smallest_positive = (min_positive == INT_MAX) ? 0 : min_positive;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(test1);\n    printf(\"({%d, %d})\\n\", result1[0], result1[1]); // Expected: (0, 1)\n\n    vector<int> test2 = {};\n    vector<int> result2 = largest_smallest_integers(test2);\n    printf(\"({%d, %d})\\n\", result2[0], result2[1]); // Expected: (0, 0)\n\n    vector<int> test3 = {0};\n    vector<int> result3 = largest_smallest_integers(test3);\n    printf(\"({%d, %d})\\n\", result3[0], result3[1]); // Expected: (0, 0)\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to parse string as float, handling both '.' and ',' as decimal separators.\nfloat parse_string_to_float(const std::string& str) {\n    size_t pos = str.find_first_of(\",.\");\n    if (pos != std::string::npos && pos != str.length() - 1) {\n        return std::stof(str);\n    } else {\n        throw std::invalid_argument(\"Invalid string format\");\n    }\n}\n\n// Function to compare two values of different types and return the larger one.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Extracting values\n    if (a.type() == typeid(int)) {\n        int ai = boost::any_cast<int>(a);\n        float af = static_cast<float>(ai);\n        \n        if (b.type() == typeid(int)) {\n            return std::max(ai, boost::any_cast<int>(b));\n        } else if (b.type() == typeid(float)) {\n            return std::max(af, boost::any_cast<float>(b));\n        } else if (b.type() == typeid(std::string)) {\n            float bf = parse_string_to_float(boost::any_cast<std::string>(b));\n            return af > bf ? af : bf;\n        }\n    } else if (a.type() == typeid(float)) {\n        float af = boost::any_cast<float>(a);\n        \n        if (b.type() == typeid(int)) {\n            return std::max(af, static_cast<float>(boost::any_cast<int>(b)));\n        } else if (b.type() == typeid(float)) {\n            return std::max(af, boost::any_cast<float>(b));\n        } else if (b.type() == typeid(std::string)) {\n            float bf = parse_string_to_float(boost::any_cast<std::string>(b));\n            return af > bf ? af : bf;\n        }\n    } else if (a.type() == typeid(std::string)) {\n        float af = parse_string_to_float(boost::any_cast<std::string>(a));\n        \n        if (b.type() == typeid(int)) {\n            return af > static_cast<float>(boost::any_cast<int>(b)) ? af : boost::any_cast<int>(b);\n        } else if (b.type() == typeid(float)) {\n            float bf = parse_string_to_float(boost::any_cast<std::string>(a));\n            return std::max(bf, boost::any_cast<float>(b));\n        } else if (b.type() == typeid(std::string)) {\n            float af2 = parse_string_to_float(a.as<std::string>());\n            float bf = parse_string_to_float(b.as<std::string>());\n            \n            if (af2 > bf) return a;\n            if (bf > af2) return b;\n        }\n    }\n\n    // If values are equal\n    return \"None\";\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 20 and also an even number.\n    return (n >= 20 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    if(n == 0 || n == 1)\n        return 1;\n    \n    return n * factorial(n - 1);\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n    \n    for (char ch : text) {\n        if (ch == ' ') {\n            spaceCount++;\n            // If there are more than two consecutive spaces, append '-' and reset count\n            if (spaceCount > 2) continue; \n            else result += '_';\n        } else {\n            spaceCount = 0;\n            result += ch;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isValidExtension(const string& file_name, size_t pos) {\n    // Check if the substring after the dot matches one of the valid extensions.\n    const char* valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    for (const auto& ext : valid_extensions) {\n        if (file_name.substr(pos + 1) == ext)\n            return true;\n    }\n    return false;\n}\n\nbool hasValidDigits(const string& file_name, size_t pos) {\n    // Count the number of digits in the part before the dot.\n    int digit_count = 0;\n    for (size_t i = 0; i < pos; ++i) {\n        if (isdigit(file_name[i]))\n            digit_count++;\n    }\n    return digit_count <= 3;\n}\n\nstring file_name_check(string file_name) {\n    size_t dot_pos = file_name.find('.');\n    \n    // Check if there is exactly one dot.\n    if (dot_pos == string::npos || file_name.rfind('.', dot_pos + 1) != dot_pos)\n        return \"No\";\n    \n    // Ensure the part before the dot starts with a letter and has no more than three digits.\n    if (!isalpha(file_name[0]) || !hasValidDigits(file_name, dot_pos))\n        return \"No\";\n\n    // Check for valid extension after the dot.\n    if (!isValidExtension(file_name, dot_pos))\n        return \"No\";\n    \n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\n\nint sum_squares(const std::vector<int>& lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if ((i + 1) % 4 == 0) { // Index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is (no change)\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime length from the sentence\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::ostringstream oss;\n    std::string word;\n\n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            // Append the word and a space to the output string, except for the last word\n            oss << word << \" \";\n        }\n    }\n\n    // Remove the trailing space from the result\n    if (!oss.str().empty()) {\n        oss.seekp(-1, std::ostream::end);\n        oss << \"\";\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse fraction and return numerator and denominator as integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    int numeratorX, denominatorX;\n    parseFraction(x, numeratorX, denominatorX);\n\n    int numeratorN, denominatorN;\n    parseFraction(n, numeratorN, denominatorN);\n\n    // Multiply the two fractions: (numeratorX/denominatorX) * (numeratorN/denominatorN)\n    long long resultNum = static_cast<long long>(numeratorX) * numeratorN;\n    long long resultDen = static_cast<long long>(denominatorX) * denominatorN;\n\n    // Simplify the fraction by dividing both numerator and denominator by their GCD\n    long long gcdValue = __gcd(resultNum, resultDen);\n\n    // Check if the simplified fraction is a whole number (i.e., denominator becomes 1)\n    return (resultDen / gcdValue == 1);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = (num < 0);\n    while(num != 0) {\n        int digit = abs(num % 10); // Get last digit\n        if(is_negative && digit > 0)\n            sum -= digit; // Subtract positive digits for negative numbers\n        else\n            sum += digit;\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Function to sort vector based on sum of digits.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexed_nums;\n\n    // Pair each number with its index and calculate the digit sum.\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({digit_sum(nums[i]), static_cast<int>(i)});\n    }\n\n    // Sort pairs based on digit sum, then by original index if sums are equal.\n    std::stable_sort(indexed_nums.begin(), indexed_nums.end(),\n                     [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n        return a.first < b.first || (a.first == b.first && a.second < b.second);\n    });\n\n    // Reconstruct the sorted vector based on original indices.\n    std::vector<int> result(nums.size());\n    for (size_t i = 0; i < indexed_nums.size(); ++i) {\n        result[indexed_nums[i].second] = nums[indexed_nums[i].second];\n    }\n\n    return result;\n}\n\n// Example usage and verification\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\n// Function to check if a digit is odd.\nbool isOddDigit(int d) {\n    return (d % 2 != 0);\n}\n\n// Function to get the last digit of a number.\nint getLastDigit(int num) {\n    return abs(num) % 10;\n}\n\n// Function to get the first digit of a number.\nint getFirstDigit(int num) {\n    int n = abs(num);\n    while (n >= 10) {\n        n /= 10;\n    }\n    return n;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (auto& num : nums) {\n        if (num > 10 && isOddDigit(getFirstDigit(num)) && isOddDigit(getLastDigit(num))) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(specialFilter({15, -73, 14, -15}) == 1);\n    assert(specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula given.\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "const std::vector<std::string> PLANETS = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator for sorting strings by length, then lexicographically.\nbool compare_strings(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // Alphabetical order if lengths are the same\n    }\n    return a.length() < b.length(); // Ascending order of length\n}\n\nvector<string> vector_sort(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { \n        return s.length() % 2 != 0; \n    }), lst.end());\n\n    // Sort the remaining strings by length, then lexicographically\n    sort(lst.begin(), lst.end(), compare_strings);\n\n    return lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime.\n    for (int i = 2; i * i <= n; ++i) { // Check divisibility up to the square root of n.\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function that returns x if n is prime, otherwise y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y; // Use ternary operator to decide based on the result of is_prime.\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long sum_of_odd_squares(const std::vector<float>& lst) {\n    long long result = 0;\n    \n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == ceil(num) && static_cast<int>(num) % 2 != 0) {\n            result += std::pow(static_cast<long long>(num), 2);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    // Iterate through both vectors and calculate differences\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculate_strength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer\n\n    for (const auto& extension : extensions) {\n        int strength = calculate_strength(extension);\n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If the length of 'b' is greater than 'a', it cannot be a substring.\n    if (b.length() > a.length()) return false;\n    \n    // Concatenate 'a' with itself to handle rotations\n    string doubled_a = a + a;\n\n    // Check if 'b' or any of its rotations is a substring of the concatenated string\n    for (int i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (doubled_a.find(rotated_b) != string::npos)\n            return true;\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Make sure we work with a positive number\n    if (num < 0) {\n        num = -num;\n    }\n\n    int evenCount = 0, oddCount = 0;\n\n    while (num > 0) {\n        int digit = num % 10;  // Get the last digit\n\n        if (digit % 2 == 0) {  // Check if the digit is even\n            evenCount++;\n        } else {  // Otherwise, it's odd\n            oddCount++;\n        }\n\n        num /= 10;  // Remove the last digit\n    }\n\n    return vector<int>{evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their Roman numeral equivalents.\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"},  {90, \"xc\"},  {50, \"l\"},  {40, \"xl\"},\n        {10, \"x\"},   {9, \"ix\"},   {5, \"v\"},   {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Convert the number to a Roman numeral.\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure that 'c' is always the largest number among a, b, and c.\n    if (a > c) std::swap(a, c);\n    if (b > c) std::swap(b, c);\n\n    // Check Pythagorean theorem: a^2 + b^2 == c^2\n    return std::abs((a * a + b * b) - (c * c)) < 1e-6;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of unique characters in a string\nint count_unique_chars(const string& word) {\n    set<char> char_set;\n    for (char c : word) {\n        char_set.insert(c);\n    }\n    return char_set.size();\n}\n\nstring find_max(vector<string>& words) {\n    // Initialize variables to keep track of the maximum unique characters and corresponding word\n    int max_unique_chars = 0;\n    string result;\n\n    for (const auto& word : words) {\n        int current_unique_chars = count_unique_chars(word);\n        \n        // Check if this word has more unique characters than the current best or is lexicographically smaller\n        if (current_unique_chars > max_unique_chars || \n            (current_unique_chars == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_chars;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<string> words1 = {\"name\", \"of\", \"string\"};\n    assert(find_max(words1) == \"string\");\n\n    vector<string> words2 = {\"name\", \"enam\", \"game\"};\n    assert(find_max(words2) == \"enam\");\n\n    vector<string> words3 = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(find_max(words3) == \"aaaaaaa\");\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots can be eaten without exceeding the available stock\n    int toEat = min(need, remaining);\n    \n    // Update the total number of carrots eaten and the remaining stock\n    int totalEaten = number + toEat;\n    int leftOver = remaining - toEat;\n\n    return {totalEaten, leftOver};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nint do_algebra(std::vector<std::string> operatorVec, std::vector<int> operandVec) {\n    // Initialize result with the first element in the operand vector.\n    int result = operandVec[0];\n\n    // Iterate through each operator and apply it to the current result and next operand.\n    for (size_t i = 0; i < operatorVec.size(); ++i) {\n        if (operatorVec[i] == \"+\") {\n            result += operandVec[i + 1];\n        } else if (operatorVec[i] == \"-\") {\n            result -= operandVec[i + 1];\n        } else if (operatorVec[i] == \"*\") {\n            result *= operandVec[i + 1];\n        } else if (operatorVec[i] == \"//\") {\n            // Floor division\n            result /= operandVec[i + 1]; // C++ integer division already floors the result.\n        } else if (operatorVec[i] == \"**\") {\n            result = pow(result, operandVec[i + 1]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if character is an alphabet\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to reverse case of a letter\nchar toggleCase(char c) {\n    if(c >= 'a' && c <= 'z')\n        return c - 32; // Convert lowercase to uppercase\n    else if(c >= 'A' && c <= 'Z')\n        return c + 32; // Convert uppercase to lowercase\n    return c;\n}\n\n// Function to check if the string contains any letter\nbool hasLetter(const string& s) {\n    for(char c : s) {\n        if(isLetter(c)) return true;\n    }\n    return false;\n}\n\nstring solve(string s) {\n    bool containsLetters = hasLetter(s);\n    \n    // If there are no letters, reverse the entire string\n    if(!containsLetters) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    for(char& c : s) {\n        if(isLetter(c)) {\n            c = toggleCase(c);  // Toggle case of letter\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nstd::string string_to_md5(std::string text) {\n    if (text.empty()) return \"\";  // Return an empty string instead of None for C++ compatibility\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&hash);\n\n    std::stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n\n    return ss.str();\n}\n\n// Example usage and check function\n#include <iostream>\nvoid check_md5() {\n    std::string test = \"Hello world\";\n    std::cout << \"MD5 of \\\"\" << test << \"\\\": \" << string_to_md5(test) << std::endl;\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure a <= b for simplicity in range checking\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> result;\n    \n    // Check each even digit and add to the result if it's within the range [a, b]\n    for (int i = 2; i <= 8; i += 2) { \n        if (i >= a && i <= b) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print results\nvoid check_and_print(int a, int b) {\n    vector<int> result = generate_integers(a, b);\n    printf(\"{\");\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i > 0) printf(\", \");\n        printf(\"%d\", result[i]);\n    }\n    printf(\"}\\n\");\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list and check if any two consecutive elements\n    // are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no close elements were found, return false.\n    return false;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    int balance = 0; // Tracks the current level of nesting\n    size_t start_index = 0; // Start index for a new group\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(' || paren_string[i] == ')') { // Ignore spaces\n            if (paren_string[i] == '(') {\n                balance++;\n            } else if (paren_string[i] == ')') {\n                balance--;\n            }\n\n            // When balance returns to 0, a group is complete\n            if (balance == 0 && i > start_index) {\n                result.push_back(paren_string.substr(start_index, i - start_index + 1));\n                start_index = i + 1; // Start of the next potential group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Example usage and verification function\nvoid check() {\n    std::vector<std::string> expected = {\"()\", \"(())\", \"(()())\"};\n    std::vector<std::string> actual = separate_paren_groups(\"( ) (( )) (( )( ))\");\n    \n    for (const auto& group : actual) {\n        printf(\"\\\"%s\\\" \", group.c_str());\n    }\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>  // For floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);  // Get the integer part\n    float decimal_part = number - integer_part;  // Subtract to get the decimal part\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int operation : operations) {\n        balance += operation; // Update the balance based on the current operation\n        \n        if (balance < 0) {\n            return true; // If balance falls below zero, return true\n        }\n    }\n    \n    return false; // If no point where balance is negative, return false\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad_sum = 0.0f;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Calculate the size of the resulting vector.\n    size_t result_size = numbers.size() + (numbers.size() > 0 ? numbers.size() - 1 : 0);\n    \n    // Create a new vector with the calculated size.\n    vector<int> result(result_size);\n\n    if (!numbers.empty()) {\n        int pos = 0;\n        \n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result[pos++] = numbers[i];\n            \n            if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n                result[pos++] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes.\nvoid printVector(const vector<int>& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    \n    // Function to calculate depth for a single group of parentheses\n    auto calculate_depth = [](const string& group) -> int {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (max_depth < current_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                --current_depth;\n            }\n        }\n        return max_depth;\n    };\n\n    // Split the input string into groups and calculate depth for each group\n    size_t start = 0, end = paren_string.find(' ');\n    while (end != string::npos) {\n        depths.push_back(calculate_depth(paren_string.substr(start, end - start)));\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Add the last group\n    if (start < paren_string.length()) {\n        depths.push_back(calculate_depth(paren_string.substr(start)));\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each element in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered_strings vector\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Example usage and verification function\nvoid check_function() {\n    auto result1 = filter_by_substring({}, \"a\");\n    assert(result1.empty());\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    vector<string> expected_result2{\"abc\", \"bacd\", \"vector\"};\n    for (const auto& str : expected_result2) {\n        assert(find(result2.begin(), result2.end(), str) != result2.end());\n    }\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n#include <utility> // For std::pair\n\n// Function to calculate sum and product of elements in the vector.\nstd::pair<int, long> sum_product(const std::vector<int>& numbers) {\n    int sum = 0;\n    long product = 1; // Use long to prevent overflow for large products\n    \n    for (int num : numbers) {\n        sum += num;\n        product *= static_cast<long>(num); // Cast to long to avoid integer overflow\n    }\n    \n    return {sum, product};\n}\n\n// Example usage and check function\nvoid check() {\n    auto result1 = sum_product({});\n    printf(\"(Sum: %d, Product: %ld)\\n\", result1.first, result1.second);\n    \n    auto result2 = sum_product({1, 2, 3, 4});\n    printf(\"(Sum: %d, Product: %ld)\\n\", result2.first, result2.second);\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int max_so_far = numbers[0];  // Initialize the maximum value with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update the maximum value if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    return string(str.rbegin(), str.rend()) == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Iterate from the end of the string towards the beginning\n    for (size_t i = str.size(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            break;\n        }\n    }\n\n    // The part before this palindromic suffix is what we need to reverse and append\n    string non_palindromic_prefix = str.substr(i);\n    \n    // Append the reverse of the non-palindromic prefix to form a palindrome\n    return str + string(non_palindromic_prefix.rbegin(), non_palindromic_prefix.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure that both strings are of equal length for simplicity.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result.\n\n    // Iterate through each character in the strings and perform XOR operation.\n    for (int i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If both characters are the same, append '0' to the result string.\n        } else {\n            result += '1';  // If characters are different, append '1'.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {  // Check if the vector is empty\n        return \"\";  // Return an empty string instead of None, as C++ doesn't have a direct equivalent to Python's None for strings\n    }\n\n    string longest_str = strings[0];  // Initialize with the first string in the vector\n\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {  // If current string is longer than the longest found so far\n            longest_str = str;  // Update the longest string\n        }\n    }\n\n    return longest_str;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both numbers are positive\n    if (a <= 0 || b <= 0) {\n        return -1; // or throw an exception/error for invalid input\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            ss << \" \";\n        }\n        ss << i;\n    }\n    return ss.str();\n}\n\n// Function to test the correctness of string_sequence\nvoid check_function() {\n    std::cout << \"string_sequence(0): \\\"\" << string_sequence(0) << \"\\\"\\n\";\n    std::cout << \"string_sequence(5): \\\"\" << string_sequence(5) << \"\\\"\\n\";\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype> // For std::tolower\n\nint count_distinct_characters(std::string str) {\n    // Convert all characters to lowercase\n    for (char &ch : str) {\n        ch = std::tolower(ch);\n    }\n\n    // Use a set to store unique characters\n    std::unordered_set<char> unique_chars;\n    \n    // Insert each character into the set\n    for (char ch : str) {\n        unique_chars.insert(ch);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\n\nstd::vector<int> parse_music(std::string music_string) {\n    std::vector<int> beats;\n    \n    // Iterate through each character in the string\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') { // Whole note\n            beats.push_back(4);\n        } else if (music_string.substr(i, 2) == \"o|\") { // Half note\n            beats.push_back(2);\n            i++; // Skip the next character as it's part of this half note\n        } else if (music_string.substr(i, 2) == \".|\") { // Quarter note\n            beats.push_back(1);\n            i++; // Skip the next character as it's part of this quarter note\n        }\n    }\n\n    return beats;\n}\n\n// Example usage and verification function\nvoid check() {\n    std::vector<int> result = parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n    for (int beat : result) {\n        printf(\"%d \", beat);\n    }\n    // Expected output: 4 2 1 2 2 1 1 1 1 4 4\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Iterate through the string to find all occurrences of the substring.\n    while ((pos = str.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++; // Move past the last found position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n\nusing namespace std;\n\n// Function to map string numbers to integer values\nint word_to_int(const string& word) {\n    static const map<string, int> number_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2},\n        {\"three\", 3}, {\"four\", 4}, {\"five\", 5},\n        {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8},\n        {\"nine\", 9}\n    };\n    return number_map.at(word);\n}\n\n// Function to map integer values back to string numbers\nstring int_to_word(int num) {\n    static const vector<string> words = {\"zero\", \"one\", \"two\",\n                                         \"three\", \"four\", \"five\",\n                                         \"six\", \"seven\", \"eight\",\n                                         \"nine\"};\n    return words[num];\n}\n\n// Function to sort the input string of number words\nstring sort_numbers(string numbers) {\n    stringstream ss(numbers);\n    string word;\n    vector<int> nums;\n\n    // Extract each word and convert it to an integer, then store in a vector\n    while (ss >> word) {\n        nums.push_back(word_to_int(word));\n    }\n\n    // Sort the integers\n    sort(nums.begin(), nums.end());\n\n    // Convert sorted integers back to words and build the result string\n    stringstream result;\n    for (int num : nums) {\n        if (&num != &nums.front()) {  // Avoid adding a space before the first number\n            result << \" \";\n        }\n        result << int_to_word(num);\n    }\n\n    return result.str();\n}\n\n// Function to test the sort_numbers function with some examples\nvoid check() {\n    cout << (sort_numbers(\"three one five\") == \"one three five\" ? \"Pass\" : \"Fail\") << endl;\n    cout << (sort_numbers(\"nine eight zero\") == \"zero eight nine\" ? \"Pass\" : \"Fail\") << endl;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    // First, sort the vector to make it easier to find the closest elements.\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = INFINITY; // Initialize with a very large value\n    std::pair<float, float> closest_pair;\n\n    // Iterate through the sorted list and find the pair of consecutive elements with the smallest difference.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair.first = numbers[i];\n            closest_pair.second = numbers[i + 1];\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element, std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply linear transformation: (num - min_val) / (max_val - min_val)\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check_function() {\n    list_any test1 = {std::string(\"a\"), 3.14, 5};\n    auto filtered_test1 = filter_integers(test1);\n    for (int num : filtered_test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    list_any test2 = {1, 2, 3, std::string(\"abc\"), {}, {}};\n    auto filtered_test2 = filter_integers(test2);\n    for (int num : filtered_test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint strlen(const std::string& str) {\n    return str.length(); // or str.size()\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen for n > 1, return -1 or an appropriate value.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Handle even numbers first.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors starting from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to print the vector of factors for testing purposes.\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << factors[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each element\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements to the result that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) {\n            cout << \", \";\n        }\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n\nstd::string flip_case(std::string str) {\n    for (char &c : str) {  // Iterate over each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string concatenate(const std::vector<std::string>& strings) {\n    // Initialize an empty string to store the result.\n    std::string result;\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n\n// Function to test the concatenate function with some sample data points\nvoid check_function() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    assert(concatenate({\"hello\", \" \", \"world\"}) == \"hello world\");\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    // Create an empty vector to store filtered results\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            result.push_back(str);\n        }\n    }\n\n    return result;\n}\n\n// Function to test and display results\nvoid check(vector<string> input, string prefix) {\n    vector<string> filtered = filter_by_prefix(input, prefix);\n    \n    cout << \"{\";\n    for (size_t i = 0; i < filtered.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << filtered[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to return only positive numbers from the input vector.\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element of the vector and check if it is positive.\n    for (float num : l) {\n        if (num > 0) {  // Check if the number is greater than zero.\n            result.push_back(num);  // Add positive numbers to the result vector.\n        }\n    }\n\n    return result;\n}\n\n// Function to test and print the results of get_positive function.\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    for (float num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 2 5 6\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    for (float num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Expected output: 5 3 2 3 9 123 1\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: numbers less than or equal to 1 are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by 2 and 3 first, as they are the smallest primes.\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // If divisible by 2 or 3, it's not prime\n    \n    // Check for divisibility from 5 onwards, skipping even numbers.\n    long long i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false; // If divisible by any number in this range, it's not prime\n        i += 6; // Skip even numbers and multiples of 3\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0.0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\nbool sign_change(double a, double b) {\n    return (a > 0 && b < 0) || (a < 0 && b > 0);\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Ensure the polynomial has an even number of coefficients and non-zero highest coefficient\n    if (xs.size() % 2 != 0 || xs.back() == 0.0) {\n        throw std::invalid_argument(\"Invalid input: Polynomial must have an even number of coefficients with a non-zero leading term.\");\n    }\n\n    // Initial interval [a, b] where the function changes sign\n    double a = -100.0; // arbitrary lower bound\n    double b = 100.0;  // arbitrary upper bound\n\n    while (!sign_change(poly(xs, a), poly(xs, b))) {\n        if (poly(xs, a) == 0.0) return a;\n        if (poly(xs, b) == 0.0) return b;\n\n        if (a > b) std::swap(a, b);\n        a *= 2; // expand the interval\n        b *= 2;\n    }\n\n    while ((b - a) / 2.0 > 1e-6) { // precision threshold\n        double c = (a + b) / 2.0;\n        if (sign_change(poly(xs, a), poly(xs, c))) {\n            b = c; // root lies in [a, c]\n        } else {\n            a = c; // root lies in [c, b]\n        }\n    }\n\n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;  // To store elements at indices divisible by three\n    \n    // Extract elements at indices divisible by three and add them to 'to_sort'\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {  // Note: We use (i+1) because indexing starts from 1 in the problem statement\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace original elements with sorted ones\n    size_t j = 0;  // Index for 'to_sort'\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0 && j < to_sort.size()) {  // Check if index is divisible by three\n            l[i] = to_sort[j++];  // Replace with sorted element and increment 'j'\n        }\n    }\n\n    return l;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the new end of the vector\n    l.erase(last, l.end());\n\n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {  // Check if vector is empty\n        throw std::invalid_argument(\"Vector must not be empty\");\n    }\n\n    float max_value = l[0];  // Initialize with the first element of the vector\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n    return max_value;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) { // Check divisibility by 11 or 13\n            int temp = i;\n            \n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit 7\n                    count++;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract elements at even indices (0-based index)\n    std::vector<float> even_elements;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector to store the result\n    std::vector<float> sorted_l = l;\n\n    // Replace even indices in the original vector with sorted values\n    size_t even_index = 0;\n    for (size_t i = 1; i < sorted_l.size(); i += 2) {\n        if (even_index < even_elements.size()) {\n            sorted_l[i] = even_elements[even_index++];\n        }\n    }\n\n    return sorted_l;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<float> test1 = {1, 2, 3};\n    std::vector<float> result1 = sort_even(test1);\n    for (float num : result1) {\n        printf(\"%.0f \", num); // Output should be: 1 2 3\n    }\n    printf(\"\\n\");\n\n    std::vector<float> test2 = {5, 6, 3, 4};\n    std::vector<float> result2 = sort_even(test2);\n    for (float num : result2) {\n        printf(\"%.0f \", num); // Output should be: 5 4 3 6\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        if (is_prime(fib3)) {\n            ++count;\n            if (count == n) return fib3; // Return the nth prime Fibonacci number\n        }\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1 + fib2; // Generate next Fibonacci number\n    }\n\n    return -1; // This line should never be reached as we always find a result.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <iostream>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    std::sort(l.begin(), l.end());\n    \n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    // Since each car going left to right collides with exactly one car going right to left,\n    // and there are 'n' cars in each direction, the total number of collisions is simply 'n'.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &i : l) {  // Iterate through each element and increment it by 1.\n        i += 1;\n    }\n    return l;  // Return the modified vector.\n}\n\n// Function to print elements of a vector\nvoid print_vector(const vector<int>& vec) {\n    for (const int& elem : vec) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    // Create a set to store elements we've seen so far.\n    std::unordered_set<int> seen;\n\n    for (int num : l) {\n        // Check if the complement of the current number exists in the set.\n        int complement = -num;\n        if (seen.find(complement) != seen.end()) {\n            return true;  // Found a pair that sums to zero.\n        }\n        \n        // Add the current number to the set.\n        seen.insert(num);\n    }\n\n    return false;  // No pairs sum up to zero.\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nstd::string change_base(int x, int base) {\n    if (base <= 1 || base >= 10) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    std::string result = \"\";\n    while (x > 0) {\n        // Prepend the remainder to the result string\n        result = std::to_string(x % base) + result;\n        x /= base; // Divide x by base for the next iteration\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is (1/2) * base * height\n    return 0.5f * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3)\n        return 0;\n    \n    // Initialize the first four values of the sequence.\n    int a = 0, b = 2, c = 0, d = 0; // fib4(0), fib4(2), fib4(1), fib4(3) respectively\n    \n    if (n == 2)\n        return b;\n    \n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        \n        // Shift the values to the left\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    \n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nfloat median(std::vector<float> l) {\n    // Sort the vector\n    std::sort(l.begin(), l.end());\n    \n    size_t n = l.size();\n    if (n % 2 == 0) { // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Special case for 2^0 = 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the current result by the base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "string decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adjusting the formula to shift back by 5\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\n// Function to remove vowels from a given string.\nstd::string remove_vowels(std::string text) {\n    std::string result;\n    for (char c : text) {\n        // Check if the character is not a vowel, considering both lowercase and uppercase.\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n            && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Function to test the remove_vowels function with provided data points.\nvoid check_function() {\n    std::cout << (remove_vowels(\"\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"abcdef\") == \"bcdf\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaaaa\") == \"\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"aaBAA\") == \"B\" ? \"Passed\" : \"Failed\") << \"\\n\";\n    std::cout << (remove_vowels(\"zbcd\") == \"zbcd\" ? \"Passed\" : \"Failed\") << \"\\n\";\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::sort and std::unique\n\nbool same_chars(std::string s0, std::string s1) {\n    // Sort both strings\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\n    // Remove duplicates from both sorted strings\n    auto last_unique_s0 = std::unique(s0.begin(), s0.end());\n    auto last_unique_s1 = std::unique(s1.begin(), s1.end());\n\n    // Erase the duplicate characters in the string\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the resulting sets of unique characters\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case for invalid input\n    else if (n == 1) return 1; // First Fibonacci number\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid check_fib() {\n    std::cout << \"fib(10): \" << fib(10) << std::endl; // Should print 55\n    std::cout << \"fib(1): \" << fib(1) << std::endl;   // Should print 1\n    std::cout << \"fib(8): \" << fib(8) << std::endl;   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will count the number of unmatched '<' characters.\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++; // Increment balance when an opening bracket is found.\n        } else if (c == '>') {\n            balance--; // Decrement balance when a closing bracket is found.\n            \n            // If at any point the balance goes negative, it means there's a closing\n            // bracket without a matching opening one before it.\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // At the end of the string, the balance should be zero for all brackets to match correctly.\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() <= 1) return true; // A single element or empty list is trivially monotonic\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are met, the sequence is neither strictly increasing nor decreasing\n        if (increasing && decreasing) return false;\n\n    }\n    \n    return true; // The sequence is either monotonically increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Remove duplicates from each vector\n    auto last_unique_l1 = unique(l1.begin(), l1.end());\n    l1.erase(last_unique_l1, l1.end());\n\n    auto last_unique_l2 = unique(l2.begin(), l2.end());\n    l2.erase(last_unique_l2, l2.end());\n\n    // Vector to store common elements\n    vector<int> result;\n\n    // Find and add common elements to the result vector\n    for (int num : l1) {\n        if (find(l2.begin(), l2.end(), num) != l2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;  // equivalent to n >>= 1\n    }\n\n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n// Function to test the largest_prime_factor function with given inputs\nvoid check_largest_prime_factor() {\n    std::cout << \"Largest prime factor of 13195 is: \" << largest_prime_factor(13195) << std::endl; // Should print 29\n    std::cout << \"Largest prime factor of 2048 is: \" << largest_prime_factor(2048) << std::endl;   // Should print 2\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i;\n    }\n    return result;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_sum_to_n() {\n    std::cout << \"sum_to_n(30): \" << sum_to_n(30) << \" (Expected: 465)\" << std::endl;\n    std::cout << \"sum_to_n(100): \" << sum_to_n(100) << \" (Expected: 5050)\" << std::endl;\n    std::cout << \"sum_to_n(5): \" << sum_to_n(5) << \" (Expected: 15)\" << std::endl;\n    std::cout << \"sum_to_n(10): \" << sum_to_n(10) << \" (Expected: 55)\" << std::endl;\n    std::cout << \"sum_to_n(1): \" << sum_to_n(1) << \" (Expected: 1)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // If the stack is empty, all opening brackets have been matched\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial.\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // The derivative starts from the first coefficient and goes up to the last but one.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    std::string lower_s = s; // Convert to lowercase for simplicity\n\n    // Convert the string to lowercase\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (char ch : lower_s) {\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Special case: treat 'y' as a vowel only if it is at the end of the word\n    if (!lower_s.empty() && lower_s.back() == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string num_str = to_string(x);\n    \n    // Determine number of digits\n    int num_digits = num_str.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= num_digits) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform circular right shift by 'shift' positions\n    shift %= num_digits;  // Ensure shift is within the bounds of the number's length\n    \n    // Rotate the string to the right by 'shift'\n    string result = num_str.substr(num_digits - shift) + num_str.substr(0, num_digits - shift);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    for (char c : s) {\n        if (isupper(c)) { // Check if character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Create a stream to parse the string\n    istringstream iss(s);\n    \n    int apples = 0;\n    int oranges = 0;\n    \n    // Extract numbers from the string\n    string temp; \n    iss >> temp >> apples; // Read \"apples\" and extract number before it\n    iss.ignore();          // Ignore 'and'\n    iss >> temp >> oranges; // Read \"oranges\" and extract number before it\n    \n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum integer value\n    int minIndex = -1;          // No even number found yet\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is an even number and less than or equal to the current minimum\n            if (arr[i] < minEvenValue || minIndex > i) { // If it's smaller, or same but with a smaller index\n                minEvenValue = arr[i];                    // Update the smallest even value\n                minIndex = i;                             // Update the index of this value\n            }\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};  // Return an empty vector if no even number was found\n    } else {\n        return {minEvenValue, minIndex}; // Return the smallest even value and its index\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    // Step 1: Count frequency of each integer in the vector\n    std::unordered_map<int, int> freq;\n    for (auto num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2 and 3: Find the maximum integer that satisfies the condition\n    int max_val = -1; // Initialize with -1 to handle case where no such value exists\n    for (const auto& entry : freq) {\n        if (entry.first <= entry.second && entry.first > max_val) {\n            max_val = entry.first;\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return lst; // Return empty vector if input is empty\n    \n    std::sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0, right = lst.size() - 1;\n    while (left <= right) {\n        if (left == right) { // If only one element is remaining\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        result.push_back(lst[left++]); // Add the minimum value and move left pointer to the right\n        result.push_back(lst[right--]); // Add the maximum value and move right pointer to the left\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Apply Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum is less than or equal to w\n    return (sum <= w);\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0; // Start from the beginning\n    int right = arr.size() - 1; // Start from the end\n    int changes = 0; // Count of required changes\n\n    while (left < right) { // Continue until pointers meet in the middle\n        if (arr[left] != arr[right]) {\n            changes++; // Increment change count when elements are not equal\n        }\n        left++; // Move left pointer to the right\n        right--; // Move right pointer to the left\n    }\n\n    return changes; // Return total number of required changes\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate list\n    if (chars_lst1 < chars_lst2 || chars_lst1 == chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true; // Special cases for smallest primes\n    if (n % 2 == 0 || n % 3 == 0) return false; // Eliminate multiples of 2 and 3\n\n    int i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n        i += 6;\n    }\n    return true;\n}\n\n// Function to check if a number is the product of exactly three prime numbers\nbool is_multiply_prime(int num) {\n    int count = 0; // To keep track of how many prime factors we have found\n\n    for (int i = 2; i <= 100 && count < 3; ++i) { // Check only up to 100 as per problem statement\n        if (num % i == 0 && is_prime(i)) {\n            num /= i;\n            count++;\n            // If the remaining number after division becomes 1, it means we have found exactly three prime factors\n            if (count < 3 && num == 1) return false; \n        }\n    }\n\n    // Check if there are exactly three prime factors and the final value of 'num' is 1\n    return count == 3 && num == 1;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Edge cases: 1 can be any number to the power of 0.\n    if (x == 1 && n != 0)\n        return true;\n    \n    // If n is 1, then only x = 1 is a valid simple power\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    // Calculate the logarithm of x to base n.\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value.\n    int exponent = static_cast<int>(log_result);\n    return fabs(log_result - exponent) < 1e-9;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of 'a'\n    double cbrt_a = std::cbrt(a);\n    \n    // Round to the nearest integer\n    int rounded_cbrt_a = static_cast<int>(std::round(cbrt_a));\n    \n    // Check if cubing this rounded value gives back 'a'\n    return (rounded_cbrt_a * rounded_cbrt_a * rounded_cbrt_a == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\n// Function to count prime hexadecimal digits in a given string.\nint hex_key(const std::string& num) {\n    // Define which hexadecimal characters are prime numbers.\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int prime_count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit.\n        if (std::find(std::begin(prime_hex_digits), std::end(prime_hex_digits), c) != std::end(prime_hex_digits)) {\n            ++prime_count;\n        }\n    }\n    \n    return prime_count;\n}\n\n// Function to test and verify the correctness of the hex_key function.\nvoid check(const std::string& num, int expected) {\n    int result = hex_key(num);\n    if (result == expected)\n        std::cout << \"PASS: For \\\"\" << num << \"\\\", got \" << result << \"\\n\";\n    else\n        std::cout << \"FAIL: For \\\"\" << num << \"\\\", expected \" << expected << \", but got \" << result << \"\\n\";\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal number to binary and format it as specified\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary using bitset for simplicity\n    string binary = \"\";\n    \n    if (decimal == 0) { // Special case for zero\n        return \"db0db\";\n    }\n    \n    while(decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder to form the binary string\n        decimal /= 2;\n    }\n\n    // Add 'db' at the beginning and end of the binary string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n\nbool is_happy(std::string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // If any two out of three consecutive characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa >= 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\"); // In case of a GPA below 0, which is not expected but handled for completeness\n        }\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(std::string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers.\n    \n    long long count = 0;\n    count += 2 * pow(10, n-1); // Count of numbers starting or ending with 1\n    count -= pow(10, n-2);     // Subtract the overlap (numbers that both start and end with 1)\n    \n    return static_cast<int>(count);\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = (num % 2 ? \"1\" : \"0\") + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring solve(int N) {\n    int sumOfDigits = 0;\n\n    // Sum all the digits of N\n    while (N > 0) {\n        sumOfDigits += N % 10;  // Add the last digit to the sum\n        N /= 10;                // Remove the last digit from N\n    }\n\n    // Convert the sum into a binary string and return it\n    return intToBinary(sumOfDigits);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (the first odd index)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for sort()\nusing namespace std;\n\n// Function to anti-shuffle the string\nstring anti_shuffle(string s) {\n    string result = \"\";  // Resultant string after sorting each word\n    int n = s.length();\n    \n    for (int i = 0; i < n;) {\n        if (s[i] == ' ') {  // If current character is a space, add it to the result and move to next position\n            result += \" \";\n            ++i;\n        } else {\n            int j = i + 1;\n            \n            // Find the end of the word\n            while (j < n && s[j] != ' ') {\n                ++j;\n            }\n            \n            // Sort characters in this word\n            string temp = s.substr(i, j - i);\n            sort(temp.begin(), temp.end());\n            \n            // Append sorted word to result\n            result += temp;\n            \n            // Move to the next word\n            i = j;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << \"Testing 'Hi': \" << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'hello': \" << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Testing 'Hello World!!!': \" << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nstruct Coordinate {\n    int row;\n    int col;\n\n    // Constructor for coordinate initialization\n    Coordinate(int r = 0, int c = 0) : row(r), col(c) {}\n\n    // Comparator function to sort coordinates first by row in ascending order,\n    // and then by column in descending order within the same row.\n    bool operator<(const Coordinate& other) const {\n        if (row == other.row)\n            return col > other.col;  // Descending order for columns\n        else\n            return row < other.row;  // Ascending order for rows\n    }\n};\n\nstd::vector<std::vector<int>> get_row(std::vector<std::vector<int>> lst, int x) {\n    std::vector<Coordinate> coordinates;\n\n    // Iterate through the list to find all occurrences of x and record their positions.\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x)\n                coordinates.push_back(Coordinate(row, col));\n        }\n    }\n\n    // Sort the coordinates as per the given criteria.\n    std::sort(coordinates.begin(), coordinates.end());\n\n    // Convert Coordinate objects to vector<int> and return\n    std::vector<std::vector<int>> result;\n    for (const auto& coord : coordinates) {\n        result.push_back({coord.row, coord.col});\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_array(std::vector<int> array) {\n    // If the vector is empty or has only one element, return it as is.\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements.\n    int sum = array.front() + array.back();\n\n    // Create a copy of the vector to sort.\n    std::vector<int> sorted_array(array);\n\n    // Sort in ascending order if the sum is odd, otherwise sort in descending order.\n    if (sum % 2 == 1) {\n        std::sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        std::sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Example usage and check function\nvoid check() {\n    assert(sort_array({}) == std::vector<int>({}));\n    assert(sort_array({5}) == std::vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == std::vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == std::vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nstd::string encrypt(std::string s) {\n    const std::string ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n    int shift = 4; // The number of positions to rotate each letter\n    \n    for (char &c : s) { // Iterate over each character in the string\n        if (isalpha(c)) { // Check if the character is a letter\n            char lower_c = tolower(c); // Convert to lowercase for simplicity\n            \n            size_t pos = ALPHABET.find(lower_c); // Find position of the letter in the alphabet\n            if (pos != std::string::npos) {\n                size_t new_pos = (pos + shift) % 26; // Calculate new position with wrapping around\n                char encrypted_char = ALPHABET[new_pos]; // Get the corresponding character\n                \n                // Preserve original case\n                c = isupper(c) ? toupper(encrypted_char) : encrypted_char;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm> // For std::sort and std::unique\n#include <optional>  // To return an optional value\n\nstd::optional<int> next_smallest(std::vector<int> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt; // Return None if there are less than two elements\n    }\n\n    // Sort the vector\n    std::sort(lst.begin(), lst.end());\n\n    // Remove duplicates\n    auto last = std::unique(lst.begin(), lst.end());\n    lst.erase(last, lst.end()); // Erase the part of the vector after unique\n\n    // Check if there are at least two distinct elements\n    if (lst.size() < 2) {\n        return std::nullopt; // Return None if there is no second smallest element\n    }\n\n    // The second smallest element will be at index 1 now\n    return lst[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nint is_bored(const std::string& S) {\n    int boredom_count = 0;\n    \n    // Delimiters for splitting the string into sentences.\n    const char* delimiters = \".?!\\n\";\n    size_t start = 0, end = 0;\n\n    while ((end = S.find_first_of(delimiters, start)) != std::string::npos) {\n        std::string sentence = S.substr(start, end - start);\n        \n        // Trim leading and trailing spaces\n        auto wsfront = sentence.find_first_not_of(\" \");\n        if (wsfront == std::string::npos)\n            return boredom_count;  // Sentence is empty after trimming.\n        \n        auto wsback = sentence.find_last_not_of(\" \");\n        sentence = sentence.substr(wsfront, wsback - wsfront + 1);\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.size() > 0 && sentence[0] == 'I') {\n            boredom_count++;\n        }\n        \n        start = end + 1;\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(int a, int b, int c) {\n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a message according to specified rules\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    for (char &c : message) {\n        // Swap case of the character\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowel with the letter 2 places ahead in the alphabet\n        size_t pos = vowels.find(c);\n        if (pos != string::npos) {\n            char replacement;\n            if (c == 'A') replacement = 'C';\n            else if (c == 'E') replacement = 'G';\n            else if (c == 'I') replacement = 'K';\n            else if (c == 'O') replacement = 'Q';\n            else if (c == 'U') replacement = 'W';\n            else if (c == 'C') replacement = 'A'; // for uppercase\n            else if (c == 'G') replacement = 'E';\n            else if (c == 'K') replacement = 'I';\n            else if (c == 'Q') replacement = 'O';\n            else if (c == 'W') replacement = 'U';\n\n            c = replacement;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint digitSum(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds and returns the sum of digits of the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a value less than any possible prime number\n    \n    for (const auto& num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    return digitSum(maxPrime); // Return the sum of digits of the largest prime\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <map>\n#include <string>\n\nbool isLowercase(const std::string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const std::string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Determine case consistency\n        if (!isLowercase(key)) allLowercase = false;\n        if (!isUppercase(key)) allUppercase = false;\n\n        // If both flags are already false, no need to continue checking\n        if (!allLowercase && !allUppercase) break;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> primes_below_n(int n) {\n    vector<int> result;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    assert((primes_below_n(5) == vector<int>{2,3}));\n    assert((primes_below_n(11) == vector<int>{2,3,5,7}));\n    assert(primes_below_n(0).empty());\n    assert((primes_below_n(20) == vector<int>{2,3,5,7,11,13,17,19}));\n    assert(primes_below_n(1).empty());\n    assert((primes_below_n(18) == vector<int>{2,3,5,7,11,13,17}));\n\n    printf(\"All checks passed.\\n\");\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the last digit of both numbers by taking modulo 10\n    int last_digit_a = abs(a % 10);\n    int last_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return last_digit_a * last_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices (0-based)\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(std::string value) {\n    double num = std::stod(value); // Convert string to double\n\n    if (num > 0 && num - floor(num) == 0.5)\n        return static_cast<int>(ceil(num));\n    else if (num < 0 && ceil(num) - num == 0.5)\n        return static_cast<int>(floor(num));\n\n    return static_cast<int>(round(num)); // Standard rounding\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;  // Start with 'n' stones for the first level.\n    \n    // Add the number of stones for each level to the vector.\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine if we need an odd or even next number based on whether 'n' is odd/even.\n        int increment = (n % 2 == 1) ? 2 : 2;\n        current_stones += increment;  // Increment by 2 to get the next odd/even number.\n    }\n    \n    return pile;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    for (int i = 0; i < result.size(); ++i) {\n        printf(\"%d \", result[i]);\n    }\n    // Expected output: 3 5 7\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            // If the current character is a comma or space, add the collected word to the result and reset it\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            // Otherwise, append the character to the current word\n            word += c;\n        }\n    }\n\n    // Add any remaining word after the loop (in case there's no trailing comma or space)\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<string>& vec) {\n    for (const string& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) return -1;\n    \n    // Adjust y to be the largest even number in the range [x, y]\n    if (y % 2 != 0) { \n        y--; // If y is odd, decrement it by 1 to make it even.\n    }\n    \n    // Check if the adjusted y is still within or equal to x\n    if (y >= x) {\n        return y;\n    } else {\n        return -1; // No even number in range [x, y]\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    \n    string result = \"\";\n    while (num > 0) {\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\n// Main function to calculate the rounded average and convert it to binary\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long total_sum = ((long)m - n + 1) * (n + m) / 2;\n    \n    // Calculate the average and round it down\n    int rounded_avg = floor(total_sum / (m - n + 1));\n    \n    return int_to_binary(rounded_avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to check if a number has any even digit\nbool has_odd_digits(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false; // If the digit is even, return false\n        n /= 10; // Move to the next digit\n    }\n    return true; // All digits are odd\n}\n\n// Function to filter and sort numbers with only odd digits\nstd::vector<int> unique_digits(std::vector<int> x) {\n    std::vector<int> result;\n    \n    for (int num : x) {\n        if (has_odd_digits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test and print results\nvoid test() {\n    std::vector<int> example1 = {15, 33, 1422, 1};\n    std::vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(example1) == expected1);\n\n    std::vector<int> example2 = {152, 323, 1422, 10};\n    std::vector<int> expected2;\n    assert(unique_digits(example2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\\n\";\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n// Map to store digit names\nstd::map<int, std::string> digit_names = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n    {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n    {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<int> arr) {\n    // Filter and sort the array\n    std::vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n\n    std::sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted vector\n    std::reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert digits to their corresponding names\n    std::vector<std::string> result;\n    for (int num : filtered_sorted) {\n        if (digit_names.find(num) != digit_names.end()) {\n            result.push_back(digit_names[num]);\n        }\n    }\n\n    return result;\n}\n\n// Example usage and check function\nvoid check() {\n    std::vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result1 = by_length(arr1);\n    for (const auto& str : result1) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n\n    std::vector<int> arr2 = {};\n    auto result2 = by_length(arr2);\n    if (result2.empty()) {\n        printf(\"Empty vector\\n\");\n    }\n\n    std::vector<int> arr3 = {1, -1, 55};\n    auto result3 = by_length(arr3);\n    for (const auto& str : result3) {\n        printf(\"%s \", str.c_str());\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Function to compute factorial of a number x\nint factorial(int x) {\n    if (x == 0 || x == 1)\n        return 1;\n    int result = 1;\n    for (int i = 2; i <= x; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the sum of numbers from 1 to x\nint arithmetic_sum(int x) {\n    return (x * (x + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int value_at_i;\n        \n        // If index is even, calculate factorial of (index - 1)\n        if ((i + 1) % 2 == 0) {\n            value_at_i = factorial(i);\n        } else { // If index is odd, calculate sum from 1 to (index + 1)\n            value_at_i = arithmetic_sum(i + 1);\n        }\n        \n        result[i] = value_at_i;\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a given integer is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int left = 0;\n    int right = str_num.length() - 1;\n    \n    while (left < right) {\n        if (str_num[left] != str_num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize the result vector with two elements: [even_count, odd_count]\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage and check function to verify correctness.\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nint sum_of_signed_digits(int num) {\n    int sum = 0;\n    bool is_negative = false;\n\n    if (num == 0) return 1; // Special case for zero\n\n    while (num != 0) {\n        int digit = num % 10;\n        if (digit < 0 || (is_negative && digit > 0)) digit *= -1; // Adjust sign\n        sum += digit;\n\n        if (num < 0) is_negative = true; // Mark the number as negative\n\n        num /= 10;\n    }\n\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n\n    for (auto& num : n) {\n        if (sum_of_signed_digits(num) > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Test cases\nvoid test() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    // If the vector is empty or has only one element, return true.\n    if (arr.empty() || arr.size() == 1) {\n        return true;\n    }\n\n    int n = arr.size();\n    \n    // Find the break point where elements are not in non-decreasing order\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            // Check if all elements before this point are greater than or equal to their next element after the shift.\n            bool is_valid_shift = true;\n            for (int j = 0; j < i; ++j) {\n                int next_index = (j + 1) % n;\n                if (arr[j] > arr[next_index]) {\n                    is_valid_shift = false;\n                    break;\n                }\n            }\n\n            // Check if all elements after this point form a non-decreasing sequence when shifted back.\n            for (int j = i; j < n - 1; ++j) {\n                int next_index = (j + 1) % n;\n                if (arr[j] > arr[next_index]) {\n                    is_valid_shift = false;\n                    break;\n                }\n            }\n\n            return is_valid_shift;\n        }\n    }\n\n    // If no such point exists, the array is already in non-decreasing order.\n    return true;\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count odd numbers in the vector\nint countOdd(const vector<int>& lst) {\n    int count = 0;\n    for (const auto& num : lst) {\n        if (num % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to check if there are enough even numbers in the second list\nbool hasEnoughEvens(const vector<int>& lst, int requiredCount) {\n    int evens = 0;\n    for (const auto& num : lst) {\n        if (num % 2 == 0) {\n            ++evens;\n        }\n        if (evens >= requiredCount) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = countOdd(lst1);\n    \n    // If there are no odd numbers in lst1, it's already possible\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n    \n    // Check if lst2 has enough even numbers to replace all odd numbers in lst1\n    if (hasEnoughEvens(lst2, oddCount)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage and testing the function\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n// Function to find the histogram of a given string\nmap<char, int> histogram(string test) {\n    // Map to store character counts\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Skip spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count among all characters\n    int maxCount = 0;\n    for (auto& entry : charCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Filter and return only those characters with the maximum count\n    map<char, int> result;\n    for (auto& entry : charCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& entry : hist) {\n        cout << \"{\" << entry.first << \", \" << entry.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    // Prepare and return the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n\n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if digit is odd\n                ++count;\n            }\n        }\n\n        // Construct the output string based on the count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits> // For INT_MAX\n\nlong long minSubArraySum(std::vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long min_sum = nums[0];\n    long long current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For std::ceil\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    // Iterate through each well (row)\n    for(const auto& row : grid) {\n        int water_units = 0; // Total units of water in the current well\n        \n        // Sum up all 1s in the current well\n        for(int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate how many times a bucket needs to be lowered for this well\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Custom comparator function\nbool customComparator(int a, int b) {\n    // Count the number of 1s in binary representation for both numbers\n    std::bitset<32> bit_a(a);\n    std::bitset<32> bit_b(b);\n\n    int count_ones_a = bit_a.count();\n    int count_ones_b = bit_b.count();\n\n    // If they have different counts, sort by the number of 1s in ascending order\n    if (count_ones_a != count_ones_b) {\n        return count_ones_a < count_ones_b;\n    }\n    \n    // If they have the same number of 1s, sort by decimal value\n    return a < b;\n}\n\nvector<int> sort_array(vector<int> arr){\n    // Sort using the custom comparator\n    std::sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for case-insensitive comparison.\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    \n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        \n        // Count consonants in the current word\n        int consonant_count = count_if(word.begin(), word.end(), is_consonant);\n        \n        // If the number of consonants matches n, add to result vector\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n        \n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check for the last word in the string\n    string last_word = s.substr(start);\n    int consonant_count_last = count_if(last_word.begin(), last_word.end(), is_consonant);\n    \n    if (consonant_count_last == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a vowel (case sensitive)\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to get the closest vowel that stands between two consonants from the right\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from second last character to first character\n    for (int i = n - 2; i > 0; --i) {\n        char left_char = word[i-1];\n        char middle_char = word[i];\n        char right_char = word[i+1];\n\n        // Check if the current character is a vowel and both surrounding characters are consonants\n        if (is_vowel(middle_char) && !is_vowel(left_char) && !is_vowel(right_char)) {\n            return string(1, middle_char);  // Return the vowel as a single-character string\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first = lst[0];\n    string second = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(first + second)) {\n        return \"Yes\";\n    } else if (is_balanced(second + first)) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Extract the first k elements from the sorted vector\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Step 3: Sort the extracted elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if index is even and value at that index is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-99 <= arr[i] && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and check function\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odds;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            odds.push_back(n);\n        }\n        \n        // Generate next term in Collatz sequence\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n\n    // Add the last number, which is always 1 and odd\n    odds.push_back(1);\n\n    // Sort the vector of odd numbers in increasing order\n    sort(odds.begin(), odds.end());\n\n    return odds;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Find positions of '-' characters to split the date into components\n    size_t pos1 = date.find('-');\n    size_t pos2 = date.find('-', pos1 + 1);\n    \n    // Ensure there are exactly two '-' in the correct format\n    if (pos1 == string::npos || pos2 == string::npos) return false;\n    \n    // Extract month, day, and year from the string\n    int month = stoi(date.substr(0, pos1));\n    int day = stoi(date.substr(pos1 + 1, pos2 - pos1 - 1));\n    int year = stoi(date.substr(pos2 + 1));\n\n    // Validate month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate day range based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 2 && (day < 1 || day > 29))) {\n        return false;\n    } else if ((day < 1 || day > 31)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character has an odd order in the alphabet\nbool is_odd_order(char c) {\n    // Convert lowercase letter to its position in the alphabet (0 for 'a', 1 for 'b', etc.)\n    int pos = c - 'a';\n    return pos % 2 == 1;\n}\n\n// Function to count the number of characters with odd order\nint count_odd_order(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c) && is_odd_order(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    size_t space_pos = txt.find(' ');\n    if (space_pos != string::npos) {\n        // Split on whitespace\n        size_t start = 0, end;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } else {\n        // Check for commas if no whitespace was found\n        size_t comma_pos = txt.find(',');\n        if (comma_pos != string::npos) {\n            // Split on commas\n            size_t start = 0, end;\n            while ((end = txt.find(',', start)) != string::npos) {\n                result.push_back(txt.substr(start, end - start));\n                start = end + 1;\n            }\n            result.push_back(txt.substr(start)); // Add the last part\n        } else {\n            // No whitespace or commas found, count odd order letters\n            int count = count_odd_order(txt);\n            result.push_back(to_string(count));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst){\n    // Check if list is empty or has only one element, return true as it's trivially sorted.\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    map<int, int> countMap; // To keep track of the frequency of each number\n\n    for(int i = 0; i < lst.size(); ++i){\n        // Check ascending order\n        if(i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n\n        // Count occurrences of each element\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false.\n        if(countMap[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;    \n}\n\n// Example usage and check function (not part of the solution but for testing)\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to determine the intersection and check its length\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    // If there is no intersection, return \"NO\"\n    if (start_max > end_min) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end_min - start_max + 1;\n\n    // Check if the length is a prime number and return accordingly\n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitude = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Calculate the magnitude\n        sum_magnitude += std::abs(num);\n\n        // Determine the sign and update the product of signs\n        if (num == 0) return 0; // Any number multiplied by zero is zero\n        else if (num > 0) continue; // Positive numbers don't change the product_of_signs\n        else product_of_signs *= -1; // Negative numbers flip the sign\n\n    }\n\n    // Return the final result: sum of magnitudes * product of signs\n    return sum_magnitude * product_of_signs;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int x, y;\n    vector<int> path;\n};\n\n// Function to perform BFS and find the lexicographically smallest path of length k\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // DP table to store the minimum paths ending at each cell\n    vector<vector<vector<int>>> dp(N, vector<vector<int>>(N));\n    \n    // Initialize BFS queue and visited set\n    queue<State> q;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            q.push({i, j, {grid[i][j]}});\n            dp[i][j] = {grid[i][j]};\n        }\n    }\n\n    // Directions for moving to neighboring cells\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    while (!q.empty() && k > 0) {\n        int size = q.size();\n        \n        while (size--) {\n            State curr = q.front(); q.pop();\n            \n            for (auto& dir : directions) {\n                int nx = curr.x + dir.first;\n                int ny = curr.y + dir.second;\n\n                // Check if the new position is within grid bounds\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                    vector<int> newPath(curr.path);\n                    newPath.push_back(grid[nx][ny]);\n                    \n                    // Update DP table with lexicographically smaller path\n                    if (dp[nx][ny].empty() || newPath < dp[nx][ny]) {\n                        dp[nx][ny] = newPath;\n                        q.push({nx, ny, newPath});\n                    }\n                }\n            }\n        }\n\n        --k;  // Decrease the remaining steps count\n    }\n\n    // Find and return the lexicographically smallest path of length k\n    vector<int> result(INT_MAX);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (!dp[i][j].empty() && dp[i][j].size() == k + 1 && dp[i][j] < result) {\n                result = dp[i][j];\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base cases\n    if (n >= 0) result[0] = 1;\n    if (n >= 1) result[1] = 3;\n    if (n >= 2) result[2] = 2;\n\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) { // Even case\n            result[i] = 1 + i / 2;\n        } else { // Odd case, using the corrected recurrence relation\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n\nbool is_nested(const std::string& str) {\n    int depth = 0;\n    \n    for (char c : str) {\n        if (c == '[') {\n            ++depth;\n            // If there's already an unmatched opening bracket, we have a nested pair\n            if (depth > 1) return true;\n        } else if (c == ']') {\n            --depth;\n            if (depth < 0) break; // Early exit if depth goes negative\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number to the nearest upper integer\n        float ceiling_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += pow(ceiling_num, 2);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt){\n    // Check for empty string\n    if(txt.empty()) return false;\n    \n    int last_space_pos = -1;\n    bool has_spaces = false;\n    \n    // Find the position of the last space\n    for(int i = 0; i < txt.length(); ++i) {\n        if(txt[i] == ' ') {\n            last_space_pos = i;\n            has_spaces = true;\n        }\n    }\n\n    // If there are no spaces, check if the last character is an alphabet\n    if(!has_spaces) return (txt.back() >= 'a' && txt.back() <= 'z') || (txt.back() >= 'A' && txt.back() <= 'Z');\n    \n    // Check if the character after the last space is an alphabet and it's the last character of the string\n    int next_char_pos = last_space_pos + 1;\n    return next_char_pos < txt.length() &&\n           ((txt[next_char_pos] >= 'a' && txt[next_char_pos] <= 'z') || (txt[next_char_pos] >= 'A' && txt[next_char_pos] <= 'Z')) &&\n           next_char_pos == txt.length() - 1;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if the current element is less than the previous one\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of this element\n        }\n    }\n    return -1; // If no such element exists, return -1\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            found_negative = true;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n            found_positive = true;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    int largest_negative = found_negative ? max_negative : 0;\n    int smallest_positive = found_positive ? min_positive : 0;\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to float\nfloat stringToFloat(const std::string& s) {\n    size_t pos = s.find(',');\n    if (pos != std::string::npos) {\n        return stof(s.substr(0, pos) + \".\" + s.substr(pos + 1));\n    }\n    return stof(s);\n}\n\n// Function to compare two boost::any objects\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are integers\n    if (a.type() == typeid(int) && b.type() == typeid(int)) {\n        int ia = boost::any_cast<int>(a);\n        int ib = boost::any_cast<int>(b);\n        return (ia > ib ? a : (ib > ia ? b : \"None\"));\n    }\n    \n    // Check if both are floats\n    else if (a.type() == typeid(float) && b.type() == typeid(float)) {\n        float fa = boost::any_cast<float>(a);\n        float fb = boost::any_cast<float>(b);\n        return (fa > fb ? a : (fb > fa ? b : \"None\"));\n    }\n    \n    // Check if one is integer and the other is string\n    else if ((a.type() == typeid(int) && b.type() == typeid(std::string)) ||\n             (a.type() == typeid(std::string) && b.type() == typeid(int))) {\n        float fa = a.type() == typeid(int) ? boost::any_cast<int>(a) : stringToFloat(boost::any_cast<std::string>(a));\n        float fb = b.type() == typeid(int) ? boost::any_cast<int>(b) : stringToFloat(boost::any_cast<std::string>(b));\n        return (fa > fb ? a : (fb > fa ? b : \"None\"));\n    }\n    \n    // Check if one is float and the other is string\n    else if ((a.type() == typeid(float) && b.type() == typeid(std::string)) ||\n             (a.type() == typeid(std::string) && b.type() == typeid(float))) {\n        float fa = a.type() == typeid(float) ? boost::any_cast<float>(a) : stringToFloat(boost::any_cast<std::string>(a));\n        float fb = b.type() == typeid(float) ? boost::any_cast<float>(b) : stringToFloat(boost::any_cast<std::string>(b));\n        return (fa > fb ? a : (fb > fa ? b : \"None\"));\n    }\n    \n    // Check if both are strings\n    else if (a.type() == typeid(std::string) && b.type() == typeid(std::string)) {\n        float fa = stringToFloat(boost::any_cast<std::string>(a));\n        float fb = stringToFloat(boost::any_cast<std::string>(b));\n        return (fa > fb ? a : (fb > fa ? b : \"None\"));\n    }\n    \n    // If types are not compatible, return None\n    else {\n        return \"None\";\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to compute factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Function to compute the Brazilian factorial as defined in the problem statement\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply the current factorial value with the result\n    }\n    return result;\n}\n\n// Function to test the correctness of the special_factorial function\nvoid check() {\n    cout << \"special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << endl; // Output should be 288\n    cout << \"special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << endl; // Output should be 34560\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n            // If there are more than two consecutive spaces, use '-'\n            if (space_count > 2 && result.back() != '-') {\n                result.pop_back(); // Remove the last '_'\n                result += '-';\n            } else {\n                result += '_';\n            }\n        } else {\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_valid_prefix(const string& prefix) {\n    if (prefix.empty()) return false;\n    char first_char = prefix[0];\n    // Check if the first character is a letter.\n    return (first_char >= 'a' && first_char <= 'z') || (first_char >= 'A' && first_char <= 'Z');\n}\n\nbool has_valid_suffix(const string& suffix) {\n    static const string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    for (const auto& ext : valid_extensions) {\n        if (suffix == ext) return true;\n    }\n    return false;\n}\n\nint count_digits(const string& str) {\n    int digit_count = 0;\n    for (char ch : str) {\n        if (ch >= '0' && ch <= '9') {\n            ++digit_count;\n        }\n    }\n    return digit_count;\n}\n\nstring file_name_check(string file_name) {\n    size_t dot_pos = file_name.find('.');\n    \n    // Check if there is exactly one dot\n    if (dot_pos == string::npos || file_name.rfind('.', 1) != dot_pos) {\n        return \"No\";\n    }\n\n    // Split the file name into prefix and suffix based on the dot position.\n    string prefix = file_name.substr(0, dot_pos);\n    string suffix = file_name.substr(dot_pos + 1);\n\n    // Check if the prefix is valid\n    if (!is_valid_prefix(prefix)) {\n        return \"No\";\n    }\n\n    // Check if the suffix is one of the allowed extensions\n    if (!has_valid_suffix(suffix)) {\n        return \"No\";\n    }\n\n    // Count digits in the file name and check if it's less than or equal to 3.\n    int digit_count = count_digits(file_name);\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\n\nint sum_squares(const std::vector<int>& lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // Index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the value and add to sum\n        } else if ((i + 1) % 4 == 0) { // Index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the value and add to sum\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) {\n        // Check if the length of the current word is a prime number\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse a string fraction into numerator and denominator integers\nvoid parseFraction(const string& fraction, int& num, int& den) {\n    size_t pos = fraction.find('/');\n    num = stoi(fraction.substr(0, pos));\n    den = stoi(fraction.substr(pos + 1));\n}\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    int numX, denX;\n    parseFraction(x, numX, denX);\n\n    int numN, denN;\n    parseFraction(n, numN, denN);\n\n    // Compute the product of the two fractions\n    int prodNum = numX * numN;  // Numerator of the result\n    int prodDen = denX * denN;  // Denominator of the result\n\n    // Simplify the fraction by dividing numerator and denominator with their GCD\n    int commonDivisor = gcd(prodNum, prodDen);\n    prodNum /= commonDivisor;\n    prodDen /= commonDivisor;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1)\n    return prodDen == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = (num < 0);\n    while (num != 0) {\n        int digit = num % 10;\n        if (is_negative && digit > 0)\n            sum -= digit; // If the number was negative, adjust for positive digits\n        else\n            sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Custom comparator function based on digit sums and original indices\nbool custom_compare(int a, int b, const std::vector<int>& nums) {\n    int sum_a = digit_sum(a);\n    int sum_b = digit_sum(b);\n    \n    if (sum_a == sum_b)\n        return &nums[a] < &nums[b]; // Compare based on original index\n    \n    return sum_a < sum_b;\n}\n\n// Function to sort the vector according to the custom comparator\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::stable_sort(nums.begin(), nums.end(),\n                     [&](int a, int b) { \n                         return custom_compare(a, b, nums); \n                     });\n    \n    return nums;\n}\n\n// Example usage and verification\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == std::vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == std::vector<int>{});\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit access\n    if (num == 0) return false; // Handle zero case separately\n    \n    string strNum = to_string(abs(num));\n    \n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n    \n    bool isFirstOdd = (firstDigit == '1' || firstDigit == '3' || \n                       firstDigit == '5' || firstDigit == '7' ||\n                       firstDigit == '9');\n    \n    bool isLastOdd = (lastDigit == '1' || lastDigit == '3' || \n                      lastDigit == '5' || lastDigit == '7' ||\n                      lastDigit == '9');\n    \n    return isFirstOdd && isLastOdd;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (auto num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array a based on the formula i * i - i + 1\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Count triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1, index2;\n    bool valid_planet1 = false, valid_planet2 = false;\n\n    // Find the indices of planet1 and planet2 in the planets vector.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) {\n            index1 = i;\n            valid_planet1 = true;\n        }\n        if (planets[i] == planet2) {\n            index2 = i;\n            valid_planet2 = true;\n        }\n\n        // If both planets are found, break the loop.\n        if (valid_planet1 && valid_planet2)\n            break;\n    }\n\n    // Return an empty vector if either planet is not a valid name.\n    if (!valid_planet1 || !valid_planet2) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for correct order of planets between them.\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    \n    // Collect all planets that are located between planet1 and planet2.\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test_bf() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Output should be: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom comparator function to sort strings first by length and then lexicographically\nbool customSort(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;  // Alphabetical order for same lengths\n    }\n    return a.length() < b.length();  // Length-based sorting\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd length\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {  // Check even length\n            result.push_back(str);\n        }\n    }\n\n    // Sort the filtered list by custom rules\n    sort(result.begin(), result.end(), customSort);\n\n    return result;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    // Check if n is a prime number using the helper function\n    if (is_prime(n)) {\n        return x;  // Return x if n is prime\n    } else {\n        return y;  // Return y otherwise\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nlong long sum_of_odd_squares(const std::vector<float>& lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == ceil(num)) { // Check if the number is positive and an integer\n            int n = static_cast<int>(num); // Convert to int to check odd/even\n            if (n % 2 != 0) { // If it's odd\n                sum += std::pow(n, 2); // Add square of the number to sum\n            }\n        }\n    }\n\n    return sum;\n}\n\n// Example usage and test cases:\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Example usage and verification\nvoid check() {\n    auto res1 = compare({1,2,3,4,5,1}, {1,2,3,4,2,-2});\n    for (int i : res1) printf(\"%d \", i); // Expected: 0 0 0 0 3 3\n    \n    std::cout << \"\\n\";\n    \n    auto res2 = compare({0,5,0,0,0,4}, {4,1,1,0,0,-2});\n    for (int i : res2) printf(\"%d \", i); // Expected: 4 4 1 0 0 6\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the strength of an extension based on its name.\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) {\n            uppercase++;\n        } else if (islower(c)) {\n            lowercase++;\n        }\n    }\n    \n    return uppercase - lowercase;\n}\n\n// Function to find the strongest extension and return it in the required format.\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum integer value\n    string strongest_extension;\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && extensions.size() == 1)) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate 'a' with itself\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Make sure we work with positive numbers for simplicity\n    if (num < 0) {\n        num = -num;\n    }\n\n    int evenCount = 0, oddCount = 0;\n\n    while (num > 0) {\n        int digit = num % 10;  // Get the last digit\n\n        if (digit % 2 == 0) {  // Check if the digit is even\n            evenCount++;\n        } else {  // If not, it's odd\n            oddCount++;\n        }\n\n        num /= 10;  // Remove the last digit from number\n    }\n\n    return vector<int>{evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},  {900, \"cm\"}, {500, \"d\"},  {400, \"cd\"},\n        {100, \"c\"},   {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"},\n        {10, \"x\"},    {9, \"ix\"},   {5, \"v\"},    {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& numeral : roman_numerals) {\n        while (number >= numeral.first) {\n            result += numeral.second;\n            number -= numeral.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with given examples\nvoid check() {\n    cout << \"19 -> \" << int_to_mini_roman(19) << endl;  // Expected: xix\n    cout << \"152 -> \" << int_to_mini_roman(152) << endl; // Expected: clii\n    cout << \"426 -> \" << int_to_mini_roman(426) << endl; // Expected: cdxxvi\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <algorithm> // For std::sort\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Ensure 'c' is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3); // Sort the array in ascending order\n    float hypotenuse = sides[2]; // The largest value will be at index 2\n\n    // Check if it's a right-angled triangle using Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1]) == (hypotenuse * hypotenuse);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm> // for std::sort and std::unique\n#include <set>       // to count unique characters\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) return \"\";  // Handle empty vector case\n    \n    auto max_unique_chars = 0;\n    std::string result;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        \n        int current_unique_count = unique_chars.size();\n        \n        if (current_unique_count > max_unique_chars || \n            (current_unique_count == max_unique_chars && word < result)) {\n            max_unique_chars = current_unique_count;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total number of carrots to eat after meals\n    int totalToEat = number + need;\n    \n    // If there are enough remaining carrots, calculate the new counts\n    if (remaining >= need) {\n        return {totalToEat, remaining - need};\n    }\n    // Otherwise, eat all remaining carrots and be still hungry\n    else {\n        return {number + remaining, 0};\n    }\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint evaluateExpression(const vector<string>& operators, const vector<int>& operands) {\n    int n = operators.size();\n    stack<int> values;\n    \n    for (size_t i = 0; i < operands.size(); ++i) {\n        // Push the current operand to the stack\n        if (i < operands.size() - 1 || i == 0) { // Ensure we push all but the last operand, and always push first one.\n            values.push(operands[i]);\n        }\n        \n        // If there's an operator, perform the operation with the top two elements of the stack\n        if (i > 0 && i <= n) {\n            int b = values.top(); values.pop();\n            int a = values.top(); values.pop();\n\n            if (operators[i-1] == \"+\") {\n                values.push(a + b);\n            } else if (operators[i-1] == \"-\") {\n                values.push(a - b);\n            } else if (operators[i-1] == \"*\") {\n                values.push(a * b);\n            } else if (operators[i-1] == \"//\") { // Note: C++ uses '/' for integer division, not '//'\n                values.push(a / b); \n            } else if (operators[i-1] == \"**\") {\n                values.push(pow(a, b));\n            }\n        }\n    }\n\n    return values.top();\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        return string(s.rbegin(), s.rend());\n    } else {\n        // Otherwise, transform each character as needed\n        for (char &c : s) {\n            if (isLetter(c)) c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nstd::string string_to_md5(std::string text) {\n    if (text.empty()) return \"\";  // Return an empty string instead of None as C++ doesn't have None\n\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&hash);\n\n    std::stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure that 'a' is less than or equal to 'b'\n    if (a > b) {\n        return {};  // Return an empty vector if the range is invalid\n    }\n\n    // Initialize a vector with all even digits in ascending order\n    const vector<int> evens = {2, 4, 6, 8};\n\n    // Create a result vector to store the even digits within the given range [a, b]\n    vector<int> result;\n\n    // Iterate through each even digit and check if it falls within the range [a, b]\n    for (int num : evens) {\n        if (num >= a && num <= b) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
